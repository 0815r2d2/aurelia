this.au=this.au||{},this.au.fetchClient=(function(t,kernel,runtime){"use strict";function e(t){if(!t.ok)throw t;return t}function r(t){return t}function n(t){throw t}const retryStrategy={fixed:0,incremental:1,t:2,random:3},s={s:3,interval:1e3,strategy:retryStrategy.fixed};class RetryInterceptor{constructor(t){if(this.i=Object.assign({},s,t||{}),this.i.strategy===retryStrategy.t&&1e3>=this.i.interval)throw Error("An interval less than or equal to 1 second is not allowed when using the exponential retry strategy")}o(t){const e=t;return e.i||(e.i=Object.assign({},this.i),e.i.h=0),e.i.u=t.clone(),t}response(t,e){return delete e.i,t}l(t,e,r){const{i:n}=e,{u:s}=n;return Promise.resolve().then(()=>{if(n.s>n.h){const o=n.p?n.p(t,e):1;return Promise.resolve(o).then(o=>{if(o)return n.h++,new Promise(t=>kernel.PLATFORM.global.setTimeout(t,(function(t){const{interval:e,strategy,m:r,R:n,h:s}=t;if("function"==typeof strategy)return t.strategy(s);switch(strategy){case retryStrategy.fixed:return i[retryStrategy.fixed](e);case retryStrategy.incremental:return i[retryStrategy.incremental](s,e);case retryStrategy.t:return i[retryStrategy.t](s,e);case retryStrategy.random:return i[retryStrategy.random](s,e,r,n);default:throw Error("Unrecognized retry strategy")}})(n)||0)).then(()=>{const t=s.clone();return"function"==typeof n.q?n.q(t,r):t}).then(t=>r.fetch(Object.assign({},t,{i:n})));throw delete e.i,t})}throw delete e.i,t})}}const i=[t=>t,(t,e)=>e*t,(t,e)=>1===t?e:Math.pow(e,t)/1e3,(t,e,r=0,n=6e4)=>Math.random()*(n-r)+r];class HttpClientConfiguration{constructor(){this.g="",this.v={},this.C=[]}j(t){return this.g=t,this}O(t){return this.v=t,this}T(t){return this.C.push(t),this}P(){return Object.assign(this.v,{H:"same-origin"},this.v),this.I()}I(){return this.T({response:e})}S(t){const e=new RetryInterceptor(t);return this.T(e)}}const o=/^([a-z][a-z0-9+\-.]*:)?\/\//i;class HttpClient{constructor(dom){if(void 0===dom.window.fetch)throw Error("HttpClient requires a Fetch API implementation, but the current environment doesn't support it. You may need to load a polyfill such as https://github.com/github/fetch");this.dom=dom,this.A=0,this.k=0,this.D=0,this.g="",this.v=null,this.C=[]}U(t){let e;if("object"==typeof t)e={v:t};else{if("function"!=typeof t)throw Error("invalid config");{(e=new HttpClientConfiguration).g=this.g,e.v=Object.assign({},this.v),e.C=this.C;const r=t(e);HttpClientConfiguration.prototype.isPrototypeOf(r)&&(e=r)}}const r=e.v;if(r&&Headers.prototype.isPrototypeOf(r.headers))throw Error("Default headers must be a plain object.");const n=e.C;if(n&&n.length){if(n.filter(t=>RetryInterceptor.prototype.isPrototypeOf(t)).length>1)throw Error("Only one RetryInterceptor is allowed.");const t=n.findIndex(t=>RetryInterceptor.prototype.isPrototypeOf(t));if(t>=0&&t!==n.length-1)throw Error("The retry interceptor must be the last interceptor defined.")}return this.g=e.g,this.v=r,this.C=e.C||[],this.D=1,this}fetch(t,e){this.B();let r=this.F(t,e);return this.J(r,this.C).then(t=>{let e=null;if(Response.prototype.isPrototypeOf(t))e=Promise.resolve(t);else{if(!Request.prototype.isPrototypeOf(t))throw Error(`An invalid result was returned by the interceptor chain. Expected a Request or Response instance, but got [${t}]`);r=t,e=fetch(t)}return this.M(e,this.C,r)}).then(t=>Request.prototype.isPrototypeOf(t)?this.fetch(t):t).then(t=>(this.N(),t),t=>{throw this.N(),t})}F(t,e){const r=this.v||{};let n,s,i;const h=(function(t){const e={};for(const name in t||{})t.hasOwnProperty(name)&&(e[name]="function"==typeof t[name]?t[name]():t[name]);return e})(r.headers);if(Request.prototype.isPrototypeOf(t))n=t,i=new Headers(n.headers).get("Content-Type");else{e||(e={});const h=Object.assign({},r,{headers:{}},e,(s=e.body)?{body:s}:null);i=new Headers(h.headers).get("Content-Type"),n=new Request((u=this.g,o.test(c=t)?c:(u||"")+c),h)}var u,c;return i||(new Headers(h).has("content-type")?n.headers.set("Content-Type",new Headers(h).get("content-type")):s&&(function(t){try{JSON.parse(t)}catch(t){return 0}return 1})(s)&&n.headers.set("Content-Type","application/json")),(function(t,e){for(const name in e||{})e.hasOwnProperty(name)&&!t.has(name)&&t.set(name,e[name])})(n.headers,h),s&&Blob.prototype.isPrototypeOf(s)&&s.type&&n.headers.set("Content-Type",s.type),n}get(t,e){return this.fetch(t,e)}L(t,e,r){return this.Y(t,e,r,"POST")}put(t,e,r){return this.Y(t,e,r,"PUT")}$(t,e,r){return this.Y(t,e,r,"PATCH")}delete(t,e,r){return this.Y(t,e,r,"DELETE")}B(){if(this.k=!!++this.A,this.k){const t=runtime.DOM.G("aurelia-fetch-client-request-started",{bubbles:1,cancelable:1});kernel.PLATFORM.setTimeout(()=>runtime.DOM.dispatchEvent(t),1)}}N(){if(this.k=!!--this.A,!this.k){const t=runtime.DOM.G("aurelia-fetch-client-requests-drained",{bubbles:1,cancelable:1});kernel.PLATFORM.setTimeout(()=>runtime.DOM.dispatchEvent(t),1)}}J(t,e){return this.K(t,e,"request","requestError",this)}M(t,e,r){return this.K(t,e,"response","responseError",r,this)}K(t,e,s,i,...o){return(e||[]).reduce((t,e)=>{const h=e[s],u=e[i];return t.then(h&&(value=>h.call(e,value,...o))||r,u&&(t=>u.call(e,t,...o))||n)},Promise.resolve(t))}Y(t,e,r,n){return r||(r={}),r.method=n,e&&(r.body=e),this.fetch(t,r)}}return HttpClient.inject=[runtime.IDOM],t.json=function(t,e){return JSON.stringify(void 0!==t?t:{},e)},t.retryStrategy=retryStrategy,t.RetryInterceptor=RetryInterceptor,t.HttpClientConfiguration=HttpClientConfiguration,t.HttpClient=HttpClient,t})({},kernel,runtime);
