{"version":3,"file":"index.es6.js","sources":["../src/ast.ts","../../../node_modules/tslib/tslib.es6.js","../src/attribute-pattern.ts","../src/attribute-parser.ts","../src/binding-command.ts","../src/common.ts","../src/expression-parser.ts","../src/resource-model.ts","../src/template-binder.ts","../src/template-factory.ts","../src/template-compiler.ts","../src/configuration.ts","../src/debugging.ts"],"sourcesContent":["export class AttrSyntax {\n  public readonly rawName: string;\n  public readonly rawValue: string;\n  public readonly target: string;\n  public readonly command: string | null;\n\n  constructor(rawName: string, rawValue: string, target: string, command: string | null) {\n    this.rawName = rawName;\n    this.rawValue = rawValue;\n    this.target = target;\n    this.command = command;\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { Class, DI, IContainer, IRegistry, IResolver, PLATFORM, Registration, Reporter } from '@aurelia/kernel';\nimport { AttrSyntax } from './ast';\n\nexport interface AttributePatternDefinition {\n  pattern: string;\n  symbols: string;\n}\n\n/** @internal */\nexport interface ICharSpec {\n  chars: string;\n  repeat: boolean;\n  isSymbol: boolean;\n  isInverted: boolean;\n  has(char: string): boolean;\n  equals(other: ICharSpec): boolean;\n}\n\n/** @internal */\nexport class CharSpec implements ICharSpec {\n  public chars: string;\n  public repeat: boolean;\n  public isSymbol: boolean;\n  public isInverted: boolean;\n\n  public has: (char: string) => boolean;\n\n  constructor(chars: string, repeat: boolean, isSymbol: boolean, isInverted: boolean) {\n    this.chars = chars;\n    this.repeat = repeat;\n    this.isSymbol = isSymbol;\n    this.isInverted = isInverted;\n    if (isInverted) {\n      switch (chars.length) {\n        case 0:\n          this.has = this.hasOfNoneInverse;\n          break;\n        case 1:\n          this.has = this.hasOfSingleInverse;\n          break;\n        default:\n          this.has = this.hasOfMultipleInverse;\n      }\n    } else {\n      switch (chars.length) {\n        case 0:\n          this.has = this.hasOfNone;\n          break;\n        case 1:\n          this.has = this.hasOfSingle;\n          break;\n        default:\n          this.has = this.hasOfMultiple;\n      }\n    }\n  }\n\n  public equals(other: ICharSpec): boolean {\n    return this.chars === other.chars\n        && this.repeat === other.repeat\n        && this.isSymbol === other.isSymbol\n        && this.isInverted === other.isInverted;\n  }\n\n  private hasOfMultiple(char: string): boolean {\n    return this.chars.indexOf(char) !== -1;\n  }\n\n  private hasOfSingle(char: string): boolean {\n    return this.chars === char;\n  }\n\n  private hasOfNone(char: string): boolean {\n    return false;\n  }\n\n  private hasOfMultipleInverse(char: string): boolean {\n    return this.chars.indexOf(char) === -1;\n  }\n\n  private hasOfSingleInverse(char: string): boolean {\n    return this.chars !== char;\n  }\n\n  private hasOfNoneInverse(char: string): boolean {\n    return true;\n  }\n}\n\nexport class Interpretation {\n  public parts: ReadonlyArray<string>;\n  public get pattern(): string | null {\n    const value = this._pattern;\n    if (value === '') {\n      return null;\n    } else {\n      return value;\n    }\n  }\n  public set pattern(value: string | null) {\n    if (value === null) {\n      this._pattern = '';\n      this.parts = PLATFORM.emptyArray;\n    } else {\n      this._pattern = value;\n      this.parts = this.partsRecord[value];\n    }\n  }\n  private _pattern: string;\n  private currentRecord: Record<string, string>;\n  private partsRecord: Record<string, string[]>;\n\n  constructor() {\n    this._pattern = '';\n    this.parts = PLATFORM.emptyArray;\n    this.currentRecord = {};\n    this.partsRecord = {};\n  }\n\n  public append(pattern: string, ch: string): void {\n    const { currentRecord } = this;\n    if (currentRecord[pattern] === undefined) {\n      currentRecord[pattern] = ch;\n    } else {\n      currentRecord[pattern] += ch;\n    }\n  }\n\n  public next(pattern: string): void {\n    const { currentRecord } = this;\n    if (currentRecord[pattern] !== undefined) {\n      const { partsRecord } = this;\n      if (partsRecord[pattern] === undefined) {\n        partsRecord[pattern] = [currentRecord[pattern]];\n      } else {\n        partsRecord[pattern].push(currentRecord[pattern]);\n      }\n      currentRecord[pattern] = undefined;\n    }\n  }\n}\n\n/** @internal */\nexport class State {\n  public charSpec: ICharSpec;\n  public nextStates: State[];\n  public types: SegmentTypes | null;\n  public patterns: string[];\n  public isEndpoint: boolean;\n  public get pattern(): string | null {\n    return this.isEndpoint ? this.patterns[0] : null;\n  }\n\n  constructor(charSpec: ICharSpec, ...patterns: string[]) {\n    this.charSpec = charSpec;\n    this.nextStates = [];\n    this.types = null;\n    this.patterns = patterns;\n    this.isEndpoint = false;\n  }\n\n  public findChild(charSpec: ICharSpec): State {\n    const nextStates = this.nextStates;\n    const len = nextStates.length;\n    let child: State = null;\n    for (let i = 0; i < len; ++i) {\n      child = nextStates[i];\n      if (charSpec.equals(child.charSpec)) {\n        return child;\n      }\n    }\n    return null;\n  }\n\n  public append(charSpec: ICharSpec, pattern: string): State {\n    const { patterns } = this;\n    if (patterns.indexOf(pattern) === -1) {\n      patterns.push(pattern);\n    }\n    let state = this.findChild(charSpec);\n    if (state === null) {\n      state = new State(charSpec, pattern);\n      this.nextStates.push(state);\n      if (charSpec.repeat) {\n        state.nextStates.push(state);\n      }\n    }\n    return state;\n  }\n\n  public findMatches(ch: string, interpretation: Interpretation): State[] {\n    // TODO: reuse preallocated arrays\n    const results = [];\n    const nextStates = this.nextStates;\n    const len = nextStates.length;\n    let childLen = 0;\n    let child: State = null;\n    let i = 0;\n    let j = 0;\n    for (; i < len; ++i) {\n      child = nextStates[i];\n      if (child.charSpec.has(ch)) {\n        results.push(child);\n        childLen = child.patterns.length;\n        if (child.charSpec.isSymbol) {\n          for (; j < childLen; ++j) {\n            interpretation.next(child.patterns[j]);\n          }\n        } else {\n          for (; j < childLen; ++j) {\n            interpretation.append(child.patterns[j], ch);\n          }\n        }\n      }\n    }\n    return results;\n  }\n}\n\n/** @internal */\nexport interface ISegment {\n  text: string;\n  eachChar(callback: (spec: CharSpec) => void): void;\n}\n\n/** @internal */\nexport class StaticSegment implements ISegment {\n  public text: string;\n  private len: number;\n  private specs: CharSpec[];\n\n  constructor(text: string) {\n    this.text = text;\n    const len = this.len = text.length;\n    const specs = this.specs = [];\n    for (let i = 0; i < len; ++i) {\n      specs.push(new CharSpec(text[i], false, false, false));\n    }\n  }\n\n  public eachChar(callback: (spec: CharSpec) => void): void {\n    const { len, specs } = this;\n    for (let i = 0; i < len; ++i) {\n      callback(specs[i]);\n    }\n  }\n}\n\n/** @internal */\nexport class DynamicSegment implements ISegment {\n  public text: string;\n  private spec: CharSpec;\n\n  constructor(symbols: string) {\n    this.text = 'PART';\n    this.spec = new CharSpec(symbols, true, false, true);\n  }\n\n  public eachChar(callback: (spec: CharSpec) => void): void {\n    callback(this.spec);\n  }\n}\n\n/** @internal */\nexport class SymbolSegment implements ISegment {\n  public text: string;\n  private spec: CharSpec;\n\n  constructor(text: string) {\n    this.text = text;\n    this.spec = new CharSpec(text, false, true, false);\n  }\n\n  public eachChar(callback: (spec: CharSpec) => void): void {\n    callback(this.spec);\n  }\n}\n\n/** @internal */\nexport class SegmentTypes {\n  public statics: number;\n  public dynamics: number;\n  public symbols: number;\n\n  constructor() {\n    this.statics = 0;\n    this.dynamics = 0;\n    this.symbols = 0;\n  }\n}\n\nexport interface ISyntaxInterpreter {\n  add(def: AttributePatternDefinition): void;\n  add(defs: AttributePatternDefinition[]): void;\n  add(defOrDefs: AttributePatternDefinition | AttributePatternDefinition[]): void;\n  interpret(value: string): Interpretation;\n}\n\nexport const ISyntaxInterpreter = DI.createInterface<ISyntaxInterpreter>().withDefault(x => x.singleton(SyntaxInterpreter));\n\n/** @internal */\nexport class SyntaxInterpreter {\n  public rootState: State;\n  private initialStates: State[];\n\n  constructor() {\n    this.rootState = new State(null);\n    this.initialStates = [this.rootState];\n  }\n\n  public add(def: AttributePatternDefinition): void;\n  public add(defs: AttributePatternDefinition[]): void;\n  public add(defOrDefs: AttributePatternDefinition | AttributePatternDefinition[]): void {\n    let i = 0;\n    if (Array.isArray(defOrDefs)) {\n      const ii = defOrDefs.length;\n      for (; i < ii; ++i) {\n        this.add(defOrDefs[i]);\n      }\n      return;\n    }\n    let currentState = this.rootState;\n    const def = defOrDefs;\n    const pattern = def.pattern;\n    const types = new SegmentTypes();\n    const segments = this.parse(def, types);\n    const len = segments.length;\n    const callback = (ch: ICharSpec): void => {\n      currentState = currentState.append(ch, pattern);\n    };\n    for (i = 0; i < len; ++i) {\n      segments[i].eachChar(callback);\n    }\n    currentState.types = types;\n    currentState.isEndpoint = true;\n  }\n\n  public interpret(name: string): Interpretation {\n    const interpretation = new Interpretation();\n    let states = this.initialStates;\n    const len = name.length;\n    for (let i = 0; i < len; ++i) {\n      states = this.getNextStates(states, name.charAt(i), interpretation);\n      if (states.length === 0) {\n        break;\n      }\n    }\n\n    states.sort((a, b) => {\n      if (a.isEndpoint) {\n        if (!b.isEndpoint) {\n          return -1;\n        }\n      } else if (b.isEndpoint) {\n        return 1;\n      } else {\n        return 0;\n      }\n      const aTypes = a.types;\n      const bTypes = b.types;\n      if (aTypes.statics !== bTypes.statics) {\n        return bTypes.statics - aTypes.statics;\n      }\n      if (aTypes.dynamics !== bTypes.dynamics) {\n        return bTypes.dynamics - aTypes.dynamics;\n      }\n      if (aTypes.symbols !== bTypes.symbols) {\n        return bTypes.symbols - aTypes.symbols;\n      }\n      return 0;\n    });\n\n    if (states.length > 0) {\n      const state = states[0];\n      if (!state.charSpec.isSymbol) {\n        interpretation.next(state.pattern);\n      }\n      interpretation.pattern = state.pattern;\n    }\n    return interpretation;\n  }\n\n  public getNextStates(states: State[], ch: string, interpretation: Interpretation): State[] {\n    // TODO: reuse preallocated arrays\n    const nextStates: State[] = [];\n    let state: State = null;\n    const len = states.length;\n    for (let i = 0; i < len; ++i) {\n      state = states[i];\n      nextStates.push(...state.findMatches(ch, interpretation));\n    }\n\n    return nextStates;\n  }\n\n  private parse(def: AttributePatternDefinition, types: SegmentTypes): ISegment[] {\n    const result = [];\n    const pattern = def.pattern;\n    const len = pattern.length;\n    let i = 0;\n    let start = 0;\n    let c = '';\n\n    while (i < len) {\n      c = pattern.charAt(i);\n      if (def.symbols.indexOf(c) === -1) {\n        if (i === start) {\n          if (c === 'P' && pattern.slice(i, i + 4) === 'PART') {\n            start = i = (i + 4);\n            result.push(new DynamicSegment(def.symbols));\n            ++types.dynamics;\n          } else {\n            ++i;\n          }\n        } else {\n          ++i;\n        }\n      } else if (i !== start) {\n        result.push(new StaticSegment(pattern.slice(start, i)));\n        ++types.statics;\n        start = i;\n      } else {\n        result.push(new SymbolSegment(pattern.slice(start, i + 1)));\n        ++types.symbols;\n        start = ++i;\n      }\n    }\n    if (start !== i) {\n      result.push(new StaticSegment(pattern.slice(start, i)));\n      ++types.statics;\n    }\n\n    return result;\n  }\n}\n\nfunction validatePrototype(handler: IAttributePatternHandler, patternDefs: AttributePatternDefinition[]): void {\n  for (const def of patternDefs) {\n    // note: we're intentionally not throwing here\n    if (!(def.pattern in handler)) {\n      Reporter.write(401, def); // TODO: organize error codes\n    } else if (typeof handler[def.pattern] !== 'function') {\n      Reporter.write(402, def); // TODO: organize error codes\n    }\n  }\n}\n\nexport interface IAttributePattern {\n  $patternDefs: AttributePatternDefinition[];\n}\n\nexport interface IAttributePatternHandler {\n  [pattern: string]: (rawName: string, rawValue: string, parts: ReadonlyArray<string>) => AttrSyntax;\n}\n\nexport const IAttributePattern = DI.createInterface<IAttributePattern>().noDefault();\n\ntype DecoratableAttributePattern<TProto, TClass> = Class<TProto & Partial<IAttributePattern | IAttributePatternHandler>, TClass> & Partial<IRegistry>;\ntype DecoratedAttributePattern<TProto, TClass> =  Class<TProto & IAttributePattern | IAttributePatternHandler, TClass> & IRegistry;\n\ntype AttributePatternDecorator = <TProto, TClass>(target: DecoratableAttributePattern<TProto, TClass>) => DecoratedAttributePattern<TProto, TClass>;\n\nexport function attributePattern(...patternDefs: AttributePatternDefinition[]): AttributePatternDecorator {\n  return function decorator<TProto, TClass>(target: DecoratableAttributePattern<TProto, TClass>): DecoratedAttributePattern<TProto, TClass> {\n    const proto = target.prototype;\n    // Note: the prototype is really meant to be an intersection type between IAttrubutePattern and IAttributePatternHandler, but\n    // a type with an index signature cannot be intersected with anything else that has normal property names.\n    // So we're forced to use a union type and cast it here.\n    validatePrototype(proto as IAttributePatternHandler, patternDefs);\n    proto.$patternDefs = patternDefs;\n\n    target.register = function register(container: IContainer): IResolver {\n      return Registration.singleton(IAttributePattern, target).register(container, IAttributePattern);\n    };\n    return target as DecoratedAttributePattern<TProto, TClass>;\n  } as AttributePatternDecorator;\n}\n\nexport interface DotSeparatedAttributePattern extends IAttributePattern {}\n\n@attributePattern(\n  { pattern: 'PART.PART', symbols: '.' },\n  { pattern: 'PART.PART.PART', symbols: '.' }\n)\nexport class DotSeparatedAttributePattern implements DotSeparatedAttributePattern {\n  public static register: IRegistry['register'];\n\n  public ['PART.PART'](rawName: string, rawValue: string, parts: string[]): AttrSyntax {\n    return new AttrSyntax(rawName, rawValue, parts[0], parts[1]);\n  }\n\n  public ['PART.PART.PART'](rawName: string, rawValue: string, parts: string[]): AttrSyntax {\n    return new AttrSyntax(rawName, rawValue, parts[0], parts[2]);\n  }\n}\n\nexport interface RefAttributePattern extends IAttributePattern {}\n\n@attributePattern(\n  { pattern: 'ref', symbols: '' },\n  { pattern: 'ref.PART', symbols: '.' }\n)\nexport class RefAttributePattern implements RefAttributePattern {\n  public static register: IRegistry['register'];\n\n  public ['ref'](rawName: string, rawValue: string, parts: string[]): AttrSyntax {\n    return new AttrSyntax(rawName, rawValue, 'ref', null);\n  }\n\n  public ['ref.PART'](rawName: string, rawValue: string, parts: string[]): AttrSyntax {\n    return new AttrSyntax(rawName, rawValue, 'ref', parts[1]);\n  }\n}\n\nexport interface ColonPrefixedBindAttributePattern extends IAttributePattern {}\n\n@attributePattern({ pattern: ':PART', symbols: ':' })\nexport class ColonPrefixedBindAttributePattern implements ColonPrefixedBindAttributePattern  {\n  public static register: IRegistry['register'];\n\n  public [':PART'](rawName: string, rawValue: string, parts: string[]): AttrSyntax {\n    return new AttrSyntax(rawName, rawValue, parts[0], 'bind');\n  }\n}\n\nexport interface AtPrefixedTriggerAttributePattern extends IAttributePattern {}\n\n@attributePattern({ pattern: '@PART', symbols: '@' })\nexport class AtPrefixedTriggerAttributePattern implements AtPrefixedTriggerAttributePattern  {\n  public static register: IRegistry['register'];\n\n  public ['@PART'](rawName: string, rawValue: string, parts: string[]): AttrSyntax {\n    return new AttrSyntax(rawName, rawValue, parts[0], 'trigger');\n  }\n}\n","import { all, DI, inject } from '@aurelia/kernel';\nimport { AttrSyntax } from './ast';\nimport { IAttributePattern, IAttributePatternHandler, Interpretation, ISyntaxInterpreter } from './attribute-pattern';\n\nexport interface IAttributeParser {\n  parse(name: string, value: string): AttrSyntax;\n}\n\nexport const IAttributeParser = DI.createInterface<IAttributeParser>()\n  .withDefault(x => x.singleton(AttributeParser));\n\n/** @internal */\n@inject(ISyntaxInterpreter, all(IAttributePattern))\nexport class AttributeParser implements IAttributeParser {\n  private interpreter: ISyntaxInterpreter;\n  private cache: Record<string, Interpretation>;\n  private patterns: Record<string, IAttributePatternHandler>;\n\n  constructor(interpreter: ISyntaxInterpreter, attrPatterns: IAttributePattern[]) {\n    this.interpreter = interpreter;\n    this.cache = {};\n    const patterns: AttributeParser['patterns'] = this.patterns = {};\n    attrPatterns.forEach(attrPattern => {\n      const defs = attrPattern.$patternDefs;\n      interpreter.add(defs);\n      defs.forEach(def => {\n        patterns[def.pattern] = attrPattern as unknown as IAttributePatternHandler;\n      });\n    });\n  }\n\n  public parse(name: string, value: string): AttrSyntax {\n    let interpretation = this.cache[name];\n    if (interpretation === undefined) {\n      interpretation = this.cache[name] = this.interpreter.interpret(name);\n    }\n    const pattern = interpretation.pattern;\n    if (pattern === null) {\n      return new AttrSyntax(name, value, name, null);\n    } else {\n      return this.patterns[pattern][pattern](name, value, interpretation.parts);\n    }\n  }\n}\n","import { Class, Constructable, IContainer, IRegistry, PLATFORM, Registration, Writable } from '@aurelia/kernel';\nimport {\n  AttributeInstruction,\n  BindingMode,\n  BindingType,\n  CallBindingInstruction,\n  CaptureBindingInstruction,\n  DelegateBindingInstruction,\n  ForOfStatement,\n  FromViewBindingInstruction,\n  IResourceDefinition,\n  IResourceKind,\n  IResourceType,\n  IsBindingBehavior,\n  IteratorBindingInstruction,\n  OneTimeBindingInstruction,\n  ToViewBindingInstruction,\n  TriggerBindingInstruction,\n  TwoWayBindingInstruction\n} from '@aurelia/runtime';\nimport { BindingSymbol, PlainAttributeSymbol, SymbolFlags } from './template-binder';\n\nexport interface IBindingCommand {\n  bindingType: BindingType;\n  compile(binding: PlainAttributeSymbol | BindingSymbol): AttributeInstruction;\n}\n\nexport interface IBindingCommandDefinition extends IResourceDefinition { }\n\nexport interface IBindingCommandType extends IResourceType<IBindingCommandDefinition, IBindingCommand, Class<IBindingCommand>> { }\n\nexport interface IBindingCommandResource extends\n  IResourceKind<IBindingCommandDefinition, IBindingCommand, Class<IBindingCommand>> { }\n\ntype BindingCommandDecorator = <TProto, TClass>(target: Class<TProto, TClass> & Partial<IBindingCommandType>) => Class<TProto, TClass> & IBindingCommandType;\n\nfunction register(this: IBindingCommandType, container: IContainer): void {\n  const resourceKey = BindingCommandResource.keyFrom(this.description.name);\n  container.register(Registration.singleton(resourceKey, this));\n}\n\nexport function bindingCommand(name: string): BindingCommandDecorator;\nexport function bindingCommand(definition: IBindingCommandDefinition): BindingCommandDecorator;\nexport function bindingCommand(nameOrDefinition: string | IBindingCommandDefinition): BindingCommandDecorator {\n  return target => BindingCommandResource.define(nameOrDefinition, target);\n}\n\nfunction keyFrom(this: IBindingCommandResource, name: string): string {\n  return `${this.name}:${name}`;\n}\n\nfunction isType<T>(this: IBindingCommandResource, Type: T & Partial<IBindingCommandType>): Type is T & IBindingCommandType {\n  return Type.kind === this;\n}\n\nfunction define<T extends Constructable>(this: IBindingCommandResource, name: string, ctor: T): T & IBindingCommandType;\nfunction define<T extends Constructable>(this: IBindingCommandResource, definition: IBindingCommandDefinition, ctor: T): T & IBindingCommandType;\nfunction define<T extends Constructable>(this: IBindingCommandResource, nameOrDefinition: string | IBindingCommandDefinition, ctor: T): T & IBindingCommandType {\n  const Type = ctor as T & Writable<IBindingCommandType>;\n  const description = typeof nameOrDefinition === 'string' ? { name: nameOrDefinition, target: null } : nameOrDefinition;\n\n  Type.kind = BindingCommandResource;\n  Type.description = description;\n  Type.register = register;\n\n  return Type;\n}\n\nexport const BindingCommandResource: IBindingCommandResource = {\n  name: 'binding-command',\n  keyFrom,\n  isType,\n  define\n};\n\nfunction getTarget(binding: PlainAttributeSymbol | BindingSymbol, camelCase: boolean): string {\n  if (binding.flags & SymbolFlags.isBinding) {\n    return (binding as BindingSymbol).bindable.propName;\n  } else if (camelCase) {\n    return PLATFORM.camelCase((binding as PlainAttributeSymbol).syntax.target);\n  } else {\n    return (binding as PlainAttributeSymbol).syntax.target;\n  }\n}\n\nfunction getMode(binding: PlainAttributeSymbol | BindingSymbol): BindingMode {\n  if (binding.flags & SymbolFlags.isBinding) {\n    return (binding as BindingSymbol).bindable.mode;\n  } else {\n    return commandToMode[(binding as PlainAttributeSymbol).syntax.command];\n  }\n}\n\nexport interface OneTimeBindingCommand extends IBindingCommand {}\n\n@bindingCommand('one-time')\nexport class OneTimeBindingCommand implements IBindingCommand {\n  public static register: IRegistry['register'];\n  public bindingType: BindingType.OneTimeCommand;\n\n  constructor() {\n    this.bindingType = BindingType.OneTimeCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): AttributeInstruction {\n    return new OneTimeBindingInstruction(binding.expression as IsBindingBehavior, getTarget(binding, false));\n  }\n}\n\nexport interface ToViewBindingCommand extends IBindingCommand {}\n\n@bindingCommand('to-view')\nexport class ToViewBindingCommand implements IBindingCommand {\n  public static register: IRegistry['register'];\n  public bindingType: BindingType.ToViewCommand;\n\n  constructor() {\n    this.bindingType = BindingType.ToViewCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): AttributeInstruction {\n    return new ToViewBindingInstruction(binding.expression as IsBindingBehavior, getTarget(binding, false));\n  }\n}\n\nexport interface FromViewBindingCommand extends IBindingCommand {}\n\n@bindingCommand('from-view')\nexport class FromViewBindingCommand implements IBindingCommand {\n  public static register: IRegistry['register'];\n  public bindingType: BindingType.FromViewCommand;\n\n  constructor() {\n    this.bindingType = BindingType.FromViewCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): AttributeInstruction {\n    return new FromViewBindingInstruction(binding.expression as IsBindingBehavior, getTarget(binding, false));\n  }\n}\n\nexport interface TwoWayBindingCommand extends IBindingCommand {}\n\n@bindingCommand('two-way')\nexport class TwoWayBindingCommand implements IBindingCommand {\n  public static register: IRegistry['register'];\n  public bindingType: BindingType.TwoWayCommand;\n\n  constructor() {\n    this.bindingType = BindingType.TwoWayCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): AttributeInstruction {\n    return new TwoWayBindingInstruction(binding.expression as IsBindingBehavior, getTarget(binding, false));\n  }\n}\n\n// Not bothering to throw on non-existing modes, should never happen anyway.\n// Keeping all array elements of the same type for better optimizeability.\nconst modeToProperty = ['', '$1', '$2', '', '$4', '', '$6'];\nconst commandToMode = {\n  'bind': BindingMode.toView,\n  'one-time': BindingMode.oneTime,\n  'to-view': BindingMode.toView,\n  'from-view': BindingMode.fromView,\n  'two-way': BindingMode.twoWay,\n};\n\nexport interface DefaultBindingCommand extends IBindingCommand {}\n\n@bindingCommand('bind')\nexport class DefaultBindingCommand implements IBindingCommand {\n  public static register: IRegistry['register'];\n  public bindingType: BindingType.BindCommand;\n  public $1: typeof OneTimeBindingCommand.prototype.compile;\n  public $2: typeof ToViewBindingCommand.prototype.compile;\n  public $4: typeof FromViewBindingCommand.prototype.compile;\n  public $6: typeof TwoWayBindingCommand.prototype.compile;\n\n  constructor() {\n    this.bindingType = BindingType.BindCommand;\n    this.$1 = OneTimeBindingCommand.prototype.compile;\n    this.$2 = ToViewBindingCommand.prototype.compile;\n    this.$4 = FromViewBindingCommand.prototype.compile;\n    this.$6 = TwoWayBindingCommand.prototype.compile;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): AttributeInstruction {\n    return this[modeToProperty[getMode(binding)]](binding);\n  }\n}\n\nexport interface TriggerBindingCommand extends IBindingCommand {}\n\n@bindingCommand('trigger')\nexport class TriggerBindingCommand implements IBindingCommand {\n  public static register: IRegistry['register'];\n  public bindingType: BindingType.TriggerCommand;\n\n  constructor() {\n    this.bindingType = BindingType.TriggerCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): AttributeInstruction {\n    return new TriggerBindingInstruction(binding.expression as IsBindingBehavior, getTarget(binding, false));\n  }\n}\n\nexport interface DelegateBindingCommand extends IBindingCommand {}\n\n@bindingCommand('delegate')\nexport class DelegateBindingCommand implements IBindingCommand {\n  public static register: IRegistry['register'];\n  public bindingType: BindingType.DelegateCommand;\n\n  constructor() {\n    this.bindingType = BindingType.DelegateCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): AttributeInstruction {\n    return new DelegateBindingInstruction(binding.expression as IsBindingBehavior, getTarget(binding, false));\n  }\n}\n\nexport interface CaptureBindingCommand extends IBindingCommand {}\n\n@bindingCommand('capture')\nexport class CaptureBindingCommand implements IBindingCommand {\n  public static register: IRegistry['register'];\n  public bindingType: BindingType.CaptureCommand;\n\n  constructor() {\n    this.bindingType = BindingType.CaptureCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): AttributeInstruction {\n    return new CaptureBindingInstruction(binding.expression as IsBindingBehavior, getTarget(binding, false));\n  }\n}\n\nexport interface CallBindingCommand extends IBindingCommand {}\n\n@bindingCommand('call')\nexport class CallBindingCommand implements IBindingCommand {\n  public static register: IRegistry['register'];\n  public bindingType: BindingType.CallCommand;\n\n  constructor() {\n    this.bindingType = BindingType.CallCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): AttributeInstruction {\n    return new CallBindingInstruction(binding.expression as IsBindingBehavior, getTarget(binding, true));\n  }\n}\n\n@bindingCommand('for')\nexport class ForBindingCommand implements IBindingCommand {\n  public static register: IRegistry['register'];\n  public bindingType: BindingType.ForCommand;\n\n  constructor() {\n    this.bindingType = BindingType.ForCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): AttributeInstruction {\n    return new IteratorBindingInstruction(binding.expression as ForOfStatement, getTarget(binding, false));\n  }\n}\n","/** @internal */\nexport function unescapeCode(code: number): number {\n  switch (code) {\n    case Char.LowerB: return Char.Backspace;\n    case Char.LowerT: return Char.Tab;\n    case Char.LowerN: return Char.LineFeed;\n    case Char.LowerV: return Char.VerticalTab;\n    case Char.LowerF: return Char.FormFeed;\n    case Char.LowerR: return Char.CarriageReturn;\n    case Char.DoubleQuote: return Char.DoubleQuote;\n    case Char.SingleQuote: return Char.SingleQuote;\n    case Char.Backslash: return Char.Backslash;\n    default: return code;\n  }\n}\n\n/** @internal */\nexport const enum Access {\n  Reset                   = 0b0000000000000,\n  Ancestor                = 0b0000111111111,\n  This                    = 0b0001000000000,\n  Scope                   = 0b0010000000000,\n  Member                  = 0b0100000000000,\n  Keyed                   = 0b1000000000000\n}\n/** @internal */\nexport const enum Precedence {\n  Variadic                = 0b000111101,\n  Assign                  = 0b000111110,\n  Conditional             = 0b000111111,\n  LogicalOR               = 0b001000000,\n  LogicalAND              = 0b010000000,\n  Equality                = 0b011000000,\n  Relational              = 0b100000000,\n  Additive                = 0b101000000,\n  Multiplicative          = 0b110000000,\n  Binary                  = 0b111000000,\n  LeftHandSide            = 0b111000001,\n  Primary                 = 0b111000010,\n  Unary                   = 0b111000011,\n}\n/** @internal */\nexport const enum Token {\n  EOF                     = 0b110000000000_000_000000,\n  ExpressionTerminal      = 0b100000000000_000_000000,\n  AccessScopeTerminal     = 0b010000000000_000_000000,\n  ClosingToken            = 0b001000000000_000_000000,\n  OpeningToken            = 0b000100000000_000_000000,\n  BinaryOp                = 0b000010000000_000_000000,\n  UnaryOp                 = 0b000001000000_000_000000,\n  LeftHandSide            = 0b000000100000_000_000000,\n  StringOrNumericLiteral  = 0b000000011000_000_000000,\n  NumericLiteral          = 0b000000010000_000_000000,\n  StringLiteral           = 0b000000001000_000_000000,\n  IdentifierName          = 0b000000000110_000_000000,\n  Keyword                 = 0b000000000100_000_000000,\n  Identifier              = 0b000000000010_000_000000,\n  Contextual              = 0b000000000001_000_000000,\n  Precedence              = 0b000000000000_111_000000,\n  Type                    = 0b000000000000_000_111111,\n  FalseKeyword            = 0b000000000100_000_000000,\n  TrueKeyword             = 0b000000000100_000_000001,\n  NullKeyword             = 0b000000000100_000_000010,\n  UndefinedKeyword        = 0b000000000100_000_000011,\n  ThisScope               = 0b000000000110_000_000100,\n  ParentScope             = 0b000000000110_000_000101,\n  OpenParen               = 0b010100100000_000_000110,\n  OpenBrace               = 0b000100000000_000_000111,\n  Dot                     = 0b000000100000_000_001000,\n  CloseBrace              = 0b111000000000_000_001001,\n  CloseParen              = 0b111000000000_000_001010,\n  Comma                   = 0b110000000000_000_001011,\n  OpenBracket             = 0b010100100000_000_001100,\n  CloseBracket            = 0b111000000000_000_001101,\n  Colon                   = 0b110000000000_000_001110,\n  Question                = 0b110000000000_000_001111,\n  Ampersand               = 0b110000000000_000_010000,\n  Bar                     = 0b110000000000_000_010011,\n  BarBar                  = 0b110010000000_010_010100,\n  AmpersandAmpersand      = 0b110010000000_011_010101,\n  EqualsEquals            = 0b110010000000_100_010110,\n  ExclamationEquals       = 0b110010000000_100_010111,\n  EqualsEqualsEquals      = 0b110010000000_100_011000,\n  ExclamationEqualsEquals = 0b110010000000_100_011001,\n  LessThan                = 0b110010000000_101_011010,\n  GreaterThan             = 0b110010000000_101_011011,\n  LessThanEquals          = 0b110010000000_101_011100,\n  GreaterThanEquals       = 0b110010000000_101_011101,\n  InKeyword               = 0b110010000100_101_011110,\n  InstanceOfKeyword       = 0b110010000100_101_011111,\n  Plus                    = 0b010011000000_110_100000,\n  Minus                   = 0b010011000000_110_100001,\n  TypeofKeyword           = 0b000001000100_000_100010,\n  VoidKeyword             = 0b000001000100_000_100011,\n  Asterisk                = 0b110010000000_111_100100,\n  Percent                 = 0b110010000000_111_100101,\n  Slash                   = 0b110010000000_111_100110,\n  Equals                  = 0b100000000000_000_100111,\n  Exclamation             = 0b000001000000_000_101000,\n  TemplateTail            = 0b010000100000_000_101001,\n  TemplateContinuation    = 0b010000100000_000_101010,\n  OfKeyword               = 0b100000000101_000_101011\n}\n\n/** @internal */\nexport const enum Char {\n  Null           = 0x00,\n  Backspace      = 0x08,\n  Tab            = 0x09,\n  LineFeed       = 0x0A,\n  VerticalTab    = 0x0B,\n  FormFeed       = 0x0C,\n  CarriageReturn = 0x0D,\n  Space          = 0x20,\n  Exclamation    = 0x21,\n  DoubleQuote    = 0x22,\n  Dollar         = 0x24,\n  Percent        = 0x25,\n  Ampersand      = 0x26,\n  SingleQuote    = 0x27,\n  OpenParen      = 0x28,\n  CloseParen     = 0x29,\n  Asterisk       = 0x2A,\n  Plus           = 0x2B,\n  Comma          = 0x2C,\n  Minus          = 0x2D,\n  Dot            = 0x2E,\n  Slash          = 0x2F,\n  Semicolon      = 0x3B,\n  Backtick       = 0x60,\n  OpenBracket    = 0x5B,\n  Backslash      = 0x5C,\n  CloseBracket   = 0x5D,\n  Caret          = 0x5E,\n  Underscore     = 0x5F,\n  OpenBrace      = 0x7B,\n  Bar            = 0x7C,\n  CloseBrace     = 0x7D,\n  Colon          = 0x3A,\n  LessThan       = 0x3C,\n  Equals         = 0x3D,\n  GreaterThan    = 0x3E,\n  Question       = 0x3F,\n\n  Zero   = 0x30,\n  One    = 0x31,\n  Two    = 0x32,\n  Three  = 0x33,\n  Four   = 0x34,\n  Five   = 0x35,\n  Six    = 0x36,\n  Seven  = 0x37,\n  Eight  = 0x38,\n  Nine   = 0x39,\n\n  UpperA = 0x41,\n  UpperB = 0x42,\n  UpperC = 0x43,\n  UpperD = 0x44,\n  UpperE = 0x45,\n  UpperF = 0x46,\n  UpperG = 0x47,\n  UpperH = 0x48,\n  UpperI = 0x49,\n  UpperJ = 0x4A,\n  UpperK = 0x4B,\n  UpperL = 0x4C,\n  UpperM = 0x4D,\n  UpperN = 0x4E,\n  UpperO = 0x4F,\n  UpperP = 0x50,\n  UpperQ = 0x51,\n  UpperR = 0x52,\n  UpperS = 0x53,\n  UpperT = 0x54,\n  UpperU = 0x55,\n  UpperV = 0x56,\n  UpperW = 0x57,\n  UpperX = 0x58,\n  UpperY = 0x59,\n  UpperZ = 0x5A,\n\n  LowerA  = 0x61,\n  LowerB  = 0x62,\n  LowerC  = 0x63,\n  LowerD  = 0x64,\n  LowerE  = 0x65,\n  LowerF  = 0x66,\n  LowerG  = 0x67,\n  LowerH  = 0x68,\n  LowerI  = 0x69,\n  LowerJ  = 0x6A,\n  LowerK  = 0x6B,\n  LowerL  = 0x6C,\n  LowerM  = 0x6D,\n  LowerN  = 0x6E,\n  LowerO  = 0x6F,\n  LowerP  = 0x70,\n  LowerQ  = 0x71,\n  LowerR  = 0x72,\n  LowerS  = 0x73,\n  LowerT  = 0x74,\n  LowerU  = 0x75,\n  LowerV  = 0x76,\n  LowerW  = 0x77,\n  LowerX  = 0x78,\n  LowerY  = 0x79,\n  LowerZ  = 0x7A\n}\n","import { IContainer, IRegistry, Reporter } from '@aurelia/kernel';\nimport {\n  AccessKeyed, AccessMember, AccessScope, AccessThis,\n  ArrayBindingPattern, ArrayLiteral, Assign, Binary,\n  BinaryOperator, BindingBehavior, BindingIdentifier,\n  BindingIdentifierOrPattern, BindingType, CallFunction,\n  CallMember, CallScope, Conditional, ExpressionKind, ForOfStatement,\n  IExpression, IExpressionParser, Interpolation, IsAssign, IsAssignable,\n  IsBinary, IsBindingBehavior, IsConditional,\n  IsExpressionOrStatement, IsLeftHandSide, IsPrimary, IsUnary,\n  IsValueConverter, ObjectBindingPattern, ObjectLiteral, PrimitiveLiteral, TaggedTemplate, Template, Unary, UnaryOperator, ValueConverter\n} from '@aurelia/runtime';\nimport { Access, Char, Precedence, Token, unescapeCode } from './common';\n\nexport const ParserRegistration: IRegistry = {\n  register(container: IContainer): void {\n    container.registerTransformer(IExpressionParser, parser => {\n      parser['parseCore'] = parseCore;\n      return parser;\n    });\n  }\n};\n\nconst $false = PrimitiveLiteral.$false;\nconst $true = PrimitiveLiteral.$true;\nconst $null = PrimitiveLiteral.$null;\nconst $undefined = PrimitiveLiteral.$undefined;\nconst $this = AccessThis.$this;\nconst $parent = AccessThis.$parent;\n\n/** @internal */\nexport class ParserState {\n  public index: number;\n  public startIndex: number;\n  public input: string;\n  public lastIndex: number;\n  public length: number;\n  public currentToken: Token;\n  public tokenValue: string | number;\n  public currentChar: number;\n  public assignable: boolean;\n  public get tokenRaw(): string {\n    return this.input.slice(this.startIndex, this.index);\n  }\n\n  constructor(input: string) {\n    this.index = 0;\n    this.startIndex = 0;\n    this.lastIndex = 0;\n    this.input = input;\n    this.length = input.length;\n    this.currentToken = Token.EOF;\n    this.tokenValue = '';\n    this.currentChar = input.charCodeAt(0);\n    this.assignable = true;\n  }\n}\n\nconst $state = new ParserState('');\n\nconst enum SyntaxError {\n  InvalidExpressionStart = 100,\n  UnconsumedToken = 101,\n  DoubleDot = 102,\n  InvalidMemberExpression = 103,\n  UnexpectedEndOfExpression = 104,\n  ExpectedIdentifier = 105,\n  InvalidForDeclaration = 106,\n  InvalidObjectLiteralPropertyDefinition = 107,\n  UnterminatedQuote = 108,\n  UnterminatedTemplate = 109,\n  MissingExpectedToken = 110,\n  UnexpectedCharacter = 111,\n  MissingValueConverter = 112,\n  MissingBindingBehavior = 113\n}\n\nconst enum SemanticError {\n  NotAssignable = 150,\n  UnexpectedForOf = 151\n}\n\n/** @internal */\nexport function parseCore(input: string, bindingType?: BindingType): IExpression {\n  $state.input = input;\n  $state.length = input.length;\n  $state.index = 0;\n  $state.currentChar = input.charCodeAt(0);\n  return parse($state, Access.Reset, Precedence.Variadic, bindingType === undefined ? BindingType.BindCommand : bindingType);\n}\n\n/** @internal */\n// JUSTIFICATION: This is performance-critical code which follows a subset of the well-known ES spec.\n// Knowing the spec, or parsers in general, will help with understanding this code and it is therefore not the\n// single source of information for being able to figure it out.\n// It generally does not need to change unless the spec changes or spec violations are found, or optimization\n// opportunities are found (which would likely not fix these warnings in any case).\n// It's therefore not considered to have any tangible impact on the maintainability of the code base.\n// For reference, most of the parsing logic is based on: https://tc39.github.io/ecma262/#sec-ecmascript-language-expressions\n// tslint:disable-next-line:no-big-function cognitive-complexity\nexport function parse<TPrec extends Precedence, TType extends BindingType>(state: ParserState, access: Access, minPrecedence: TPrec, bindingType: TType):\n  TPrec extends Precedence.Unary ? IsUnary :\n  TPrec extends Precedence.Binary ? IsBinary :\n  TPrec extends Precedence.LeftHandSide ? IsLeftHandSide :\n  TPrec extends Precedence.Assign ? IsAssign :\n  TPrec extends Precedence.Conditional ? IsConditional :\n  TPrec extends Precedence.Primary ? IsPrimary :\n  TPrec extends Precedence.Multiplicative ? IsBinary :\n  TPrec extends Precedence.Additive ? IsBinary :\n  TPrec extends Precedence.Relational ? IsBinary :\n  TPrec extends Precedence.Equality ? IsBinary :\n  TPrec extends Precedence.LogicalAND ? IsBinary :\n  TPrec extends Precedence.LogicalOR ? IsBinary :\n  TPrec extends Precedence.Variadic ?\n    TType extends BindingType.Interpolation ? Interpolation :\n    TType extends BindingType.ForCommand ? ForOfStatement :\n    never : never {\n\n  if (state.index === 0) {\n    if (bindingType & BindingType.Interpolation) {\n      // tslint:disable-next-line:no-any\n      return parseInterpolation(state) as any;\n    }\n    nextToken(state);\n    if (state.currentToken & Token.ExpressionTerminal) {\n      throw Reporter.error(SyntaxError.InvalidExpressionStart, { state });\n    }\n  }\n\n  state.assignable = Precedence.Binary > minPrecedence;\n  let result = undefined as IsExpressionOrStatement;\n\n  if (state.currentToken & Token.UnaryOp) {\n    /** parseUnaryExpression\n     * https://tc39.github.io/ecma262/#sec-unary-operators\n     *\n     * UnaryExpression :\n     *   1. LeftHandSideExpression\n     *   2. void UnaryExpression\n     *   3. typeof UnaryExpression\n     *   4. + UnaryExpression\n     *   5. - UnaryExpression\n     *   6. ! UnaryExpression\n     *\n     * IsValidAssignmentTarget\n     *   2,3,4,5,6 = false\n     *   1 = see parseLeftHandSideExpression\n     *\n     * Note: technically we should throw on ++ / -- / +++ / ---, but there's nothing to gain from that\n     */\n    const op = TokenValues[state.currentToken & Token.Type] as UnaryOperator;\n    nextToken(state);\n    result = new Unary(op, parse(state, access, Precedence.LeftHandSide, bindingType));\n    state.assignable = false;\n  } else {\n    /** parsePrimaryExpression\n     * https://tc39.github.io/ecma262/#sec-primary-expression\n     *\n     * PrimaryExpression :\n     *   1. this\n     *   2. IdentifierName\n     *   3. Literal\n     *   4. ArrayLiteral\n     *   5. ObjectLiteral\n     *   6. TemplateLiteral\n     *   7. ParenthesizedExpression\n     *\n     * Literal :\n     *    NullLiteral\n     *    BooleanLiteral\n     *    NumericLiteral\n     *    StringLiteral\n     *\n     * ParenthesizedExpression :\n     *   ( AssignmentExpression )\n     *\n     * IsValidAssignmentTarget\n     *   1,3,4,5,6,7 = false\n     *   2 = true\n     */\n    primary: switch (state.currentToken) {\n    case Token.ParentScope: // $parent\n      state.assignable = false;\n      do {\n        nextToken(state);\n        access++; // ancestor\n        if (consumeOpt(state, Token.Dot)) {\n          if ((state.currentToken as Token) === Token.Dot) {\n            throw Reporter.error(SyntaxError.DoubleDot, { state });\n          } else if ((state.currentToken as Token) === Token.EOF) {\n            throw Reporter.error(SyntaxError.ExpectedIdentifier, { state });\n          }\n        } else if (state.currentToken & Token.AccessScopeTerminal) {\n          const ancestor = access & Access.Ancestor;\n          result = ancestor === 0 ? $this : ancestor === 1 ? $parent : new AccessThis(ancestor);\n          access = Access.This;\n          break primary;\n        } else {\n          throw Reporter.error(SyntaxError.InvalidMemberExpression, { state });\n        }\n      } while (state.currentToken === Token.ParentScope);\n    // falls through\n    case Token.Identifier: // identifier\n      if (bindingType & BindingType.IsIterator) {\n        result = new BindingIdentifier(state.tokenValue as string);\n      } else {\n        result = new AccessScope(state.tokenValue as string, access & Access.Ancestor);\n        access = Access.Scope;\n      }\n      state.assignable = true;\n      nextToken(state);\n      break;\n    case Token.ThisScope: // $this\n      state.assignable = false;\n      nextToken(state);\n      result = $this;\n      access = Access.This;\n      break;\n    case Token.OpenParen: // parenthesized expression\n      nextToken(state);\n      result = parse(state, Access.Reset, Precedence.Assign, bindingType);\n      consume(state, Token.CloseParen);\n      access = Access.Reset;\n      break;\n    case Token.OpenBracket:\n      result = parseArrayLiteralExpression(state, access, bindingType);\n      access = Access.Reset;\n      break;\n    case Token.OpenBrace:\n      result = parseObjectLiteralExpression(state, bindingType);\n      access = Access.Reset;\n      break;\n    case Token.TemplateTail:\n      result = new Template([state.tokenValue as string]);\n      state.assignable = false;\n      nextToken(state);\n      access = Access.Reset;\n      break;\n    case Token.TemplateContinuation:\n      result = parseTemplate(state, access, bindingType, result as IsLeftHandSide, false);\n      access = Access.Reset;\n      break;\n    case Token.StringLiteral:\n    case Token.NumericLiteral:\n      result = new PrimitiveLiteral(state.tokenValue);\n      state.assignable = false;\n      nextToken(state);\n      access = Access.Reset;\n      break;\n    case Token.NullKeyword:\n    case Token.UndefinedKeyword:\n    case Token.TrueKeyword:\n    case Token.FalseKeyword:\n      result = TokenValues[state.currentToken & Token.Type] as PrimitiveLiteral;\n      state.assignable = false;\n      nextToken(state);\n      access = Access.Reset;\n      break;\n    default:\n      if (state.index >= state.length) {\n        throw Reporter.error(SyntaxError.UnexpectedEndOfExpression, { state });\n      } else {\n        throw Reporter.error(SyntaxError.UnconsumedToken, { state });\n      }\n    }\n\n    if (bindingType & BindingType.IsIterator) {\n      // tslint:disable-next-line:no-any\n      return parseForOfStatement(state, result as BindingIdentifierOrPattern) as any;\n    }\n    // tslint:disable-next-line:no-any\n    if (Precedence.LeftHandSide < minPrecedence) return result as any;\n\n    /** parseMemberExpression (Token.Dot, Token.OpenBracket, Token.TemplateContinuation)\n     * MemberExpression :\n     *   1. PrimaryExpression\n     *   2. MemberExpression [ AssignmentExpression ]\n     *   3. MemberExpression . IdentifierName\n     *   4. MemberExpression TemplateLiteral\n     *\n     * IsValidAssignmentTarget\n     *   1,4 = false\n     *   2,3 = true\n     *\n     *\n     * parseCallExpression (Token.OpenParen)\n     * CallExpression :\n     *   1. MemberExpression Arguments\n     *   2. CallExpression Arguments\n     *   3. CallExpression [ AssignmentExpression ]\n     *   4. CallExpression . IdentifierName\n     *   5. CallExpression TemplateLiteral\n     *\n     * IsValidAssignmentTarget\n     *   1,2,5 = false\n     *   3,4 = true\n     */\n    let name = state.tokenValue as string;\n    while ((state.currentToken & Token.LeftHandSide) > 0) {\n      switch ((state.currentToken as Token)) {\n        case Token.Dot:\n          state.assignable = true;\n          nextToken(state);\n          if ((state.currentToken & Token.IdentifierName) === 0) {\n            throw Reporter.error(SyntaxError.ExpectedIdentifier, { state });\n          }\n          name = state.tokenValue as string;\n          nextToken(state);\n          // Change $This to $Scope, change $Scope to $Member, keep $Member as-is, change $Keyed to $Member, disregard other flags\n          access = ((access & (Access.This | Access.Scope)) << 1) | (access & Access.Member) | ((access & Access.Keyed) >> 1);\n          if ((state.currentToken as Token) === Token.OpenParen) {\n            if (access === Access.Reset) { // if the left hand side is a literal, make sure we parse a CallMember\n              access = Access.Member;\n            }\n            continue;\n          }\n          if (access & Access.Scope) {\n            result = new AccessScope(name, (result as AccessScope | AccessThis).ancestor);\n          } else { // if it's not $Scope, it's $Member\n            result = new AccessMember(result as IsLeftHandSide, name);\n          }\n          continue;\n        case Token.OpenBracket:\n          state.assignable = true;\n          nextToken(state);\n          access = Access.Keyed;\n          result = new AccessKeyed(result as IsLeftHandSide, parse(state, Access.Reset, Precedence.Assign, bindingType));\n          consume(state, Token.CloseBracket);\n          break;\n        case Token.OpenParen:\n          state.assignable = false;\n          nextToken(state);\n          const args = new Array<IsAssign>();\n          while ((state.currentToken as Token) !== Token.CloseParen) {\n            args.push(parse(state, Access.Reset, Precedence.Assign, bindingType));\n            if (!consumeOpt(state, Token.Comma)) {\n              break;\n            }\n          }\n          consume(state, Token.CloseParen);\n          if (access & Access.Scope) {\n            result = new CallScope(name, args, (result as AccessScope | AccessThis).ancestor);\n          } else if (access & Access.Member) {\n            result = new CallMember(result as IsLeftHandSide, name, args);\n          } else {\n            result = new CallFunction(result as IsLeftHandSide, args);\n          }\n          access = 0;\n          break;\n        case Token.TemplateTail:\n          state.assignable = false;\n          const strings = [state.tokenValue as string];\n          result = new TaggedTemplate(strings, strings, result as IsLeftHandSide);\n          nextToken(state);\n          break;\n        case Token.TemplateContinuation:\n          result = parseTemplate(state, access, bindingType, result as IsLeftHandSide, true);\n        default:\n      }\n    }\n  }\n\n  // tslint:disable-next-line:no-any\n  if (Precedence.Binary < minPrecedence) return result as any;\n\n  /** parseBinaryExpression\n   * https://tc39.github.io/ecma262/#sec-multiplicative-operators\n   *\n   * MultiplicativeExpression : (local precedence 6)\n   *   UnaryExpression\n   *   MultiplicativeExpression * / % UnaryExpression\n   *\n   * AdditiveExpression : (local precedence 5)\n   *   MultiplicativeExpression\n   *   AdditiveExpression + - MultiplicativeExpression\n   *\n   * RelationalExpression : (local precedence 4)\n   *   AdditiveExpression\n   *   RelationalExpression < > <= >= instanceof in AdditiveExpression\n   *\n   * EqualityExpression : (local precedence 3)\n   *   RelationalExpression\n   *   EqualityExpression == != === !== RelationalExpression\n   *\n   * LogicalANDExpression : (local precedence 2)\n   *   EqualityExpression\n   *   LogicalANDExpression && EqualityExpression\n   *\n   * LogicalORExpression : (local precedence 1)\n   *   LogicalANDExpression\n   *   LogicalORExpression || LogicalANDExpression\n   */\n  while ((state.currentToken & Token.BinaryOp) > 0) {\n    const opToken = state.currentToken;\n    if ((opToken & Token.Precedence) <= minPrecedence) {\n      break;\n    }\n    nextToken(state);\n    result = new Binary(TokenValues[opToken & Token.Type] as BinaryOperator, result as IsBinary, parse(state, access, opToken & Token.Precedence, bindingType));\n    state.assignable = false;\n  }\n  // tslint:disable-next-line:no-any\n  if (Precedence.Conditional < minPrecedence) return result as any;\n\n  /**\n   * parseConditionalExpression\n   * https://tc39.github.io/ecma262/#prod-ConditionalExpression\n   *\n   * ConditionalExpression :\n   *   1. BinaryExpression\n   *   2. BinaryExpression ? AssignmentExpression : AssignmentExpression\n   *\n   * IsValidAssignmentTarget\n   *   1,2 = false\n   */\n\n  if (consumeOpt(state, Token.Question)) {\n    const yes = parse(state, access, Precedence.Assign, bindingType);\n    consume(state, Token.Colon);\n    result = new Conditional(result as IsBinary, yes, parse(state, access, Precedence.Assign, bindingType));\n    state.assignable = false;\n  }\n  // tslint:disable-next-line:no-any\n  if (Precedence.Assign < minPrecedence) return result as any;\n\n  /** parseAssignmentExpression\n   * https://tc39.github.io/ecma262/#prod-AssignmentExpression\n   * Note: AssignmentExpression here is equivalent to ES Expression because we don't parse the comma operator\n   *\n   * AssignmentExpression :\n   *   1. ConditionalExpression\n   *   2. LeftHandSideExpression = AssignmentExpression\n   *\n   * IsValidAssignmentTarget\n   *   1,2 = false\n   */\n  if (consumeOpt(state, Token.Equals)) {\n    if (!state.assignable) {\n      throw Reporter.error(SemanticError.NotAssignable, { state });\n    }\n    result = new Assign(result as IsAssignable, parse(state, access, Precedence.Assign, bindingType));\n  }\n  // tslint:disable-next-line:no-any\n  if (Precedence.Variadic < minPrecedence) return result as any;\n\n  /** parseValueConverter\n   */\n  while (consumeOpt(state, Token.Bar)) {\n    if (state.currentToken === Token.EOF) {\n      throw Reporter.error(112);\n    }\n    const name = state.tokenValue as string;\n    nextToken(state);\n    const args = new Array<IsAssign>();\n    while (consumeOpt(state, Token.Colon)) {\n      args.push(parse(state, access, Precedence.Assign, bindingType));\n    }\n    result = new ValueConverter(result as IsValueConverter, name, args);\n  }\n\n  /** parseBindingBehavior\n   */\n  while (consumeOpt(state, Token.Ampersand)) {\n    if (state.currentToken === Token.EOF) {\n      throw Reporter.error(113);\n    }\n    const name = state.tokenValue as string;\n    nextToken(state);\n    const args = new Array<IsAssign>();\n    while (consumeOpt(state, Token.Colon)) {\n      args.push(parse(state, access, Precedence.Assign, bindingType));\n    }\n    result = new BindingBehavior(result as IsBindingBehavior, name, args);\n  }\n  if (state.currentToken !== Token.EOF) {\n    if (bindingType & BindingType.Interpolation) {\n      // tslint:disable-next-line:no-any\n      return result as any;\n    }\n    if (state.tokenRaw === 'of') {\n      throw Reporter.error(SemanticError.UnexpectedForOf, { state });\n    }\n    throw Reporter.error(SyntaxError.UnconsumedToken, { state });\n  }\n  // tslint:disable-next-line:no-any\n  return result as any;\n}\n\n/**\n * parseArrayLiteralExpression\n * https://tc39.github.io/ecma262/#prod-ArrayLiteral\n *\n * ArrayLiteral :\n *   [ Elision(opt) ]\n *   [ ElementList ]\n *   [ ElementList, Elision(opt) ]\n *\n * ElementList :\n *   Elision(opt) AssignmentExpression\n *   ElementList, Elision(opt) AssignmentExpression\n *\n * Elision :\n *  ,\n *  Elision ,\n */\nfunction parseArrayLiteralExpression(state: ParserState, access: Access, bindingType: BindingType): ArrayBindingPattern | ArrayLiteral {\n  nextToken(state);\n  const elements = new Array<IsAssign>();\n  while (state.currentToken !== Token.CloseBracket) {\n    if (consumeOpt(state, Token.Comma)) {\n      elements.push($undefined);\n      if ((state.currentToken as Token) === Token.CloseBracket) {\n        elements.push($undefined);\n        break;\n      }\n    } else {\n      elements.push(parse(state, access, Precedence.Assign, bindingType & ~BindingType.IsIterator));\n      if (consumeOpt(state, Token.Comma)) {\n        if ((state.currentToken as Token) === Token.CloseBracket) {\n          elements.push($undefined);\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n  }\n  consume(state, Token.CloseBracket);\n  if (bindingType & BindingType.IsIterator) {\n    return new ArrayBindingPattern(elements);\n  } else {\n    state.assignable = false;\n    return new ArrayLiteral(elements);\n  }\n}\n\nfunction parseForOfStatement(state: ParserState, result: BindingIdentifier | ArrayBindingPattern | ObjectBindingPattern): ForOfStatement {\n  if ((result.$kind & ExpressionKind.IsForDeclaration) === 0) {\n    throw Reporter.error(SyntaxError.InvalidForDeclaration, { state });\n  }\n  if (state.currentToken !== Token.OfKeyword) {\n    throw Reporter.error(SyntaxError.InvalidForDeclaration, { state });\n  }\n  nextToken(state);\n  const declaration = result;\n  const statement = parse(state, Access.Reset, Precedence.Variadic, BindingType.None);\n  return new ForOfStatement(declaration, statement as IsBindingBehavior);\n}\n\n/**\n * parseObjectLiteralExpression\n * https://tc39.github.io/ecma262/#prod-Literal\n *\n * ObjectLiteral :\n *   { }\n *   { PropertyDefinitionList }\n *\n * PropertyDefinitionList :\n *   PropertyDefinition\n *   PropertyDefinitionList, PropertyDefinition\n *\n * PropertyDefinition :\n *   IdentifierName\n *   PropertyName : AssignmentExpression\n *\n * PropertyName :\n *   IdentifierName\n *   StringLiteral\n *   NumericLiteral\n */\nfunction parseObjectLiteralExpression(state: ParserState, bindingType: BindingType): ObjectBindingPattern | ObjectLiteral {\n  const keys = new Array<string | number>();\n  const values = new Array<IsAssign>();\n  nextToken(state);\n  while (state.currentToken !== Token.CloseBrace) {\n    keys.push(state.tokenValue);\n    // Literal = mandatory colon\n    if (state.currentToken & Token.StringOrNumericLiteral) {\n      nextToken(state);\n      consume(state, Token.Colon);\n      values.push(parse(state, Access.Reset, Precedence.Assign, bindingType & ~BindingType.IsIterator));\n    } else if (state.currentToken & Token.IdentifierName) {\n      // IdentifierName = optional colon\n      const { currentChar, currentToken, index } = state;\n      nextToken(state);\n      if (consumeOpt(state, Token.Colon)) {\n        values.push(parse(state, Access.Reset, Precedence.Assign, bindingType & ~BindingType.IsIterator));\n      } else {\n        // Shorthand\n        state.currentChar = currentChar;\n        state.currentToken = currentToken;\n        state.index = index;\n        values.push(parse(state, Access.Reset, Precedence.Primary, bindingType & ~BindingType.IsIterator));\n      }\n    } else {\n      throw Reporter.error(SyntaxError.InvalidObjectLiteralPropertyDefinition, { state });\n    }\n    if ((state.currentToken as Token) !== Token.CloseBrace) {\n      consume(state, Token.Comma);\n    }\n  }\n  consume(state, Token.CloseBrace);\n  if (bindingType & BindingType.IsIterator) {\n    return new ObjectBindingPattern(keys, values);\n  } else {\n    state.assignable = false;\n    return new ObjectLiteral(keys, values);\n  }\n}\n\nfunction parseInterpolation(state: ParserState): Interpolation {\n  const parts = [];\n  const expressions = [];\n  const length = state.length;\n  let result = '';\n  while (state.index < length) {\n    switch (state.currentChar) {\n      case Char.Dollar:\n        if (state.input.charCodeAt(state.index + 1) === Char.OpenBrace) {\n          parts.push(result);\n          result = '';\n\n          state.index += 2;\n          state.currentChar = state.input.charCodeAt(state.index);\n          nextToken(state);\n          const expression = parse(state, Access.Reset, Precedence.Variadic, BindingType.Interpolation);\n          expressions.push(expression);\n          continue;\n        } else {\n          result += '$';\n        }\n        break;\n      case Char.Backslash:\n        result += String.fromCharCode(unescapeCode(nextChar(state)));\n        break;\n      default:\n        result += String.fromCharCode(state.currentChar);\n    }\n    nextChar(state);\n  }\n  if (expressions.length) {\n    parts.push(result);\n    return new Interpolation(parts, expressions);\n  }\n  return null;\n}\n\n/**\n * parseTemplateLiteralExpression\n * https://tc39.github.io/ecma262/#prod-Literal\n *\n * Template :\n *   NoSubstitutionTemplate\n *   TemplateHead\n *\n * NoSubstitutionTemplate :\n *   ` TemplateCharacters(opt) `\n *\n * TemplateHead :\n *   ` TemplateCharacters(opt) ${\n *\n * TemplateSubstitutionTail :\n *   TemplateMiddle\n *   TemplateTail\n *\n * TemplateMiddle :\n *   } TemplateCharacters(opt) ${\n *\n * TemplateTail :\n *   } TemplateCharacters(opt) `\n *\n * TemplateCharacters :\n *   TemplateCharacter TemplateCharacters(opt)\n *\n * TemplateCharacter :\n *   $ [lookahead ≠ {]\n *   \\ EscapeSequence\n *   SourceCharacter (but not one of ` or \\ or $)\n */\nfunction parseTemplate(state: ParserState, access: Access, bindingType: BindingType, result: IsLeftHandSide, tagged: boolean): TaggedTemplate | Template {\n  const cooked = [state.tokenValue as string];\n  // TODO: properly implement raw parts / decide whether we want this\n  consume(state, Token.TemplateContinuation);\n  const expressions = [parse(state, access, Precedence.Assign, bindingType)];\n  while ((state.currentToken = scanTemplateTail(state)) !== Token.TemplateTail) {\n    cooked.push(state.tokenValue as string);\n    consume(state, Token.TemplateContinuation);\n    expressions.push(parse(state, access, Precedence.Assign, bindingType));\n  }\n  cooked.push(state.tokenValue as string);\n  state.assignable = false;\n  if (tagged) {\n    nextToken(state);\n    return new TaggedTemplate(cooked, cooked, result, expressions);\n  } else {\n    nextToken(state);\n    return new Template(cooked, expressions);\n  }\n}\n\nfunction nextToken(state: ParserState): void {\n  while (state.index < state.length) {\n    state.startIndex = state.index;\n    if ((state.currentToken = CharScanners[state.currentChar](state)) !== null) { // a null token means the character must be skipped\n      return;\n    }\n  }\n  state.currentToken = Token.EOF;\n}\n\nfunction nextChar(state: ParserState): number {\n  return state.currentChar = state.input.charCodeAt(++state.index);\n}\n\nfunction scanIdentifier(state: ParserState): Token {\n  // run to the next non-idPart\n  while (IdParts[nextChar(state)]);\n\n  const token: Token|undefined = KeywordLookup[state.tokenValue = state.tokenRaw];\n  return token === undefined ? Token.Identifier : token;\n}\n\nfunction scanNumber(state: ParserState, isFloat: boolean): Token {\n  let char = state.currentChar;\n  if (isFloat === false) {\n    do {\n      char = nextChar(state);\n    } while (char <= Char.Nine && char >= Char.Zero);\n\n    if (char !== Char.Dot) {\n      state.tokenValue = parseInt(state.tokenRaw, 10);\n      return Token.NumericLiteral;\n    }\n    // past this point it's always a float\n    char = nextChar(state);\n    if (state.index >= state.length) {\n      // unless the number ends with a dot - that behaves a little different in native ES expressions\n      // but in our AST that behavior has no effect because numbers are always stored in variables\n      state.tokenValue = parseInt(state.tokenRaw.slice(0, -1), 10);\n      return Token.NumericLiteral;\n    }\n  }\n\n  if (char <= Char.Nine && char >= Char.Zero) {\n    do {\n      char = nextChar(state);\n    } while (char <= Char.Nine && char >= Char.Zero);\n  } else {\n    state.currentChar = state.input.charCodeAt(--state.index);\n  }\n\n  state.tokenValue = parseFloat(state.tokenRaw);\n  return Token.NumericLiteral;\n}\n\nfunction scanString(state: ParserState): Token {\n  const quote = state.currentChar;\n  nextChar(state); // Skip initial quote.\n\n  let unescaped = 0;\n  const buffer = new Array<string>();\n  let marker = state.index;\n\n  while (state.currentChar !== quote) {\n    if (state.currentChar === Char.Backslash) {\n      buffer.push(state.input.slice(marker, state.index));\n      nextChar(state);\n      unescaped = unescapeCode(state.currentChar);\n      nextChar(state);\n      buffer.push(String.fromCharCode(unescaped));\n      marker = state.index;\n    } else if (state.index >= state.length) {\n      throw Reporter.error(SyntaxError.UnterminatedQuote, { state });\n    } else {\n      nextChar(state);\n    }\n  }\n\n  const last = state.input.slice(marker, state.index);\n  nextChar(state); // Skip terminating quote.\n\n  // Compute the unescaped string value.\n  buffer.push(last);\n  const unescapedStr = buffer.join('');\n\n  state.tokenValue = unescapedStr;\n  return Token.StringLiteral;\n}\n\nfunction scanTemplate(state: ParserState): Token {\n  let tail = true;\n  let result = '';\n\n  while (nextChar(state) !== Char.Backtick) {\n    if (state.currentChar === Char.Dollar) {\n      if ((state.index + 1) < state.length && state.input.charCodeAt(state.index + 1) === Char.OpenBrace) {\n        state.index++;\n        tail = false;\n        break;\n      } else {\n        result += '$';\n      }\n    } else if (state.currentChar === Char.Backslash) {\n      result += String.fromCharCode(unescapeCode(nextChar(state)));\n    } else {\n      if (state.index >= state.length) {\n        throw Reporter.error(SyntaxError.UnterminatedTemplate, { state });\n      }\n      result += String.fromCharCode(state.currentChar);\n    }\n  }\n\n  nextChar(state);\n  state.tokenValue = result;\n  if (tail) {\n    return Token.TemplateTail;\n  }\n  return Token.TemplateContinuation;\n}\n\nfunction scanTemplateTail(state: ParserState): Token {\n  if (state.index >= state.length) {\n    throw Reporter.error(SyntaxError.UnterminatedTemplate, { state });\n  }\n  state.index--;\n  return scanTemplate(state);\n}\n\nfunction consumeOpt(state: ParserState, token: Token): boolean {\n  // tslint:disable-next-line:possible-timing-attack\n  if (state.currentToken === token) {\n    nextToken(state);\n    return true;\n  }\n\n  return false;\n}\n\nfunction consume(state: ParserState, token: Token): void {\n  // tslint:disable-next-line:possible-timing-attack\n  if (state.currentToken === token) {\n    nextToken(state);\n  } else {\n    throw Reporter.error(SyntaxError.MissingExpectedToken, { state, expected: token });\n  }\n}\n\n/**\n * Array for mapping tokens to token values. The indices of the values\n * correspond to the token bits 0-38.\n * For this to work properly, the values in the array must be kept in\n * the same order as the token bits.\n * Usage: TokenValues[token & Token.Type]\n */\nconst TokenValues = [\n  $false, $true, $null, $undefined, '$this', '$parent',\n\n  '(', '{', '.', '}', ')', ',', '[', ']', ':', '?', '\\'', '\"',\n\n  '&', '|', '||', '&&', '==', '!=', '===', '!==', '<', '>',\n  '<=', '>=', 'in', 'instanceof', '+', '-', 'typeof', 'void', '*', '%', '/', '=', '!',\n  Token.TemplateTail, Token.TemplateContinuation,\n  'of'\n];\n\nconst KeywordLookup: {\n  [key: string]: Token;\n} = Object.create(null);\nKeywordLookup.true = Token.TrueKeyword;\nKeywordLookup.null = Token.NullKeyword;\nKeywordLookup.false = Token.FalseKeyword;\nKeywordLookup.undefined = Token.UndefinedKeyword;\nKeywordLookup.$this = Token.ThisScope;\nKeywordLookup.$parent = Token.ParentScope;\nKeywordLookup.in = Token.InKeyword;\nKeywordLookup.instanceof = Token.InstanceOfKeyword;\nKeywordLookup.typeof = Token.TypeofKeyword;\nKeywordLookup.void = Token.VoidKeyword;\nKeywordLookup.of = Token.OfKeyword;\n\n/**\n * Ranges of code points in pairs of 2 (eg 0x41-0x5B, 0x61-0x7B, ...) where the second value is not inclusive (5-7 means 5 and 6)\n * Single values are denoted by the second value being a 0\n *\n * Copied from output generated with \"node build/generate-unicode.js\"\n *\n * See also: https://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF\n */\nconst codes = {\n  /* [$0-9A-Za_a-z] */\n  AsciiIdPart: [0x24, 0, 0x30, 0x3A, 0x41, 0x5B, 0x5F, 0, 0x61, 0x7B],\n  IdStart: /*IdentifierStart*/[0x24, 0, 0x41, 0x5B, 0x5F, 0, 0x61, 0x7B, 0xAA, 0, 0xBA, 0, 0xC0, 0xD7, 0xD8, 0xF7, 0xF8, 0x2B9, 0x2E0, 0x2E5, 0x1D00, 0x1D26, 0x1D2C, 0x1D5D, 0x1D62, 0x1D66, 0x1D6B, 0x1D78, 0x1D79, 0x1DBF, 0x1E00, 0x1F00, 0x2071, 0, 0x207F, 0, 0x2090, 0x209D, 0x212A, 0x212C, 0x2132, 0, 0x214E, 0, 0x2160, 0x2189, 0x2C60, 0x2C80, 0xA722, 0xA788, 0xA78B, 0xA7AF, 0xA7B0, 0xA7B8, 0xA7F7, 0xA800, 0xAB30, 0xAB5B, 0xAB5C, 0xAB65, 0xFB00, 0xFB07, 0xFF21, 0xFF3B, 0xFF41, 0xFF5B],\n  Digit: /*DecimalNumber*/[0x30, 0x3A],\n  Skip: /*Skippable*/[0, 0x21, 0x7F, 0xA1]\n};\n\n/**\n * Decompress the ranges into an array of numbers so that the char code\n * can be used as an index to the lookup\n */\nfunction decompress(lookup: (CharScanner | number)[] | null, $set: Set<number> | null, compressed: number[], value: CharScanner | number | boolean): void {\n  const rangeCount = compressed.length;\n  for (let i = 0; i < rangeCount; i += 2) {\n    const start = compressed[i];\n    let end = compressed[i + 1];\n    end = end > 0 ? end : start + 1;\n    if (lookup) {\n      lookup.fill(value as CharScanner | number, start, end);\n    }\n    if ($set) {\n      for (let ch = start; ch < end; ch++) {\n        $set.add(ch);\n      }\n    }\n  }\n}\n\n// CharFuncLookup functions\nfunction returnToken(token: Token): (s: ParserState) => Token {\n  return s => {\n    nextChar(s);\n    return token;\n  };\n}\nconst unexpectedCharacter: CharScanner = s => {\n  throw Reporter.error(SyntaxError.UnexpectedCharacter, { state: s });\n};\nunexpectedCharacter.notMapped = true;\n\n// ASCII IdentifierPart lookup\nconst AsciiIdParts = new Set();\ndecompress(null, AsciiIdParts, codes.AsciiIdPart, true);\n\n// IdentifierPart lookup\nconst IdParts = new Uint8Array(0xFFFF);\n// tslint:disable-next-line:no-any\ndecompress(IdParts as any, null, codes.IdStart, 1);\n// tslint:disable-next-line:no-any\ndecompress(IdParts as any, null, codes.Digit, 1);\n\ntype CharScanner = ((p: ParserState) => Token | null) & { notMapped?: boolean };\n\n// Character scanning function lookup\nconst CharScanners = new Array<CharScanner>(0xFFFF);\nCharScanners.fill(unexpectedCharacter, 0, 0xFFFF);\n\ndecompress(CharScanners, null, codes.Skip, s => {\n  nextChar(s);\n  return null;\n});\ndecompress(CharScanners, null, codes.IdStart, scanIdentifier);\ndecompress(CharScanners, null, codes.Digit, s => scanNumber(s, false));\n\nCharScanners[Char.DoubleQuote] =\nCharScanners[Char.SingleQuote] = s => {\n  return scanString(s);\n};\nCharScanners[Char.Backtick] = s => {\n  return scanTemplate(s);\n};\n\n// !, !=, !==\nCharScanners[Char.Exclamation] = s => {\n  if (nextChar(s) !== Char.Equals) {\n    return Token.Exclamation;\n  }\n  if (nextChar(s) !== Char.Equals) {\n    return Token.ExclamationEquals;\n  }\n  nextChar(s);\n  return Token.ExclamationEqualsEquals;\n};\n\n// =, ==, ===\nCharScanners[Char.Equals] =  s => {\n  if (nextChar(s) !== Char.Equals) {\n    return Token.Equals;\n  }\n  if (nextChar(s) !== Char.Equals) {\n    return Token.EqualsEquals;\n  }\n  nextChar(s);\n  return Token.EqualsEqualsEquals;\n};\n\n// &, &&\nCharScanners[Char.Ampersand] = s => {\n  if (nextChar(s) !== Char.Ampersand) {\n    return Token.Ampersand;\n  }\n  nextChar(s);\n  return Token.AmpersandAmpersand;\n};\n\n// |, ||\nCharScanners[Char.Bar] = s => {\n  if (nextChar(s) !== Char.Bar) {\n    return Token.Bar;\n  }\n  nextChar(s);\n  return Token.BarBar;\n};\n\n// .\nCharScanners[Char.Dot] = s => {\n  if (nextChar(s) <= Char.Nine && s.currentChar >= Char.Zero) {\n    return scanNumber(s, true);\n  }\n  return Token.Dot;\n};\n\n// <, <=\nCharScanners[Char.LessThan] =  s => {\n  if (nextChar(s) !== Char.Equals) {\n    return Token.LessThan;\n  }\n  nextChar(s);\n  return Token.LessThanEquals;\n};\n\n// >, >=\nCharScanners[Char.GreaterThan] =  s => {\n  if (nextChar(s) !== Char.Equals) {\n    return Token.GreaterThan;\n  }\n  nextChar(s);\n  return Token.GreaterThanEquals;\n};\n\nCharScanners[Char.Percent]      = returnToken(Token.Percent);\nCharScanners[Char.OpenParen]    = returnToken(Token.OpenParen);\nCharScanners[Char.CloseParen]   = returnToken(Token.CloseParen);\nCharScanners[Char.Asterisk]     = returnToken(Token.Asterisk);\nCharScanners[Char.Plus]         = returnToken(Token.Plus);\nCharScanners[Char.Comma]        = returnToken(Token.Comma);\nCharScanners[Char.Minus]        = returnToken(Token.Minus);\nCharScanners[Char.Slash]        = returnToken(Token.Slash);\nCharScanners[Char.Colon]        = returnToken(Token.Colon);\nCharScanners[Char.Question]     = returnToken(Token.Question);\nCharScanners[Char.OpenBracket]  = returnToken(Token.OpenBracket);\nCharScanners[Char.CloseBracket] = returnToken(Token.CloseBracket);\nCharScanners[Char.OpenBrace]    = returnToken(Token.OpenBrace);\nCharScanners[Char.CloseBrace]   = returnToken(Token.CloseBrace);\n","import { PLATFORM, Reporter } from '@aurelia/kernel';\nimport { AttributeDefinition, BindingMode, CustomAttributeResource, CustomElementResource, IBindableDescription, IElement, IResourceDescriptions, TemplateDefinition } from '@aurelia/runtime';\nimport { AttrSyntax } from './ast';\nimport { BindingCommandResource, IBindingCommand } from './binding-command';\n\n/**\n * A pre-processed piece of information about declared custom elements, attributes and\n * binding commands, optimized for consumption by the template compiler.\n */\nexport class ResourceModel {\n\n  private resources: IResourceDescriptions;\n  private elementLookup: Record<string, ElementInfo>;\n  private attributeLookup: Record<string, AttrInfo>;\n  private commandLookup: Record<string, IBindingCommand>;\n\n  constructor(resources: IResourceDescriptions) {\n    this.resources = resources;\n    this.elementLookup = {};\n    this.attributeLookup = {};\n    this.commandLookup = {};\n  }\n\n  /**\n   * Retrieve information about a custom element resource.\n   *\n   * @param element The original DOM element.\n   *\n   * @returns The resource information if the element exists, or `null` if it does not exist.\n   */\n  public getElementInfo(element: IElement): ElementInfo | null {\n    let name = element.getAttribute('as-element');\n    if (name === null) {\n      name = element.nodeName.toLowerCase();\n    }\n    let result = this.elementLookup[name];\n    if (result === undefined) {\n      const def = this.resources.find(CustomElementResource, name);\n      if (def === null) {\n        result = null;\n      } else {\n        result = createElementInfo(def);\n      }\n      this.elementLookup[name] = result;\n    }\n    return result;\n  }\n\n  /**\n   * Retrieve information about a custom attribute resource.\n   *\n   * @param syntax The parsed `AttrSyntax`\n   *\n   * @returns The resource information if the attribute exists, or `null` if it does not exist.\n   */\n  public getAttributeInfo(syntax: AttrSyntax): AttrInfo | null {\n    const name = PLATFORM.camelCase(syntax.target);\n    let result = this.attributeLookup[name];\n    if (result === undefined) {\n      const def = this.resources.find(CustomAttributeResource, name);\n      if (def === null) {\n        result = null;\n      } else {\n        result = createAttributeInfo(def);\n      }\n      this.attributeLookup[name] = result;\n    }\n    return result;\n  }\n\n  /**\n   * Retrieve a binding command resource.\n   *\n   * @param name The parsed `AttrSyntax`\n   *\n   * @returns An instance of the command if it exists, or `null` if it does not exist.\n   */\n  public getBindingCommand(syntax: AttrSyntax): IBindingCommand | null {\n    const name = syntax.command;\n    if (name === null) {\n      return null;\n    }\n    let result = this.commandLookup[name];\n    if (result === undefined) {\n      result = this.resources.create(BindingCommandResource, name);\n      if (result === null) {\n        // unknown binding command\n        throw Reporter.error(0); // TODO: create error code\n      }\n      this.commandLookup[name] = result;\n    }\n    return result;\n  }\n}\n\nfunction createElementInfo(def: TemplateDefinition): ElementInfo {\n  const info = new ElementInfo(def.name, def.containerless);\n  const bindables = def.bindables;\n  const defaultBindingMode = BindingMode.toView;\n\n  let bindable: IBindableDescription;\n  let prop: string;\n  let attr: string;\n  let mode: BindingMode;\n\n  for (prop in bindables) {\n    bindable = bindables[prop];\n    // explicitly provided property name has priority over the implicit property name\n    if (bindable.property !== undefined) {\n      prop = bindable.property;\n    }\n    // explicitly provided attribute name has priority over the derived implicit attribute name\n    if (bindable.attribute !== undefined) {\n      attr = bindable.attribute;\n    } else {\n      // derive the attribute name from the resolved property name\n      attr = PLATFORM.kebabCase(prop);\n    }\n    if (bindable.mode !== undefined && bindable.mode !== BindingMode.default) {\n      mode = bindable.mode;\n    } else {\n      mode = defaultBindingMode;\n    }\n    info.bindables[attr] = new BindableInfo(prop, mode);\n  }\n  return info;\n}\n\nfunction createAttributeInfo(def: AttributeDefinition): AttrInfo {\n  const info = new AttrInfo(def.name, def.isTemplateController);\n  const bindables = def.bindables;\n  const defaultBindingMode = def.defaultBindingMode !== undefined && def.defaultBindingMode !== BindingMode.default\n    ? def.defaultBindingMode\n    : BindingMode.toView;\n\n  let bindable: IBindableDescription;\n  let prop: string;\n  let mode: BindingMode;\n  let bindableCount: number = 0;\n\n  for (prop in bindables) {\n    ++bindableCount;\n    bindable = bindables[prop];\n    // explicitly provided property name has priority over the implicit property name\n    if (bindable.property !== undefined) {\n      prop = bindable.property;\n    }\n    if (bindable.mode !== undefined && bindable.mode !== BindingMode.default) {\n      mode = bindable.mode;\n    } else {\n      mode = defaultBindingMode;\n    }\n    info.bindables[prop] = new BindableInfo(prop, mode);\n    // set to first bindable by convention\n    if (info.bindable === null) {\n      info.bindable = info.bindables[prop];\n    }\n  }\n  // if no bindables are present, default to \"value\"\n  if (info.bindable === null) {\n    info.bindable = new BindableInfo('value', defaultBindingMode);\n  }\n  if (def.hasDynamicOptions || bindableCount > 1) {\n    info.hasDynamicOptions = true;\n  }\n  return info;\n}\n\n/**\n * A pre-processed piece of information about a defined bindable property on a custom\n * element or attribute, optimized for consumption by the template compiler.\n */\nexport class BindableInfo {\n  /**\n   * The pre-processed *property* (not attribute) name of the bindable, which is\n   * (in order of priority):\n   *\n   * 1. The `property` from the description (if defined)\n   * 2. The name of the property of the bindable itself\n   */\n  public propName: string;\n  /**\n   * The pre-processed (default) bindingMode of the bindable, which is (in order of priority):\n   *\n   * 1. The `mode` from the bindable (if defined and not bindingMode.default)\n   * 2. The `defaultBindingMode` (if it's an attribute, defined, and not bindingMode.default)\n   * 3. `bindingMode.toView`\n   */\n  public mode: BindingMode;\n\n  constructor(propName: string, mode: BindingMode) {\n    this.propName = propName;\n    this.mode = mode;\n  }\n}\n\n/**\n * Pre-processed information about a custom element resource, optimized\n * for consumption by the template compiler.\n */\nexport class ElementInfo {\n  public name: string;\n  public containerless: boolean;\n\n  /**\n   * A lookup of the bindables of this element, indexed by the (pre-processed)\n   * attribute names as they would be found in parsed markup.\n   */\n  public bindables: Record<string, BindableInfo>;\n\n  constructor(name: string, containerless: boolean) {\n    this.name = name;\n    this.containerless = containerless;\n    this.bindables = {};\n  }\n}\n\n/**\n * Pre-processed information about a custom attribute resource, optimized\n * for consumption by the template compiler.\n */\nexport class AttrInfo {\n  public name: string;\n\n  /**\n   * A lookup of the bindables of this attribute, indexed by the (pre-processed)\n   * bindable names as they would be found in the attribute value.\n   *\n   * Only applicable to multi attribute bindings (semicolon-separated).\n   */\n  public bindables: Record<string, BindableInfo>;\n  /**\n   * The single or first bindable of this attribute, or a default 'value'\n   * bindable if no bindables were defined on the attribute.\n   *\n   * Only applicable to single attribute bindings (where the attribute value\n   * contains no semicolons)\n   */\n  public bindable: BindableInfo;\n\n  public isTemplateController: boolean;\n\n  public hasDynamicOptions: boolean;\n\n  constructor(name: string, isTemplateController: boolean) {\n    this.name = name;\n    this.bindables = {};\n    this.bindable = null;\n    this.isTemplateController = isTemplateController;\n    this.hasDynamicOptions = false;\n  }\n}\n","import { PLATFORM, Reporter, Tracer } from '@aurelia/kernel';\nimport { BindingMode, BindingType, DOM, IExpressionParser, IHTMLElement, IHTMLTemplateElement, INode, Interpolation, IsExpressionOrStatement, IText, NodeType } from '@aurelia/runtime';\nimport { AttrSyntax } from './ast';\nimport { IAttributeParser } from './attribute-parser';\nimport { IBindingCommand } from './binding-command';\nimport { Char } from './common';\nimport { AttrInfo, BindableInfo, ElementInfo, ResourceModel } from './resource-model';\n\nexport const enum SymbolFlags {\n  type                 = 0b000000_111111111,\n  isTemplateController = 0b000000_000000001,\n  isReplacePart        = 0b000000_000000010,\n  isCustomAttribute    = 0b000000_000000100,\n  isPlainAttribute     = 0b000000_000001000,\n  isCustomElement      = 0b000000_000010000,\n  isLetElement         = 0b000000_000100000,\n  isPlainElement       = 0b000000_001000000,\n  isText               = 0b000000_010000000,\n  isBinding            = 0b000000_100000000,\n  hasMarker            = 0b000001_000000000,\n  hasTemplate          = 0b000010_000000000,\n  hasAttributes        = 0b000100_000000000,\n  hasBindings          = 0b001000_000000000,\n  hasChildNodes        = 0b010000_000000000,\n  hasParts             = 0b100000_000000000,\n}\n\n/**\n * A html attribute that is associated with a registered resource, specifically a template controller.\n */\nexport class TemplateControllerSymbol {\n  public flags: SymbolFlags;\n  public res: string;\n  public partName: string | null;\n  public physicalNode: IHTMLTemplateElement | null;\n  public syntax: AttrSyntax;\n  public template: ParentNodeSymbol | null;\n  public templateController: TemplateControllerSymbol | null;\n  public marker: IHTMLElement;\n\n  private _bindings: BindingSymbol[] | null;\n  public get bindings(): BindingSymbol[] {\n    if (this._bindings === null) {\n      this._bindings = [];\n      this.flags |= SymbolFlags.hasBindings;\n    }\n    return this._bindings;\n  }\n\n  constructor(syntax: AttrSyntax, info: AttrInfo, partName: string | null) {\n    this.flags = SymbolFlags.isTemplateController | SymbolFlags.hasMarker;\n    this.res = info.name;\n    this.partName = partName;\n    this.physicalNode = null;\n    this.syntax = syntax;\n    this.template = null;\n    this.templateController = null;\n    this.marker = createMarker();\n    this._bindings = null;\n  }\n}\n\n/**\n * Wrapper for an element (with all of its attributes, regardless of the order in which they are declared)\n * that has a replace-part attribute on it.\n *\n * This element will be lifted from the DOM just like a template controller.\n */\nexport class ReplacePartSymbol {\n  public flags: SymbolFlags;\n  public name: string;\n  public physicalNode: IHTMLTemplateElement | null;\n  public parent: ParentNodeSymbol | null;\n  public template: ParentNodeSymbol | null;\n\n  constructor(name: string) {\n    this.flags = SymbolFlags.isReplacePart;\n    this.name = name;\n    this.physicalNode = null;\n    this.parent = null;\n    this.template = null;\n  }\n}\n\n/**\n * A html attribute that is associated with a registered resource, but not a template controller.\n */\nexport class CustomAttributeSymbol {\n  public flags: SymbolFlags;\n  public res: string;\n  public syntax: AttrSyntax;\n\n  private _bindings: BindingSymbol[] | null;\n  public get bindings(): BindingSymbol[] {\n    if (this._bindings === null) {\n      this._bindings = [];\n      this.flags |= SymbolFlags.hasBindings;\n    }\n    return this._bindings;\n  }\n\n  constructor(syntax: AttrSyntax, info: AttrInfo) {\n    this.flags = SymbolFlags.isCustomAttribute;\n    this.res = info.name;\n    this.syntax = syntax;\n    this._bindings = null;\n  }\n}\n\n/**\n * An attribute, with either a binding command or an interpolation, whose target is the html\n * attribute of the element.\n *\n * This will never target a bindable property of a custom attribute or element;\n */\nexport class PlainAttributeSymbol {\n  public flags: SymbolFlags;\n  public syntax: AttrSyntax;\n  public command: IBindingCommand | null;\n  public expression: IsExpressionOrStatement | null;\n\n  constructor(\n    syntax: AttrSyntax,\n    command: IBindingCommand | null,\n    expression: IsExpressionOrStatement | null\n  ) {\n    this.flags = SymbolFlags.isPlainAttribute;\n    this.syntax = syntax;\n    this.command = command;\n    this.expression = expression;\n  }\n}\n\n/**\n * Either an attribute on an custom element that maps to a declared bindable property of that element,\n * a single-value bound custom attribute, or one of several bindables that were extracted from the attribute\n * value of a dynamicOptions custom attribute.\n *\n * This will always target a bindable property of a custom attribute or element;\n */\nexport class BindingSymbol {\n  public flags: SymbolFlags;\n  public command: IBindingCommand | null;\n  public bindable: BindableInfo;\n  public expression: IsExpressionOrStatement | null;\n  public rawValue: string;\n  public target: string;\n\n  constructor(\n    command: IBindingCommand | null,\n    bindable: BindableInfo,\n    expression: IsExpressionOrStatement | null,\n    rawValue: string,\n    target: string\n  ) {\n    this.flags = SymbolFlags.isBinding;\n    this.command = command;\n    this.bindable = bindable;\n    this.expression = expression;\n    this.rawValue = rawValue;\n    this.target = target;\n  }\n}\n\n/**\n * A html element that is associated with a registered resource either via its (lowerCase) `nodeName`\n * or the value of its `as-element` attribute.\n */\nexport class CustomElementSymbol {\n  public flags: SymbolFlags;\n  public res: string;\n  public physicalNode: IHTMLElement;\n  public bindables: Record<string, BindableInfo>;\n  public isTarget: true;\n  public templateController: TemplateControllerSymbol | null;\n  public isContainerless: boolean;\n  public marker: IHTMLElement | null;\n\n  private _attributes: AttributeSymbol[] | null;\n  public get attributes(): AttributeSymbol[] {\n    if (this._attributes === null) {\n      this._attributes = [];\n      this.flags |= SymbolFlags.hasAttributes;\n    }\n    return this._attributes;\n  }\n\n  private _bindings: BindingSymbol[] | null;\n  public get bindings(): BindingSymbol[] {\n    if (this._bindings === null) {\n      this._bindings = [];\n      this.flags |= SymbolFlags.hasBindings;\n    }\n    return this._bindings;\n  }\n\n  private _childNodes: NodeSymbol[] | null;\n  public get childNodes(): NodeSymbol[] {\n    if (this._childNodes === null) {\n      this._childNodes = [];\n      this.flags |= SymbolFlags.hasChildNodes;\n    }\n    return this._childNodes;\n  }\n\n  private _parts: ReplacePartSymbol[] | null;\n  public get parts(): ReplacePartSymbol[] {\n    if (this._parts === null) {\n      this._parts = [];\n      this.flags |= SymbolFlags.hasParts;\n    }\n    return this._parts;\n  }\n\n  constructor(node: IHTMLElement, info: ElementInfo) {\n    this.flags = SymbolFlags.isCustomElement;\n    this.res = info.name;\n    this.physicalNode = node;\n    this.bindables = info.bindables;\n    this.isTarget = true;\n    this.templateController = null;\n    if (info.containerless) {\n      this.isContainerless = true;\n      this.marker = createMarker();\n      this.flags |= SymbolFlags.hasMarker;\n    } else {\n      this.isContainerless = false;\n      this.marker = null;\n    }\n    this._attributes = null;\n    this._bindings = null;\n    this._childNodes = null;\n    this._parts = null;\n  }\n}\n\nexport class LetElementSymbol {\n  public flags: SymbolFlags;\n  public physicalNode: IHTMLElement;\n  public toViewModel: boolean;\n  public marker: IHTMLElement;\n\n  private _bindings: BindingSymbol[] | null;\n  public get bindings(): BindingSymbol[] {\n    if (this._bindings === null) {\n      this._bindings = [];\n      this.flags |= SymbolFlags.hasBindings;\n    }\n    return this._bindings;\n  }\n\n  constructor(node: IHTMLElement) {\n    this.flags = SymbolFlags.isLetElement | SymbolFlags.hasMarker;\n    this.physicalNode = node;\n    this.toViewModel = false;\n    this.marker = createMarker();\n    this._bindings = null;\n  }\n}\n\n/**\n * A normal html element that may or may not have attribute behaviors and/or child node behaviors.\n *\n * It is possible for a PlainElementSymbol to not yield any instructions during compilation.\n */\nexport class PlainElementSymbol {\n  public flags: SymbolFlags;\n  public physicalNode: IHTMLElement;\n  public isTarget: boolean;\n  public templateController: TemplateControllerSymbol | null;\n  public hasSlots?: boolean;\n\n  private _attributes: AttributeSymbol[] | null;\n  public get attributes(): AttributeSymbol[] {\n    if (this._attributes === null) {\n      this._attributes = [];\n      this.flags |= SymbolFlags.hasAttributes;\n    }\n    return this._attributes;\n  }\n\n  private _childNodes: NodeSymbol[] | null;\n  public get childNodes(): NodeSymbol[] {\n    if (this._childNodes === null) {\n      this._childNodes = [];\n      this.flags |= SymbolFlags.hasChildNodes;\n    }\n    return this._childNodes;\n  }\n\n  constructor(node: IHTMLElement) {\n    this.flags = SymbolFlags.isPlainElement;\n    this.physicalNode = node;\n    this.isTarget = false;\n    this.templateController = null;\n    this._attributes = null;\n    this._childNodes = null;\n  }\n}\n\n/**\n * A standalone text node that has an interpolation.\n */\nexport class TextSymbol {\n  public flags: SymbolFlags;\n  public physicalNode: IText;\n  public interpolation: Interpolation;\n  public marker: IHTMLElement;\n\n  constructor(node: IText, interpolation: Interpolation) {\n    this.flags = SymbolFlags.isText | SymbolFlags.hasMarker;\n    this.physicalNode = node;\n    this.interpolation = interpolation;\n    this.marker = createMarker();\n  }\n}\n\nexport type AttributeSymbol = CustomAttributeSymbol | PlainAttributeSymbol;\nexport type ResourceAttributeSymbol = CustomAttributeSymbol | TemplateControllerSymbol;\nexport type ElementSymbol = CustomElementSymbol | PlainElementSymbol;\nexport type ParentNodeSymbol = ElementSymbol | TemplateControllerSymbol;\nexport type NodeSymbol = TextSymbol | LetElementSymbol | ParentNodeSymbol;\nexport type SymbolWithBindings = LetElementSymbol | CustomElementSymbol | ResourceAttributeSymbol;\nexport type SymbolWithTemplate = TemplateControllerSymbol | ReplacePartSymbol;\nexport type SymbolWithMarker = TemplateControllerSymbol | TextSymbol | LetElementSymbol | CustomElementSymbol;\nexport type AnySymbol =\n  TemplateControllerSymbol |\n  ReplacePartSymbol |\n  CustomAttributeSymbol |\n  PlainAttributeSymbol |\n  CustomElementSymbol |\n  PlainElementSymbol |\n  TextSymbol;\n\nconst slice = Array.prototype.slice;\n\nfunction createMarker(): IHTMLElement {\n  const marker = DOM.createElement('au-m');\n  marker.className = 'au';\n  return marker as IHTMLElement;\n}\n\nconst invalidSurrogateAttribute = {\n  'id': true,\n  'part': true,\n  'replace-part': true\n};\n\nconst attributesToIgnore = {\n  'as-element': true,\n  'part': true,\n  'replace-part': true\n};\n\nexport class TemplateBinder {\n  public resources: ResourceModel;\n  public attrParser: IAttributeParser;\n  public exprParser: IExpressionParser;\n\n  private surrogate: PlainElementSymbol | null;\n\n  // This is any \"original\" (as in, not a template created for a template controller) element.\n  // It collects all attribute symbols except for template controllers and replace-parts.\n  private manifest: ElementSymbol | null;\n\n  // This is the nearest wrapping custom element.\n  // It only collects replace-parts (and inherently everything that the manifest collects, if they are the same instance)\n  private manifestRoot: CustomElementSymbol | null;\n\n  // This is the nearest wrapping custom element relative to the current manifestRoot (the manifestRoot \"one level up\").\n  // It exclusively collects replace-parts that are placed on the current manifestRoot.\n  private parentManifestRoot: CustomElementSymbol | null;\n\n  private partName: string | null;\n\n  constructor(resources: ResourceModel, attrParser: IAttributeParser, exprParser: IExpressionParser) {\n    this.resources = resources;\n    this.attrParser = attrParser;\n    this.exprParser = exprParser;\n    this.surrogate = null;\n    this.manifest = null;\n    this.manifestRoot = null;\n    this.parentManifestRoot = null;\n    this.partName = null;\n  }\n\n  public bind(node: IHTMLTemplateElement): PlainElementSymbol {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bind', slice.call(arguments)); }\n\n    const surrogateSave = this.surrogate;\n    const parentManifestRootSave = this.parentManifestRoot;\n    const manifestRootSave = this.manifestRoot;\n    const manifestSave = this.manifest;\n\n    const manifest = this.surrogate = this.manifest = new PlainElementSymbol(node);\n\n    const attributes = node.attributes;\n    let i = 0;\n    while (i < attributes.length) {\n      const attr = attributes[i];\n      const attrSyntax = this.attrParser.parse(attr.name, attr.value);\n\n      if (invalidSurrogateAttribute[attrSyntax.target] === true) {\n        throw new Error(`Invalid surrogate attribute: ${attrSyntax.target}`);\n        // TODO: use reporter\n      }\n      const attrInfo = this.resources.getAttributeInfo(attrSyntax);\n      if (attrInfo === null) {\n        this.bindPlainAttribute(attrSyntax);\n      } else if (attrInfo.isTemplateController) {\n        throw new Error('Cannot have template controller on surrogate element.');\n        // TODO: use reporter\n      } else {\n        this.bindCustomAttribute(attrSyntax, attrInfo);\n      }\n      ++i;\n    }\n\n    this.bindChildNodes(node);\n\n    this.surrogate = surrogateSave;\n    this.parentManifestRoot = parentManifestRootSave;\n    this.manifestRoot = manifestRootSave;\n    this.manifest = manifestSave;\n\n    if (Tracer.enabled) { Tracer.leave(); }\n    return manifest;\n  }\n\n  private bindManifest(parentManifest: ElementSymbol, node: IHTMLTemplateElement | IHTMLElement): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindManifest', slice.call(arguments)); }\n\n    switch (node.nodeName) {\n      case 'LET':\n        // let cannot have children and has some different processing rules, so return early\n        this.bindLetElement(parentManifest, node);\n        if (Tracer.enabled) { Tracer.leave(); }\n        return;\n      case 'SLOT':\n        // slot requires no compilation\n        this.surrogate.hasSlots = true;\n        if (Tracer.enabled) { Tracer.leave(); }\n        return;\n    }\n\n    // nodes are processed bottom-up so we need to store the manifests before traversing down and\n    // restore them again afterwards\n    const parentManifestRootSave = this.parentManifestRoot;\n    const manifestRootSave = this.manifestRoot;\n    const manifestSave = this.manifest;\n\n    // get the part name to override the name of the compiled definition\n    this.partName = node.getAttribute('part');\n\n    let manifestRoot: CustomElementSymbol;\n    const elementInfo = this.resources.getElementInfo(node);\n    if (elementInfo === null) {\n      // there is no registered custom element with this name\n      this.manifest = new PlainElementSymbol(node);\n    } else {\n      // it's a custom element so we set the manifestRoot as well (for storing replace-parts)\n      this.parentManifestRoot = this.manifestRoot;\n      manifestRoot = this.manifestRoot = this.manifest = new CustomElementSymbol(node, elementInfo);\n    }\n\n    // lifting operations done by template controllers and replace-parts effectively unlink the nodes, so start at the bottom\n    this.bindChildNodes(node);\n\n    // the parentManifest will receive either the direct child nodes, or the template controllers / replace-parts\n    // wrapping them\n    this.bindAttributes(node, parentManifest);\n\n    if (manifestRoot !== undefined && manifestRoot.isContainerless) {\n      node.parentNode.replaceChild(manifestRoot.marker, node);\n    } else if (this.manifest.isTarget) {\n      node.classList.add('au');\n    }\n\n    // restore the stored manifests so the attributes are processed on the correct lavel\n    this.parentManifestRoot = parentManifestRootSave;\n    this.manifestRoot = manifestRootSave;\n    this.manifest = manifestSave;\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private bindLetElement(parentManifest: ElementSymbol, node: IHTMLElement): void {\n    const symbol = new LetElementSymbol(node);\n    parentManifest.childNodes.push(symbol);\n\n    const attributes = node.attributes;\n    let i = 0;\n    while (i < attributes.length) {\n      const attr = attributes[i];\n      if (attr.name === 'to-view-model') {\n        node.removeAttribute('to-view-model');\n        symbol.toViewModel = true;\n        continue;\n      }\n      const attrSyntax = this.attrParser.parse(attr.name, attr.value);\n      const command = this.resources.getBindingCommand(attrSyntax);\n      const bindingType = command === null ? BindingType.Interpolation : command.bindingType;\n      const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);\n      const to = PLATFORM.camelCase(attrSyntax.target);\n      const info = new BindableInfo(to, BindingMode.toView);\n      symbol.bindings.push(new BindingSymbol(command, info, expr, attrSyntax.rawValue, to));\n\n      ++i;\n    }\n    node.parentNode.replaceChild(symbol.marker, node);\n  }\n\n  private bindAttributes(node: IHTMLTemplateElement | IHTMLElement, parentManifest: ElementSymbol): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindAttributes', slice.call(arguments)); }\n\n    const { parentManifestRoot, manifestRoot, manifest } = this;\n    // This is the top-level symbol for the current depth.\n    // If there are no template controllers or replace-parts, it is always the manifest itself.\n    // If there are template controllers, then this will be the outer-most TemplateControllerSymbol.\n    let manifestProxy = manifest as ParentNodeSymbol;\n\n    const replacePart = this.declareReplacePart(node);\n\n    let previousController: TemplateControllerSymbol;\n    let currentController: TemplateControllerSymbol;\n\n    const attributes = node.attributes;\n    let i = 0;\n    while (i < attributes.length) {\n      const attr = attributes[i];\n      ++i;\n      if (attributesToIgnore[attr.name] === true) {\n        continue;\n      }\n      const attrSyntax = this.attrParser.parse(attr.name, attr.value);\n      const attrInfo = this.resources.getAttributeInfo(attrSyntax);\n\n      if (attrInfo === null) {\n        // it's not a custom attribute but might be a regular bound attribute or interpolation (it might also be nothing)\n        this.bindPlainAttribute(attrSyntax);\n      } else if (attrInfo.isTemplateController) {\n        // the manifest is wrapped by the inner-most template controller (if there are multiple on the same element)\n        // so keep setting manifest.templateController to the latest template controller we find\n        currentController = manifest.templateController = this.declareTemplateController(attrSyntax, attrInfo);\n\n        // the proxy and the manifest are only identical when we're at the first template controller (since the controller\n        // is assigned to the proxy), so this evaluates to true at most once per node\n        if (manifestProxy === manifest) {\n          currentController.template = manifest;\n          manifestProxy = currentController;\n        } else {\n          currentController.templateController = previousController;\n          currentController.template = previousController.template;\n          previousController.template = currentController;\n        }\n        previousController = currentController;\n      } else {\n        // a regular custom attribute\n        this.bindCustomAttribute(attrSyntax, attrInfo);\n      }\n    }\n\n    processTemplateControllers(manifestProxy, manifest);\n\n    if (replacePart === null) {\n      // the proxy is either the manifest itself or the outer-most controller; add it directly to the parent\n      parentManifest.childNodes.push(manifestProxy);\n    } else {\n      // there is a replace-part attribute on this node, so add it to the parts collection of the manifestRoot\n      // instead of to the childNodes\n      replacePart.parent = parentManifest;\n      replacePart.template = manifestProxy;\n\n      // if the current manifest is also the manifestRoot, it means the replace-part sits on a custom\n      // element, so add the part to the parent wrapping custom element instead\n      const partOwner = manifest === manifestRoot ? parentManifestRoot : manifestRoot;\n      partOwner.parts.push(replacePart);\n\n      processReplacePart(replacePart, manifestProxy);\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private bindChildNodes(node: IHTMLTemplateElement | IHTMLElement): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindChildNodes', slice.call(arguments)); }\n\n    let childNode: INode;\n    if (node.nodeName === 'TEMPLATE') {\n      childNode = (node as IHTMLTemplateElement).content.firstChild;\n    } else {\n      childNode = node.firstChild;\n    }\n\n    let nextChild: INode;\n    while (childNode !== null) {\n      switch (childNode.nodeType) {\n        case NodeType.Element:\n          nextChild = childNode.nextSibling;\n          this.bindManifest(this.manifest, childNode as IHTMLElement);\n          childNode = nextChild;\n          break;\n        case NodeType.Text:\n          childNode = this.bindText(childNode as IText).nextSibling;\n          break;\n        case NodeType.CDATASection:\n        case NodeType.ProcessingInstruction:\n        case NodeType.Comment:\n        case NodeType.DocumentType:\n          childNode = childNode.nextSibling;\n          break;\n        case NodeType.Document:\n        case NodeType.DocumentFragment:\n          childNode = childNode.firstChild;\n      }\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private bindText(node: IText): INode {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindText', slice.call(arguments)); }\n    const interpolation = this.exprParser.parse(node.wholeText, BindingType.Interpolation);\n    if (interpolation !== null) {\n      const symbol = new TextSymbol(node, interpolation);\n      this.manifest.childNodes.push(symbol);\n      processInterpolationText(symbol);\n    }\n    while (node.nextSibling !== null && node.nextSibling.nodeType === NodeType.Text) {\n      node = node.nextSibling as IText;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return node;\n  }\n\n  private declareTemplateController(attrSyntax: AttrSyntax, attrInfo: AttrInfo): TemplateControllerSymbol {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.declareTemplateController', slice.call(arguments)); }\n\n    let symbol: TemplateControllerSymbol;\n    // dynamicOptions logic here is similar to (and explained in) bindCustomAttribute\n    const command = this.resources.getBindingCommand(attrSyntax);\n    if (command === null && attrInfo.hasDynamicOptions) {\n      symbol = new TemplateControllerSymbol(attrSyntax, attrInfo, this.partName);\n      this.partName = null;\n      this.bindMultiAttribute(symbol, attrInfo, attrSyntax.rawValue);\n    } else {\n      symbol = new TemplateControllerSymbol(attrSyntax, attrInfo, this.partName);\n      const bindingType = command === null ? BindingType.Interpolation : command.bindingType;\n      const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);\n      symbol.bindings.push(new BindingSymbol(command, attrInfo.bindable, expr, attrSyntax.rawValue, attrSyntax.target));\n      this.partName = null;\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n    return symbol;\n  }\n\n  private bindCustomAttribute(attrSyntax: AttrSyntax, attrInfo: AttrInfo): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindCustomAttribute', slice.call(arguments)); }\n\n    const command = this.resources.getBindingCommand(attrSyntax);\n    let symbol: CustomAttributeSymbol;\n    if (command === null && attrInfo.hasDynamicOptions) {\n      // a dynamicOptions (semicolon separated binding) is only valid without a binding command;\n      // the binding commands must be declared in the dynamicOptions expression itself\n      symbol = new CustomAttributeSymbol(attrSyntax, attrInfo);\n      this.bindMultiAttribute(symbol, attrInfo, attrSyntax.rawValue);\n    } else {\n      // we've either got a command (with or without dynamicOptions, the latter maps to the first bindable),\n      // or a null command but without dynamicOptions (which may be an interpolation or a normal string)\n      symbol = new CustomAttributeSymbol(attrSyntax, attrInfo);\n      const bindingType = command === null ? BindingType.Interpolation : command.bindingType;\n      const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);\n      symbol.bindings.push(new BindingSymbol(command, attrInfo.bindable, expr, attrSyntax.rawValue, attrSyntax.target));\n    }\n    this.manifest.attributes.push(symbol);\n    this.manifest.isTarget = true;\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private bindMultiAttribute(symbol: ResourceAttributeSymbol, attrInfo: AttrInfo, value: string): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindMultiAttribute', slice.call(arguments)); }\n\n    const attributes = parseMultiAttributeBinding(value);\n    let attr: IAttrLike;\n    for (let i = 0, ii = attributes.length; i < ii; ++i) {\n      attr = attributes[i];\n      const attrSyntax = this.attrParser.parse(attr.name, attr.value);\n      const command = this.resources.getBindingCommand(attrSyntax);\n      const bindingType = command === null ? BindingType.Interpolation : command.bindingType;\n      const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);\n      let bindable = attrInfo.bindables[attrSyntax.target];\n      if (bindable === undefined) {\n        // everything in a dynamicOptions expression must be used, so if it's not a bindable then we create one on the spot\n        bindable = attrInfo.bindables[attrSyntax.target] = new BindableInfo(attrSyntax.target, BindingMode.toView);\n      }\n\n      symbol.bindings.push(new BindingSymbol(command, bindable, expr, attrSyntax.rawValue, attrSyntax.target));\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private bindPlainAttribute(attrSyntax: AttrSyntax): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindPlainAttribute', slice.call(arguments)); }\n\n    if (attrSyntax.rawValue.length === 0) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n\n    const command = this.resources.getBindingCommand(attrSyntax);\n    const bindingType = command === null ? BindingType.Interpolation : command.bindingType;\n    const manifest = this.manifest;\n    const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);\n\n    if (manifest.flags & SymbolFlags.isCustomElement) {\n      const bindable = (manifest as CustomElementSymbol).bindables[attrSyntax.target];\n      if (bindable !== undefined) {\n        // if the attribute name matches a bindable property name, add it regardless of whether it's a command, interpolation, or just a plain string;\n        // the template compiler will translate it to the correct instruction\n        (manifest as CustomElementSymbol).bindings.push(new BindingSymbol(command, bindable, expr, attrSyntax.rawValue, attrSyntax.target));\n        manifest.isTarget = true;\n      } else if (expr !== null) {\n        // if it does not map to a bindable, only add it if we were able to parse an expression (either a command or interpolation)\n        manifest.attributes.push(new PlainAttributeSymbol(attrSyntax, command, expr));\n        manifest.isTarget = true;\n      }\n    } else if (expr !== null || attrSyntax.target === 'ref') {\n      // either a binding command, an interpolation, or a ref\n      manifest.attributes.push(new PlainAttributeSymbol(attrSyntax, command, expr));\n      manifest.isTarget = true;\n    } else if (manifest === this.surrogate) {\n      // any attributes, even if they are plain (no command/interpolation etc), should be added if they\n      // are on the surrogate element\n      manifest.attributes.push(new PlainAttributeSymbol(attrSyntax, command, expr));\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private declareReplacePart(node: IHTMLTemplateElement | IHTMLElement): ReplacePartSymbol {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.declareReplacePart', slice.call(arguments)); }\n\n    const name = node.getAttribute('replace-part');\n    if (name === null) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return null;\n    }\n    node.removeAttribute('replace-part');\n\n    const symbol = new ReplacePartSymbol(name);\n\n    if (Tracer.enabled) { Tracer.leave(); }\n    return symbol;\n  }\n}\n\nfunction processInterpolationText(symbol: TextSymbol): void {\n  const node = symbol.physicalNode;\n  const parentNode = node.parentNode;\n  while (node.nextSibling !== null && node.nextSibling.nodeType === NodeType.Text) {\n    parentNode.removeChild(node.nextSibling);\n  }\n  node.textContent = '';\n  parentNode.insertBefore(symbol.marker, node);\n}\n\n/**\n * A (temporary) standalone function that purely does the DOM processing (lifting) related to template controllers.\n * It's a first refactoring step towards separating DOM parsing/binding from mutations.\n */\nfunction processTemplateControllers(manifestProxy: ParentNodeSymbol, manifest: ElementSymbol): void {\n  const manifestNode = manifest.physicalNode;\n  let current = manifestProxy as TemplateControllerSymbol;\n  while ((current as ParentNodeSymbol) !== manifest) {\n    if (current.template === manifest) {\n      // the DOM linkage is still in its original state here so we can safely assume the parentNode is non-null\n      manifestNode.parentNode.replaceChild(current.marker, manifestNode);\n\n      // if the manifest is a template element (e.g. <template repeat.for=\"...\">) then we can skip one lift operation\n      // and simply use the template directly, saving a bit of work\n      if (manifestNode.nodeName === 'TEMPLATE') {\n        current.physicalNode = manifestNode as IHTMLTemplateElement;\n        // the template could safely stay without affecting anything visible, but let's keep the DOM tidy\n        manifestNode.remove();\n      } else {\n        // the manifest is not a template element so we need to wrap it in one\n        current.physicalNode = DOM.createTemplate();\n        current.physicalNode.content.appendChild(manifestNode);\n      }\n    } else {\n      current.physicalNode = DOM.createTemplate();\n      current.physicalNode.content.appendChild(current.marker);\n    }\n    manifestNode.removeAttribute(current.syntax.rawName);\n    current = current.template as TemplateControllerSymbol;\n  }\n}\n\nfunction processReplacePart(replacePart: ReplacePartSymbol, manifestProxy: ParentNodeSymbol): void {\n    let proxyNode: IHTMLElement;\n    if (manifestProxy.flags & SymbolFlags.hasMarker) {\n      proxyNode = (manifestProxy as SymbolWithMarker).marker;\n    } else {\n      proxyNode = manifestProxy.physicalNode;\n    }\n    if (proxyNode.nodeName === 'TEMPLATE') {\n      // if it's a template element, no need to do anything special, just assign it to the replacePart\n      replacePart.physicalNode = proxyNode as IHTMLTemplateElement;\n    } else {\n      // otherwise wrap the replace-part in a template\n      replacePart.physicalNode = DOM.createTemplate();\n      replacePart.physicalNode.content.appendChild(proxyNode);\n    }\n}\n\ninterface IAttrLike {\n  name: string;\n  value: string;\n}\n\nclass ParserState {\n  public input: string;\n  public index: number;\n  public length: number;\n\n  constructor(input: string) {\n    this.input = input;\n    this.index = 0;\n    this.length = input.length;\n  }\n}\n\nconst fromCharCode = String.fromCharCode;\n\n// TODO: move to expression parser\nfunction parseMultiAttributeBinding(input: string): IAttrLike[] {\n  const attributes: IAttrLike[] = [];\n\n  const state = new ParserState(input);\n  const length = state.length;\n  let name: string;\n  let value: string;\n\n  while (state.index < length) {\n    name = scanAttributeName(state);\n    if (name.length === 0) {\n      return attributes;\n    }\n    value = scanAttributeValue(state);\n    attributes.push({ name, value });\n  }\n\n  return attributes;\n}\n\nfunction scanAttributeName(state: ParserState): string {\n  const start = state.index;\n  const { length, input } = state;\n  while (state.index < length && input.charCodeAt(++state.index) !== Char.Colon);\n\n  return input.slice(start, state.index).trim();\n}\n\nfunction scanAttributeValue(state: ParserState): string {\n  ++state.index;\n  const { length, input } = state;\n  let token = '';\n  let inString = false;\n  let quote = null;\n  let ch = 0;\n  while (state.index < length) {\n    ch = input.charCodeAt(state.index);\n    switch (ch) {\n      case Char.Semicolon:\n        ++state.index;\n        return token.trim();\n      case Char.Slash:\n        ch = input.charCodeAt(++state.index);\n        if (ch === Char.DoubleQuote) {\n          if (inString === false) {\n            inString = true;\n            quote = Char.DoubleQuote;\n          } else if (quote === Char.DoubleQuote) {\n            inString = false;\n            quote = null;\n          }\n        }\n        token += `\\\\${fromCharCode(ch)}`;\n        break;\n      case Char.SingleQuote:\n        if (inString === false) {\n          inString = true;\n          quote = Char.SingleQuote;\n        } else if (quote === Char.SingleQuote) {\n          inString = false;\n          quote = null;\n        }\n        token += '\\'';\n        break;\n      default:\n        token += fromCharCode(ch);\n    }\n    ++state.index;\n  }\n\n  return token.trim();\n}\n","import { DI } from '@aurelia/kernel';\nimport { DOM, IElement, IHTMLTemplateElement, INode } from '@aurelia/runtime';\n\n/**\n * Utility that creates a `HTMLTemplateElement` out of string markup or an existing DOM node.\n *\n * It is idempotent in the sense that passing in an existing template element will simply return that template element,\n * so it is always safe to pass in a node without causing unnecessary DOM parsing or template creation.\n */\nexport interface ITemplateFactory {\n  /**\n   * Create a `HTMLTemplateElement` from a provided html string.\n   *\n   * @param markup A raw html string that may or may not be wrapped in `<template></template>`\n   */\n  createTemplate(markup: string): IHTMLTemplateElement;\n  /**\n   * Create a `HTMLTemplateElement` from a provided DOM node. If the node is already a template, it\n   * will be returned as-is (and removed from the DOM).\n   *\n   * @param node A DOM node that may or may not be wrapped in `<template></template>`\n   */\n  createTemplate(node: INode): IHTMLTemplateElement;\n  /**\n   * Create a `HTMLTemplateElement` from a provided DOM node or html string.\n   *\n   * @param input A DOM node or raw html string that may or may not be wrapped in `<template></template>`\n   */\n  createTemplate(input: unknown): IHTMLTemplateElement;\n  createTemplate(input: unknown): IHTMLTemplateElement;\n}\n\nexport const ITemplateFactory = DI.createInterface<ITemplateFactory>()\n  .withDefault(x => x.singleton(TemplateFactory));\n\n/**\n * Default implementation for `ITemplateFactory` for use in an HTML based runtime.\n *\n * @internal\n */\nexport class TemplateFactory {\n  private template: IHTMLTemplateElement;\n\n  constructor() {\n    this.template = DOM.createTemplate();\n  }\n\n  public createTemplate(markup: string): IHTMLTemplateElement;\n  public createTemplate(node: INode): IHTMLTemplateElement;\n  public createTemplate(input: unknown): IHTMLTemplateElement;\n  public createTemplate(input: string | INode): IHTMLTemplateElement {\n    if (typeof input === 'string') {\n      const template = this.template;\n      template.innerHTML = input;\n      const node = template.content.firstElementChild as IElement;\n      // if the input is either not wrapped in a template or there is more than one node,\n      // return the whole template that wraps it/them (and create a new one for the next input)\n      if (node === null || node.nodeName !== 'TEMPLATE' || node.nextElementSibling !== null) {\n        this.template = DOM.createTemplate();\n        return template;\n      }\n      // the node to return is both a template and the only node, so return just the node\n      // and clean up the template for the next input\n      template.content.removeChild(node);\n      return node as IHTMLTemplateElement;\n    }\n    if (input.nodeName !== 'TEMPLATE') {\n      // if we get one node that is not a template, wrap it in one\n      const template = DOM.createTemplate();\n      template.content.appendChild(input);\n      return template;\n    }\n    // we got a template element, remove it from the DOM if it's present there and don't\n    // do any other processing\n    if (input.parentNode !== null) {\n      input.parentNode.removeChild(input);\n    }\n    return input as IHTMLTemplateElement;\n  }\n}\n","import { inject, PLATFORM } from '@aurelia/kernel';\nimport {\n  AttributeInstruction,\n  HydrateAttributeInstruction,\n  HydrateElementInstruction,\n  HydrateTemplateController,\n  IBuildInstruction,\n  IExpressionParser,\n  ILetBindingInstruction,\n  InstructionRow,\n  Interpolation,\n  InterpolationInstruction,\n  IResourceDescriptions,\n  IsBindingBehavior,\n  ITemplateCompiler,\n  ITemplateDefinition,\n  LetBindingInstruction,\n  LetElementInstruction,\n  RefBindingInstruction,\n  SetAttributeInstruction,\n  SetPropertyInstruction,\n  TargetedInstruction,\n  TemplateDefinition,\n  TextBindingInstruction\n} from '@aurelia/runtime';\nimport { IAttributeParser } from './attribute-parser';\nimport { ResourceModel } from './resource-model';\nimport {\n  AttributeSymbol,\n  BindingSymbol,\n  CustomAttributeSymbol,\n  CustomElementSymbol,\n  ElementSymbol,\n  LetElementSymbol,\n  NodeSymbol,\n  ParentNodeSymbol,\n  PlainAttributeSymbol,\n  PlainElementSymbol,\n  ReplacePartSymbol,\n  SymbolFlags,\n  SymbolWithBindings,\n  TemplateBinder,\n  TemplateControllerSymbol,\n  TextSymbol\n} from './template-binder';\nimport { ITemplateFactory } from './template-factory';\n\nconst buildNotRequired: IBuildInstruction = Object.freeze({\n  required: false,\n  compiler: 'default'\n});\n\n/**\n * Default (runtime-agnostic) implementation for `ITemplateCompiler`.\n *\n * @internal\n */\n@inject(ITemplateFactory, IAttributeParser, IExpressionParser)\nexport class TemplateCompiler implements ITemplateCompiler {\n  private factory: ITemplateFactory;\n  private attrParser: IAttributeParser;\n  private exprParser: IExpressionParser;\n\n  /**\n   * The instructions array for the currently instruction-collecting `ITemplateDefinition`\n   */\n  private instructionRows: InstructionRow[];\n\n  public get name(): string {\n    return 'default';\n  }\n\n  constructor(factory: ITemplateFactory, attrParser: IAttributeParser, exprParser: IExpressionParser) {\n    this.factory = factory;\n    this.attrParser = attrParser;\n    this.exprParser = exprParser;\n    this.instructionRows = null;\n  }\n\n  public compile(definition: ITemplateDefinition, descriptions: IResourceDescriptions): TemplateDefinition {\n    const resources = new ResourceModel(descriptions);\n    const binder = new TemplateBinder(resources, this.attrParser, this.exprParser);\n    const template = definition.template = this.factory.createTemplate(definition.template);\n    const surrogate = binder.bind(template);\n    if (definition.instructions === undefined || definition.instructions === PLATFORM.emptyArray) {\n      definition.instructions = [];\n    }\n    if (surrogate.hasSlots === true) {\n      definition.hasSlots = true;\n    }\n\n    this.instructionRows = definition.instructions as InstructionRow[];\n\n    const attributes = surrogate.attributes;\n    const len = attributes.length;\n    if (len > 0) {\n      let surrogates: TargetedInstruction[];\n      if (definition.surrogates === undefined || definition.surrogates === PLATFORM.emptyArray) {\n        definition.surrogates = Array(len);\n      }\n      surrogates = definition.surrogates;\n      for (let i = 0; i < len; ++i) {\n        surrogates[i] = this.compileAttribute(attributes[i]);\n      }\n    }\n\n    this.compileChildNodes(surrogate);\n\n    this.instructionRows = null;\n\n    return definition as TemplateDefinition;\n  }\n\n  private compileChildNodes(parent: ElementSymbol): void {\n    if (parent.flags & SymbolFlags.hasChildNodes) {\n      const { childNodes } = parent;\n      let childNode: NodeSymbol;\n      const ii = childNodes.length;\n      for (let i = 0; i < ii; ++i) {\n        childNode = childNodes[i];\n        if (childNode.flags & SymbolFlags.isText) {\n          this.instructionRows.push([new TextBindingInstruction((childNode as TextSymbol).interpolation)]);\n        } else if (childNode.flags & SymbolFlags.isLetElement) {\n          const bindings = (childNode as LetElementSymbol).bindings;\n          const instructions: ILetBindingInstruction[] = [];\n          let binding: BindingSymbol;\n          const jj = bindings.length;\n          for (let j = 0; j < jj; ++j) {\n            binding = bindings[j];\n            instructions[j] = new LetBindingInstruction(binding.expression as IsBindingBehavior, binding.target);\n          }\n          this.instructionRows.push([new LetElementInstruction(instructions, (childNode as LetElementSymbol).toViewModel)]);\n        } else {\n          this.compileParentNode(childNode as ParentNodeSymbol);\n        }\n      }\n    }\n  }\n\n  private compileCustomElement(symbol: CustomElementSymbol): void {\n    // offset 1 to leave a spot for the hydrate instruction so we don't need to create 2 arrays with a spread etc\n    const instructionRow = this.compileAttributes(symbol, 1) as InstructionRow;\n    instructionRow[0] = new HydrateElementInstruction(\n      symbol.res,\n      this.compileBindings(symbol),\n      this.compileParts(symbol)\n    );\n\n    this.instructionRows.push(instructionRow);\n  }\n\n  private compilePlainElement(symbol: PlainElementSymbol): void {\n    const attributes = this.compileAttributes(symbol, 0);\n    if (attributes.length > 0) {\n      this.instructionRows.push(attributes as InstructionRow);\n    }\n    this.compileChildNodes(symbol);\n  }\n\n  private compileParentNode(symbol: ParentNodeSymbol): void {\n    switch (symbol.flags & SymbolFlags.type) {\n      case SymbolFlags.isCustomElement:\n        this.compileCustomElement(symbol as CustomElementSymbol);\n        break;\n      case SymbolFlags.isPlainElement:\n        this.compilePlainElement(symbol as PlainElementSymbol);\n        break;\n      case SymbolFlags.isTemplateController:\n        this.compileTemplateController(symbol as TemplateControllerSymbol);\n    }\n  }\n\n  private compileTemplateController(symbol: TemplateControllerSymbol): void {\n    const bindings = this.compileBindings(symbol);\n    const instructionRowsSave = this.instructionRows;\n    const controllerInstructions = this.instructionRows = [];\n    this.compileParentNode(symbol.template);\n    this.instructionRows = instructionRowsSave;\n\n    const def = {\n      name: symbol.partName === null ? symbol.res : symbol.partName,\n      template: symbol.physicalNode,\n      instructions: controllerInstructions,\n      build: buildNotRequired\n    };\n    this.instructionRows.push([new HydrateTemplateController(def, symbol.res, bindings, symbol.res === 'else')]);\n  }\n\n  private compileBindings(symbol: SymbolWithBindings): AttributeInstruction[] {\n    let bindingInstructions: AttributeInstruction[];\n    if (symbol.flags & SymbolFlags.hasBindings) {\n      // either a custom element with bindings, a custom attribute / template controller with dynamic options,\n      // or a single value custom attribute binding\n      const { bindings } = symbol;\n      const len = bindings.length;\n      bindingInstructions = Array(len);\n      let i = 0;\n      for (; i < len; ++i) {\n        bindingInstructions[i] = this.compileBinding(bindings[i]);\n      }\n    } else {\n      bindingInstructions = PLATFORM.emptyArray as AttributeInstruction[];\n    }\n    return bindingInstructions;\n  }\n\n  private compileBinding(symbol: BindingSymbol): AttributeInstruction {\n    if (symbol.command === null) {\n      // either an interpolation or a normal string value assigned to an element or attribute binding\n      if (symbol.expression === null) {\n        // the template binder already filtered out non-bindables, so we know we need a setProperty here\n        return new SetPropertyInstruction(symbol.rawValue, symbol.bindable.propName);\n      } else {\n        // either an element binding interpolation or a dynamic options attribute binding interpolation\n        return new InterpolationInstruction(symbol.expression as Interpolation, symbol.bindable.propName);\n      }\n    } else {\n      // either an element binding command, dynamic options attribute binding command,\n      // or custom attribute / template controller (single value) binding command\n      return symbol.command.compile(symbol);\n    }\n  }\n\n  private compileAttributes(symbol: ElementSymbol, offset: number): AttributeInstruction[] {\n    let attributeInstructions: AttributeInstruction[];\n    if (symbol.flags & SymbolFlags.hasAttributes) {\n      // any attributes on a custom element (which are not bindables) or a plain element\n      const { attributes } = symbol;\n      const len = attributes.length;\n      attributeInstructions = Array(offset + len);\n      for (let i = 0; i < len; ++i) {\n        attributeInstructions[i + offset] = this.compileAttribute(attributes[i]);\n      }\n    } else if (offset > 0) {\n      attributeInstructions = Array(offset);\n    } else {\n      attributeInstructions = PLATFORM.emptyArray as AttributeInstruction[];\n    }\n    return attributeInstructions;\n  }\n\n  private compileAttribute(symbol: AttributeSymbol): AttributeInstruction {\n    if (symbol.syntax.target === 'ref') {\n      return new RefBindingInstruction(symbol.syntax.rawValue);\n    }\n    // any attribute on a custom element (which is not a bindable) or a plain element\n    if (symbol.flags & SymbolFlags.isCustomAttribute) {\n      // a normal custom attribute (not template controller)\n      const bindings = this.compileBindings(symbol as CustomAttributeSymbol);\n      return new HydrateAttributeInstruction((symbol as CustomAttributeSymbol).res, bindings);\n    } else if ((symbol as PlainAttributeSymbol).command === null) {\n      if ((symbol as PlainAttributeSymbol).expression === null) {\n        // a plain attribute on a surrogate\n        return new SetAttributeInstruction(symbol.syntax.rawValue, symbol.syntax.target);\n      } else {\n        // a plain attribute with an interpolation\n        return new InterpolationInstruction((symbol as PlainAttributeSymbol).expression as Interpolation, symbol.syntax.target);\n      }\n    } else {\n      // a plain attribute with a binding command\n      return (symbol as PlainAttributeSymbol).command.compile(symbol as PlainAttributeSymbol);\n    }\n  }\n\n  private compileParts(symbol: CustomElementSymbol): Record<string, ITemplateDefinition> {\n    let parts: Record<string, ITemplateDefinition>;\n    if (symbol.flags & SymbolFlags.hasParts) {\n      parts = {};\n      const replaceParts = symbol.parts;\n      const ii = replaceParts.length;\n      let instructionRowsSave: InstructionRow[];\n      let partInstructions: InstructionRow[];\n      let replacePart: ReplacePartSymbol;\n      for (let i = 0; i < ii; ++i) {\n        replacePart = replaceParts[i];\n        instructionRowsSave = this.instructionRows;\n        partInstructions = this.instructionRows = [];\n        this.compileParentNode(replacePart.template);\n        parts[replacePart.name] = {\n          name: replacePart.name,\n          template: replacePart.physicalNode,\n          instructions: partInstructions,\n          build: buildNotRequired\n        };\n        this.instructionRows = instructionRowsSave;\n      }\n    } else {\n      parts = PLATFORM.emptyObject;\n    }\n    return parts;\n  }\n}\n","import { IContainer, IRegistry, Registration } from '@aurelia/kernel';\nimport {\n  AttrBindingBehavior,\n  Compose,\n  DebounceBindingBehavior,\n  Else,\n  FromViewBindingBehavior,\n  HtmlRenderer,\n  If,\n  ITemplateCompiler,\n  OneTimeBindingBehavior,\n  Repeat,\n  Replaceable,\n  SanitizeValueConverter,\n  SelfBindingBehavior,\n  SignalBindingBehavior,\n  ThrottleBindingBehavior,\n  ToViewBindingBehavior,\n  TwoWayBindingBehavior,\n  UpdateTriggerBindingBehavior,\n  With\n} from '@aurelia/runtime';\nimport {\n  DotSeparatedAttributePattern,\n  RefAttributePattern\n} from './attribute-pattern';\nimport {\n  CallBindingCommand,\n  CaptureBindingCommand,\n  DefaultBindingCommand,\n  DelegateBindingCommand,\n  ForBindingCommand,\n  FromViewBindingCommand,\n  OneTimeBindingCommand,\n  ToViewBindingCommand,\n  TriggerBindingCommand,\n  TwoWayBindingCommand\n} from './binding-command';\nimport { ParserRegistration } from './expression-parser';\nimport { TemplateCompiler } from './template-compiler';\n\nexport const GlobalResources: IRegistry[] = [\n  Compose,\n  If,\n  Else,\n  Repeat,\n  Replaceable,\n  With,\n  SanitizeValueConverter,\n  AttrBindingBehavior,\n  DebounceBindingBehavior,\n  OneTimeBindingBehavior,\n  ToViewBindingBehavior,\n  FromViewBindingBehavior,\n  SelfBindingBehavior,\n  SignalBindingBehavior,\n  ThrottleBindingBehavior,\n  TwoWayBindingBehavior,\n  UpdateTriggerBindingBehavior\n];\n\nexport const DefaultBindingLanguage: IRegistry[] = [\n  DefaultBindingCommand,\n  OneTimeBindingCommand,\n  ToViewBindingCommand,\n  FromViewBindingCommand,\n  TwoWayBindingCommand,\n  TriggerBindingCommand,\n  DelegateBindingCommand,\n  CaptureBindingCommand,\n  CallBindingCommand,\n  ForBindingCommand,\n  DotSeparatedAttributePattern,\n  RefAttributePattern\n];\n\nexport const BasicConfiguration = {\n  register(container: IContainer): void {\n    container.register(\n      ParserRegistration,\n      HtmlRenderer,\n      Registration.singleton(ITemplateCompiler, TemplateCompiler),\n      ...GlobalResources,\n      ...DefaultBindingLanguage\n    );\n  }\n};\n","import { IHTMLElement, IHTMLTemplateElement, INode, ITemplateDefinition, NodeType, TargetedInstruction, TargetedInstructionType } from '@aurelia/runtime';\n\nexport function stringifyDOM(node: INode, depth: number): string {\n  const indent = ' '.repeat(depth);\n  let output = indent;\n  output += `Node: ${node.nodeName}`;\n  if (node.nodeType === NodeType.Text) {\n    output += ` \"${node.textContent}\"`;\n  }\n  if (node.nodeType === NodeType.Element) {\n    let i = 0;\n    let attr;\n    const attributes = (node as IHTMLElement).attributes;\n    const len = attributes.length;\n    for (; i < len; ++i) {\n      attr = attributes[i];\n      output += ` ${attr.name}=${attr.value}`;\n    }\n  }\n  output += '\\n';\n  if (node.nodeType === NodeType.Element) {\n    let i = 0;\n    let childNodes = node.childNodes;\n    let len = childNodes.length;\n    for (; i < len; ++i) {\n      output += stringifyDOM(childNodes[i], depth + 1);\n    }\n    if (node.nodeName === 'TEMPLATE') {\n      i = 0;\n      childNodes = (node as IHTMLTemplateElement).content.childNodes;\n      len = childNodes.length;\n      for (; i < len; ++i) {\n        output += stringifyDOM(childNodes[i], depth + 1);\n      }\n    }\n  }\n  return output;\n}\n\nexport function stringifyInstructions(instruction: TargetedInstruction, depth: number): string {\n  const indent = ' '.repeat(depth);\n  let output = indent;\n  switch (instruction.type) {\n    case TargetedInstructionType.textBinding:\n      output += 'textBinding\\n';\n      break;\n    case TargetedInstructionType.callBinding:\n      output += 'callBinding\\n';\n      break;\n    case TargetedInstructionType.iteratorBinding:\n      output += 'iteratorBinding\\n';\n      break;\n    case TargetedInstructionType.listenerBinding:\n      output += 'listenerBinding\\n';\n      break;\n    case TargetedInstructionType.propertyBinding:\n      output += 'propertyBinding\\n';\n      break;\n    case TargetedInstructionType.refBinding:\n      output += 'refBinding\\n';\n      break;\n    case TargetedInstructionType.stylePropertyBinding:\n      output += 'stylePropertyBinding\\n';\n      break;\n    case TargetedInstructionType.setProperty:\n      output += 'setProperty\\n';\n      break;\n    case TargetedInstructionType.setAttribute:\n      output += 'setAttribute\\n';\n      break;\n    case TargetedInstructionType.interpolation:\n      output += 'interpolation\\n';\n      break;\n    case TargetedInstructionType.hydrateLetElement:\n      output += 'hydrateLetElement\\n';\n      instruction.instructions.forEach(i => {\n        output += stringifyInstructions(i, depth + 1);\n      });\n      break;\n    case TargetedInstructionType.hydrateAttribute:\n      output += `hydrateAttribute: ${instruction.res}\\n`;\n      instruction.instructions.forEach(i => {\n        output += stringifyInstructions(i, depth + 1);\n      });\n      break;\n    case TargetedInstructionType.hydrateElement:\n      output += `hydrateElement: ${instruction.res}\\n`;\n      instruction.instructions.forEach(i => {\n        output += stringifyInstructions(i, depth + 1);\n      });\n      break;\n    case TargetedInstructionType.hydrateTemplateController:\n      output += `hydrateTemplateController: ${instruction.res}\\n`;\n      output += stringifyTemplateDefinition(instruction.def, depth + 1);\n      instruction.instructions.forEach(i => {\n        output += stringifyInstructions(i, depth + 1);\n      });\n  }\n  return output;\n}\n\nexport function stringifyTemplateDefinition(def: ITemplateDefinition, depth: number): string {\n  const indent = ' '.repeat(depth);\n  let output = indent;\n\n  output += `TemplateDefinition: ${def.name}\\n`;\n  output += stringifyDOM(def.template as INode, depth + 1);\n  output += `${indent} Instructions:\\n`;\n  def.instructions.forEach(row => {\n    output += `${indent}  Row:\\n`;\n    row.forEach(i => {\n      output += stringifyInstructions(i, depth + 3);\n    });\n  });\n\n  return output;\n}\n"],"names":["ParserState"],"mappings":"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"}