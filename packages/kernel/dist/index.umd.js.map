{"version":3,"file":"index.umd.js","sources":["../src/platform.ts","../src/reporter.ts","../src/di.ts","../src/profiler.ts","../src/resource.ts"],"sourcesContent":["import { IPerformanceEntry, ITimerHandler, IWindowOrWorkerGlobalScope } from './interfaces';\n\n// tslint:disable-next-line:no-redundant-jump\nfunction $noop(): void { return; }\n\ndeclare var global: IWindowOrWorkerGlobalScope;\ndeclare var self: IWindowOrWorkerGlobalScope;\ndeclare var window: IWindowOrWorkerGlobalScope;\ndeclare function setTimeout(handler: (...args: unknown[]) => void, timeout: number): unknown;\n\nconst $global: IWindowOrWorkerGlobalScope = (function(): IWindowOrWorkerGlobalScope {\n  // https://github.com/Microsoft/tslint-microsoft-contrib/issues/415\n  // tslint:disable:no-typeof-undefined\n  if (typeof global !== 'undefined') {\n    return global as unknown as IWindowOrWorkerGlobalScope;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  // tslint:enable:no-typeof-undefined\n  try {\n    // Not all environments allow eval and Function. Use only as a last resort:\n    // tslint:disable-next-line:no-function-constructor-with-string-args function-constructor\n    return new Function('return this')();\n  } catch {\n    // If all fails, give up and create an object.\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    return {} as IWindowOrWorkerGlobalScope;\n  }\n})();\n\n// performance.now polyfill for non-browser envs based on https://github.com/myrne/performance-now\nconst $now = (function(): () => number {\n  let getNanoSeconds: () => number;\n  let hrtime: (time?: [number, number]) => [number, number];\n  let moduleLoadTime: number;\n  let nodeLoadTime: number;\n  let upTime: number;\n\n  if (($global.performance !== undefined && $global.performance !== null) && $global.performance.now) {\n    const $performance = $global.performance;\n    return function(): number {\n      return $performance.now();\n    };\n  } else if (($global.process !== undefined && $global.process !== null) && $global.process.hrtime) {\n    const now = function(): number {\n      return (getNanoSeconds() - nodeLoadTime) / 1e6;\n    };\n    hrtime = $global.process.hrtime;\n    getNanoSeconds = function(): number {\n      let hr: [number, number];\n      hr = hrtime();\n      return hr[0] * 1e9 + hr[1];\n    };\n    moduleLoadTime = getNanoSeconds();\n    upTime = $global.process.uptime() * 1e9;\n    nodeLoadTime = moduleLoadTime - upTime;\n    return now;\n  }\n})();\n\n// performance.mark / measure polyfill based on https://github.com/blackswanny/performance-polyfill\n// note: this is NOT intended to be a polyfill for browsers that don't support it; it's just for NodeJS\n// TODO: probably want to move environment-specific logic to the appropriate runtime (e.g. the NodeJS polyfill\n// to runtime-html-jsdom)\nconst {\n  $mark,\n  $measure,\n  $getEntriesByName,\n  $getEntriesByType,\n  $clearMarks,\n  $clearMeasures\n} = (function(): {\n  $mark: IWindowOrWorkerGlobalScope['performance']['mark'];\n  $measure: IWindowOrWorkerGlobalScope['performance']['measure'];\n  $getEntriesByName: IWindowOrWorkerGlobalScope['performance']['getEntriesByName'];\n  $getEntriesByType: IWindowOrWorkerGlobalScope['performance']['getEntriesByType'];\n  $clearMarks: IWindowOrWorkerGlobalScope['performance']['clearMarks'];\n  $clearMeasures: IWindowOrWorkerGlobalScope['performance']['clearMeasures'];\n } {\n  if (\n    $global.performance !== undefined &&\n    $global.performance !== null &&\n    $global.performance.mark &&\n    $global.performance.measure &&\n    $global.performance.getEntriesByName &&\n    $global.performance.getEntriesByType &&\n    $global.performance.clearMarks &&\n    $global.performance.clearMeasures\n  ) {\n    const $performance = $global.performance;\n    return {\n      $mark: function(name: string): void {\n        $performance.mark(name);\n      },\n      $measure: function(name: string, start?: string, end?: string): void {\n        $performance.measure(name, start, end);\n      },\n      $getEntriesByName: function(name: string): IPerformanceEntry[] {\n        return $performance.getEntriesByName(name);\n      },\n      $getEntriesByType: function(type: string): IPerformanceEntry[] {\n        return $performance.getEntriesByType(type);\n      },\n      $clearMarks: function(name?: string): void {\n        $performance.clearMarks(name);\n      },\n      $clearMeasures: function(name?: string): void {\n        $performance.clearMeasures(name);\n      }\n    };\n  } else if ($global.process !== undefined && $global.process !== null && $global.process.hrtime) {\n    const entries: IPerformanceEntry[] = [];\n    const marksIndex: Record<string, IPerformanceEntry> = {};\n\n    const filterEntries = function (key: string, value: string): IPerformanceEntry[] {\n      let i = 0;\n      const n = entries.length;\n      const result = [];\n      for (; i < n; i++) {\n        if (entries[i][key] === value) {\n          result.push(entries[i]);\n        }\n      }\n      return\tresult;\n    };\n\n    const clearEntries = function (type: string, name: string): void {\n      let i = entries.length;\n      let entry: IPerformanceEntry;\n      while (i--) {\n        entry = entries[i];\n        if (entry.entryType === type && (name === void 0 || entry.name === name)) {\n          entries.splice(i, 1);\n        }\n      }\n    };\n\n    return {\n      $mark: function(name: string): void {\n        const mark: IPerformanceEntry = {\n          name,\n          entryType: 'mark',\n          startTime: $now(),\n          duration: 0\n        };\n        entries.push(mark);\n        marksIndex[name] = mark;\n      },\n      $measure: function(name: string, startMark?: string, endMark?: string): void {\n        let startTime: number;\n        let endTime: number;\n\n        if (endMark !== undefined && marksIndex[endMark] === undefined) {\n          throw new SyntaxError(`Failed to execute 'measure' on 'Performance': The mark '${endMark}' does not exist.`);\n        }\n        if (startMark !== undefined && marksIndex[startMark] === undefined) {\n          throw new SyntaxError(`Failed to execute 'measure' on 'Performance': The mark '${startMark}' does not exist.`);\n        }\n\n        if (marksIndex[startMark]) {\n          startTime = marksIndex[startMark].startTime;\n        } else {\n          startTime = 0;\n        }\n        if (marksIndex[endMark]) {\n          endTime = marksIndex[endMark].startTime;\n        } else {\n          endTime = $now();\n        }\n        entries.push({\n          name,\n          entryType: 'measure',\n          startTime,\n          duration: endTime - startTime\n        });\n      },\n      $getEntriesByName: function(name: string): IPerformanceEntry[] {\n        return filterEntries('name', name);\n      },\n      $getEntriesByType: function(type: string): IPerformanceEntry[] {\n        return filterEntries('entryType', type);\n      },\n      $clearMarks: function(name?: string): void {\n        clearEntries('mark', name);\n      },\n      $clearMeasures: function(name?: string): void {\n        clearEntries('measure', name);\n      }\n    };\n  }\n})();\n\n// RAF polyfill for non-browser envs from https://github.com/chrisdickinson/raf/blob/master/index.js\nconst { $raf, $caf } = (function(): { $raf(callback: (time: number) => void): number; $caf(handle: number): void } {\n  const vendors = ['moz', 'webkit'];\n  const suffix = 'AnimationFrame';\n  let raf: (callback: (time: number) => void) => number = $global[`request${suffix}`];\n  let caf: (handle: number) => void = $global[`cancel${suffix}`] || $global[`cancelRequest${suffix}`];\n\n  for (let i = 0; !raf && i < vendors.length; ++i) {\n    raf = $global[`${vendors[i]}Request${suffix}`];\n    caf = $global[`${vendors[i]}Cancel${suffix}`] || $global[`${vendors[i]}CancelRequest${suffix}`];\n  }\n\n  // Some versions of FF have rAF but not cAF\n  if (!raf || !caf) {\n    let last = 0;\n    let id = 0;\n    const queue: { handle: number; cancelled: boolean; callback(time: number): void }[] = [];\n    const frameDuration = 1000 / 60;\n\n    raf = function(callback: (time: number) => void): number {\n      let _now: number;\n      let next: number;\n      if (queue.length === 0) {\n        _now = $now();\n        next = Math.max(0, frameDuration - (_now - last));\n        last = next + _now;\n        setTimeout(\n          function(): void {\n            const cp = queue.slice(0);\n            // Clear queue here to prevent callbacks from appending listeners to the current frame's queue\n            queue.length = 0;\n            for (let i = 0; i < cp.length; ++i) {\n              if (!cp[i].cancelled) {\n                try {\n                  cp[i].callback(last);\n                } catch (e) {\n                  setTimeout(function(): void { throw e; }, 0);\n                }\n              }\n            }\n          },\n          Math.round(next)\n        );\n      }\n      queue.push({\n        handle: ++id,\n        callback: callback,\n        cancelled: false\n      });\n      return id;\n    };\n\n    caf = function(handle: number): void {\n      for (let i = 0; i < queue.length; ++i) {\n        if (queue[i].handle === handle) {\n          queue[i].cancelled = true;\n        }\n      }\n    };\n  }\n\n  const $$raf = function(callback: (time: number) => void): number {\n    return raf.call($global, callback);\n  };\n  $$raf.cancel = function(): void {\n    caf.apply($global, arguments);\n  };\n  $global.requestAnimationFrame = raf;\n  $global.cancelAnimationFrame = caf;\n  return { $raf: $$raf, $caf: caf };\n})();\n\n// A stripped-down version of pixijs's ticker @ https://github.com/pixijs/pixi.js/tree/dev/packages/ticker/src\nconst fpms = 0.06;\n\nclass Notifier {\n  public fn: (frameDelta?: number) => void;\n  public context: unknown;\n  public next: this;\n  public prev: this;\n  public disconnected: boolean;\n\n  constructor(fn: (frameDelta?: number) => void, context: unknown = null) {\n    this.fn = fn;\n    this.context = context;\n    this.next = null;\n    this.prev = null;\n    this.disconnected = false;\n  }\n\n  public equals(fn: (frameDelta?: number) => void, context: unknown): boolean {\n    return this.fn === fn && this.context === (context === undefined ? null : context);\n  }\n\n  public notify(frameDelta: number): this {\n    if (this.fn !== null) {\n      if (this.context !== null) {\n        this.fn.call(this.context, frameDelta);\n      } else {\n        this.fn(frameDelta);\n      }\n    }\n    const next = this.next;\n    if (this.disconnected) {\n      this.next = null;\n    }\n    return next;\n  }\n\n  public connect(prev: this): void {\n    this.prev = prev;\n    if (prev.next !== null) {\n      prev.next.prev = this;\n    }\n    this.next = prev.next;\n    prev.next = this;\n  }\n\n  public disconnect(hard: boolean = false): this {\n    this.disconnected = true;\n    this.fn = null;\n    this.context = null;\n    if (this.prev !== null) {\n      this.prev.next = this.next;\n    }\n    if (this.next !== null) {\n      this.next.prev = this.prev;\n    }\n    const next = this.next;\n    this.next = hard ? null : next;\n    this.prev = null;\n    return next;\n  }\n}\n\nexport class Ticker {\n  private requestId: number;\n  private frameDelta: number;\n  private lastTime: number;\n  private started: boolean;\n  private promise: Promise<number>;\n  private resolve: (deltaTime: number) => void;\n  private readonly head: Notifier;\n  private readonly tick: (deltaTime: number) => void;\n\n  constructor() {\n    this.head = new Notifier(null, null);\n    this.requestId = -1;\n    this.frameDelta = 1;\n    this.lastTime = -1;\n    this.started = false;\n    this.promise = null;\n    this.resolve = $noop;\n    this.tick = (deltaTime: number) => {\n      this.requestId = -1;\n      if (this.started) {\n        this.update(deltaTime);\n        if (this.started && this.requestId === -1 && this.head.next !== null) {\n          this.requestId = $raf(this.tick);\n        }\n      }\n      this.resolve(deltaTime);\n      this.resolve = $noop;\n      this.promise = null;\n    };\n  }\n\n  public add(fn: (frameDelta?: number) => void, context: unknown): this {\n    const notifier = new Notifier(fn, context);\n    let cur = this.head.next;\n    let prev = this.head;\n    if (cur === null) {\n      notifier.connect(prev);\n    } else {\n      while (cur !== null) {\n        prev = cur;\n        cur = cur.next;\n      }\n      if (notifier.prev === null) {\n        notifier.connect(prev);\n      }\n    }\n    if (this.started) {\n      this.tryRequest();\n    } else {\n      this.start();\n    }\n    return this;\n  }\n\n  public remove(fn: (frameDelta?: number) => void, context: unknown): this {\n    let notifier = this.head.next;\n    while (notifier !== null) {\n      if (notifier.equals(fn, context)) {\n        notifier = notifier.disconnect();\n      } else {\n        notifier = notifier.next;\n      }\n    }\n    if (this.head.next === null) {\n      this.tryCancel();\n    }\n    return this;\n  }\n\n  public start(): void {\n    if (!this.started) {\n      this.started = true;\n      this.tryRequest();\n    }\n  }\n\n  public stop(): void {\n    if (this.started) {\n      this.started = false;\n      this.tryCancel();\n    }\n  }\n\n  public update(currentTime: number = $now()): void {\n    let elapsedMS: number;\n\n    if (currentTime > this.lastTime) {\n      elapsedMS = currentTime - this.lastTime;\n      // ElapsedMS * 60 / 1000 is to get the frame delta as calculated based on the elapsed time.\n      // Adding half a rounding margin to that and performing a double bitwise negate rounds it to the rounding margin which is the nearest\n      // 1/1000th of a frame (this algorithm is about twice as fast as Math.round - every CPU cycle counts :)).\n      // The rounding is to account for floating point imprecisions in performance.now caused by the browser, and accounts for frame counting mismatch\n      // caused by frame delta's like 0.999238239.\n      this.frameDelta = (~~(elapsedMS * 60 + 0.5)) / 1000;\n      const head = this.head;\n      let notifier = head.next;\n      while (notifier !== null) {\n        notifier = notifier.notify(this.frameDelta);\n      }\n      if (head.next === null) {\n        this.tryCancel();\n      }\n    } else {\n      this.frameDelta = 0;\n    }\n    this.lastTime = currentTime;\n  }\n\n  public waitForNextTick(): Promise<number> {\n    if (this.promise === null) {\n      // tslint:disable-next-line:promise-must-complete\n      this.promise = new Promise(resolve => {\n        this.resolve = resolve;\n      });\n    }\n    return this.promise;\n  }\n\n  private tryRequest(): void {\n    if (this.requestId === -1 && this.head.next !== null) {\n      this.lastTime = $now();\n      this.requestId = $raf(this.tick);\n    }\n  }\n\n  private tryCancel(): void {\n    if (this.requestId !== -1) {\n      $caf(this.requestId);\n      this.requestId = -1;\n    }\n  }\n}\n\nconst camelCaseLookup: Record<string, string> = {};\nconst kebabCaseLookup: Record<string, string> = {};\n\nexport const PLATFORM = {\n  global: $global,\n  ticker: new Ticker(),\n  emptyArray: Object.freeze([]),\n  emptyObject: Object.freeze({}),\n  noop: $noop,\n  now: $now,\n  mark: $mark,\n  measure: $measure,\n  getEntriesByName: $getEntriesByName,\n  getEntriesByType: $getEntriesByType,\n  clearMarks: $clearMarks,\n  clearMeasures: $clearMeasures,\n\n  camelCase(input: string): string {\n    // benchmark: http://jsben.ch/qIz4Z\n    let value = camelCaseLookup[input];\n    if (value !== undefined) return value;\n    value = '';\n    let first = true;\n    let sep = false;\n    let char: string;\n    for (let i = 0, ii = input.length; i < ii; ++i) {\n      char = input.charAt(i);\n      if (char === '-' || char === '.' || char === '_') {\n        sep = true; // skip separators\n      } else {\n        value = value + (first ? char.toLowerCase() : (sep ? char.toUpperCase() : char));\n        sep = false;\n      }\n      first = false;\n    }\n    return camelCaseLookup[input] = value;\n  },\n\n  kebabCase(input: string): string {\n    // benchmark: http://jsben.ch/v7K9T\n    let value = kebabCaseLookup[input];\n    if (value !== undefined) return value;\n    value = '';\n    let first = true;\n    let char: string, lower: string;\n    for (let i = 0, ii = input.length; i < ii; ++i) {\n      char = input.charAt(i);\n      lower = char.toLowerCase();\n      value = value + (first ? lower : (char !== lower ? `-${lower}` : lower));\n      first = false;\n    }\n    return kebabCaseLookup[input] = value;\n  },\n\n  toArray<T = unknown>(input: ArrayLike<T>): T[] {\n    // benchmark: http://jsben.ch/xjsyF\n    const len = input.length;\n    const arr = Array(len);\n    for (let i = 0; i < len; ++i) {\n        arr[i] = input[i];\n    }\n    return arr;\n  },\n\n  requestAnimationFrame(callback: (time: number) => void): number {\n    return $raf(callback);\n  },\n\n  clearInterval(handle?: number): void {\n    $global.clearInterval(handle);\n  },\n\n  clearTimeout(handle?: number): void {\n    $global.clearTimeout(handle);\n  },\n\n  // tslint:disable-next-line:no-any\n  setInterval(handler: ITimerHandler, timeout?: number, ...args: any[]): number {\n    return $global.setInterval(handler, timeout, ...args);\n  },\n\n  // tslint:disable-next-line:no-any\n  setTimeout(handler: ITimerHandler, timeout?: number, ...args: any[]): number {\n    return $global.setTimeout(handler, timeout, ...args);\n  }\n};\n","\nexport interface ITraceInfo {\n  readonly name: string;\n  readonly depth: number;\n  params: ReadonlyArray<unknown> | null;\n  next: ITraceInfo | null;\n  prev: ITraceInfo | null;\n}\nexport interface ITraceWriter {\n  write(info: ITraceInfo): void;\n}\nexport const Reporter = {\n  write(code: number, ...params: unknown[]): void { return; },\n  error(code: number, ...params: unknown[]): Error { return new Error(`Code ${code}`); }\n};\nexport const Tracer = {\n  /**\n   * A convenience property for the user to conditionally call the tracer.\n   * This saves unnecessary `noop` and `slice` calls in non-AOT scenarios even if debugging is disabled.\n   * In AOT these calls will simply be removed entirely.\n   *\n   * This property **only** turns on tracing if `@aurelia/debug` is included and configured as well.\n   */\n  enabled: false,\n  liveLoggingEnabled: false,\n  liveWriter: null as ITraceWriter,\n  /**\n   * Call this at the start of a method/function.\n   * Each call to `enter` **must** have an accompanying call to `leave` for the tracer to work properly.\n   * @param name Any human-friendly name to identify the traced method with.\n   * @param args Pass in `Array.prototype.slice.call(arguments)` to also trace the parameters, or `null` if this is not needed (to save memory/cpu)\n   */\n  enter(name: string, args: unknown[] | null): void { return; },\n  /**\n   * Call this at the end of a method/function. Pops one trace item off the stack.\n   */\n  leave(): void { return; },\n  /**\n   * Writes only the trace info leading up to the current method call.\n   * @param writer An object to write the output to.\n   */\n  writeStack(writer: ITraceWriter): void { return; },\n  /**\n   * Writes all trace info captured since the previous flushAll operation.\n   * @param writer An object to write the output to. Can be null to simply reset the tracer state.\n   */\n  flushAll(writer: ITraceWriter | null): void { return; },\n  /**\n   * Writes out each trace info item as they are traced.\n   * @param writer An object to write the output to.\n   */\n  enableLiveLogging(writer: ITraceWriter): void { return; },\n  /**\n   * Stops writing out each trace info item as they are traced.\n   */\n  disableLiveLogging(): void { return; }\n};\n","/// <reference types=\"reflect-metadata\" />\nimport { Class, Constructable, IIndexable, Injectable, InterfaceSymbol, Primitive } from './interfaces';\nimport { PLATFORM } from './platform';\nimport { Reporter, Tracer } from './reporter';\nimport { IResourceType } from './resource';\n\nconst slice = Array.prototype.slice;\n\nexport type ResolveCallback<T = unknown> = (handler?: IContainer, requestor?: IContainer, resolver?: IResolver) => T;\n\nexport type Key<T> = InterfaceSymbol<T> | Primitive | IIndexable | Constructable;\n\nexport interface IDefaultableInterfaceSymbol<T> extends InterfaceSymbol<T> {\n  withDefault(configure: (builder: IResolverBuilder<T>) => IResolver): InterfaceSymbol<T>;\n  noDefault(): InterfaceSymbol<T>;\n}\n\n// This interface exists only to break a circular type referencing issue in the IServiceLocator interface.\n// Otherwise IServiceLocator references IResolver, which references IContainer, which extends IServiceLocator.\ninterface IResolverLike<TValue, TContainer> {\n  resolve(handler: TContainer, requestor: TContainer): TValue;\n  getFactory?(container: TContainer): IFactory<TValue> | null;\n}\n\nexport interface IResolver<T = any> extends IResolverLike<T, IContainer> { }\n\nexport interface IRegistration<T = any> {\n  register(container: IContainer, key?: Key<T>): IResolver<T>;\n}\n\nexport interface IFactory<T = any> {\n  readonly Type: Constructable;\n  registerTransformer(transformer: (instance: T) => T): boolean;\n  construct(container: IContainer, dynamicDependencies?: Key<unknown>[]): T;\n}\n\nexport interface IServiceLocator {\n  has<K>(key: Constructable | Key<unknown> | IResolver<unknown> | K, searchAncestors: boolean): boolean;\n\n  get<K>(key: Constructable | Key<unknown> | IResolver<unknown> | K):\n    K extends InterfaceSymbol<infer T> ? T :\n    K extends Constructable ? InstanceType<K> :\n    K extends IResolverLike<infer T1, unknown> ? T1 extends Constructable ? InstanceType<T1> : T1 :\n    K;\n\n  getAll<K>(key: Constructable | Key<unknown> | IResolver<unknown> | K):\n    K extends InterfaceSymbol<infer T> ? ReadonlyArray<T> :\n    K extends Constructable ? ReadonlyArray<InstanceType<K>> :\n    K extends IResolverLike<infer T1, unknown> ? T1 extends Constructable ? ReadonlyArray<InstanceType<T1>> : ReadonlyArray<T1> :\n    ReadonlyArray<K>;\n}\n\nexport interface IRegistry {\n  register(container: IContainer): void;\n}\n\nexport interface IContainer extends IServiceLocator {\n  register(...params: IRegistry[]): IContainer;\n  register(...params: Record<string, Partial<IRegistry>>[]): IContainer;\n  register(...params: (IRegistry | Record<string, Partial<IRegistry>>)[]): IContainer;\n  register(registry: Record<string, Partial<IRegistry>>): IContainer;\n  register(registry: IRegistry): IContainer;\n  register(registry: IRegistry | Record<string, Partial<IRegistry>>): IContainer;\n\n  registerResolver<T>(key: Key<T>, resolver: IResolver<T>): IResolver<T>;\n  registerResolver<T extends Constructable>(key: T, resolver: IResolver<InstanceType<T>>): IResolver<InstanceType<T>>;\n\n  registerTransformer<T>(key: Key<T>, transformer: (instance: T) => T): boolean;\n  registerTransformer<T extends Constructable>(key: T, transformer: (instance: InstanceType<T>) => T): boolean;\n\n  getResolver<T>(key: Key<T>, autoRegister?: boolean): IResolver<T> | null;\n  getResolver<T extends Constructable>(key: T, autoRegister?: boolean): IResolver<InstanceType<T>> | null;\n\n  getFactory<T extends Constructable>(Type: T): IFactory<InstanceType<T>>;\n\n  createChild(): IContainer;\n}\n\nexport interface IResolverBuilder<T> {\n  instance(value: T & IIndexable): IResolver;\n  singleton(value: Constructable): IResolver;\n  transient(value: Constructable): IResolver;\n  callback(value: ResolveCallback<T>): IResolver;\n  aliasTo(destinationKey: Key<T>): IResolver;\n}\n\nexport type RegisterSelf<T extends Constructable> = {\n  register(container: IContainer): IResolver<InstanceType<T>>;\n};\n\n// Shims to augment the Reflect object with methods used from the Reflect Metadata API proposal:\n// https://www.typescriptlang.org/docs/handbook/decorators.html#metadata\n// https://rbuckton.github.io/reflect-metadata/\n// As the official spec proposal uses \"any\", we use it here as well and suppress related typedef linting warnings.\n// tslint:disable:no-any ban-types\nif (!('getOwnMetadata' in Reflect)) {\n  Reflect.getOwnMetadata = function(metadataKey: any, target: Object): any {\n    return (target as IIndexable)[metadataKey];\n  };\n\n  Reflect.metadata = function(metadataKey: any, metadataValue: any): (target: Function) => void {\n    return function(target: Function): void {\n      (target as IIndexable)[metadataKey] = metadataValue;\n    };\n  };\n}\n// tslint:enable:no-any ban-types\n\nfunction createContainer(...params: IRegistry[]): IContainer;\nfunction createContainer(...params: Record<string, Partial<IRegistry>>[]): IContainer;\nfunction createContainer(...params: (IRegistry | Record<string, Partial<IRegistry>>)[]): IContainer;\nfunction createContainer(registry: Record<string, Partial<IRegistry>>): IContainer;\nfunction createContainer(registry: IRegistry): IContainer;\nfunction createContainer(registry: IRegistry | Record<string, Partial<IRegistry>>): IContainer;\nfunction createContainer(...params: (IRegistry | Record<string, Partial<IRegistry>>)[]): IContainer {\n  if (arguments.length === 0) {\n    return new Container();\n  } else {\n    return new Container().register(...params);\n  }\n}\n\nexport const DI = {\n  createContainer,\n\n  getDesignParamTypes(target: Constructable): Key<unknown>[] {\n    return Reflect.getOwnMetadata('design:paramtypes', target) || PLATFORM.emptyArray;\n  },\n\n  getDependencies(Type: Constructable | Injectable): Key<unknown>[] {\n    let dependencies: Key<unknown>[];\n\n    if ((Type as Injectable).inject === undefined) {\n      dependencies = DI.getDesignParamTypes(Type);\n    } else {\n      dependencies = [];\n      let ctor = Type as Injectable;\n\n      while (typeof ctor === 'function') {\n        if (ctor.hasOwnProperty('inject')) {\n          dependencies.push(...ctor.inject);\n        }\n\n        ctor = Object.getPrototypeOf(ctor);\n      }\n    }\n\n    return dependencies;\n  },\n\n  createInterface<T = unknown>(friendlyName?: string): IDefaultableInterfaceSymbol<T> {\n    const Interface: IDefaultableInterfaceSymbol<T> & Partial<IRegistration<T> & {friendlyName: string}> = function(target: Injectable, property: string, index: number): unknown {\n      if (target === undefined) {\n        throw Reporter.error(16, Interface.friendlyName, Interface); // TODO: add error (trying to resolve an InterfaceSymbol that has no registrations)\n      }\n      (target.inject || (target.inject = []))[index] = Interface;\n      return target;\n    };\n    Interface.friendlyName = friendlyName || 'Interface';\n\n    Interface.noDefault = function(): InterfaceSymbol<T> {\n      return Interface;\n    };\n\n    Interface.withDefault = function(configure: (builder: IResolverBuilder<T>) => IResolver): InterfaceSymbol<T> {\n      Interface.withDefault = function(): InterfaceSymbol<T> {\n        throw Reporter.error(17, Interface);\n      };\n\n      Interface.register = function(container: IContainer, key?: Key<T>): IResolver<T> {\n        const trueKey = key || Interface;\n        return configure({\n          instance(value: T): IResolver {\n            return container.registerResolver(trueKey, new Resolver(trueKey, ResolverStrategy.instance, value));\n          },\n          singleton(value: Constructable): IResolver {\n            return container.registerResolver(trueKey, new Resolver(trueKey, ResolverStrategy.singleton, value));\n          },\n          transient(value: Constructable): IResolver {\n            return container.registerResolver(trueKey, new Resolver(trueKey, ResolverStrategy.transient, value));\n          },\n          callback(value: ResolveCallback): IResolver {\n            return container.registerResolver(trueKey, new Resolver(trueKey, ResolverStrategy.callback, value));\n          },\n          aliasTo(destinationKey: T): IResolver {\n            return container.registerResolver(trueKey, new Resolver(trueKey, ResolverStrategy.alias, destinationKey));\n          },\n        });\n      };\n\n      return Interface;\n    };\n\n    return Interface;\n  },\n\n  inject(...dependencies: Key<unknown>[]): (target: Injectable, key?: string, descriptor?: PropertyDescriptor | number) => void {\n    return function(target: Injectable, key?: string, descriptor?: PropertyDescriptor | number): void {\n      if (typeof descriptor === 'number') { // It's a parameter decorator.\n        if (!target.hasOwnProperty('inject')) {\n          const types = DI.getDesignParamTypes(target);\n          target.inject = types.slice() as Constructable[];\n        }\n\n        if (dependencies.length === 1) {\n          target.inject[descriptor] = dependencies[0] as Constructable;\n        }\n      } else if (key) { // It's a property decorator. Not supported by the container without plugins.\n        const actualTarget = target.constructor as Injectable;\n        (actualTarget.inject || ((actualTarget.inject as unknown) = {}))[key] = dependencies[0];\n      } else if (descriptor) { // It's a function decorator (not a Class constructor)\n        const fn = descriptor.value;\n        fn.inject = dependencies;\n      } else { // It's a class decorator.\n        if (dependencies.length === 0) {\n          const types = DI.getDesignParamTypes(target);\n          target.inject = types.slice() as Constructable[];\n        } else {\n          target.inject = dependencies as Constructable[];\n        }\n      }\n    };\n  },\n\n  // tslint:disable:jsdoc-format\n  /**\n   * Registers the `target` class as a transient dependency; each time the dependency is resolved\n   * a new instance will be created.\n   *\n   * @param target The class / constructor function to register as transient.\n   * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.\n   *\n   * Example usage:\n```ts\n// On an existing class\nclass Foo { }\nDI.transient(Foo);\n\n// Inline declaration\nconst Foo = DI.transient(class { });\n// Foo is now strongly typed with register\nFoo.register(container);\n```\n   */\n  // tslint:enable:jsdoc-format\n  transient<T extends Constructable>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T> {\n    target.register = function register(container: IContainer): IResolver<InstanceType<T>> {\n      const registration = Registration.transient(target, target);\n      return registration.register(container, target);\n    };\n    return target as T & RegisterSelf<T>;\n  },\n\n  // tslint:disable:jsdoc-format\n  /**\n   * Registers the `target` class as a singleton dependency; the class will only be created once. Each\n   * consecutive time the dependency is resolved, the same instance will be returned.\n   *\n   * @param target The class / constructor function to register as a singleton.\n   * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.\n   * Example usage:\n```ts\n// On an existing class\nclass Foo { }\nDI.singleton(Foo);\n\n// Inline declaration\nconst Foo = DI.singleton(class { });\n// Foo is now strongly typed with register\nFoo.register(container);\n```\n   */\n  // tslint:enable:jsdoc-format\n  singleton<T extends Constructable>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T> {\n    target.register = function register(container: IContainer): IResolver<InstanceType<T>> {\n      const registration = Registration.singleton(target, target);\n      return registration.register(container, target);\n    };\n    return target as T & RegisterSelf<T>;\n  }\n};\n\nexport const IContainer = DI.createInterface<IContainer>('IContainer').noDefault();\nexport const IServiceLocator = IContainer as InterfaceSymbol<IServiceLocator>;\n\nfunction createResolver(getter: (key: unknown, handler: IContainer, requestor: IContainer) => any): (key: unknown) => ReturnType<typeof DI.inject> {\n  return function(key: unknown): ReturnType<typeof DI.inject> {\n    const resolver: InterfaceSymbol<{}> & Partial<Pick<IResolver, 'resolve'>> = function (target: Injectable, property?: string, descriptor?: PropertyDescriptor | number): void {\n      DI.inject(resolver)(target, property, descriptor);\n    };\n\n    resolver.resolve = function(handler: IContainer, requestor: IContainer): any {\n      return getter(key, handler, requestor);\n    };\n\n    return resolver;\n  };\n}\n\nexport const inject = DI.inject;\n\nfunction transientDecorator<T extends Constructable>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T> {\n  return DI.transient(target);\n}\n// tslint:disable:jsdoc-format\n/**\n * Registers the decorated class as a transient dependency; each time the dependency is resolved\n * a new instance will be created.\n *\n * Example usage:\n```ts\n@transient\nclass Foo { }\n```\n */\n// tslint:enable:jsdoc-format\nexport function transient<T extends Constructable>(): typeof transientDecorator;\n// tslint:disable:jsdoc-format\n/**\n * Registers the `target` class as a transient dependency; each time the dependency is resolved\n * a new instance will be created.\n *\n * @param target The class / constructor function to register as transient.\n *\n * Example usage:\n```ts\n@transient()\nclass Foo { }\n```\n */\n// tslint:enable:jsdoc-format\nexport function transient<T extends Constructable>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T>;\nexport function transient<T extends Constructable>(target?: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T> | typeof transientDecorator {\n  return target === undefined ? transientDecorator : transientDecorator(target);\n}\n\nfunction singletonDecorator<T extends Constructable>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T> {\n  return DI.singleton(target);\n}\n// tslint:disable:jsdoc-format\n/**\n * Registers the decorated class as a singleton dependency; the class will only be created once. Each\n * consecutive time the dependency is resolved, the same instance will be returned.\n *\n * Example usage:\n```ts\n@singleton\nclass Foo { }\n```\n */\n// tslint:enable:jsdoc-format\nexport function singleton<T extends Constructable>(): typeof singletonDecorator;\n// tslint:disable:jsdoc-format\n/**\n * Registers the `target` class as a singleton dependency; the class will only be created once. Each\n * consecutive time the dependency is resolved, the same instance will be returned.\n *\n * @param target The class / constructor function to register as a singleton.\n *\n * Example usage:\n```ts\n@singleton()\nclass Foo { }\n```\n */\n// tslint:enable:jsdoc-format\nexport function singleton<T extends Constructable>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T>;\nexport function singleton<T extends Constructable>(target?: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T> | typeof singletonDecorator {\n  return target === undefined ? singletonDecorator : singletonDecorator(target);\n}\n\nexport const all = createResolver((key: unknown, handler: IContainer, requestor: IContainer) => requestor.getAll(key));\n\nexport const lazy = createResolver((key: unknown, handler: IContainer, requestor: IContainer) =>  {\n  let instance: unknown = null; // cache locally so that lazy always returns the same instance once resolved\n  return () => {\n    if (instance === null) {\n      instance = requestor.get(key);\n    }\n\n    return instance;\n  };\n});\n\nexport const optional = createResolver((key: unknown, handler: IContainer, requestor: IContainer) =>  {\n  if (requestor.has(key, true)) {\n    return requestor.get(key);\n  } else {\n    return null;\n  }\n});\n\n/** @internal */\nexport const enum ResolverStrategy {\n  instance = 0,\n  singleton = 1,\n  transient = 2,\n  callback = 3,\n  array = 4,\n  alias = 5\n}\n\n/** @internal */\nexport class Resolver implements IResolver, IRegistration {\n  public key: Key<unknown>;\n  public strategy: ResolverStrategy;\n  public state: unknown;\n  constructor(key: Key<unknown>, strategy: ResolverStrategy, state: unknown) {\n    this.key = key;\n    this.strategy = strategy;\n    this.state = state;\n  }\n\n  public register(container: IContainer, key?: Key<unknown>): IResolver {\n    return container.registerResolver(key || this.key, this);\n  }\n\n  public resolve(handler: IContainer, requestor: IContainer): unknown {\n    switch (this.strategy) {\n      case ResolverStrategy.instance:\n        return this.state;\n      case ResolverStrategy.singleton: {\n        this.strategy = ResolverStrategy.instance;\n        const factory = handler.getFactory(this.state as Constructable);\n        return this.state = factory.construct(handler);\n      }\n      case ResolverStrategy.transient: {\n        // Always create transients from the requesting container\n        const factory = handler.getFactory(this.state as Constructable);\n        return factory.construct(requestor);\n      }\n      case ResolverStrategy.callback:\n        return (this.state as ResolveCallback)(handler, requestor, this);\n      case ResolverStrategy.array:\n        return (this.state as IResolver[])[0].resolve(handler, requestor);\n      case ResolverStrategy.alias:\n        return handler.get(this.state);\n      default:\n        throw Reporter.error(6, this.strategy);\n    }\n  }\n\n  public getFactory(container: IContainer): IFactory | null {\n    switch (this.strategy) {\n      case ResolverStrategy.singleton:\n      case ResolverStrategy.transient:\n        return container.getFactory(this.state as Constructable);\n      default:\n        return null;\n    }\n  }\n}\n\n/** @internal */\nexport interface IInvoker {\n  invoke(container: IContainer, fn: Constructable, dependencies: Key<unknown>[]): Constructable;\n  invokeWithDynamicDependencies(\n    container: IContainer,\n    fn: Constructable,\n    staticDependencies: Key<unknown>[],\n    dynamicDependencies: Key<unknown>[]\n  ): Constructable;\n}\n\n/** @internal */\nexport class Factory implements IFactory {\n  public Type: Constructable;\n  private readonly invoker: IInvoker;\n  private readonly dependencies: Key<unknown>[];\n  private transformers: ((instance: any) => any)[] | null;\n\n  constructor(Type: Constructable, invoker: IInvoker, dependencies: Key<unknown>[]) {\n    this.Type = Type;\n    this.invoker = invoker;\n    this.dependencies = dependencies;\n    this.transformers = null;\n  }\n\n  public static create(Type: Constructable): IFactory {\n    const dependencies = DI.getDependencies(Type);\n    const invoker = classInvokers[dependencies.length] || fallbackInvoker;\n    return new Factory(Type, invoker, dependencies);\n  }\n\n  public construct(container: IContainer, dynamicDependencies?: Key<unknown>[]): Constructable {\n    if (Tracer.enabled) { Tracer.enter(`Factory.construct`, slice.call(arguments).concat(this.Type)); }\n    const transformers = this.transformers;\n    let instance = dynamicDependencies !== undefined\n      ? this.invoker.invokeWithDynamicDependencies(container, this.Type, this.dependencies, dynamicDependencies)\n      : this.invoker.invoke(container, this.Type, this.dependencies);\n\n    if (transformers === null) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return instance;\n    }\n\n    for (let i = 0, ii = transformers.length; i < ii; ++i) {\n      instance = transformers[i](instance);\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n    return instance;\n  }\n\n  public registerTransformer(transformer: (instance: any) => any): boolean {\n    if (this.transformers === null) {\n      this.transformers = [];\n    }\n\n    this.transformers.push(transformer);\n    return true;\n  }\n}\n\n/** @internal */\nexport interface IContainerConfiguration {\n  factories?: Map<Constructable, IFactory>;\n  resourceLookup?: Record<string, IResourceType<unknown, unknown>>;\n}\n\nconst containerResolver: IResolver = {\n  resolve(handler: IContainer, requestor: IContainer): IContainer {\n    return requestor;\n  }\n};\n\nfunction isRegistry(obj: IRegistry | Record<string, IRegistry>): obj is IRegistry {\n  return typeof obj.register === 'function';\n}\n\nfunction isClass<T extends { prototype?: unknown }>(obj: T): obj is Class<unknown, T> {\n  return obj.prototype !== undefined;\n}\n\n/** @internal */\nexport class Container implements IContainer {\n  private parent: Container | null;\n  private registerDepth: number;\n  private readonly resolvers: Map<InterfaceSymbol<IContainer>, IResolver>;\n  private readonly factories: Map<Constructable, IFactory>;\n  private readonly configuration: IContainerConfiguration;\n  private readonly resourceLookup: Record<string, IResolver>;\n\n  constructor(configuration: IContainerConfiguration = {}) {\n    this.parent = null;\n    this.registerDepth = 0;\n    this.resolvers = new Map<InterfaceSymbol<IContainer>, IResolver>();\n    this.configuration = configuration;\n    this.factories = configuration.factories || (configuration.factories = new Map());\n    this.resourceLookup = configuration.resourceLookup || (configuration.resourceLookup = Object.create(null));\n    this.resolvers.set(IContainer, containerResolver);\n  }\n\n  public register(...params: IRegistry[]): this;\n  public register(...params: Record<string, Partial<IRegistry>>[]): this;\n  public register(...params: (IRegistry | Record<string, Partial<IRegistry>>)[]): this;\n  public register(registry: Record<string, Partial<IRegistry>>): this;\n  public register(registry: IRegistry): this;\n  public register(registry: IRegistry | Record<string, Partial<IRegistry>>): this;\n  public register(...params: (IRegistry | Record<string, Partial<IRegistry>>)[]): this {\n    if (++this.registerDepth === 100) {\n      throw new Error('Unable to autoregister dependency');\n      // TODO: change to reporter.error and add various possible causes in description.\n      // Most likely cause is trying to register a plain object that does not have a\n      // register method and is not a class constructor\n    }\n    for (let i = 0, ii = params.length; i < ii; ++i) {\n      const current = params[i] as IRegistry | Record<string, IRegistry>;\n      if (isRegistry(current)) {\n        current.register(this);\n      } else if (isClass(current)) {\n        Registration.singleton(current, current).register(this);\n      } else {\n        const keys = Object.keys(current);\n        for (let j = 0, jj = keys.length; j < jj; ++j) {\n          const value = current[keys[j]];\n          // note: we could remove this if-branch and call this.register directly\n          // - the extra check is just a perf tweak to create fewer unnecessary arrays by the spread operator\n          if (isRegistry(value)) {\n            value.register(this);\n          } else {\n            this.register(value);\n          }\n        }\n      }\n    }\n    --this.registerDepth;\n    return this;\n  }\n\n  public registerResolver(key: Key<IContainer>, resolver: IResolver): IResolver {\n    validateKey(key);\n\n    const resolvers = this.resolvers;\n    const result = resolvers.get(key as InterfaceSymbol<IContainer>);\n\n    if (result === undefined) {\n      resolvers.set(key as InterfaceSymbol<IContainer>, resolver);\n      if (typeof key === 'string') {\n        this.resourceLookup[key] = resolver;\n      }\n    } else if (result instanceof Resolver && result.strategy === ResolverStrategy.array) {\n      (result.state as IResolver[]).push(resolver);\n    } else {\n      resolvers.set(key as InterfaceSymbol<IContainer>, new Resolver(key, ResolverStrategy.array, [result, resolver]));\n    }\n\n    return resolver;\n  }\n\n  public registerTransformer(key: IResolver, transformer: (instance: any) => any): boolean {\n    const resolver = this.getResolver(key);\n\n    if (resolver === null) {\n      return false;\n    }\n\n    if (resolver.getFactory) {\n      const handler = resolver.getFactory(this);\n\n      if (handler === null) {\n        return false;\n      }\n\n      return handler.registerTransformer(transformer);\n    }\n\n    return false;\n  }\n\n  public getResolver(key: Key<IContainer> | IResolver, autoRegister: boolean = true): IResolver | null {\n    validateKey(key);\n\n    if ((key as IResolver).resolve) {\n      return key as IResolver;\n    }\n\n    let current: Container = this;\n\n    while (current !== null) {\n      const resolver = current.resolvers.get(key as InterfaceSymbol<IContainer>);\n\n      if (resolver === undefined) {\n        if (current.parent === null) {\n          return autoRegister ? this.jitRegister(key as InterfaceSymbol<IContainer>, current) : null;\n        }\n\n        current = current.parent;\n      } else {\n        return resolver;\n      }\n    }\n\n    return null;\n  }\n\n  public has(key: Key<IContainer>, searchAncestors: boolean = false): boolean {\n    return this.resolvers.has(key as InterfaceSymbol<IContainer>)\n      ? true\n      : searchAncestors && this.parent !== null\n      ? this.parent.has(key, true)\n      : false;\n  }\n\n  public get(key: Key<IContainer>|IResolver): any {\n    if (Tracer.enabled) { Tracer.enter(`Container.get`, slice.call(arguments)); }\n    validateKey(key);\n\n    if ((key as IResolver).resolve) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return (key as IResolver).resolve(this, this);\n    }\n\n    let current: Container = this;\n\n    while (current !== null) {\n      let resolver = current.resolvers.get(key as InterfaceSymbol<IContainer>);\n\n      if (resolver === undefined) {\n        if (current.parent === null) {\n          resolver = this.jitRegister(key as InterfaceSymbol<IContainer>, current);\n          if (Tracer.enabled) { Tracer.leave(); }\n          return resolver.resolve(current, this);\n        }\n\n        current = current.parent;\n      } else {\n        if (Tracer.enabled) { Tracer.leave(); }\n        return resolver.resolve(current, this);\n      }\n    }\n  }\n\n  public getAll(key: Key<IContainer>): any {\n    validateKey(key);\n\n    let current: Container | null = this;\n\n    while (current !== null) {\n      const resolver = current.resolvers.get(key as InterfaceSymbol<IContainer>);\n\n      if (resolver === undefined) {\n        if (this.parent === null) {\n          return PLATFORM.emptyArray;\n        }\n\n        current = current.parent;\n      } else {\n        return buildAllResponse(resolver, current, this);\n      }\n    }\n\n    return PLATFORM.emptyArray;\n  }\n\n  public getFactory(Type: Constructable): IFactory {\n    let factory = this.factories.get(Type);\n\n    if (factory === undefined) {\n      factory = Factory.create(Type);\n      this.factories.set(Type, factory);\n    }\n\n    return factory;\n  }\n\n  public createChild(): IContainer {\n    const config = this.configuration;\n    const childConfig = { factories: config.factories, resourceLookup: { ...config.resourceLookup } };\n    const child = new Container(childConfig);\n    child.parent = this;\n    return child;\n  }\n\n  private jitRegister(keyAsValue: Key<IContainer>|IRegistration, handler: Container): IResolver {\n    if ((keyAsValue as IRegistration).register) {\n      const registrationResolver = (keyAsValue as IRegistration).register(handler, keyAsValue);\n      if (!(registrationResolver && registrationResolver.resolve)) {\n        throw Reporter.error(40); // did not return a valid resolver from the static register method\n      }\n      return registrationResolver;\n    }\n\n    const resolver = new Resolver(keyAsValue, ResolverStrategy.singleton, keyAsValue);\n    handler.resolvers.set(keyAsValue as InterfaceSymbol<IContainer>, resolver);\n    return resolver;\n  }\n}\n\nexport const Registration = {\n  instance(key: Key<unknown>, value: unknown): IRegistration {\n    return new Resolver(key, ResolverStrategy.instance, value);\n  },\n\n  singleton(key: Key<unknown>, value: Constructable): IRegistration {\n    return new Resolver(key, ResolverStrategy.singleton, value);\n  },\n\n  transient(key: Key<unknown>, value: Constructable): IRegistration {\n    return new Resolver(key, ResolverStrategy.transient, value);\n  },\n\n  callback(key: Key<unknown>, callback: ResolveCallback): IRegistration {\n    return new Resolver(key, ResolverStrategy.callback, callback);\n  },\n\n  alias(originalKey: Key<unknown>, aliasKey: Key<unknown>): IRegistration {\n    return new Resolver(aliasKey, ResolverStrategy.alias, originalKey);\n  },\n\n  interpret(interpreterKey: Key<{}>, ...rest: Constructable[]): IRegistry {\n    return {\n      register(container: IContainer): void {\n        const resolver = container.getResolver<IRegistry>(interpreterKey);\n\n        if (resolver !== null) {\n          let registry: IRegistry | null =  null;\n\n          if (resolver.getFactory) {\n            const factory = resolver.getFactory(container);\n\n            if (factory !== null) {\n              registry = factory.construct(container, rest);\n            }\n          } else {\n            registry = resolver.resolve(container, container);\n          }\n\n          if (registry !== null) {\n            registry.register(container);\n          }\n        }\n      }\n    };\n  }\n};\n\n/** @internal */\nexport function validateKey(key: unknown): void {\n  // note: design:paramTypes which will default to Object if the param types cannot be statically analyzed by tsc\n  // this check is intended to properly report on that problem - under no circumstance should Object be a valid key anyway\n  if (key === null || key === undefined || key === Object) {\n    throw Reporter.error(5);\n  }\n}\n\nfunction buildAllResponse(resolver: IResolver, handler: IContainer, requestor: IContainer): any[] {\n  if (resolver instanceof Resolver && resolver.strategy === ResolverStrategy.array) {\n    const state = resolver.state as IResolver[];\n    let i = state.length;\n    const results = new Array(i);\n\n    while (i--) {\n      results[i] = state[i].resolve(handler, requestor);\n    }\n\n    return results;\n  }\n\n  return [resolver.resolve(handler, requestor)];\n}\n\n/** @internal */\nexport const classInvokers: IInvoker[] = [\n  {\n    invoke<T extends Constructable, K>(container: IContainer, Type: T): K {\n      return new Type();\n    },\n    invokeWithDynamicDependencies\n  },\n  {\n    invoke<T extends Constructable, K>(container: IContainer, Type: T, deps: Key<unknown>[]): K {\n      return new Type(container.get(deps[0]));\n    },\n    invokeWithDynamicDependencies\n  },\n  {\n    invoke<T extends Constructable, K>(container: IContainer, Type: T, deps: Key<unknown>[]): K {\n      return new Type(container.get(deps[0]), container.get(deps[1]));\n    },\n    invokeWithDynamicDependencies\n  },\n  {\n    invoke<T extends Constructable, K>(container: IContainer, Type: T, deps: Key<unknown>[]): K {\n      return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]));\n    },\n    invokeWithDynamicDependencies\n  },\n  {\n    invoke<T extends Constructable, K>(container: IContainer, Type: T, deps: Key<unknown>[]): K {\n      return new Type(\n        container.get(deps[0]),\n        container.get(deps[1]),\n        container.get(deps[2]),\n        container.get(deps[3])\n      );\n    },\n    invokeWithDynamicDependencies\n  },\n  {\n    invoke<T extends Constructable, K>(container: IContainer, Type: T, deps: Key<unknown>[]): K {\n      return new Type(\n        container.get(deps[0]),\n        container.get(deps[1]),\n        container.get(deps[2]),\n        container.get(deps[3]),\n        container.get(deps[4])\n      );\n    },\n    invokeWithDynamicDependencies\n  }\n];\n\n/** @internal */\nexport const fallbackInvoker: IInvoker = {\n  invoke: invokeWithDynamicDependencies as (container: IContainer, fn: Constructable, dependencies: Key<unknown>[]) => Constructable,\n  invokeWithDynamicDependencies\n};\n\n/** @internal */\nexport function invokeWithDynamicDependencies<T extends Constructable, K>(\n  container: IContainer,\n  Type: T,\n  staticDependencies: Key<unknown>[],\n  dynamicDependencies: Key<unknown>[]\n): K {\n  let i = staticDependencies.length;\n  let args: Key<unknown>[] = new Array(i);\n  let lookup: Key<unknown>;\n\n  while (i--) {\n    lookup = staticDependencies[i];\n\n    if (lookup === null || lookup === undefined) {\n      throw Reporter.error(7, `Index ${i}.`);\n    } else {\n      args[i] = container.get(lookup);\n    }\n  }\n\n  if (dynamicDependencies !== undefined) {\n    args = args.concat(dynamicDependencies);\n  }\n\n  return Reflect.construct(Type, args);\n}\n","import { PLATFORM } from './platform';\n\nexport interface ITimer {\n  enter(): void;\n  leave(): void;\n}\n\nexport interface IProfile {\n  name: string;\n  duration: number;\n  topLevelCount: number;\n  totalCount: number;\n}\n\nexport const Profiler = (function(): {\n  createTimer: typeof createTimer;\n  enable: typeof enable;\n  disable: typeof disable;\n  report: typeof report;\n  readonly enabled: boolean;\n} {\n  const now = PLATFORM.now;\n  const timers: string[] = [];\n  let profileMap: Record<string, IProfile>;\n\n  const profiler = {\n    createTimer,\n    enable,\n    disable,\n    report,\n    enabled: false\n  };\n  return profiler;\n\n  function createTimer(name: string): ITimer {\n    timers.push(name);\n    let depth = 0;\n    let mark = 0;\n\n    return {\n      enter,\n      leave\n    };\n\n    function enter(): void {\n      if (++depth === 1) {\n        mark = now();\n        ++profileMap[name].topLevelCount;\n      }\n      ++profileMap[name].totalCount;\n    }\n    function leave(): void {\n      if (--depth === 0) {\n        profileMap[name].duration += (now() - mark);\n      }\n    }\n  }\n\n  function enable(): void {\n    profileMap = {};\n    for (const timer of timers) {\n      profileMap[timer] = {\n        name: timer,\n        duration: 0,\n        topLevelCount: 0,\n        totalCount: 0\n      };\n    }\n    profiler.enabled = true;\n  }\n\n  function disable(): void {\n    profiler.enabled = false;\n  }\n\n  function report(cb: (name: string, duration: number, topLevelCount: number, totalCount: number) => void): void {\n    Object.keys(profileMap).map(key => profileMap[key]).sort((a, b) => b.duration - a.duration).forEach(p => {\n      cb(p.name, p.duration, p.topLevelCount, p.totalCount);\n    });\n  }\n})();\n","import { IContainer, IRegistry, IResolver } from './di';\nimport { Class, Constructable, Immutable } from './interfaces';\n\nexport interface IResourceDefinition {\n  name: string;\n}\n\nexport interface IResourceKind<TDef, TProto, TClass extends Class<TProto, unknown> = Class<TProto>> {\n  readonly name: string;\n  keyFrom(name: string): string;\n  isType<T>(Type: T & Partial<IResourceType<TDef, TProto>>): Type is T & TClass & IResourceType<TDef, TProto>;\n\n  define<T extends Constructable>(name: string, ctor: T): T & TClass & IResourceType<TDef, TProto>;\n  define<T extends Constructable>(definition: TDef, ctor: T): T & TClass & IResourceType<TDef, TProto>;\n  define<T extends Constructable>(nameOrDefinition: string | TDef, ctor: T): T & TClass & IResourceType<TDef, TProto>;\n}\n\nexport type ResourceDescription<TDef> = Immutable<Required<TDef>>;\n\nexport type ResourcePartDescription<TDef> = Immutable<TDef>;\n\nexport interface IResourceType<TDef, TProto, TClass extends Class<TProto, unknown> = Class<TProto>> extends Class<TProto, unknown>, IRegistry {\n  readonly kind: IResourceKind<TDef, TProto, TClass>;\n  readonly description: ResourceDescription<TDef>;\n}\n\nexport interface IResourceDescriptions {\n  find<TDef, TProto>(kind: IResourceKind<TDef, TProto>, name: string): ResourceDescription<TDef> | null;\n  create<TDef, TProto>(kind: IResourceKind<TDef, TProto>, name: string): TProto | null;\n}\n\nexport class RuntimeCompilationResources implements IResourceDescriptions {\n  private readonly context: IContainer;\n\n  constructor(context: IContainer) {\n    this.context = context;\n  }\n\n  public find<TDef, TProto>(kind: IResourceKind<TDef, TProto>, name: string): ResourceDescription<TDef> | null {\n    const key = kind.keyFrom(name);\n    const resourceLookup = (this.context as unknown as { resourceLookup: Record<string, IResolver> }).resourceLookup;\n    let resolver = resourceLookup[key];\n    if (resolver === undefined) {\n      resolver = resourceLookup[key] = this.context.getResolver(key, false);\n    }\n\n    if (resolver !== null && resolver.getFactory) {\n      const factory = resolver.getFactory(this.context);\n\n      if (factory !== null) {\n        const description = (factory.Type as IResourceType<TDef, TProto>).description;\n        return description === undefined ? null : description;\n      }\n    }\n\n    return null;\n  }\n\n  public create<TDef, TProto>(kind: IResourceKind<TDef, TProto>, name: string): TProto | null {\n    const key = kind.keyFrom(name);\n    const resourceLookup = (this.context as unknown as { resourceLookup: Record<string, IResolver> }).resourceLookup;\n    let resolver = resourceLookup[key];\n    if (resolver === undefined) {\n      resolver = resourceLookup[key] = this.context.getResolver(key, false);\n    }\n    if (resolver !== null) {\n      const instance = resolver.resolve(this.context, this.context);\n      return instance === undefined ? null : instance;\n    }\n    return null;\n  }\n}\n"],"names":[],"mappings":"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"}