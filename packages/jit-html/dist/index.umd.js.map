{"version":3,"file":"index.umd.js","sources":["../../../node_modules/tslib/tslib.es6.js","../src/binding-command.ts","../src/template-binder.ts","../src/template-element-factory.ts","../src/template-compiler.ts","../src/configuration.ts","../src/debugging.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import {\n  bindingCommand,\n  BindingSymbol,\n  getTarget,\n  IBindingCommand,\n  PlainAttributeSymbol\n} from '@aurelia/jit';\nimport { IRegistry } from '@aurelia/kernel';\nimport { BindingType, IsBindingBehavior } from '@aurelia/runtime';\nimport {\n  CaptureBindingInstruction,\n  DelegateBindingInstruction,\n  HTMLAttributeInstruction,\n  TriggerBindingInstruction\n} from '@aurelia/runtime-html';\n\nexport interface TriggerBindingCommand extends IBindingCommand {}\n\n@bindingCommand('trigger')\nexport class TriggerBindingCommand implements IBindingCommand {\n  public static register: IRegistry['register'];\n  public bindingType: BindingType.TriggerCommand;\n\n  constructor() {\n    this.bindingType = BindingType.TriggerCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): HTMLAttributeInstruction {\n    return new TriggerBindingInstruction(binding.expression as IsBindingBehavior, getTarget(binding, false));\n  }\n}\n\nexport interface DelegateBindingCommand extends IBindingCommand {}\n\n@bindingCommand('delegate')\nexport class DelegateBindingCommand implements IBindingCommand {\n  public static register: IRegistry['register'];\n  public bindingType: BindingType.DelegateCommand;\n\n  constructor() {\n    this.bindingType = BindingType.DelegateCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): HTMLAttributeInstruction {\n    return new DelegateBindingInstruction(binding.expression as IsBindingBehavior, getTarget(binding, false));\n  }\n}\n\nexport interface CaptureBindingCommand extends IBindingCommand {}\n\n@bindingCommand('capture')\nexport class CaptureBindingCommand implements IBindingCommand {\n  public static register: IRegistry['register'];\n  public bindingType: BindingType.CaptureCommand;\n\n  constructor() {\n    this.bindingType = BindingType.CaptureCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): HTMLAttributeInstruction {\n    return new CaptureBindingInstruction(binding.expression as IsBindingBehavior, getTarget(binding, false));\n  }\n}\n","import {\n  AttrInfo,\n  AttrSyntax,\n  BindableInfo,\n  BindingSymbol,\n  CustomAttributeSymbol,\n  CustomElementSymbol,\n  IAttributeParser,\n  IElementSymbol,\n  IParentNodeSymbol,\n  IResourceAttributeSymbol,\n  ISymbolWithMarker,\n  LetElementSymbol,\n  PlainAttributeSymbol,\n  PlainElementSymbol,\n  ReplacePartSymbol,\n  ResourceModel,\n  SymbolFlags,\n  TemplateControllerSymbol,\n  TextSymbol\n} from '@aurelia/jit';\nimport { PLATFORM, Tracer } from '@aurelia/kernel';\nimport {\n  BindingMode,\n  BindingType,\n  IDOM,\n  IExpressionParser\n} from '@aurelia/runtime';\nimport { NodeType } from '@aurelia/runtime-html';\n\nconst slice = Array.prototype.slice;\n\nconst invalidSurrogateAttribute = {\n  'id': true,\n  'part': true,\n  'replace-part': true\n};\n\nconst attributesToIgnore = {\n  'as-element': true,\n  'part': true,\n  'replace-part': true\n};\n\nexport class TemplateBinder {\n  public dom: IDOM;\n  public resources: ResourceModel;\n  public attrParser: IAttributeParser;\n  public exprParser: IExpressionParser;\n\n  private surrogate: PlainElementSymbol | null;\n\n  // This is any \"original\" (as in, not a template created for a template controller) element.\n  // It collects all attribute symbols except for template controllers and replace-parts.\n  private manifest: IElementSymbol | null;\n\n  // This is the nearest wrapping custom element.\n  // It only collects replace-parts (and inherently everything that the manifest collects, if they are the same instance)\n  private manifestRoot: CustomElementSymbol | null;\n\n  // This is the nearest wrapping custom element relative to the current manifestRoot (the manifestRoot \"one level up\").\n  // It exclusively collects replace-parts that are placed on the current manifestRoot.\n  private parentManifestRoot: CustomElementSymbol | null;\n\n  private partName: string | null;\n\n  constructor(dom: IDOM, resources: ResourceModel, attrParser: IAttributeParser, exprParser: IExpressionParser) {\n    this.dom = dom;\n    this.resources = resources;\n    this.attrParser = attrParser;\n    this.exprParser = exprParser;\n    this.surrogate = null;\n    this.manifest = null;\n    this.manifestRoot = null;\n    this.parentManifestRoot = null;\n    this.partName = null;\n  }\n\n  public bind(node: HTMLTemplateElement): PlainElementSymbol {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bind', slice.call(arguments)); }\n\n    const surrogateSave = this.surrogate;\n    const parentManifestRootSave = this.parentManifestRoot;\n    const manifestRootSave = this.manifestRoot;\n    const manifestSave = this.manifest;\n\n    const manifest = this.surrogate = this.manifest = new PlainElementSymbol(node);\n\n    const attributes = node.attributes;\n    let i = 0;\n    while (i < attributes.length) {\n      const attr = attributes[i];\n      const attrSyntax = this.attrParser.parse(attr.name, attr.value);\n\n      if (invalidSurrogateAttribute[attrSyntax.target] === true) {\n        throw new Error(`Invalid surrogate attribute: ${attrSyntax.target}`);\n        // TODO: use reporter\n      }\n      const attrInfo = this.resources.getAttributeInfo(attrSyntax);\n      if (attrInfo === null) {\n        this.bindPlainAttribute(attrSyntax);\n      } else if (attrInfo.isTemplateController) {\n        throw new Error('Cannot have template controller on surrogate element.');\n        // TODO: use reporter\n      } else {\n        this.bindCustomAttribute(attrSyntax, attrInfo);\n      }\n      ++i;\n    }\n\n    this.bindChildNodes(node);\n\n    this.surrogate = surrogateSave;\n    this.parentManifestRoot = parentManifestRootSave;\n    this.manifestRoot = manifestRootSave;\n    this.manifest = manifestSave;\n\n    if (Tracer.enabled) { Tracer.leave(); }\n    return manifest;\n  }\n\n  private bindManifest(parentManifest: IElementSymbol, node: HTMLTemplateElement | HTMLElement): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindManifest', slice.call(arguments)); }\n\n    switch (node.nodeName) {\n      case 'LET':\n        // let cannot have children and has some different processing rules, so return early\n        this.bindLetElement(parentManifest, node);\n        if (Tracer.enabled) { Tracer.leave(); }\n        return;\n      case 'SLOT':\n        // slot requires no compilation\n        this.surrogate.hasSlots = true;\n        if (Tracer.enabled) { Tracer.leave(); }\n        return;\n    }\n\n    // nodes are processed bottom-up so we need to store the manifests before traversing down and\n    // restore them again afterwards\n    const parentManifestRootSave = this.parentManifestRoot;\n    const manifestRootSave = this.manifestRoot;\n    const manifestSave = this.manifest;\n\n    // get the part name to override the name of the compiled definition\n    this.partName = node.getAttribute('part');\n\n    let manifestRoot: CustomElementSymbol;\n    let name = node.getAttribute('as-element');\n    if (name === null) {\n      name = node.nodeName.toLowerCase();\n    }\n    const elementInfo = this.resources.getElementInfo(name);\n    if (elementInfo === null) {\n      // there is no registered custom element with this name\n      this.manifest = new PlainElementSymbol(node);\n    } else {\n      // it's a custom element so we set the manifestRoot as well (for storing replace-parts)\n      this.parentManifestRoot = this.manifestRoot;\n      manifestRoot = this.manifestRoot = this.manifest = new CustomElementSymbol(this.dom, node, elementInfo);\n    }\n\n    // lifting operations done by template controllers and replace-parts effectively unlink the nodes, so start at the bottom\n    this.bindChildNodes(node);\n\n    // the parentManifest will receive either the direct child nodes, or the template controllers / replace-parts\n    // wrapping them\n    this.bindAttributes(node, parentManifest);\n\n    if (manifestRoot !== undefined && manifestRoot.isContainerless) {\n      node.parentNode.replaceChild(manifestRoot.marker as Node, node);\n    } else if (this.manifest.isTarget) {\n      node.classList.add('au');\n    }\n\n    // restore the stored manifests so the attributes are processed on the correct lavel\n    this.parentManifestRoot = parentManifestRootSave;\n    this.manifestRoot = manifestRootSave;\n    this.manifest = manifestSave;\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private bindLetElement(parentManifest: IElementSymbol, node: HTMLElement): void {\n    const symbol = new LetElementSymbol(this.dom, node);\n    parentManifest.childNodes.push(symbol);\n\n    const attributes = node.attributes;\n    let i = 0;\n    while (i < attributes.length) {\n      const attr = attributes[i];\n      if (attr.name === 'to-view-model') {\n        node.removeAttribute('to-view-model');\n        symbol.toViewModel = true;\n        continue;\n      }\n      const attrSyntax = this.attrParser.parse(attr.name, attr.value);\n      const command = this.resources.getBindingCommand(attrSyntax);\n      const bindingType = command === null ? BindingType.Interpolation : command.bindingType;\n      const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);\n      const to = PLATFORM.camelCase(attrSyntax.target);\n      const info = new BindableInfo(to, BindingMode.toView);\n      symbol.bindings.push(new BindingSymbol(command, info, expr, attrSyntax.rawValue, to));\n\n      ++i;\n    }\n    node.parentNode.replaceChild(symbol.marker as Node, node);\n  }\n\n  private bindAttributes(node: HTMLTemplateElement | HTMLElement, parentManifest: IElementSymbol): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindAttributes', slice.call(arguments)); }\n\n    const { parentManifestRoot, manifestRoot, manifest } = this;\n    // This is the top-level symbol for the current depth.\n    // If there are no template controllers or replace-parts, it is always the manifest itself.\n    // If there are template controllers, then this will be the outer-most TemplateControllerSymbol.\n    let manifestProxy = manifest as IParentNodeSymbol;\n\n    const replacePart = this.declareReplacePart(node);\n\n    let previousController: TemplateControllerSymbol;\n    let currentController: TemplateControllerSymbol;\n\n    const attributes = node.attributes;\n    let i = 0;\n    while (i < attributes.length) {\n      const attr = attributes[i];\n      ++i;\n      if (attributesToIgnore[attr.name] === true) {\n        continue;\n      }\n      const attrSyntax = this.attrParser.parse(attr.name, attr.value);\n      const attrInfo = this.resources.getAttributeInfo(attrSyntax);\n\n      if (attrInfo === null) {\n        // it's not a custom attribute but might be a regular bound attribute or interpolation (it might also be nothing)\n        this.bindPlainAttribute(attrSyntax);\n      } else if (attrInfo.isTemplateController) {\n        // the manifest is wrapped by the inner-most template controller (if there are multiple on the same element)\n        // so keep setting manifest.templateController to the latest template controller we find\n        currentController = manifest.templateController = this.declareTemplateController(attrSyntax, attrInfo);\n\n        // the proxy and the manifest are only identical when we're at the first template controller (since the controller\n        // is assigned to the proxy), so this evaluates to true at most once per node\n        if (manifestProxy === manifest) {\n          currentController.template = manifest;\n          manifestProxy = currentController;\n        } else {\n          currentController.templateController = previousController;\n          currentController.template = previousController.template;\n          previousController.template = currentController;\n        }\n        previousController = currentController;\n      } else {\n        // a regular custom attribute\n        this.bindCustomAttribute(attrSyntax, attrInfo);\n      }\n    }\n\n    processTemplateControllers(this.dom, manifestProxy, manifest);\n\n    if (replacePart === null) {\n      // the proxy is either the manifest itself or the outer-most controller; add it directly to the parent\n      parentManifest.childNodes.push(manifestProxy);\n    } else {\n      // there is a replace-part attribute on this node, so add it to the parts collection of the manifestRoot\n      // instead of to the childNodes\n      replacePart.parent = parentManifest;\n      replacePart.template = manifestProxy;\n\n      // if the current manifest is also the manifestRoot, it means the replace-part sits on a custom\n      // element, so add the part to the parent wrapping custom element instead\n      const partOwner = manifest === manifestRoot ? parentManifestRoot : manifestRoot;\n      partOwner.parts.push(replacePart);\n\n      processReplacePart(this.dom, replacePart, manifestProxy);\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private bindChildNodes(node: HTMLTemplateElement | HTMLElement): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindChildNodes', slice.call(arguments)); }\n\n    let childNode: ChildNode;\n    if (node.nodeName === 'TEMPLATE') {\n      childNode = (node as HTMLTemplateElement).content.firstChild;\n    } else {\n      childNode = node.firstChild;\n    }\n\n    let nextChild: ChildNode;\n    while (childNode !== null) {\n      switch (childNode.nodeType) {\n        case NodeType.Element:\n          nextChild = childNode.nextSibling as ChildNode;\n          this.bindManifest(this.manifest, childNode as HTMLElement);\n          childNode = nextChild;\n          break;\n        case NodeType.Text:\n          childNode = this.bindText(childNode as Text).nextSibling as ChildNode;\n          break;\n        case NodeType.CDATASection:\n        case NodeType.ProcessingInstruction:\n        case NodeType.Comment:\n        case NodeType.DocumentType:\n          childNode = childNode.nextSibling as ChildNode;\n          break;\n        case NodeType.Document:\n        case NodeType.DocumentFragment:\n          childNode = childNode.firstChild;\n      }\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private bindText(node: Text): ChildNode {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindText', slice.call(arguments)); }\n    const interpolation = this.exprParser.parse(node.wholeText, BindingType.Interpolation);\n    if (interpolation !== null) {\n      const symbol = new TextSymbol(this.dom, node, interpolation);\n      this.manifest.childNodes.push(symbol);\n      processInterpolationText(symbol);\n    }\n    while (node.nextSibling !== null && node.nextSibling.nodeType === NodeType.Text) {\n      node = node.nextSibling as Text;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return node;\n  }\n\n  private declareTemplateController(attrSyntax: AttrSyntax, attrInfo: AttrInfo): TemplateControllerSymbol {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.declareTemplateController', slice.call(arguments)); }\n\n    let symbol: TemplateControllerSymbol;\n    // dynamicOptions logic here is similar to (and explained in) bindCustomAttribute\n    const command = this.resources.getBindingCommand(attrSyntax);\n    if (command === null && attrInfo.hasDynamicOptions) {\n      symbol = new TemplateControllerSymbol(this.dom, attrSyntax, attrInfo, this.partName);\n      this.partName = null;\n      this.bindMultiAttribute(symbol, attrInfo, attrSyntax.rawValue);\n    } else {\n      symbol = new TemplateControllerSymbol(this.dom, attrSyntax, attrInfo, this.partName);\n      const bindingType = command === null ? BindingType.Interpolation : command.bindingType;\n      const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);\n      symbol.bindings.push(new BindingSymbol(command, attrInfo.bindable, expr, attrSyntax.rawValue, attrSyntax.target));\n      this.partName = null;\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n    return symbol;\n  }\n\n  private bindCustomAttribute(attrSyntax: AttrSyntax, attrInfo: AttrInfo): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindCustomAttribute', slice.call(arguments)); }\n\n    const command = this.resources.getBindingCommand(attrSyntax);\n    let symbol: CustomAttributeSymbol;\n    if (command === null && attrInfo.hasDynamicOptions) {\n      // a dynamicOptions (semicolon separated binding) is only valid without a binding command;\n      // the binding commands must be declared in the dynamicOptions expression itself\n      symbol = new CustomAttributeSymbol(attrSyntax, attrInfo);\n      this.bindMultiAttribute(symbol, attrInfo, attrSyntax.rawValue);\n    } else {\n      // we've either got a command (with or without dynamicOptions, the latter maps to the first bindable),\n      // or a null command but without dynamicOptions (which may be an interpolation or a normal string)\n      symbol = new CustomAttributeSymbol(attrSyntax, attrInfo);\n      const bindingType = command === null ? BindingType.Interpolation : command.bindingType;\n      const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);\n      symbol.bindings.push(new BindingSymbol(command, attrInfo.bindable, expr, attrSyntax.rawValue, attrSyntax.target));\n    }\n    this.manifest.attributes.push(symbol);\n    this.manifest.isTarget = true;\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private bindMultiAttribute(symbol: IResourceAttributeSymbol, attrInfo: AttrInfo, value: string): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindMultiAttribute', slice.call(arguments)); }\n\n    const attributes = parseMultiAttributeBinding(value);\n    let attr: IAttrLike;\n    for (let i = 0, ii = attributes.length; i < ii; ++i) {\n      attr = attributes[i];\n      const attrSyntax = this.attrParser.parse(attr.name, attr.value);\n      const command = this.resources.getBindingCommand(attrSyntax);\n      const bindingType = command === null ? BindingType.Interpolation : command.bindingType;\n      const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);\n      let bindable = attrInfo.bindables[attrSyntax.target];\n      if (bindable === undefined) {\n        // everything in a dynamicOptions expression must be used, so if it's not a bindable then we create one on the spot\n        bindable = attrInfo.bindables[attrSyntax.target] = new BindableInfo(attrSyntax.target, BindingMode.toView);\n      }\n\n      symbol.bindings.push(new BindingSymbol(command, bindable, expr, attrSyntax.rawValue, attrSyntax.target));\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private bindPlainAttribute(attrSyntax: AttrSyntax): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindPlainAttribute', slice.call(arguments)); }\n\n    if (attrSyntax.rawValue.length === 0) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n\n    const command = this.resources.getBindingCommand(attrSyntax);\n    const bindingType = command === null ? BindingType.Interpolation : command.bindingType;\n    const manifest = this.manifest;\n    const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);\n\n    if (manifest.flags & SymbolFlags.isCustomElement) {\n      const bindable = (manifest as CustomElementSymbol).bindables[attrSyntax.target];\n      if (bindable !== undefined) {\n        // if the attribute name matches a bindable property name, add it regardless of whether it's a command, interpolation, or just a plain string;\n        // the template compiler will translate it to the correct instruction\n        (manifest as CustomElementSymbol).bindings.push(new BindingSymbol(command, bindable, expr, attrSyntax.rawValue, attrSyntax.target));\n        manifest.isTarget = true;\n      } else if (expr !== null) {\n        // if it does not map to a bindable, only add it if we were able to parse an expression (either a command or interpolation)\n        manifest.attributes.push(new PlainAttributeSymbol(attrSyntax, command, expr));\n        manifest.isTarget = true;\n      }\n    } else if (expr !== null || attrSyntax.target === 'ref') {\n      // either a binding command, an interpolation, or a ref\n      manifest.attributes.push(new PlainAttributeSymbol(attrSyntax, command, expr));\n      manifest.isTarget = true;\n    } else if (manifest === this.surrogate) {\n      // any attributes, even if they are plain (no command/interpolation etc), should be added if they\n      // are on the surrogate element\n      manifest.attributes.push(new PlainAttributeSymbol(attrSyntax, command, expr));\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private declareReplacePart(node: HTMLTemplateElement | HTMLElement): ReplacePartSymbol {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.declareReplacePart', slice.call(arguments)); }\n\n    const name = node.getAttribute('replace-part');\n    if (name === null) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return null;\n    }\n    node.removeAttribute('replace-part');\n\n    const symbol = new ReplacePartSymbol(name);\n\n    if (Tracer.enabled) { Tracer.leave(); }\n    return symbol;\n  }\n}\n\nfunction processInterpolationText(symbol: TextSymbol): void {\n  const node = symbol.physicalNode as Text;\n  const parentNode = node.parentNode;\n  while (node.nextSibling !== null && node.nextSibling.nodeType === NodeType.Text) {\n    parentNode.removeChild(node.nextSibling);\n  }\n  node.textContent = '';\n  parentNode.insertBefore(symbol.marker as Node, node);\n}\n\n/**\n * A (temporary) standalone function that purely does the DOM processing (lifting) related to template controllers.\n * It's a first refactoring step towards separating DOM parsing/binding from mutations.\n */\nfunction processTemplateControllers(dom: IDOM, manifestProxy: IParentNodeSymbol, manifest: IElementSymbol): void {\n  const manifestNode = manifest.physicalNode as HTMLElement;\n  let current = manifestProxy as TemplateControllerSymbol;\n  let currentTemplate: HTMLTemplateElement;\n  while ((current as IParentNodeSymbol) !== manifest) {\n    if (current.template === manifest) {\n      // the DOM linkage is still in its original state here so we can safely assume the parentNode is non-null\n      manifestNode.parentNode.replaceChild(current.marker as Node, manifestNode);\n\n      // if the manifest is a template element (e.g. <template repeat.for=\"...\">) then we can skip one lift operation\n      // and simply use the template directly, saving a bit of work\n      if (manifestNode.nodeName === 'TEMPLATE') {\n        current.physicalNode = manifestNode as HTMLTemplateElement;\n        // the template could safely stay without affecting anything visible, but let's keep the DOM tidy\n        manifestNode.remove();\n      } else {\n        // the manifest is not a template element so we need to wrap it in one\n        currentTemplate = current.physicalNode = dom.createTemplate() as HTMLTemplateElement;\n        currentTemplate.content.appendChild(manifestNode);\n      }\n    } else {\n      currentTemplate = current.physicalNode = dom.createTemplate() as HTMLTemplateElement;\n      currentTemplate.content.appendChild(current.marker as Node);\n    }\n    manifestNode.removeAttribute(current.syntax.rawName);\n    current = current.template as TemplateControllerSymbol;\n  }\n}\n\nfunction processReplacePart(dom: IDOM, replacePart: ReplacePartSymbol, manifestProxy: IParentNodeSymbol | ISymbolWithMarker): void {\n    let proxyNode: HTMLElement;\n    let currentTemplate: HTMLTemplateElement;\n    if (manifestProxy.flags & SymbolFlags.hasMarker) {\n      proxyNode = (manifestProxy as ISymbolWithMarker).marker as HTMLElement;\n    } else {\n      proxyNode = manifestProxy.physicalNode as HTMLElement;\n    }\n    if (proxyNode.nodeName === 'TEMPLATE') {\n      // if it's a template element, no need to do anything special, just assign it to the replacePart\n      replacePart.physicalNode = proxyNode as HTMLTemplateElement;\n    } else {\n      // otherwise wrap the replace-part in a template\n      currentTemplate = replacePart.physicalNode = dom.createTemplate() as HTMLTemplateElement;\n      currentTemplate.content.appendChild(proxyNode);\n    }\n}\n\ninterface IAttrLike {\n  name: string;\n  value: string;\n}\n\nclass ParserState {\n  public input: string;\n  public index: number;\n  public length: number;\n\n  constructor(input: string) {\n    this.input = input;\n    this.index = 0;\n    this.length = input.length;\n  }\n}\n\nconst fromCharCode = String.fromCharCode;\n\n// TODO: move to expression parser\nfunction parseMultiAttributeBinding(input: string): IAttrLike[] {\n  const attributes: IAttrLike[] = [];\n\n  const state = new ParserState(input);\n  const length = state.length;\n  let name: string;\n  let value: string;\n\n  while (state.index < length) {\n    name = scanAttributeName(state);\n    if (name.length === 0) {\n      return attributes;\n    }\n    value = scanAttributeValue(state);\n    attributes.push({ name, value });\n  }\n\n  return attributes;\n}\n\nfunction scanAttributeName(state: ParserState): string {\n  const start = state.index;\n  const { length, input } = state;\n  while (state.index < length && input.charCodeAt(++state.index) !== Char.Colon);\n\n  return input.slice(start, state.index).trim();\n}\n\nconst enum Char {\n  DoubleQuote    = 0x22,\n  SingleQuote    = 0x27,\n  Slash          = 0x2F,\n  Semicolon      = 0x3B,\n  Colon          = 0x3A\n}\n\nfunction scanAttributeValue(state: ParserState): string {\n  ++state.index;\n  const { length, input } = state;\n  let token = '';\n  let inString = false;\n  let quote = null;\n  let ch = 0;\n  while (state.index < length) {\n    ch = input.charCodeAt(state.index);\n    switch (ch) {\n      case Char.Semicolon:\n        ++state.index;\n        return token.trim();\n      case Char.Slash:\n        ch = input.charCodeAt(++state.index);\n        if (ch === Char.DoubleQuote) {\n          if (inString === false) {\n            inString = true;\n            quote = Char.DoubleQuote;\n          } else if (quote === Char.DoubleQuote) {\n            inString = false;\n            quote = null;\n          }\n        }\n        token += `\\\\${fromCharCode(ch)}`;\n        break;\n      case Char.SingleQuote:\n        if (inString === false) {\n          inString = true;\n          quote = Char.SingleQuote;\n        } else if (quote === Char.SingleQuote) {\n          inString = false;\n          quote = null;\n        }\n        token += '\\'';\n        break;\n      default:\n        token += fromCharCode(ch);\n    }\n    ++state.index;\n  }\n\n  return token.trim();\n}\n","import { DI, inject, InterfaceSymbol } from '@aurelia/kernel';\nimport { IDOM, INode } from '@aurelia/runtime';\n\n/**\n * Utility that creates a `HTMLTemplateElement` out of string markup or an existing DOM node.\n *\n * It is idempotent in the sense that passing in an existing template element will simply return that template element,\n * so it is always safe to pass in a node without causing unnecessary DOM parsing or template creation.\n */\nexport interface ITemplateElementFactory {\n  /**\n   * Create a `HTMLTemplateElement` from a provided html string.\n   *\n   * @param markup A raw html string that may or may not be wrapped in `<template></template>`\n   */\n  createTemplate(markup: string): INode;\n  /**\n   * Create a `HTMLTemplateElement` from a provided DOM node. If the node is already a template, it\n   * will be returned as-is (and removed from the DOM).\n   *\n   * @param node A DOM node that may or may not be wrapped in `<template></template>`\n   */\n  createTemplate(node: INode): INode;\n  /**\n   * Create a `HTMLTemplateElement` from a provided DOM node or html string.\n   *\n   * @param input A DOM node or raw html string that may or may not be wrapped in `<template></template>`\n   */\n  createTemplate(input: unknown): INode;\n  createTemplate(input: unknown): INode;\n}\n\n// For some reason rollup complains about `DI.createInterface<ITemplateElementFactory>().noDefault()` with this message:\n// \"semantic error TS2742 The inferred type of 'ITemplateElementFactory' cannot be named without a reference to '@aurelia/jit/node_modules/@aurelia/kernel'. This is likely not portable. A type annotation is necessary\"\n// So.. investigate why that happens (or rather, why it *only* happens here and not for the other 50)\nexport const ITemplateElementFactory: InterfaceSymbol<ITemplateElementFactory> = DI.createInterface().noDefault();\n\n/**\n * Default implementation for `ITemplateFactory` for use in an HTML based runtime.\n *\n * @internal\n */\n@inject(IDOM)\nexport class HTMLTemplateElementFactory implements ITemplateElementFactory {\n  private dom: IDOM;\n  private template: HTMLTemplateElement;\n\n  constructor(dom: IDOM) {\n    this.dom = dom;\n    this.template = dom.createTemplate() as HTMLTemplateElement;\n  }\n\n  public createTemplate(markup: string): HTMLTemplateElement;\n  public createTemplate(node: Node): HTMLTemplateElement;\n  public createTemplate(input: unknown): HTMLTemplateElement;\n  public createTemplate(input: string | Node): HTMLTemplateElement {\n    if (typeof input === 'string') {\n      const template = this.template;\n      template.innerHTML = input;\n      const node = template.content.firstElementChild;\n      // if the input is either not wrapped in a template or there is more than one node,\n      // return the whole template that wraps it/them (and create a new one for the next input)\n      if (node === null || node.nodeName !== 'TEMPLATE' || node.nextElementSibling !== null) {\n        this.template = this.dom.createTemplate() as HTMLTemplateElement;\n        return template;\n      }\n      // the node to return is both a template and the only node, so return just the node\n      // and clean up the template for the next input\n      template.content.removeChild(node);\n      return node as HTMLTemplateElement;\n    }\n    if (input.nodeName !== 'TEMPLATE') {\n      // if we get one node that is not a template, wrap it in one\n      const template = this.dom.createTemplate() as HTMLTemplateElement;\n      template.content.appendChild(input);\n      return template;\n    }\n    // we got a template element, remove it from the DOM if it's present there and don't\n    // do any other processing\n    if (input.parentNode !== null) {\n      input.parentNode.removeChild(input);\n    }\n    return input as HTMLTemplateElement;\n  }\n}\n","import {\n  BindingSymbol,\n  CustomAttributeSymbol,\n  CustomElementSymbol,\n  IAttributeParser,\n  IAttributeSymbol,\n  IElementSymbol,\n  INodeSymbol,\n  IParentNodeSymbol,\n  ISymbolWithBindings,\n  LetElementSymbol,\n  PlainAttributeSymbol,\n  PlainElementSymbol,\n  ReplacePartSymbol,\n  ResourceModel,\n  SymbolFlags,\n  TemplateControllerSymbol,\n  TextSymbol\n} from '@aurelia/jit';\nimport { inject, IResourceDescriptions, PLATFORM } from '@aurelia/kernel';\nimport {\n  HydrateAttributeInstruction,\n  HydrateElementInstruction,\n  HydrateTemplateController,\n  IBuildInstruction,\n  IDOM,\n  IExpressionParser,\n  ILetBindingInstruction,\n  Interpolation,\n  InterpolationInstruction,\n  IsBindingBehavior,\n  ITargetedInstruction,\n  ITemplateCompiler,\n  ITemplateDefinition,\n  LetBindingInstruction,\n  LetElementInstruction,\n  RefBindingInstruction,\n  SetPropertyInstruction,\n  TemplateDefinition\n} from '@aurelia/runtime';\nimport {\n  HTMLAttributeInstruction,\n  HTMLInstructionRow,\n  SetAttributeInstruction,\n  TextBindingInstruction\n} from '@aurelia/runtime-html';\nimport { TemplateBinder } from './template-binder';\nimport { ITemplateElementFactory } from './template-element-factory';\n\nconst buildNotRequired: IBuildInstruction = Object.freeze({\n  required: false,\n  compiler: 'default'\n});\n\n/**\n * Default (runtime-agnostic) implementation for `ITemplateCompiler`.\n *\n * @internal\n */\n@inject(ITemplateElementFactory, IAttributeParser, IExpressionParser)\nexport class TemplateCompiler implements ITemplateCompiler {\n  private factory: ITemplateElementFactory;\n  private attrParser: IAttributeParser;\n  private exprParser: IExpressionParser;\n\n  /**\n   * The instructions array for the currently instruction-collecting `ITemplateDefinition`\n   */\n  private instructionRows: HTMLInstructionRow[];\n\n  public get name(): string {\n    return 'default';\n  }\n\n  constructor(factory: ITemplateElementFactory, attrParser: IAttributeParser, exprParser: IExpressionParser) {\n    this.factory = factory;\n    this.attrParser = attrParser;\n    this.exprParser = exprParser;\n    this.instructionRows = null;\n  }\n\n  public compile(dom: IDOM, definition: ITemplateDefinition, descriptions: IResourceDescriptions): TemplateDefinition {\n    const binder = new TemplateBinder(dom, new ResourceModel(descriptions), this.attrParser, this.exprParser);\n    const template = definition.template = this.factory.createTemplate(definition.template) as HTMLTemplateElement;\n    const surrogate = binder.bind(template);\n    if (definition.instructions === undefined || definition.instructions === PLATFORM.emptyArray) {\n      definition.instructions = [];\n    }\n    if (surrogate.hasSlots === true) {\n      definition.hasSlots = true;\n    }\n\n    this.instructionRows = definition.instructions as HTMLInstructionRow[];\n\n    const attributes = surrogate.attributes;\n    const len = attributes.length;\n    if (len > 0) {\n      let surrogates: ITargetedInstruction[];\n      if (definition.surrogates === undefined || definition.surrogates === PLATFORM.emptyArray) {\n        definition.surrogates = Array(len);\n      }\n      surrogates = definition.surrogates;\n      for (let i = 0; i < len; ++i) {\n        surrogates[i] = this.compileAttribute(attributes[i]);\n      }\n    }\n\n    this.compileChildNodes(surrogate);\n\n    this.instructionRows = null;\n\n    return definition as TemplateDefinition;\n  }\n\n  private compileChildNodes(parent: IElementSymbol): void {\n    if (parent.flags & SymbolFlags.hasChildNodes) {\n      const { childNodes } = parent;\n      let childNode: INodeSymbol;\n      const ii = childNodes.length;\n      for (let i = 0; i < ii; ++i) {\n        childNode = childNodes[i];\n        if (childNode.flags & SymbolFlags.isText) {\n          this.instructionRows.push([new TextBindingInstruction((childNode as TextSymbol).interpolation)]);\n        } else if (childNode.flags & SymbolFlags.isLetElement) {\n          const bindings = (childNode as LetElementSymbol).bindings;\n          const instructions: ILetBindingInstruction[] = [];\n          let binding: BindingSymbol;\n          const jj = bindings.length;\n          for (let j = 0; j < jj; ++j) {\n            binding = bindings[j];\n            instructions[j] = new LetBindingInstruction(binding.expression as IsBindingBehavior, binding.target);\n          }\n          this.instructionRows.push([new LetElementInstruction(instructions, (childNode as LetElementSymbol).toViewModel)]);\n        } else {\n          this.compileParentNode(childNode as IParentNodeSymbol);\n        }\n      }\n    }\n  }\n\n  private compileCustomElement(symbol: CustomElementSymbol): void {\n    // offset 1 to leave a spot for the hydrate instruction so we don't need to create 2 arrays with a spread etc\n    const instructionRow = this.compileAttributes(symbol, 1) as HTMLInstructionRow;\n    instructionRow[0] = new HydrateElementInstruction(\n      symbol.res,\n      this.compileBindings(symbol),\n      this.compileParts(symbol)\n    );\n\n    this.instructionRows.push(instructionRow);\n  }\n\n  private compilePlainElement(symbol: PlainElementSymbol): void {\n    const attributes = this.compileAttributes(symbol, 0);\n    if (attributes.length > 0) {\n      this.instructionRows.push(attributes as HTMLInstructionRow);\n    }\n    this.compileChildNodes(symbol);\n  }\n\n  private compileParentNode(symbol: IParentNodeSymbol): void {\n    switch (symbol.flags & SymbolFlags.type) {\n      case SymbolFlags.isCustomElement:\n        this.compileCustomElement(symbol as CustomElementSymbol);\n        break;\n      case SymbolFlags.isPlainElement:\n        this.compilePlainElement(symbol as PlainElementSymbol);\n        break;\n      case SymbolFlags.isTemplateController:\n        this.compileTemplateController(symbol as TemplateControllerSymbol);\n    }\n  }\n\n  private compileTemplateController(symbol: TemplateControllerSymbol): void {\n    const bindings = this.compileBindings(symbol);\n    const instructionRowsSave = this.instructionRows;\n    const controllerInstructions = this.instructionRows = [];\n    this.compileParentNode(symbol.template);\n    this.instructionRows = instructionRowsSave;\n\n    const def = {\n      name: symbol.partName === null ? symbol.res : symbol.partName,\n      template: symbol.physicalNode,\n      instructions: controllerInstructions,\n      build: buildNotRequired\n    };\n    this.instructionRows.push([new HydrateTemplateController(def, symbol.res, bindings, symbol.res === 'else')]);\n  }\n\n  private compileBindings(symbol: ISymbolWithBindings): HTMLAttributeInstruction[] {\n    let bindingInstructions: HTMLAttributeInstruction[];\n    if (symbol.flags & SymbolFlags.hasBindings) {\n      // either a custom element with bindings, a custom attribute / template controller with dynamic options,\n      // or a single value custom attribute binding\n      const { bindings } = symbol;\n      const len = bindings.length;\n      bindingInstructions = Array(len);\n      let i = 0;\n      for (; i < len; ++i) {\n        bindingInstructions[i] = this.compileBinding(bindings[i]);\n      }\n    } else {\n      bindingInstructions = PLATFORM.emptyArray as HTMLAttributeInstruction[];\n    }\n    return bindingInstructions;\n  }\n\n  private compileBinding(symbol: BindingSymbol): HTMLAttributeInstruction {\n    if (symbol.command === null) {\n      // either an interpolation or a normal string value assigned to an element or attribute binding\n      if (symbol.expression === null) {\n        // the template binder already filtered out non-bindables, so we know we need a setProperty here\n        return new SetPropertyInstruction(symbol.rawValue, symbol.bindable.propName);\n      } else {\n        // either an element binding interpolation or a dynamic options attribute binding interpolation\n        return new InterpolationInstruction(symbol.expression as Interpolation, symbol.bindable.propName);\n      }\n    } else {\n      // either an element binding command, dynamic options attribute binding command,\n      // or custom attribute / template controller (single value) binding command\n      return symbol.command.compile(symbol) as HTMLAttributeInstruction;\n    }\n  }\n\n  private compileAttributes(symbol: IElementSymbol, offset: number): HTMLAttributeInstruction[] {\n    let attributeInstructions: HTMLAttributeInstruction[];\n    if (symbol.flags & SymbolFlags.hasAttributes) {\n      // any attributes on a custom element (which are not bindables) or a plain element\n      const { attributes } = symbol;\n      const len = attributes.length;\n      attributeInstructions = Array(offset + len);\n      for (let i = 0; i < len; ++i) {\n        attributeInstructions[i + offset] = this.compileAttribute(attributes[i]);\n      }\n    } else if (offset > 0) {\n      attributeInstructions = Array(offset);\n    } else {\n      attributeInstructions = PLATFORM.emptyArray as HTMLAttributeInstruction[];\n    }\n    return attributeInstructions;\n  }\n\n  private compileCustomAttribute(symbol: CustomAttributeSymbol): HTMLAttributeInstruction {\n    // a normal custom attribute (not template controller)\n    const bindings = this.compileBindings(symbol);\n    return new HydrateAttributeInstruction(symbol.res, bindings);\n  }\n\n  private compilePlainAttribute(symbol: PlainAttributeSymbol): HTMLAttributeInstruction {\n    if ((symbol as PlainAttributeSymbol).command === null) {\n      if (symbol.expression === null) {\n        // a plain attribute on a surrogate\n        return new SetAttributeInstruction(symbol.syntax.rawValue, symbol.syntax.target);\n      } else {\n        // a plain attribute with an interpolation\n        return new InterpolationInstruction(symbol.expression as Interpolation, symbol.syntax.target);\n      }\n    } else {\n      // a plain attribute with a binding command\n      return symbol.command.compile(symbol) as HTMLAttributeInstruction;\n    }\n  }\n\n  private compileAttribute(symbol: IAttributeSymbol): HTMLAttributeInstruction {\n    if (symbol.syntax.target === 'ref') {\n      return new RefBindingInstruction(symbol.syntax.rawValue);\n    }\n    // any attribute on a custom element (which is not a bindable) or a plain element\n    if (symbol.flags & SymbolFlags.isCustomAttribute) {\n      return this.compileCustomAttribute(symbol as CustomAttributeSymbol);\n    } else {\n      return this.compilePlainAttribute(symbol as PlainAttributeSymbol);\n    }\n  }\n\n  private compileParts(symbol: CustomElementSymbol): Record<string, ITemplateDefinition> {\n    let parts: Record<string, ITemplateDefinition>;\n    if (symbol.flags & SymbolFlags.hasParts) {\n      parts = {};\n      const replaceParts = symbol.parts;\n      const ii = replaceParts.length;\n      let instructionRowsSave: HTMLInstructionRow[];\n      let partInstructions: HTMLInstructionRow[];\n      let replacePart: ReplacePartSymbol;\n      for (let i = 0; i < ii; ++i) {\n        replacePart = replaceParts[i];\n        instructionRowsSave = this.instructionRows;\n        partInstructions = this.instructionRows = [];\n        this.compileParentNode(replacePart.template);\n        parts[replacePart.name] = {\n          name: replacePart.name,\n          template: replacePart.physicalNode,\n          instructions: partInstructions,\n          build: buildNotRequired\n        };\n        this.instructionRows = instructionRowsSave;\n      }\n    } else {\n      parts = PLATFORM.emptyObject;\n    }\n    return parts;\n  }\n}\n","import { JitConfiguration } from '@aurelia/jit';\nimport { DI, IContainer, IRegistry, Registration } from '@aurelia/kernel';\nimport { ITemplateCompiler } from '@aurelia/runtime';\nimport { HTMLRuntimeConfiguration } from '@aurelia/runtime-html';\nimport {\n  CaptureBindingCommand,\n  DelegateBindingCommand,\n  TriggerBindingCommand\n} from './binding-command';\nimport { TemplateCompiler } from './template-compiler';\nimport { HTMLTemplateElementFactory, ITemplateElementFactory } from './template-element-factory';\n\nexport const HTMLBindingLanguage: IRegistry[] = [\n  TriggerBindingCommand,\n  DelegateBindingCommand,\n  CaptureBindingCommand\n];\n\nexport const HTMLJitConfiguration = {\n  register(container: IContainer): void {\n    container.register(\n      HTMLRuntimeConfiguration,\n      JitConfiguration,\n      Registration.singleton(ITemplateCompiler, TemplateCompiler),\n      Registration.singleton(ITemplateElementFactory, HTMLTemplateElementFactory),\n      ...HTMLBindingLanguage\n    );\n  },\n  createContainer(): IContainer {\n    const container = DI.createContainer();\n    container.register(HTMLJitConfiguration);\n    return container;\n  }\n};\n","import { ITemplateDefinition, TargetedInstructionType } from '@aurelia/runtime';\nimport { HTMLTargetedInstruction, HTMLTargetedInstructionType, NodeType } from '@aurelia/runtime-html';\n\nexport function stringifyDOM(node: Node, depth: number): string {\n  const indent = ' '.repeat(depth);\n  let output = indent;\n  output += `Node: ${node.nodeName}`;\n  if (node.nodeType === NodeType.Text) {\n    output += ` \"${node.textContent}\"`;\n  }\n  if (node.nodeType === NodeType.Element) {\n    let i = 0;\n    let attr;\n    const attributes = (node as HTMLElement).attributes;\n    const len = attributes.length;\n    for (; i < len; ++i) {\n      attr = attributes[i];\n      output += ` ${attr.name}=${attr.value}`;\n    }\n  }\n  output += '\\n';\n  if (node.nodeType === NodeType.Element) {\n    let i = 0;\n    let childNodes = node.childNodes;\n    let len = childNodes.length;\n    for (; i < len; ++i) {\n      output += stringifyDOM(childNodes[i], depth + 1);\n    }\n    if (node.nodeName === 'TEMPLATE') {\n      i = 0;\n      childNodes = (node as HTMLTemplateElement).content.childNodes;\n      len = childNodes.length;\n      for (; i < len; ++i) {\n        output += stringifyDOM(childNodes[i], depth + 1);\n      }\n    }\n  }\n  return output;\n}\n\nexport function stringifyInstructions(instruction: HTMLTargetedInstruction, depth: number): string {\n  const indent = ' '.repeat(depth);\n  let output = indent;\n  switch (instruction.type) {\n    case HTMLTargetedInstructionType.textBinding:\n      output += 'textBinding\\n';\n      break;\n    case TargetedInstructionType.callBinding:\n      output += 'callBinding\\n';\n      break;\n    case TargetedInstructionType.iteratorBinding:\n      output += 'iteratorBinding\\n';\n      break;\n    case HTMLTargetedInstructionType.listenerBinding:\n      output += 'listenerBinding\\n';\n      break;\n    case TargetedInstructionType.propertyBinding:\n      output += 'propertyBinding\\n';\n      break;\n    case TargetedInstructionType.refBinding:\n      output += 'refBinding\\n';\n      break;\n    case HTMLTargetedInstructionType.stylePropertyBinding:\n      output += 'stylePropertyBinding\\n';\n      break;\n    case TargetedInstructionType.setProperty:\n      output += 'setProperty\\n';\n      break;\n    case HTMLTargetedInstructionType.setAttribute:\n      output += 'setAttribute\\n';\n      break;\n    case TargetedInstructionType.interpolation:\n      output += 'interpolation\\n';\n      break;\n    case TargetedInstructionType.hydrateLetElement:\n      output += 'hydrateLetElement\\n';\n      instruction.instructions.forEach(i => {\n        output += stringifyInstructions(i, depth + 1);\n      });\n      break;\n    case TargetedInstructionType.hydrateAttribute:\n      output += `hydrateAttribute: ${instruction.res}\\n`;\n      instruction.instructions.forEach(i => {\n        output += stringifyInstructions(i as HTMLTargetedInstruction, depth + 1);\n      });\n      break;\n    case TargetedInstructionType.hydrateElement:\n      output += `hydrateElement: ${instruction.res}\\n`;\n      instruction.instructions.forEach(i => {\n        output += stringifyInstructions(i as HTMLTargetedInstruction, depth + 1);\n      });\n      break;\n    case TargetedInstructionType.hydrateTemplateController:\n      output += `hydrateTemplateController: ${instruction.res}\\n`;\n      output += stringifyTemplateDefinition(instruction.def, depth + 1);\n      instruction.instructions.forEach(i => {\n        output += stringifyInstructions(i as HTMLTargetedInstruction, depth + 1);\n      });\n  }\n  return output;\n}\n\nexport function stringifyTemplateDefinition(def: ITemplateDefinition, depth: number): string {\n  const indent = ' '.repeat(depth);\n  let output = indent;\n\n  output += `TemplateDefinition: ${def.name}\\n`;\n  output += stringifyDOM(def.template as Node, depth + 1);\n  output += `${indent} Instructions:\\n`;\n  def.instructions.forEach(row => {\n    output += `${indent}  Row:\\n`;\n    row.forEach(i => {\n      output += stringifyInstructions(i as HTMLTargetedInstruction, depth + 3);\n    });\n  });\n\n  return output;\n}\n"],"names":["TriggerBindingCommand","TriggerBindingInstruction","getTarget","bindingCommand","DelegateBindingCommand","DelegateBindingInstruction","CaptureBindingCommand","CaptureBindingInstruction","Tracer","PlainElementSymbol","CustomElementSymbol","LetElementSymbol","PLATFORM","BindableInfo","BindingMode","BindingSymbol","TextSymbol","TemplateControllerSymbol","CustomAttributeSymbol","PlainAttributeSymbol","ReplacePartSymbol","DI","HTMLTemplateElementFactory","inject","IDOM","TemplateCompiler","ResourceModel","TextBindingInstruction","LetBindingInstruction","LetElementInstruction","HydrateElementInstruction","HydrateTemplateController","SetPropertyInstruction","InterpolationInstruction","HydrateAttributeInstruction","SetAttributeInstruction","RefBindingInstruction","IAttributeParser","IExpressionParser","HTMLRuntimeConfiguration","JitConfiguration","Registration","ITemplateCompiler"],"mappings":"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"}