{"version":3,"file":"index.iife.js","sources":["../src/flags.ts","../../../node_modules/tslib/tslib.es6.js","../src/observation.ts","../src/observation/subscriber-collection.ts","../src/observation/proxy-observer.ts","../src/observation/property-observer.ts","../src/observation/setter-observer.ts","../src/observation/binding-context.ts","../src/observation/signaler.ts","../src/resources/binding-behavior.ts","../src/resources/value-converter.ts","../src/binding/ast.ts","../src/lifecycle.ts","../src/binding/connectable.ts","../src/binding/binding.ts","../src/binding/call.ts","../src/binding/expression-parser.ts","../src/binding/interpolation-binding.ts","../src/binding/let-binding.ts","../src/binding/ref.ts","../src/observation/target-observer.ts","../src/observation/collection-observer.ts","../src/observation/array-observer.ts","../src/observation/map-observer.ts","../src/observation/set-observer.ts","../src/observation/computed-observer.ts","../src/observation/dirty-checker.ts","../src/observation/primitive-observer.ts","../src/observation/property-accessor.ts","../src/observation/observer-locator.ts","../src/observation/self-observer.ts","../src/resources/binding-behaviors/binding-mode.ts","../src/resources/binding-behaviors/debounce.ts","../src/resources/binding-behaviors/signals.ts","../src/resources/binding-behaviors/throttle.ts","../src/definitions.ts","../src/templating/lifecycle-attach.ts","../src/templating/lifecycle-bind.ts","../src/dom.ts","../src/templating/view.ts","../src/rendering-engine.ts","../src/resources/custom-element.ts","../src/templating/lifecycle-render.ts","../src/resources/custom-attribute.ts","../src/templating/bindable.ts","../src/resources/custom-attributes/if.ts","../src/resources/custom-attributes/repeat.ts","../src/resources/custom-attributes/replaceable.ts","../src/resources/custom-attributes/with.ts","../src/resources/value-converters/sanitize.ts","../src/aurelia.ts","../src/renderer.ts","../src/configuration.ts","../src/instructions.ts"],"sourcesContent":["/*\n* Note: the oneTime binding now has a non-zero value for 2 reasons:\n*  - plays nicer with bitwise operations (more consistent code, more explicit settings)\n*  - allows for potentially having something like BindingMode.oneTime | BindingMode.fromView, where an initial value is set once to the view but updates from the view also propagate back to the view model\n*\n* Furthermore, the \"default\" mode would be for simple \".bind\" expressions to make it explicit for our logic that the default is being used.\n* This essentially adds extra information which binding could use to do smarter things and allows bindingBehaviors that add a mode instead of simply overwriting it\n*/\nexport enum BindingMode {\n  oneTime  = 0b0001,\n  toView   = 0b0010,\n  fromView = 0b0100,\n  twoWay   = 0b0110,\n  default  = 0b1000\n}\n\nexport const enum State {\n  none                  = 0b000000000000,\n  isBinding             = 0b000000000001,\n  isBound               = 0b000000000010,\n  isAttaching           = 0b000000000100,\n  isAttached            = 0b000000001000,\n  isMounted             = 0b000000010000,\n  isDetaching           = 0b000000100000,\n  isUnbinding           = 0b000001000000,\n  isCached              = 0b000010000000,\n  isContainerless       = 0b000100000000\n}\n\nexport const enum Hooks {\n  none                   = 0b000000000001,\n  hasCreated             = 0b000000000010,\n  hasBinding             = 0b000000000100,\n  hasBound               = 0b000000001000,\n  hasAttaching           = 0b000000010000,\n  hasAttached            = 0b000000100000,\n  hasDetaching           = 0b000001000000,\n  hasDetached            = 0b000010000000,\n  hasUnbinding           = 0b000100000000,\n  hasUnbound             = 0b001000000000,\n  hasRender              = 0b010000000000,\n  hasCaching             = 0b100000000000\n}\n\nexport enum LifecycleFlags {\n  none                      = 0b00_0000_00000000000000_000_00,\n  mustEvaluate              = 0b00_0001_00000000000000_000_00,\n  mutation                  = 0b00_0000_00000000000000_000_11,\n  isCollectionMutation      = 0b00_0000_00000000000000_000_01,\n  isInstanceMutation        = 0b00_0000_00000000000000_000_10,\n  update                    = 0b00_0000_00000000000000_111_00,\n  updateTargetObserver      = 0b00_0000_00000000000000_001_00,\n  updateTargetInstance      = 0b00_0000_00000000000000_010_00,\n  updateSourceExpression    = 0b00_0000_00000000000000_100_00,\n  from                      = 0b00_0000_11111111111111_000_00,\n  fromFlush                 = 0b00_0000_00000000000111_000_00,\n  fromAsyncFlush            = 0b00_0000_00000000000001_000_00,\n  fromSyncFlush             = 0b00_0000_00000000000010_000_00,\n  fromTick                  = 0b00_0000_00000000000100_000_00,\n  fromStartTask             = 0b00_0000_00000000001000_000_00,\n  fromStopTask              = 0b00_0000_00000000010000_000_00,\n  fromBind                  = 0b00_0000_00000000100000_000_00,\n  fromUnbind                = 0b00_0000_00000001000000_000_00,\n  fromAttach                = 0b00_0000_00000010000000_000_00,\n  fromDetach                = 0b00_0000_00000100000000_000_00,\n  fromCache                 = 0b00_0000_00001000000000_000_00,\n  fromDOMEvent              = 0b00_0000_00010000000000_000_00,\n  fromObserverSetter        = 0b00_0000_00100000000000_000_00,\n  fromBindableHandler       = 0b00_0000_01000000000000_000_00,\n  fromLifecycleTask         = 0b00_0000_10000000000000_000_00,\n  parentUnmountQueued       = 0b00_0010_00000000000000_000_00,\n  // this flag is for the synchronous flush before detach (no point in updating the\n  // DOM if it's about to be detached)\n  doNotUpdateDOM            = 0b00_0100_00000000000000_000_00,\n  isTraversingParentScope   = 0b00_1000_00000000000000_000_00,\n  // Bitmask for flags that need to be stored on a binding during $bind for mutation\n  // callbacks outside of $bind\n  persistentBindingFlags    = 0b11_0000_00000000000000_000_00,\n  allowParentScopeTraversal = 0b01_0000_00000000000000_000_00,\n  useProxies                = 0b10_0000_00000000000000_000_00,\n}\n\nexport function stringifyLifecycleFlags(flags: LifecycleFlags): string {\n  const flagNames: string[] = [];\n\n  if (flags & LifecycleFlags.mustEvaluate) { flagNames.push('mustEvaluate'); }\n  if (flags & LifecycleFlags.isCollectionMutation) { flagNames.push('isCollectionMutation'); }\n  if (flags & LifecycleFlags.isInstanceMutation) { flagNames.push('isInstanceMutation'); }\n  if (flags & LifecycleFlags.updateTargetObserver) { flagNames.push('updateTargetObserver'); }\n  if (flags & LifecycleFlags.updateTargetInstance) { flagNames.push('updateTargetInstance'); }\n  if (flags & LifecycleFlags.updateSourceExpression) { flagNames.push('updateSourceExpression'); }\n  if (flags & LifecycleFlags.fromAsyncFlush) { flagNames.push('fromAsyncFlush'); }\n  if (flags & LifecycleFlags.fromSyncFlush) { flagNames.push('fromSyncFlush'); }\n  if (flags & LifecycleFlags.fromStartTask) { flagNames.push('fromStartTask'); }\n  if (flags & LifecycleFlags.fromStopTask) { flagNames.push('fromStopTask'); }\n  if (flags & LifecycleFlags.fromBind) { flagNames.push('fromBind'); }\n  if (flags & LifecycleFlags.fromUnbind) { flagNames.push('fromUnbind'); }\n  if (flags & LifecycleFlags.fromAttach) { flagNames.push('fromAttach'); }\n  if (flags & LifecycleFlags.fromDetach) { flagNames.push('fromDetach'); }\n  if (flags & LifecycleFlags.fromCache) { flagNames.push('fromCache'); }\n  if (flags & LifecycleFlags.fromDOMEvent) { flagNames.push('fromDOMEvent'); }\n  if (flags & LifecycleFlags.fromObserverSetter) { flagNames.push('fromObserverSetter'); }\n  if (flags & LifecycleFlags.fromBindableHandler) { flagNames.push('fromBindableHandler'); }\n  if (flags & LifecycleFlags.fromLifecycleTask) { flagNames.push('fromLifecycleTask'); }\n  if (flags & LifecycleFlags.parentUnmountQueued) { flagNames.push('parentUnmountQueued'); }\n  if (flags & LifecycleFlags.doNotUpdateDOM) { flagNames.push('doNotUpdateDOM'); }\n  if (flags & LifecycleFlags.isTraversingParentScope) { flagNames.push('isTraversingParentScope'); }\n  if (flags & LifecycleFlags.allowParentScopeTraversal) { flagNames.push('allowParentScopeTraversal'); }\n  if (flags & LifecycleFlags.useProxies) { flagNames.push('useProxies'); }\n\n  return flagNames.join('|');\n}\n\nexport const enum ExpressionKind {\n  Connects             = 0b000000000001_00000, // The expression's connect() function calls observeProperty and/or calls connect() on another expression that it wraps (all expressions except for AccessThis, PrimitiveLiteral, CallMember/Function and Assign)\n  Observes             = 0b000000000010_00000, // The expression's connect() function calls observeProperty (only AccessScope, AccessMember and AccessKeyed do this)\n  CallsFunction        = 0b000000000100_00000, // Calls a function (CallFunction, CallScope, CallMember, TaggedTemplate) -> needs a valid function object returning from its lefthandside's evaluate()\n  HasAncestor          = 0b000000001000_00000, // Has an \"ancestor\" property, meaning the expression could climb up the context (only AccessThis, AccessScope and CallScope)\n  IsPrimary            = 0b000000010000_00000, // Is a primary expression according to ES parsing rules\n  IsLeftHandSide       = 0b000000100000_00000, // Is a left-hand side expression according to ES parsing rules, includes IsPrimary\n  HasBind              = 0b000001000000_00000, // Has a bind() method (currently only BindingBehavior)\n  HasUnbind            = 0b000010000000_00000, // Has an unbind() method (currentl only BindingBehavior and ValueConverter)\n  IsAssignable         = 0b000100000000_00000, // Is an assignable expression according to ES parsing rules (only AccessScope, AccessMember, AccessKeyed ans Assign)\n  IsLiteral            = 0b001000000000_00000, // Is an Aurelia resource (ValueConverter or BindingBehavior)\n  IsResource           = 0b010000000000_00000, // Is literal expression (Primitive, Array, Object or Template)\n  IsForDeclaration     = 0b100000000000_00000, // Is a For declaration (for..of, for..in -> currently only ForOfStatement)\n  Type                 = 0b000000000000_11111, // Type mask to uniquely identify each AST class (concrete types start below)\n  // ---------------------------------------------------------------------------------------------------------------------------\n  AccessThis           = 0b000000111000_00001, //               HasAncestor\n  AccessScope          = 0b000100111011_00010, // IsAssignable  HasAncestor       Observes  Connects\n  ArrayLiteral         = 0b001000110001_00011, //                                           Connects\n  ObjectLiteral        = 0b001000110001_00100, //                                           Connects\n  PrimitiveLiteral     = 0b001000110000_00101, //\n  Template             = 0b001000110001_00110, //                                           Connects\n  Unary                = 0b000000000001_00111, //                                           Connects\n  CallScope            = 0b000000101101_01000, //               HasAncestor  CallsFunction  Connects\n  CallMember           = 0b000000100100_01001, //                            CallsFunction\n  CallFunction         = 0b000000100100_01010, //                            CallsFunction\n  AccessMember         = 0b000100100011_01011, // IsAssignable                    Observes  Connects\n  AccessKeyed          = 0b000100100011_01100, // IsAssignable                    Observes  Connects\n  TaggedTemplate       = 0b000000100101_01101, //                            CallsFunction  Connects\n  Binary               = 0b000000000001_01110, //                                           Connects\n  Conditional          = 0b000000000001_11111, //                                           Connects\n  Assign               = 0b000100000000_10000, // IsAssignable\n  ValueConverter       = 0b010010000001_10001, //                                           Connects\n  BindingBehavior      = 0b010011000001_10010, //                                           Connects\n  HtmlLiteral          = 0b000000000001_10011, //                                           Connects\n  ArrayBindingPattern  = 0b100000000000_10100, //\n  ObjectBindingPattern = 0b100000000000_10101, //\n  BindingIdentifier    = 0b100000000000_10110, //\n  ForOfStatement       = 0b000000000001_10111, //                                           Connects\n  Interpolation        = 0b000000000000_11000  //\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { IDisposable, IIndexable } from '@aurelia/kernel';\nimport { LifecycleFlags } from './flags';\nimport { ILifecycle } from './lifecycle';\n\nexport interface IProxyObserver<TObj extends object = object, TMut extends MutationKind = MutationKind.proxy> extends ISubscriberCollection<TMut> {\n  proxy: IProxy<TObj>;\n}\n\nexport type IProxy<TObj extends object = object> = TObj & {\n  $raw: TObj;\n  $observer: IProxyObserver<TObj>;\n};\n\n/** @internal */\nexport const enum SubscriberFlags {\n  None            = 0,\n  Subscriber0     = 0b0001,\n  Subscriber1     = 0b0010,\n  Subscriber2     = 0b0100,\n  SubscribersRest = 0b1000,\n  Any             = 0b1111,\n}\n\nexport enum DelegationStrategy {\n  none = 0,\n  capturing = 1,\n  bubbling = 2\n}\n\n/**\n * Describes a type that tracks changes and can flush those changes in some way\n */\nexport interface IChangeTracker {\n  $nextFlush?: IChangeTracker;\n  hasChanges?: boolean;\n  flush(flags: LifecycleFlags): void;\n}\n\n/**\n * Basic interface to normalize getting/setting a value of any property on any object\n */\nexport interface IAccessor<TValue = unknown> {\n  getValue(): TValue;\n  setValue(newValue: TValue, flags: LifecycleFlags): void;\n}\n\n/**\n * Describes a target observer for to-view bindings (in other words, an observer without the observation).\n */\nexport interface IBindingTargetAccessor<\n  TObj = any,\n  TProp = keyof TObj,\n  TValue = unknown>\n  extends IDisposable,\n          IAccessor<TValue>,\n          IPropertyChangeTracker<TObj, TProp> {\n  isDOMObserver?: boolean;\n}\n\n/**\n * Describes a target observer for from-view or two-way bindings.\n */\nexport interface IBindingTargetObserver<\n  TObj = any,\n  TProp = keyof TObj,\n  TValue = unknown>\n  extends IBindingTargetAccessor<TObj, TProp, TValue>,\n          ISubscribable<MutationKind.instance>,\n          ISubscriberCollection<MutationKind.instance> {\n\n  bind?(flags: LifecycleFlags): void;\n  unbind?(flags: LifecycleFlags): void;\n}\n\nexport type AccessorOrObserver = IBindingTargetAccessor | IBindingTargetObserver;\n\n/**\n * An array of indices, where the index of an element represents the index to map FROM, and the numeric value of the element itself represents the index to map TO\n *\n * The deletedItems property contains the items (in case of an array) or keys (in case of map or set) that have been deleted.\n */\nexport type IndexMap = number[] & {\n  deletedItems?: unknown[];\n};\n\n/**\n * Mostly just a marker enum to help with typings (specifically to reduce duplication)\n */\nexport enum MutationKind {\n  instance   = 0b001,\n  collection = 0b010,\n  proxy      = 0b100\n}\n\n/**\n * Describes a type that specifically tracks changes in an object property, or simply something that can have a getter and/or setter\n */\nexport interface IPropertyChangeTracker<TObj extends Record<string, unknown>, TProp = keyof TObj, TValue = unknown> {\n  obj: TObj;\n  propertyKey?: TProp;\n  currentValue?: TValue;\n}\n\n/**\n * Describes a type that specifically tracks changes in a collection (map, set or array)\n */\nexport interface ICollectionChangeTracker<T extends Collection> extends IChangeTracker {\n  collection: T;\n  indexMap: IndexMap;\n  resetIndexMap(): void;\n}\n\n/**\n * Represents a (subscriber) function that can be called by a PropertyChangeNotifier\n */\nexport type IPropertyChangeHandler<TValue = unknown> = (newValue: TValue, previousValue: TValue, flags: LifecycleFlags) => void;\n/**\n * Represents a (observer) function that can notify subscribers of mutations on a property\n */\nexport interface IPropertyChangeNotifier extends IPropertyChangeHandler {}\n\n/**\n * Describes a (subscriber) type that has a function conforming to the IPropertyChangeHandler interface\n */\nexport interface IPropertySubscriber<TValue = unknown> { handleChange(newValue: TValue, previousValue: TValue, flags: LifecycleFlags): void; }\n\n/**\n * Represents a (subscriber) function that can be called by a ProxyChangeNotifier\n */\nexport type IProxyChangeHandler<TValue = unknown> = (key: PropertyKey, newValue: TValue, previousValue: TValue, flags: LifecycleFlags) => void;\n/**\n * Represents a (observer) function that can notify subscribers of mutations on a proxy\n */\nexport interface IProxyChangeNotifier extends IProxyChangeHandler {}\n\n/**\n * Describes a (subscriber) type that has a function conforming to the IProxyChangeHandler interface\n */\nexport interface IProxySubscriber<TValue = unknown> { handleChange(key: PropertyKey, newValue: TValue, previousValue: TValue, flags: LifecycleFlags): void; }\n\n/**\n * Represents a (subscriber) function that can be called by a CollectionChangeNotifier\n */\nexport type ICollectionChangeHandler = (origin: string, args: IArguments | null, flags: LifecycleFlags) => void;\n/**\n * Represents a (observer) function that can notify subscribers of mutations in a collection\n */\nexport interface ICollectionChangeNotifier extends ICollectionChangeHandler {}\n\n/**\n * Represents a (subscriber) function that can be called by a BatchedCollectionChangeNotifier\n */\nexport type IBatchedCollectionChangeHandler = (indexMap: number[], flags: LifecycleFlags) => void;\n/**\n * Represents a (observer) function that can notify subscribers of batched mutations in a collection\n */\nexport interface IBatchedCollectionChangeNotifier extends IBatchedCollectionChangeHandler {}\n\n/**\n * Describes a (subscriber) type that has a function conforming to the ICollectionChangeHandler interface\n */\nexport interface ICollectionSubscriber { handleChange(origin: string, args: IArguments | null, flags: LifecycleFlags): void; }\n/**\n * Describes a (subscriber) type that has a function conforming to the IBatchedCollectionChangeNotifier interface\n */\nexport interface IBatchedCollectionSubscriber { handleBatchedChange(indexMap: number[], flags: LifecycleFlags): void; }\n\n/**\n * Either a property or collection subscriber\n */\nexport type Subscriber = ICollectionSubscriber | IPropertySubscriber | IProxySubscriber;\n/**\n * Either a batched property or batched collection subscriber\n */\nexport type BatchedSubscriber = IBatchedCollectionSubscriber;\n\n/**\n * Helper type that translates from mutationKind enum to the correct subscriber interface\n */\nexport type MutationKindToSubscriber<T> =\n  T extends MutationKind.instance ? IPropertySubscriber :\n  T extends MutationKind.collection ? ICollectionSubscriber :\n  T extends MutationKind.proxy ? IProxySubscriber :\n  never;\n\n/**\n * Helper type that translates from mutationKind enum to the correct batched subscriber interface\n */\nexport type MutationKindToBatchedSubscriber<T> =\n  T extends MutationKind.collection ? IBatchedCollectionSubscriber :\n  never;\n\n/**\n * Helper type that translates from mutationKind enum to the correct notifier interface\n */\nexport type MutationKindToNotifier<T> =\n  T extends MutationKind.instance ? IPropertyChangeNotifier :\n  T extends MutationKind.collection ? ICollectionChangeNotifier :\n  T extends MutationKind.proxy ? IProxyChangeNotifier :\n  never;\n\n/**\n * Helper type that translates from mutationKind enum to the correct batched notifier interface\n */\nexport type MutationKindToBatchedNotifier<T> =\n  T extends MutationKind.collection ? IBatchedCollectionChangeNotifier :\n  never;\n\nexport interface ISubscribable<T extends MutationKind> {\n  subscribe(subscriber: MutationKindToSubscriber<T>): void;\n  unsubscribe(subscriber: MutationKindToSubscriber<T>): void;\n}\n\n/**\n * A collection of property or collection subscribers\n */\nexport interface ISubscriberCollection<T extends MutationKind> extends ISubscribable<T> {\n  /** @internal */_subscriberFlags?: SubscriberFlags;\n  /** @internal */_subscriber0?: MutationKindToSubscriber<T>;\n  /** @internal */_subscriber1?: MutationKindToSubscriber<T>;\n  /** @internal */_subscriber2?: MutationKindToSubscriber<T>;\n  /** @internal */_subscribersRest?: MutationKindToSubscriber<T>[];\n\n  callSubscribers: MutationKindToNotifier<T>;\n  hasSubscribers(): boolean;\n  hasSubscriber(subscriber: MutationKindToSubscriber<T>): boolean;\n  removeSubscriber(subscriber: MutationKindToSubscriber<T>): boolean;\n  addSubscriber(subscriber: MutationKindToSubscriber<T>): boolean;\n}\n\n/**\n * A collection of batched property or collection subscribers\n */\nexport interface IBatchedSubscriberCollection<T extends MutationKind> extends IBatchedSubscribable<T> {\n  /** @internal */_batchedSubscriberFlags?: SubscriberFlags;\n  /** @internal */_batchedSubscriber0?: MutationKindToBatchedSubscriber<T>;\n  /** @internal */_batchedSubscriber1?: MutationKindToBatchedSubscriber<T>;\n  /** @internal */_batchedSubscriber2?: MutationKindToBatchedSubscriber<T>;\n  /** @internal */_batchedSubscribersRest?: MutationKindToBatchedSubscriber<T>[];\n\n  /** @internal */lifecycle?: ILifecycle;\n  callBatchedSubscribers: MutationKindToBatchedNotifier<T>;\n\n  /** @internal */flush(flags: LifecycleFlags): void;\n  hasBatchedSubscribers(): boolean;\n  hasBatchedSubscriber(subscriber: MutationKindToBatchedSubscriber<T>): boolean;\n  removeBatchedSubscriber(subscriber: MutationKindToBatchedSubscriber<T>): boolean;\n  addBatchedSubscriber(subscriber: MutationKindToBatchedSubscriber<T>): boolean;\n}\n\nexport interface IBatchedSubscribable<T extends MutationKind> {\n  subscribeBatched(subscriber: MutationKindToBatchedSubscriber<T>): void;\n  unsubscribeBatched(subscriber: MutationKindToBatchedSubscriber<T>): void;\n}\n\n/**\n * Describes a complete property observer with an accessor, change tracking fields, normal and batched subscribers\n */\nexport interface IPropertyObserver<TObj extends Record<string, unknown>, TProp extends keyof TObj> extends\n  IDisposable,\n  IAccessor<TObj[TProp]>,\n  IPropertyChangeTracker<TObj, TProp>,\n  ISubscriberCollection<MutationKind.instance> {\n  observing: boolean;\n}\n\n/**\n * An any-typed property observer\n */\nexport type PropertyObserver = IPropertyObserver<IIndexable, string>;\n\n/**\n * A collection (array, set or map)\n */\nexport type Collection = unknown[] | Set<unknown> | Map<unknown, unknown>;\ninterface IObservedCollection {\n  $observer?: CollectionObserver;\n  $raw?: this;\n}\n\n/**\n * An array that is being observed for mutations\n */\nexport interface IObservedArray<T = unknown> extends IObservedCollection, Array<T> { }\n/**\n * A set that is being observed for mutations\n */\nexport interface IObservedSet<T = unknown> extends IObservedCollection, Set<T> { }\n/**\n * A map that is being observed for mutations\n */\nexport interface IObservedMap<K = unknown, V = unknown> extends IObservedCollection, Map<K, V> { }\n/**\n * A collection that is being observed for mutations\n */\nexport type ObservedCollection = IObservedArray | IObservedSet | IObservedMap;\n\nexport const enum CollectionKind {\n  indexed = 0b1000,\n  keyed   = 0b0100,\n  array   = 0b1001,\n  map     = 0b0110,\n  set     = 0b0111\n}\n\nexport type LengthPropertyName<T> =\n  T extends unknown[] ? 'length' :\n  T extends Set<unknown> ? 'size' :\n  T extends Map<unknown, unknown> ? 'size' :\n  never;\n\nexport type CollectionTypeToKind<T> =\n  T extends unknown[] ? CollectionKind.array | CollectionKind.indexed :\n  T extends Set<unknown> ? CollectionKind.set | CollectionKind.keyed :\n  T extends Map<unknown, unknown> ? CollectionKind.map | CollectionKind.keyed :\n  never;\n\nexport type CollectionKindToType<T> =\n  T extends CollectionKind.array ? unknown[] :\n  T extends CollectionKind.indexed ? unknown[] :\n  T extends CollectionKind.map ? Map<unknown, unknown> :\n  T extends CollectionKind.set ? Set<unknown> :\n  T extends CollectionKind.keyed ? Set<unknown> | Map<unknown, unknown> :\n  never;\n\nexport type ObservedCollectionKindToType<T> =\n  T extends CollectionKind.array ? IObservedArray :\n  T extends CollectionKind.indexed ? IObservedArray :\n  T extends CollectionKind.map ? IObservedMap :\n  T extends CollectionKind.set ? IObservedSet :\n  T extends CollectionKind.keyed ? IObservedSet | IObservedMap :\n  never;\n\n// TODO: organize this (for now it's a quick fix for length observer, but we may actually want this\n// in every observer for alternative change tracking mechanisms)\nexport interface IPatch {\n  patch(flags: LifecycleFlags): void;\n}\n\n/**\n * An observer that tracks collection mutations and notifies subscribers (either directly or in batches)\n */\nexport interface ICollectionObserver<T extends CollectionKind> extends\n  IDisposable,\n  ICollectionChangeTracker<CollectionKindToType<T>>,\n  ISubscriberCollection<MutationKind.collection>,\n  IBatchedSubscriberCollection<MutationKind.collection> {\n    persistentFlags: LifecycleFlags;\n    collection: ObservedCollectionKindToType<T>;\n    lengthPropertyName: LengthPropertyName<CollectionKindToType<T>>;\n    collectionKind: T;\n    lengthObserver: IBindingTargetObserver & IPatch;\n    getLengthObserver(flags: LifecycleFlags): IBindingTargetObserver;\n}\nexport type CollectionObserver = ICollectionObserver<CollectionKind>;\n\nexport interface IBindingContext {\n  [key: string]: unknown;\n\n  readonly $synthetic?: true;\n  readonly $observers?: ObserversLookup<IOverrideContext>;\n  getObservers?(flags: LifecycleFlags): ObserversLookup<IOverrideContext>;\n}\n\nexport interface IOverrideContext {\n  [key: string]: unknown;\n\n  readonly $synthetic?: true;\n  readonly $observers?: ObserversLookup<IOverrideContext>;\n  readonly bindingContext: IBindingContext;\n  readonly parentOverrideContext: IOverrideContext | null;\n  getObservers(flags: LifecycleFlags): ObserversLookup<IOverrideContext>;\n}\n\nexport interface IScope {\n  readonly bindingContext: IBindingContext;\n  readonly overrideContext: IOverrideContext;\n  // parentScope is strictly internal API and mainly for replaceable template controller.\n  // NOT intended for regular scope traversal!\n  /** @internal */readonly parentScope: IScope | null;\n}\n\n// TODO: currently unused, still need to fix the observersLookup type\nexport interface IObserversLookup<TObj extends IIndexable = IIndexable, TKey extends keyof TObj =\n  Exclude<keyof TObj, '$synthetic' | '$observers' | 'bindingContext' | 'overrideContext' | 'parentOverrideContext'>> { }\n\nexport type ObserversLookup<TObj extends IIndexable = IIndexable, TKey extends keyof TObj =\n  Exclude<keyof TObj, '$synthetic' | '$observers' | 'bindingContext' | 'overrideContext' | 'parentOverrideContext'>> =\n  { [P in TKey]: PropertyObserver; } & { getOrCreate(flags: LifecycleFlags, obj: IBindingContext | IOverrideContext, key: string): PropertyObserver };\n\nexport type IObservable = IIndexable & {\n  readonly $synthetic?: false;\n  $observers?: Record<string, AccessorOrObserver>;\n};\n","import { LifecycleFlags } from '../flags';\nimport {\n  IBatchedCollectionSubscriber,\n  IBatchedSubscriberCollection,\n  IndexMap,\n  IPropertySubscriber,\n  ISubscriberCollection,\n  MutationKind,\n  MutationKindToBatchedSubscriber,\n  MutationKindToSubscriber,\n  SubscriberFlags\n} from '../observation';\n\nexport function subscriberCollection<T extends MutationKind>(mutationKind: T): ClassDecorator {\n  // tslint:disable-next-line:ban-types // ClassDecorator expects it to be derived from Function\n  return function(target: Function): void {\n    const proto = target.prototype as ISubscriberCollection<MutationKind.instance | MutationKind.collection | MutationKind.proxy>;\n\n    proto._subscriberFlags = SubscriberFlags.None;\n    proto._subscriber0 = null;\n    proto._subscriber1 = null;\n    proto._subscriber2 = null;\n    proto._subscribersRest = null;\n\n    proto.addSubscriber = addSubscriber;\n    proto.removeSubscriber = removeSubscriber;\n    proto.hasSubscriber = hasSubscriber;\n    proto.hasSubscribers = hasSubscribers;\n    switch (mutationKind) {\n      case MutationKind.instance:\n        proto.callSubscribers = callPropertySubscribers;\n        break;\n      case MutationKind.collection:\n        proto.callSubscribers = callCollectionSubscribers;\n        break;\n      case MutationKind.proxy:\n        proto.callSubscribers = callProxySubscribers;\n    }\n  };\n}\n\nfunction addSubscriber<T extends MutationKind>(this: ISubscriberCollection<T>, subscriber: MutationKindToSubscriber<T>): boolean {\n  if (this.hasSubscriber(subscriber)) {\n    return false;\n  }\n  const subscriberFlags = this._subscriberFlags;\n  if (!(subscriberFlags & SubscriberFlags.Subscriber0)) {\n    this._subscriber0 = subscriber;\n    this._subscriberFlags |= SubscriberFlags.Subscriber0;\n    return true;\n  }\n  if (!(subscriberFlags & SubscriberFlags.Subscriber1)) {\n    this._subscriber1 = subscriber;\n    this._subscriberFlags |= SubscriberFlags.Subscriber1;\n    return true;\n  }\n  if (!(subscriberFlags & SubscriberFlags.Subscriber2)) {\n    this._subscriber2 = subscriber;\n    this._subscriberFlags |= SubscriberFlags.Subscriber2;\n    return true;\n  }\n  if (!(subscriberFlags & SubscriberFlags.SubscribersRest)) {\n    this._subscribersRest = [subscriber];\n    this._subscriberFlags |= SubscriberFlags.SubscribersRest;\n    return true;\n  }\n  this._subscribersRest.push(subscriber);\n  return true;\n}\n\nfunction removeSubscriber<T extends MutationKind>(this: ISubscriberCollection<T>, subscriber: IPropertySubscriber): boolean {\n  const subscriberFlags = this._subscriberFlags;\n  if ((subscriberFlags & SubscriberFlags.Subscriber0) && this._subscriber0 === subscriber) {\n    this._subscriber0 = null;\n    this._subscriberFlags &= ~SubscriberFlags.Subscriber0;\n    return true;\n  }\n  if ((subscriberFlags & SubscriberFlags.Subscriber1) && this._subscriber1 === subscriber) {\n    this._subscriber1 = null;\n    this._subscriberFlags &= ~SubscriberFlags.Subscriber1;\n    return true;\n  }\n  if ((subscriberFlags & SubscriberFlags.Subscriber2) && this._subscriber2 === subscriber) {\n    this._subscriber2 = null;\n    this._subscriberFlags &= ~SubscriberFlags.Subscriber2;\n    return true;\n  }\n  if (subscriberFlags & SubscriberFlags.SubscribersRest) {\n    const subscribers = this._subscribersRest;\n    for (let i = 0, ii = subscribers.length; i < ii; ++i) {\n      if (subscribers[i] === subscriber) {\n        subscribers.splice(i, 1);\n        if (ii === 1) {\n          this._subscriberFlags &= ~SubscriberFlags.SubscribersRest;\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction callPropertySubscribers(this: ISubscriberCollection<MutationKind.instance>, newValue: unknown, previousValue: unknown, flags: LifecycleFlags): void {\n  /**\n   * Note: change handlers may have the side-effect of adding/removing subscribers to this collection during this\n   * callSubscribers invocation, so we're caching them all before invoking any.\n   * Subscribers added during this invocation are not invoked (and they shouldn't be).\n   * Subscribers removed during this invocation will still be invoked (and they also shouldn't be,\n   * however this is accounted for via $isBound and similar flags on the subscriber objects)\n   */\n  const subscriber0 = this._subscriber0;\n  const subscriber1 = this._subscriber1;\n  const subscriber2 = this._subscriber2;\n  let subscribers = this._subscribersRest;\n  if (subscribers !== null) {\n    subscribers = subscribers.slice();\n  }\n  if (subscriber0 !== null) {\n    subscriber0.handleChange(newValue, previousValue, flags);\n  }\n  if (subscriber1 !== null) {\n    subscriber1.handleChange(newValue, previousValue, flags);\n  }\n  if (subscriber2 !== null) {\n    subscriber2.handleChange(newValue, previousValue, flags);\n  }\n  const length = subscribers && subscribers.length;\n  if (length !== undefined && length > 0) {\n    for (let i = 0; i < length; ++i) {\n      const subscriber = subscribers[i];\n      if (subscriber !== null) {\n        subscriber.handleChange(newValue, previousValue, flags);\n      }\n    }\n  }\n}\n\nfunction callCollectionSubscribers(this: ISubscriberCollection<MutationKind.collection> & Required<IBatchedSubscriberCollection<MutationKind.collection>>, origin: string, args: IArguments | null, flags: LifecycleFlags): void {\n  const subscriber0 = this._subscriber0;\n  const subscriber1 = this._subscriber1;\n  const subscriber2 = this._subscriber2;\n  let subscribers = this._subscribersRest;\n  if (subscribers !== null) {\n    subscribers = subscribers.slice();\n  }\n  if (subscriber0 !== null) {\n    subscriber0.handleChange(origin, args, flags);\n  }\n  if (subscriber1 !== null) {\n    subscriber1.handleChange(origin, args, flags);\n  }\n  if (subscriber2 !== null) {\n    subscriber2.handleChange(origin, args, flags);\n  }\n  const length = subscribers && subscribers.length;\n  if (length !== undefined && length > 0) {\n    for (let i = 0; i < length; ++i) {\n      const subscriber = subscribers[i];\n      if (subscriber !== null) {\n        subscriber.handleChange(origin, args, flags);\n      }\n    }\n  }\n  this.lifecycle.enqueueFlush(this).catch(error => { throw error; });\n}\n\nfunction callProxySubscribers(this: ISubscriberCollection<MutationKind.proxy>, key: PropertyKey, newValue: unknown, previousValue: unknown, flags: LifecycleFlags): void {\n  const subscriber0 = this._subscriber0;\n  const subscriber1 = this._subscriber1;\n  const subscriber2 = this._subscriber2;\n  let subscribers = this._subscribersRest;\n  if (subscribers !== null) {\n    subscribers = subscribers.slice();\n  }\n  if (subscriber0 !== null) {\n    subscriber0.handleChange(key, newValue, previousValue, flags);\n  }\n  if (subscriber1 !== null) {\n    subscriber1.handleChange(key, newValue, previousValue, flags);\n  }\n  if (subscriber2 !== null) {\n    subscriber2.handleChange(key, newValue, previousValue, flags);\n  }\n  const length = subscribers && subscribers.length;\n  if (length !== undefined && length > 0) {\n    for (let i = 0; i < length; ++i) {\n      const subscriber = subscribers[i];\n      if (subscriber !== null) {\n        subscriber.handleChange(key, newValue, previousValue, flags);\n      }\n    }\n  }\n}\nfunction hasSubscribers<T extends MutationKind>(this: ISubscriberCollection<T>): boolean {\n  return this._subscriberFlags !== SubscriberFlags.None;\n}\n\nfunction hasSubscriber<T extends MutationKind>(this: ISubscriberCollection<T>, subscriber: IPropertySubscriber): boolean {\n  // Flags here is just a perf tweak\n  // Compared to not using flags, it's a moderate speed-up when this collection does not have the subscriber;\n  // and minor slow-down when it does, and the former is more common than the latter.\n  const subscriberFlags = this._subscriberFlags;\n  if ((subscriberFlags & SubscriberFlags.Subscriber0) && this._subscriber0 === subscriber) {\n    return true;\n  }\n  if ((subscriberFlags & SubscriberFlags.Subscriber1) && this._subscriber1 === subscriber) {\n    return true;\n  }\n  if ((subscriberFlags & SubscriberFlags.Subscriber2) && this._subscriber2 === subscriber) {\n    return true;\n  }\n  if (subscriberFlags & SubscriberFlags.SubscribersRest) {\n    // no need to check length; if the flag is set, there's always at least one\n    const subscribers = this._subscribersRest;\n    for (let i = 0, ii = subscribers.length; i < ii; ++i) {\n      if (subscribers[i] === subscriber) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nexport function batchedSubscriberCollection(): ClassDecorator {\n  // tslint:disable-next-line:ban-types // ClassDecorator expects it to be derived from Function\n  return function(target: Function): void {\n    const proto = target.prototype as IBatchedSubscriberCollection<MutationKind.collection>;\n\n    proto._batchedSubscriberFlags = SubscriberFlags.None;\n    proto._batchedSubscriber0 = null;\n    proto._batchedSubscriber1 = null;\n    proto._batchedSubscriber2 = null;\n    proto._batchedSubscribersRest = null;\n\n    proto.addBatchedSubscriber = addBatchedSubscriber;\n    proto.removeBatchedSubscriber = removeBatchedSubscriber;\n    proto.hasBatchedSubscriber = hasBatchedSubscriber;\n    proto.hasBatchedSubscribers = hasBatchedSubscribers;\n    proto.callBatchedSubscribers = callBatchedCollectionSubscribers;\n  };\n}\n\nfunction addBatchedSubscriber(this: IBatchedSubscriberCollection<MutationKind.collection>, subscriber: MutationKindToBatchedSubscriber<MutationKind.collection>): boolean {\n  if (this.hasBatchedSubscriber(subscriber)) {\n    return false;\n  }\n  const subscriberFlags = this._batchedSubscriberFlags;\n  if (!(subscriberFlags & SubscriberFlags.Subscriber0)) {\n    this._batchedSubscriber0 = subscriber;\n    this._batchedSubscriberFlags |= SubscriberFlags.Subscriber0;\n    return true;\n  }\n  if (!(subscriberFlags & SubscriberFlags.Subscriber1)) {\n    this._batchedSubscriber1 = subscriber;\n    this._batchedSubscriberFlags |= SubscriberFlags.Subscriber1;\n    return true;\n  }\n  if (!(subscriberFlags & SubscriberFlags.Subscriber2)) {\n    this._batchedSubscriber2 = subscriber;\n    this._batchedSubscriberFlags |= SubscriberFlags.Subscriber2;\n    return true;\n  }\n  if (!(subscriberFlags & SubscriberFlags.SubscribersRest)) {\n    this._batchedSubscribersRest = [subscriber];\n    this._batchedSubscriberFlags |= SubscriberFlags.SubscribersRest;\n    return true;\n  }\n  this._batchedSubscribersRest.push(subscriber);\n  return true;\n}\n\nfunction removeBatchedSubscriber(this: IBatchedSubscriberCollection<MutationKind.collection>, subscriber: IBatchedCollectionSubscriber): boolean {\n  const subscriberFlags = this._batchedSubscriberFlags;\n  if ((subscriberFlags & SubscriberFlags.Subscriber0) && this._batchedSubscriber0 === subscriber) {\n    this._batchedSubscriber0 = null;\n    this._batchedSubscriberFlags &= ~SubscriberFlags.Subscriber0;\n    return true;\n  }\n  if ((subscriberFlags & SubscriberFlags.Subscriber1) && this._batchedSubscriber1 === subscriber) {\n    this._batchedSubscriber1 = null;\n    this._batchedSubscriberFlags &= ~SubscriberFlags.Subscriber1;\n    return true;\n  }\n  if ((subscriberFlags & SubscriberFlags.Subscriber2) && this._batchedSubscriber2 === subscriber) {\n    this._batchedSubscriber2 = null;\n    this._batchedSubscriberFlags &= ~SubscriberFlags.Subscriber2;\n    return true;\n  }\n  if (subscriberFlags & SubscriberFlags.SubscribersRest) {\n    const subscribers = this._batchedSubscribersRest;\n    for (let i = 0, ii = subscribers.length; i < ii; ++i) {\n      if (subscribers[i] === subscriber) {\n        subscribers.splice(i, 1);\n        if (ii === 1) {\n          this._batchedSubscriberFlags &= ~SubscriberFlags.SubscribersRest;\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction callBatchedCollectionSubscribers(this: IBatchedSubscriberCollection<MutationKind.collection>, indexMap: IndexMap, flags: LifecycleFlags): void {\n  const subscriber0 = this._batchedSubscriber0;\n  const subscriber1 = this._batchedSubscriber1;\n  const subscriber2 = this._batchedSubscriber2;\n  let subscribers = this._batchedSubscribersRest;\n  if (subscribers !== null) {\n    subscribers = subscribers.slice();\n  }\n  if (subscriber0 !== null) {\n    subscriber0.handleBatchedChange(indexMap, flags);\n  }\n  if (subscriber1 !== null) {\n    subscriber1.handleBatchedChange(indexMap, flags);\n  }\n  if (subscriber2 !== null) {\n    subscriber2.handleBatchedChange(indexMap, flags);\n  }\n  const length = subscribers && subscribers.length;\n  if (length !== undefined && length > 0) {\n    for (let i = 0; i < length; ++i) {\n      const subscriber = subscribers[i];\n      if (subscriber !== null) {\n        subscriber.handleBatchedChange(indexMap, flags);\n      }\n    }\n  }\n}\n\nfunction hasBatchedSubscribers(this: IBatchedSubscriberCollection<MutationKind.collection>): boolean {\n  return this._batchedSubscriberFlags !== SubscriberFlags.None;\n}\n\nfunction hasBatchedSubscriber(this: IBatchedSubscriberCollection<MutationKind.collection>, subscriber: IBatchedCollectionSubscriber): boolean {\n  // Flags here is just a perf tweak\n  // Compared to not using flags, it's a moderate speed-up when this collection does not have the subscriber;\n  // and minor slow-down when it does, and the former is more common than the latter.\n  const subscriberFlags = this._batchedSubscriberFlags;\n  if ((subscriberFlags & SubscriberFlags.Subscriber0) && this._batchedSubscriber0 === subscriber) {\n    return true;\n  }\n  if ((subscriberFlags & SubscriberFlags.Subscriber1) && this._batchedSubscriber1 === subscriber) {\n    return true;\n  }\n  if ((subscriberFlags & SubscriberFlags.Subscriber2) && this._batchedSubscriber2 === subscriber) {\n    return true;\n  }\n  if (subscriberFlags & SubscriberFlags.SubscribersRest) {\n    // no need to check length; if the flag is set, there's always at least one\n    const subscribers = this._batchedSubscribersRest;\n    for (let i = 0, ii = subscribers.length; i < ii; ++i) {\n      if (subscribers[i] === subscriber) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n","import { Tracer } from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport {\n  IPropertySubscriber,\n  IProxy,\n  IProxyObserver,\n  IProxySubscriber,\n  MutationKind\n} from '../observation';\nimport { subscriberCollection } from './subscriber-collection';\n\nconst slice = Array.prototype.slice;\n\nconst lookup: WeakMap<object, IProxy> = new WeakMap();\nexport interface ProxySubscriberCollection<TObj extends object = object> extends IProxyObserver<TObj, MutationKind.instance> {}\n\n@subscriberCollection(MutationKind.instance)\nexport class ProxySubscriberCollection<TObj extends object = object> implements ProxySubscriberCollection<TObj> {\n  public readonly proxy: IProxy<TObj>;\n  public readonly raw: TObj;\n  public readonly key: PropertyKey;\n  constructor(proxy: IProxy<TObj>, raw: TObj, key: PropertyKey) {\n    if (Tracer.enabled) { Tracer.enter('ProxySubscriberCollection.constructor', slice.call(arguments)); }\n    this.raw = raw;\n    this.key = key;\n    this.proxy = proxy;\n    this.subscribe = this.addSubscriber;\n    this.unsubscribe = this.removeSubscriber;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public setValue(value: unknown, flags?: LifecycleFlags): void {\n    const oldValue = this.raw[this.key];\n    if (oldValue !== value) {\n      this.raw[this.key] = value;\n      this.callSubscribers(value, oldValue, flags | LifecycleFlags.useProxies | LifecycleFlags.updateTargetInstance);\n    }\n  }\n  public getValue(): unknown {\n    return this.raw[this.key];\n  }\n}\n\nexport interface ProxyObserver<TObj extends object = object> extends IProxyObserver<TObj, MutationKind.proxy> {}\n\n@subscriberCollection(MutationKind.proxy)\nexport class ProxyObserver<TObj extends object = object> implements ProxyObserver<TObj> {\n  public readonly proxy: IProxy<TObj>;\n  public readonly raw: TObj;\n  private readonly subscribers: Record<PropertyKey, ProxySubscriberCollection<TObj>>;\n\n  constructor(obj: TObj) {\n    if (Tracer.enabled) { Tracer.enter('ProxyObserver.constructor', slice.call(arguments)); }\n    this.raw = obj;\n    this.proxy = new Proxy<TObj>(obj, this) as IProxy<TObj>;\n    lookup.set(obj, this.proxy);\n    this.subscribers = {};\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public static getProxyOrSelf<T extends object = object>(obj: T): T {\n    if ((obj as { $raw?: T }).$raw === undefined) {\n      const proxy = lookup.get(obj) as T;\n      if (proxy === undefined) {\n        return obj;\n      }\n      return proxy;\n    }\n    return obj;\n  }\n  public static getRawIfProxy<T extends object = object>(obj: T): T {\n    const raw = (obj as { $raw?: T }).$raw;\n    if (raw === undefined) {\n      return obj;\n    }\n    return raw;\n  }\n\n  public static getOrCreate<T extends object>(obj: T & { $raw?: T; $observer?: ProxyObserver<T> }): IProxyObserver<T, MutationKind.proxy>;\n  public static getOrCreate<T extends object>(obj: T & { $raw?: T; $observer?: ProxyObserver<T> }, key: PropertyKey): IProxyObserver<T, MutationKind.instance>;\n  public static getOrCreate<T extends object>(obj: T & { $raw?: T; $observer?: ProxyObserver<T> }, key?: PropertyKey): IProxyObserver<T, MutationKind.instance | MutationKind.proxy> {\n    let proxyObserver: ProxyObserver<T>;\n    if (obj.$raw === undefined) {\n      const proxy = lookup.get(obj);\n      if (proxy === undefined) {\n        proxyObserver = new ProxyObserver(obj);\n      } else {\n        proxyObserver = (proxy as { $observer: ProxyObserver<T> }).$observer;\n      }\n    } else {\n      proxyObserver = obj.$observer;\n    }\n    if (arguments.length === 1) {\n      return proxyObserver;\n    }\n    let subscribers = proxyObserver.subscribers[key as string | number];\n    if (subscribers === undefined) {\n      const raw = this.getRawIfProxy(obj);\n      const proxy = proxyObserver.proxy;\n      subscribers = proxyObserver.subscribers[key as string | number] = new ProxySubscriberCollection(proxy, raw, key);\n    }\n    return subscribers;\n  }\n\n  public static isProxy<T extends object>(obj: T & { $raw?: T }): obj is T & { $raw: T; $observer: ProxyObserver<T> } {\n    return obj.$raw !== undefined;\n  }\n\n  public get(target: TObj, p: PropertyKey, receiver?: unknown): unknown {\n    if (p === '$observer') {\n      return this;\n    }\n    if (p === '$raw') {\n      return target;\n    }\n    return target[p];\n  }\n\n  public set(target: TObj, p: PropertyKey, value: unknown, receiver?: unknown): boolean {\n    const oldValue = target[p];\n    if (oldValue !== value) {\n      Reflect.set(target, p, value, target);\n      this.callPropertySubscribers(value, oldValue, p);\n      this.callSubscribers(p, value, oldValue, LifecycleFlags.useProxies | LifecycleFlags.updateTargetInstance);\n    }\n    return true;\n  }\n\n  public deleteProperty(target: TObj, p: PropertyKey): boolean {\n    const oldValue = target[p];\n    if (Reflect.deleteProperty(target, p)) {\n      if (oldValue !== undefined) {\n        this.callPropertySubscribers(undefined, oldValue, p);\n        this.callSubscribers(p, undefined, oldValue, LifecycleFlags.useProxies | LifecycleFlags.updateTargetInstance);\n      }\n      return true;\n    }\n    return false;\n  }\n\n  public defineProperty(target: TObj, p: PropertyKey, attributes: PropertyDescriptor): boolean {\n    const oldValue = target[p];\n    if (Reflect.defineProperty(target, p, attributes)) {\n      if (attributes.value !== oldValue) {\n        this.callPropertySubscribers(attributes.value, oldValue, p);\n        this.callSubscribers(p, attributes.value, oldValue, LifecycleFlags.useProxies | LifecycleFlags.updateTargetInstance);\n      }\n      return true;\n    }\n    return false;\n  }\n\n  public apply(target: TObj, thisArg: unknown, argArray?: unknown[]): unknown {\n    // tslint:disable-next-line:ban-types // Reflect API dictates this\n    return Reflect.apply(target as Function, target, argArray);\n  }\n\n  public subscribe(subscriber: IProxySubscriber): void;\n  public subscribe(subscriber: IPropertySubscriber, key: PropertyKey): void;\n  public subscribe(subscriber: IPropertySubscriber | IProxySubscriber, key?: PropertyKey): void {\n    if (arguments.length === 1) {\n      this.addSubscriber(subscriber);\n    } else {\n      let subscribers = this.subscribers[key as string | number];\n      if (subscribers === undefined) {\n        subscribers = this.subscribers[key as string | number] = new ProxySubscriberCollection(this.proxy, this.raw, key);\n      }\n      subscribers.addSubscriber(subscriber as IPropertySubscriber);\n    }\n  }\n\n  public unsubscribe(subscriber: IProxySubscriber): void;\n  public unsubscribe(subscriber: IPropertySubscriber, key: PropertyKey): void;\n  public unsubscribe(subscriber: IPropertySubscriber | IProxySubscriber, key?: PropertyKey): void {\n    if (arguments.length === 1) {\n      this.removeSubscriber(subscriber);\n    } else {\n      const subscribers = this.subscribers[key as string | number];\n      if (subscribers !== undefined) {\n        subscribers.removeSubscriber(subscriber as IPropertySubscriber);\n      }\n    }\n  }\n\n  private callPropertySubscribers(newValue: unknown, oldValue: unknown, key: PropertyKey): void {\n    const subscribers = this.subscribers[key as string | number];\n    if (subscribers !== undefined) {\n      subscribers.callSubscribers(newValue, oldValue, LifecycleFlags.useProxies | LifecycleFlags.updateTargetInstance);\n    }\n  }\n}\n","import { Reporter } from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport { IPropertySubscriber, MutationKind, PropertyObserver } from '../observation';\nimport { subscriberCollection } from './subscriber-collection';\n\nconst defineProperty = Reflect.defineProperty;\n// note: we're reusing the same object for setting all descriptors, just changing some properties as needed\n//   this works, because the properties are copied by defineProperty (so changing them afterwards doesn't affect existing descriptors)\n// see also: https://tc39.github.io/ecma262/#sec-topropertydescriptor\nconst observedPropertyDescriptor: PropertyDescriptor = {\n  get: undefined,\n  set: undefined,\n  enumerable: true,\n  configurable: true\n};\n\nfunction subscribe(this: PropertyObserver, subscriber: IPropertySubscriber): void {\n  if (this.observing === false) {\n    this.observing = true;\n    const { obj, propertyKey } = this;\n    this.currentValue = obj[propertyKey];\n    observedPropertyDescriptor.get = () => this.getValue();\n    observedPropertyDescriptor.set = value => { this.setValue(value, LifecycleFlags.updateTargetInstance); };\n    if (!defineProperty(obj, propertyKey, observedPropertyDescriptor)) {\n      Reporter.write(1, propertyKey, obj);\n    }\n  }\n  this.addSubscriber(subscriber);\n}\n\nfunction dispose(this: PropertyObserver): void {\n  // tslint:disable-next-line:no-dynamic-delete\n  delete this.obj[this.propertyKey];\n  this.obj = null;\n  this.propertyKey = null;\n  this.currentValue = null;\n}\n\nexport function propertyObserver(): ClassDecorator {\n  // tslint:disable-next-line:ban-types // ClassDecorator expects it to be derived from Function\n  return function(target: Function): void {\n    subscriberCollection(MutationKind.instance)(target);\n    const proto = target.prototype as PropertyObserver;\n\n    proto.observing = false;\n    proto.obj = null;\n    proto.propertyKey = null;\n    // Note: this will generate some \"false positive\" changes when setting a target undefined from a source undefined,\n    // but those aren't harmful because the changes won't be propagated through to subscribers during $bind anyway.\n    // It will, however, solve some \"false negative\" changes when the source value is undefined but the target value is not;\n    // in such cases, this.currentValue in the observer being undefined will block the change from propagating to the target.\n    // This is likely not working correctly in vCurrent either.\n    proto.currentValue = Symbol();\n\n    proto.subscribe = proto.subscribe || subscribe;\n    proto.unsubscribe = proto.unsubscribe || proto.removeSubscriber;\n\n    proto.dispose = proto.dispose || dispose;\n  };\n}\n","import { IIndexable, Tracer } from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport { IPropertyObserver, IPropertySubscriber } from '../observation';\nimport { propertyObserver } from './property-observer';\n\nconst slice = Array.prototype.slice;\n\nexport interface SetterObserver extends IPropertyObserver<IIndexable, string> {}\n\n@propertyObserver()\nexport class SetterObserver implements SetterObserver {\n  public subscribe: (subscriber: IPropertySubscriber) => void;\n  public unsubscribe: (subscriber: IPropertySubscriber) => void;\n  public readonly persistentFlags: LifecycleFlags;\n  public obj: IIndexable;\n  public propertyKey: string;\n\n  constructor(flags: LifecycleFlags, obj: IIndexable, propertyKey: string) {\n    if (Tracer.enabled) { Tracer.enter('SetterObserver.constructor', slice.call(arguments)); }\n    this.persistentFlags = flags & LifecycleFlags.persistentBindingFlags;\n    this.obj = obj;\n    this.propertyKey = propertyKey;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public getValue(): unknown {\n    return this.currentValue;\n  }\n  public setValue(newValue: unknown, flags: LifecycleFlags): void {\n    const currentValue = this.currentValue;\n    if (currentValue !== newValue) {\n      this.currentValue = newValue;\n      if (!(flags & LifecycleFlags.fromBind)) {\n        this.callSubscribers(newValue, currentValue, this.persistentFlags | flags);\n      }\n      // If subscribe() has been called, the target property descriptor is replaced by these getter/setter methods,\n      // so calling obj[propertyKey] will actually return this.currentValue.\n      // However, if subscribe() was not yet called (indicated by !this.observing), the target descriptor\n      // is unmodified and we need to explicitly set the property value.\n      // This will happen in one-time, to-view and two-way bindings during $bind, meaning that the $bind will not actually update the target value.\n      // This wasn't visible in vCurrent due to connect-queue always doing a delayed update, so in many cases it didn't matter whether $bind updated the target or not.\n      if (!this.observing) {\n        this.obj[this.propertyKey] = newValue;\n      }\n    }\n  }\n}\n","import { IIndexable, Reporter, StrictPrimitive, Tracer } from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport { IBinding } from '../lifecycle';\nimport {\n  IBindingContext,\n  IOverrideContext,\n  IScope,\n  ObservedCollection,\n  ObserversLookup,\n  PropertyObserver\n} from '../observation';\nimport { ProxyObserver } from './proxy-observer';\nimport { SetterObserver } from './setter-observer';\n\nconst slice = Array.prototype.slice;\n\nconst enum RuntimeError {\n  UndefinedScope = 250, // trying to evaluate on something that's not a valid binding\n  NullScope = 251, // trying to evaluate on an unbound binding\n  NilOverrideContext = 252,\n  NilParentScope = 253\n}\n\n/** @internal */\nexport class InternalObserversLookup {\n  public getOrCreate(flags: LifecycleFlags, obj: IBindingContext | IOverrideContext, key: string): PropertyObserver {\n    if (Tracer.enabled) { Tracer.enter('InternalObserversLookup.getOrCreate', slice.call(arguments)); }\n    let observer = this[key];\n    if (observer === undefined) {\n      observer = this[key] = new SetterObserver(flags, obj, key);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return observer;\n  }\n}\n\ntype BindingContextValue = ObservedCollection | StrictPrimitive | IIndexable;\n\nexport class BindingContext implements IBindingContext {\n  [key: string]: BindingContextValue;\n\n  public readonly $synthetic: true;\n\n  public $observers: ObserversLookup<IOverrideContext>;\n\n  private constructor(keyOrObj?: string | IIndexable, value?: BindingContextValue) {\n    this.$synthetic = true;\n\n    if (keyOrObj !== undefined) {\n      if (value !== undefined) {\n        // if value is defined then it's just a property and a value to initialize with\n        this[keyOrObj as string] = value;\n      } else {\n        // can either be some random object or another bindingContext to clone from\n        for (const prop in keyOrObj as IIndexable) {\n          if (keyOrObj.hasOwnProperty(prop)) {\n            this[prop] = keyOrObj[prop];\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Create a new synthetic `BindingContext` for use in a `Scope`.\n   * @param obj Optional. An existing object or `BindingContext` to (shallow) clone (own) properties from.\n   */\n  public static create(flags: LifecycleFlags, obj?: IIndexable): BindingContext;\n  /**\n   * Create a new synthetic `BindingContext` for use in a `Scope`.\n   * @param key The name of the only property to initialize this `BindingContext` with.\n   * @param value The value of the only property to initialize this `BindingContext` with.\n   */\n  public static create(flags: LifecycleFlags, key: string, value: BindingContextValue): BindingContext;\n  /**\n   * Create a new synthetic `BindingContext` for use in a `Scope`.\n   *\n   * This overload signature is simply the combined signatures of the other two, and can be used\n   * to keep strong typing in situations where the arguments are dynamic.\n   */\n  public static create(flags: LifecycleFlags, keyOrObj?: string | IIndexable, value?: BindingContextValue): BindingContext;\n  public static create(flags: LifecycleFlags, keyOrObj?: string | IIndexable, value?: BindingContextValue): BindingContext {\n    const bc = new BindingContext(keyOrObj, value);\n    if (flags & LifecycleFlags.useProxies) {\n      return ProxyObserver.getOrCreate(bc).proxy;\n    }\n    return bc;\n  }\n\n  public static get(scope: IScope, name: string, ancestor: number, flags: LifecycleFlags): IBindingContext | IOverrideContext | IBinding {\n    if (Tracer.enabled) { Tracer.enter('BindingContext.get', slice.call(arguments)); }\n    if (scope === undefined) {\n      throw Reporter.error(RuntimeError.UndefinedScope);\n    }\n    if (scope === null) {\n      throw Reporter.error(RuntimeError.NullScope);\n    }\n    let overrideContext = scope.overrideContext;\n\n    if (ancestor > 0) {\n      // jump up the required number of ancestor contexts (eg $parent.$parent requires two jumps)\n      while (ancestor > 0) {\n        if (overrideContext.parentOverrideContext === null) {\n          if (Tracer.enabled) { Tracer.leave(); }\n          return undefined;\n        }\n        ancestor--;\n        overrideContext = overrideContext.parentOverrideContext;\n      }\n\n      if (Tracer.enabled) { Tracer.leave(); }\n      return name in overrideContext ? overrideContext : overrideContext.bindingContext;\n    }\n\n    // traverse the context and it's ancestors, searching for a context that has the name.\n    while (overrideContext && !(name in overrideContext) && !(overrideContext.bindingContext && name in overrideContext.bindingContext)) {\n      overrideContext = overrideContext.parentOverrideContext;\n    }\n\n    if (overrideContext) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      // we located a context with the property.  return it.\n      return name in overrideContext ? overrideContext : overrideContext.bindingContext;\n    }\n\n    // the name wasn't found. see if parent scope traversal is allowed and if so, try that\n    if ((flags & LifecycleFlags.allowParentScopeTraversal) && scope.parentScope !== null) {\n      const result = this.get(scope.parentScope, name, ancestor, flags\n        // unset the flag; only allow one level of scope boundary traversal\n        & ~LifecycleFlags.allowParentScopeTraversal\n        // tell the scope to return null if the name could not be found\n        | LifecycleFlags.isTraversingParentScope);\n      if (result !== null) {\n        if (Tracer.enabled) { Tracer.leave(); }\n        return result;\n      }\n    }\n\n    // still nothing found. return the root binding context (or null\n    // if this is a parent scope traversal, to ensure we fall back to the\n    // correct level)\n    if (flags & LifecycleFlags.isTraversingParentScope) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return null;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return scope.bindingContext || scope.overrideContext;\n  }\n\n  public getObservers(flags: LifecycleFlags): ObserversLookup<IOverrideContext> {\n    if (Tracer.enabled) { Tracer.enter('BindingContext.getObservers', slice.call(arguments)); }\n    let observers = this.$observers;\n    if (observers === undefined) {\n      this.$observers = observers = new InternalObserversLookup() as ObserversLookup<IOverrideContext>;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return observers;\n  }\n}\n\nexport class Scope implements IScope {\n  public bindingContext: IBindingContext | IBinding;\n  public overrideContext: IOverrideContext;\n  // parentScope is strictly internal API and mainly for replaceable template controller.\n  // NOT intended for regular scope traversal!\n  /** @internal */public readonly parentScope: IScope | null;\n\n  private constructor(bindingContext: IBindingContext | IBinding, overrideContext: IOverrideContext) {\n    this.bindingContext = bindingContext;\n    this.overrideContext = overrideContext;\n    this.parentScope = null;\n  }\n\n  /**\n   * Create a new `Scope` backed by the provided `BindingContext` and a new standalone `OverrideContext`.\n   *\n   * Use this overload when the scope is for the root component, in a unit test,\n   * or when you simply want to prevent binding expressions from traversing up the scope.\n   * @param bc The `BindingContext` to back the `Scope` with.\n   */\n  public static create(flags: LifecycleFlags, bc: IBindingContext | IBinding): Scope;\n  /**\n   * Create a new `Scope` backed by the provided `BindingContext` and `OverrideContext`.\n   *\n   * @param bc The `BindingContext` to back the `Scope` with.\n   * @param oc The `OverrideContext` to back the `Scope` with.\n   * If a binding expression attempts to access a property that does not exist on the `BindingContext`\n   * during binding, it will traverse up via the `parentOverrideContext` of the `OverrideContext` until\n   * it finds the property.\n   */\n  public static create(flags: LifecycleFlags, bc: IBindingContext | IBinding, oc: IOverrideContext): Scope;\n  /**\n   * Create a new `Scope` backed by the provided `BindingContext` and `OverrideContext`.\n   *\n   * Use this overload when the scope is for the root component, in a unit test,\n   * or when you simply want to prevent binding expressions from traversing up the scope.\n   *\n   * @param bc The `BindingContext` to back the `Scope` with.\n   * @param oc null. This overload is functionally equivalent to not passing this argument at all.\n   */\n  public static create(flags: LifecycleFlags, bc: IBindingContext | IBinding, oc: null): Scope;\n  public static create(flags: LifecycleFlags, bc: IBindingContext | IBinding, oc?: IOverrideContext | null): Scope {\n    if (Tracer.enabled) { Tracer.enter('Scope.create', slice.call(arguments)); }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return new Scope(bc, oc === null || oc === undefined ? OverrideContext.create(flags, bc, oc) : oc);\n  }\n\n  public static fromOverride(flags: LifecycleFlags, oc: IOverrideContext): Scope {\n    if (Tracer.enabled) { Tracer.enter('Scope.fromOverride', slice.call(arguments)); }\n    if (oc === null || oc === undefined) {\n      throw Reporter.error(RuntimeError.NilOverrideContext);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return new Scope(oc.bindingContext, oc);\n  }\n\n  public static fromParent(flags: LifecycleFlags, ps: IScope | null, bc: IBindingContext | IBinding): Scope {\n    if (Tracer.enabled) { Tracer.enter('Scope.fromParent', slice.call(arguments)); }\n    if (ps === null || ps === undefined) {\n      throw Reporter.error(RuntimeError.NilParentScope);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return new Scope(bc, OverrideContext.create(flags, bc, ps.overrideContext));\n  }\n}\n\nexport class OverrideContext implements IOverrideContext {\n  [key: string]: ObservedCollection | StrictPrimitive | IIndexable;\n\n  public readonly $synthetic: true;\n  public bindingContext: IBindingContext | IBinding;\n  public parentOverrideContext: IOverrideContext | null;\n\n  private constructor(bindingContext: IBindingContext | IBinding, parentOverrideContext: IOverrideContext | null) {\n    this.$synthetic = true;\n    this.bindingContext = bindingContext;\n    this.parentOverrideContext = parentOverrideContext;\n  }\n\n  public static create(flags: LifecycleFlags, bc: IBindingContext | IBinding, poc: IOverrideContext | null): OverrideContext {\n    if (Tracer.enabled) { Tracer.enter('OverrideContext.create', slice.call(arguments)); }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return new OverrideContext(bc, poc === undefined ? null : poc);\n  }\n\n  public getObservers(): ObserversLookup<IOverrideContext> {\n    if (Tracer.enabled) { Tracer.enter('OverrideContext.getObservers', slice.call(arguments)); }\n    let observers = this.$observers;\n    if (observers === undefined) {\n      this.$observers = observers = new InternalObserversLookup();\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return observers as ObserversLookup<IOverrideContext>;\n  }\n}\n","import { DI, Immutable } from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport { IPropertySubscriber } from '../observation';\n\ntype Signal = string;\n\nexport interface ISignaler {\n  signals: Immutable<Record<string, Set<IPropertySubscriber>>>;\n  dispatchSignal(name: Signal, flags?: LifecycleFlags): void;\n  addSignalListener(name: Signal, listener: IPropertySubscriber): void;\n  removeSignalListener(name: Signal, listener: IPropertySubscriber): void;\n}\n\nexport const ISignaler = DI.createInterface<ISignaler>('ISignaler').withDefault(x => x.singleton(Signaler));\n\n/** @internal */\nexport class Signaler implements ISignaler {\n  public signals: Record<string, Set<IPropertySubscriber>>;\n\n  constructor() {\n    this.signals = Object.create(null);\n  }\n\n  public dispatchSignal(name: Signal, flags?: LifecycleFlags): void {\n    const listeners = this.signals[name];\n    if (listeners === undefined) {\n      return;\n    }\n    for (const listener of listeners.keys()) {\n      listener.handleChange(undefined, undefined, flags | LifecycleFlags.updateTargetInstance);\n    }\n  }\n\n  public addSignalListener(name: Signal, listener: IPropertySubscriber): void {\n    const signals = this.signals;\n    const listeners = signals[name];\n    if (listeners === undefined) {\n      signals[name] = new Set([listener]);\n    } else {\n      listeners.add(listener);\n    }\n  }\n\n  public removeSignalListener(name: Signal, listener: IPropertySubscriber): void {\n    const listeners = this.signals[name];\n    if (listeners) {\n      listeners.delete(listener);\n    }\n  }\n}\n","import {\n  Class,\n  Constructable,\n  IContainer,\n  IResourceDefinition,\n  IResourceKind,\n  IResourceType,\n  Registration,\n  Writable\n} from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport { IBinding } from '../lifecycle';\nimport { IScope } from '../observation';\n\nexport interface IBindingBehavior {\n  bind(flags: LifecycleFlags, scope: IScope, binding: IBinding): void;\n  unbind(flags: LifecycleFlags, scope: IScope, binding: IBinding): void;\n}\n\nexport interface IBindingBehaviorDefinition extends IResourceDefinition { }\n\nexport interface IBindingBehaviorType extends IResourceType<IBindingBehaviorDefinition, IBindingBehavior> { }\n\nexport interface IBindingBehaviorResource extends\n  IResourceKind<IBindingBehaviorDefinition, IBindingBehavior, Class<IBindingBehavior>> {\n}\n\ntype BindingBehaviorDecorator = <TProto, TClass>(target: Class<TProto, TClass> & Partial<IBindingBehaviorType>) => Class<TProto, TClass> & IBindingBehaviorType;\n\nfunction register(this: IBindingBehaviorType, container: IContainer): void {\n  const resourceKey = BindingBehaviorResource.keyFrom(this.description.name);\n  container.register(Registration.singleton(resourceKey, this));\n}\n\nexport function bindingBehavior(name: string): BindingBehaviorDecorator;\nexport function bindingBehavior(definition: IBindingBehaviorDefinition): BindingBehaviorDecorator;\nexport function bindingBehavior(nameOrDefinition: string | IBindingBehaviorDefinition): BindingBehaviorDecorator {\n  return target => BindingBehaviorResource.define(nameOrDefinition, target);\n}\n\nfunction keyFrom(this: IBindingBehaviorResource, name: string): string {\n  return `${this.name}:${name}`;\n}\n\nfunction isType<T>(this: IBindingBehaviorResource, Type: T & Partial<IBindingBehaviorType>): Type is T & IBindingBehaviorType {\n  return Type.kind === this;\n}\n\nfunction define<T extends Constructable>(this: IBindingBehaviorResource, name: string, ctor: T): T & IBindingBehaviorType;\nfunction define<T extends Constructable>(this: IBindingBehaviorResource, ndefinition: IBindingBehaviorDefinition, ctor: T): T & IBindingBehaviorType;\nfunction define<T extends Constructable>(this: IBindingBehaviorResource, nameOrDefinition: string | IBindingBehaviorDefinition, ctor: T): T & IBindingBehaviorType {\n  const Type = ctor as T & Writable<IBindingBehaviorType>;\n  const description = typeof nameOrDefinition === 'string'\n    ? { name: nameOrDefinition }\n    : nameOrDefinition;\n\n  Type.kind = BindingBehaviorResource;\n  Type.description = description;\n  Type.register = register;\n\n  return Type;\n}\n\nexport const BindingBehaviorResource: IBindingBehaviorResource = {\n  name: 'binding-behavior',\n  keyFrom,\n  isType,\n  define\n};\n","import {\n  Class,\n  Constructable,\n  IContainer,\n  IResourceDefinition,\n  IResourceKind,\n  IResourceType,\n  Registration,\n  Writable\n} from '@aurelia/kernel';\n\nexport interface IValueConverter {\n  toView(input: unknown, ...args: unknown[]): unknown;\n  fromView?(input: unknown, ...args: unknown[]): unknown;\n}\n\nexport interface IValueConverterDefinition extends IResourceDefinition { }\n\nexport interface IValueConverterType extends IResourceType<IValueConverterDefinition, IValueConverter> { }\n\nexport interface IValueConverterResource extends\n  IResourceKind<IValueConverterDefinition, IValueConverter, Class<IValueConverter>> { }\n\ntype ValueConverterDecorator = <TProto, TClass>(target: Class<TProto, TClass> & Partial<IValueConverterType>) => Class<TProto, TClass> & IValueConverterType;\n\nfunction register(this: IValueConverterType, container: IContainer): void {\n  const resourceKey = this.kind.keyFrom(this.description.name);\n  container.register(Registration.singleton(resourceKey, this));\n}\n\nexport function valueConverter(name: string): ValueConverterDecorator;\nexport function valueConverter(definition: IValueConverterDefinition): ValueConverterDecorator;\nexport function valueConverter(nameOrDefinition: string | IValueConverterDefinition): ValueConverterDecorator {\n  return target => ValueConverterResource.define(nameOrDefinition, target);\n}\n\nfunction keyFrom(this: IValueConverterResource, name: string): string {\n  return `${this.name}:${name}`;\n}\n\nfunction isType<T>(this: IValueConverterResource, Type: T & Partial<IValueConverterType>): Type is T & IValueConverterType {\n  return Type.kind === this;\n}\n\nfunction define<T extends Constructable>(this: IValueConverterResource, name: string, ctor: T): T & IValueConverterType;\nfunction define<T extends Constructable>(this: IValueConverterResource, ndefinition: IValueConverterDefinition, ctor: T): T & IValueConverterType;\nfunction define<T extends Constructable>(this: IValueConverterResource, nameOrDefinition: string | IValueConverterDefinition, ctor: T): T & IValueConverterType {\n  const Type = ctor as T & Writable<IValueConverterType>;\n  const description = typeof nameOrDefinition === 'string'\n    ? { name: nameOrDefinition }\n    : nameOrDefinition;\n\n  Type.kind = ValueConverterResource;\n  Type.description = description;\n  Type.register = register;\n\n  return Type;\n}\n\nexport const ValueConverterResource: IValueConverterResource = {\n  name: 'value-converter',\n  keyFrom,\n  isType,\n  define\n};\n","import { IIndexable, IServiceLocator, PLATFORM, Reporter, StrictPrimitive } from '@aurelia/kernel';\nimport {\n  BinaryOperator,\n  BindingIdentifierOrPattern,\n  CallsFunction,\n  Connects,\n  HasAncestor,\n  HasBind,\n  HasUnbind,\n  IAccessKeyedExpression,\n  IAccessMemberExpression,\n  IAccessScopeExpression,\n  IAccessThisExpression,\n  IArrayBindingPattern,\n  IArrayLiteralExpression,\n  IAssignExpression,\n  IBinaryExpression,\n  IBindingBehaviorExpression,\n  IBindingIdentifier,\n  ICallFunctionExpression,\n  ICallMemberExpression,\n  ICallScopeExpression,\n  IConditionalExpression,\n  IExpression,\n  IForOfStatement,\n  IHtmlLiteralExpression,\n  IInterpolationExpression,\n  IObjectBindingPattern,\n  IObjectLiteralExpression,\n  IPrimitiveLiteralExpression,\n  IsAssign,\n  IsAssignable,\n  IsBinary,\n  IsBindingBehavior,\n  IsExpressionOrStatement,\n  IsLeftHandSide,\n  IsLiteral,\n  IsPrimary,\n  IsResource,\n  IsValueConverter,\n  ITaggedTemplateExpression,\n  ITemplateExpression,\n  IUnaryExpression,\n  IValueConverterExpression,\n  IVisitor,\n  Observes,\n  UnaryOperator\n} from '../ast';\nimport { ExpressionKind, LifecycleFlags } from '../flags';\nimport { IBinding } from '../lifecycle';\nimport { Collection, IBindingContext, IOverrideContext, IScope, ObservedCollection } from '../observation';\nimport { BindingContext } from '../observation/binding-context';\nimport { ISignaler } from '../observation/signaler';\nimport { BindingBehaviorResource, IBindingBehavior } from '../resources/binding-behavior';\nimport { IValueConverter, ValueConverterResource } from '../resources/value-converter';\nimport { IConnectableBinding } from './connectable';\n\nexport function connects(expr: IsExpressionOrStatement): expr is Connects {\n  return (expr.$kind & ExpressionKind.Connects) === ExpressionKind.Connects;\n}\nexport function observes(expr: IsExpressionOrStatement): expr is Observes {\n  return (expr.$kind & ExpressionKind.Observes) === ExpressionKind.Observes;\n}\nexport function callsFunction(expr: IsExpressionOrStatement): expr is CallsFunction {\n  return (expr.$kind & ExpressionKind.CallsFunction) === ExpressionKind.CallsFunction;\n}\nexport function hasAncestor(expr: IsExpressionOrStatement): expr is HasAncestor {\n  return (expr.$kind & ExpressionKind.HasAncestor) === ExpressionKind.HasAncestor;\n}\nexport function isAssignable(expr: IsExpressionOrStatement): expr is IsAssignable {\n  return (expr.$kind & ExpressionKind.IsAssignable) === ExpressionKind.IsAssignable;\n}\nexport function isLeftHandSide(expr: IsExpressionOrStatement): expr is IsLeftHandSide {\n  return (expr.$kind & ExpressionKind.IsLeftHandSide) === ExpressionKind.IsLeftHandSide;\n}\nexport function isPrimary(expr: IsExpressionOrStatement): expr is IsPrimary {\n  return (expr.$kind & ExpressionKind.IsPrimary) === ExpressionKind.IsPrimary;\n}\nexport function isResource(expr: IsExpressionOrStatement): expr is IsResource {\n  return (expr.$kind & ExpressionKind.IsResource) === ExpressionKind.IsResource;\n}\nexport function hasBind(expr: IsExpressionOrStatement): expr is HasBind {\n  return (expr.$kind & ExpressionKind.HasBind) === ExpressionKind.HasBind;\n}\nexport function hasUnbind(expr: IsExpressionOrStatement): expr is HasUnbind {\n  return (expr.$kind & ExpressionKind.HasUnbind) === ExpressionKind.HasUnbind;\n}\nexport function isLiteral(expr: IsExpressionOrStatement): expr is IsLiteral {\n  return (expr.$kind & ExpressionKind.IsLiteral) === ExpressionKind.IsLiteral;\n}\nexport function arePureLiterals(expressions: ReadonlyArray<IsExpressionOrStatement> | undefined): expressions is IsLiteral[] {\n  if (expressions === undefined || expressions.length === 0) {\n    return true;\n  }\n  for (let i = 0; i < expressions.length; ++i) {\n    if (!isPureLiteral(expressions[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nexport function isPureLiteral(expr: IsExpressionOrStatement): expr is IsLiteral {\n  if (isLiteral(expr)) {\n    switch (expr.$kind) {\n      case ExpressionKind.ArrayLiteral:\n        return arePureLiterals(expr.elements);\n      case ExpressionKind.ObjectLiteral:\n        return arePureLiterals(expr.values);\n      case ExpressionKind.Template:\n        return arePureLiterals(expr.expressions);\n      case ExpressionKind.PrimitiveLiteral:\n        return true;\n    }\n  }\n  return false;\n}\n\nconst enum RuntimeError {\n  NoLocator = 202,\n  NoBehaviorFound = 203,\n  BehaviorAlreadyApplied = 204,\n  NoConverterFound = 205,\n  NoBinding = 206,\n  NotAFunction = 207,\n  UnknownOperator = 208,\n  UndefinedScope = 250, // trying to evaluate on something that's not a valid binding\n  NullScope = 251, // trying to evaluate on an unbound binding\n}\n\nexport class BindingBehavior implements IBindingBehaviorExpression {\n  public readonly $kind: ExpressionKind.BindingBehavior;\n  public readonly expression: IsBindingBehavior;\n  public readonly name: string;\n  public readonly args: ReadonlyArray<IsAssign>;\n  public readonly behaviorKey: string;\n  private readonly expressionHasBind: boolean;\n  private readonly expressionHasUnbind: boolean;\n\n  constructor(expression: IsBindingBehavior, name: string, args: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.BindingBehavior;\n    this.expression = expression;\n    this.name = name;\n    this.args = args;\n    this.behaviorKey = BindingBehaviorResource.keyFrom(this.name);\n    this.expressionHasBind = hasBind(expression);\n    this.expressionHasUnbind = hasUnbind(expression);\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    return this.expression.evaluate(flags, scope, locator);\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, value: unknown): unknown {\n    return this.expression.assign(flags, scope, locator, value);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    this.expression.connect(flags, scope, binding);\n  }\n\n  public bind(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    if (scope === undefined) {\n      throw Reporter.error(RuntimeError.UndefinedScope, this);\n    }\n    if (scope === null) {\n      throw Reporter.error(RuntimeError.NullScope, this);\n    }\n    if (!binding) {\n      throw Reporter.error(RuntimeError.NoBinding, this);\n    }\n    const locator = binding.locator;\n    if (!locator) {\n      throw Reporter.error(RuntimeError.NoLocator, this);\n    }\n    if (this.expressionHasBind) {\n      (this.expression as BindingBehavior).bind(flags, scope, binding);\n    }\n    const behaviorKey = this.behaviorKey;\n    const behavior = locator.get<IBindingBehavior>(behaviorKey);\n    if (!behavior) {\n      throw Reporter.error(RuntimeError.NoBehaviorFound, this);\n    }\n    if (binding[behaviorKey] !== undefined && binding[behaviorKey] !== null) {\n      throw Reporter.error(RuntimeError.BehaviorAlreadyApplied, this);\n    }\n    binding[behaviorKey] = behavior;\n    behavior.bind.apply(behavior, ([flags, scope, binding] as unknown[]).concat(evalList(flags, scope, locator, this.args)));\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const behaviorKey = this.behaviorKey;\n    binding[behaviorKey].unbind(flags, scope, binding);\n    binding[behaviorKey] = null;\n    if (this.expressionHasUnbind) {\n      (this.expression as BindingBehavior | ValueConverter).unbind(flags, scope, binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitBindingBehavior(this);\n  }\n}\n\nexport class ValueConverter implements IValueConverterExpression {\n  public readonly $kind: ExpressionKind.ValueConverter;\n  public readonly expression: IsValueConverter;\n  public readonly name: string;\n  public readonly args: ReadonlyArray<IsAssign>;\n  public readonly converterKey: string;\n\n  constructor(expression: IsValueConverter, name: string, args: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.ValueConverter;\n    this.expression = expression;\n    this.name = name;\n    this.args = args;\n    this.converterKey = ValueConverterResource.keyFrom(this.name);\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    if (!locator) {\n      throw Reporter.error(RuntimeError.NoLocator, this);\n    }\n    const converter = locator.get<ValueConverter & IValueConverter>(this.converterKey);\n    if (!converter) {\n      throw Reporter.error(RuntimeError.NoConverterFound, this);\n    }\n    if ('toView' in converter) {\n      const args = this.args;\n      const len = args.length;\n      const result = Array(len + 1);\n      result[0] = this.expression.evaluate(flags, scope, locator);\n      for (let i = 0; i < len; ++i) {\n        result[i + 1] = args[i].evaluate(flags, scope, locator);\n      }\n      return converter.toView.apply(converter, result);\n    }\n    return this.expression.evaluate(flags, scope, locator);\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, value: unknown): unknown {\n    if (!locator) {\n      throw Reporter.error(RuntimeError.NoLocator, this);\n    }\n    const converter = locator.get<ValueConverter & IValueConverter>(this.converterKey);\n    if (!converter) {\n      throw Reporter.error(RuntimeError.NoConverterFound, this);\n    }\n    if ('fromView' in converter) {\n      value = converter.fromView.apply(converter, [value].concat(evalList(flags, scope, locator, this.args)));\n    }\n    return this.expression.assign(flags, scope, locator, value);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    if (scope === undefined) {\n      throw Reporter.error(RuntimeError.UndefinedScope, this);\n    }\n    if (scope === null) {\n      throw Reporter.error(RuntimeError.NullScope, this);\n    }\n    if (!binding) {\n      throw Reporter.error(RuntimeError.NoBinding, this);\n    }\n    const locator = binding.locator;\n    if (!locator) {\n      throw Reporter.error(RuntimeError.NoLocator, this);\n    }\n    this.expression.connect(flags, scope, binding);\n    const args = this.args;\n    for (let i = 0, ii = args.length; i < ii; ++i) {\n      args[i].connect(flags, scope, binding);\n    }\n    const converter = locator.get(this.converterKey) as { signals?: string[] };\n    if (!converter) {\n      throw Reporter.error(RuntimeError.NoConverterFound, this);\n    }\n    const signals = converter.signals;\n    if (signals === undefined) {\n      return;\n    }\n    const signaler = locator.get(ISignaler);\n    for (let i = 0, ii = signals.length; i < ii; ++i) {\n      signaler.addSignalListener(signals[i], binding);\n    }\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const locator = binding.locator;\n    const converter = locator.get(this.converterKey) as { signals?: string[] };\n    const signals = converter.signals;\n    if (signals === undefined) {\n      return;\n    }\n    const signaler = locator.get(ISignaler);\n    for (let i = 0, ii = signals.length; i < ii; ++i) {\n      signaler.removeSignalListener(signals[i], binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitValueConverter(this);\n  }\n}\n\nexport class Assign implements IAssignExpression {\n  public readonly $kind: ExpressionKind.Assign;\n  public readonly target: IsAssignable;\n  public readonly value: IsAssign;\n\n  constructor(target: IsAssignable, value: IsAssign) {\n    this.$kind = ExpressionKind.Assign;\n    this.target = target;\n    this.value = value;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    return this.target.assign(flags, scope, locator, this.value.evaluate(flags, scope, locator));\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    return;\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, value: unknown): unknown {\n    this.value.assign(flags, scope, locator, value);\n    return this.target.assign(flags, scope, locator, value);\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitAssign(this);\n  }\n}\n\nexport class Conditional implements IConditionalExpression {\n  public readonly $kind: ExpressionKind.Conditional;\n  public assign: IExpression['assign'];\n  public readonly condition: IsBinary;\n  public readonly yes: IsAssign;\n  public readonly no: IsAssign;\n\n  constructor(condition: IsBinary, yes: IsAssign, no: IsAssign) {\n    this.$kind = ExpressionKind.Conditional;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.condition = condition;\n    this.yes = yes;\n    this.no = no;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    return (!!this.condition.evaluate(flags, scope, locator))\n      ? this.yes.evaluate(flags, scope, locator)\n      : this.no.evaluate(flags, scope, locator);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const condition = this.condition;\n    if (condition.evaluate(flags, scope, null)) {\n      this.condition.connect(flags, scope, binding);\n      this.yes.connect(flags, scope, binding);\n    } else {\n      this.condition.connect(flags, scope, binding);\n      this.no.connect(flags, scope, binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitConditional(this);\n  }\n}\n\nexport class AccessThis implements IAccessThisExpression {\n  public static readonly $this: AccessThis = new AccessThis(0);\n  public static readonly $parent: AccessThis = new AccessThis(1);\n  public readonly $kind: ExpressionKind.AccessThis;\n  public assign: IExpression['assign'];\n  public connect: IExpression['connect'];\n  public readonly ancestor: number;\n\n  constructor(ancestor: number = 0) {\n    this.$kind = ExpressionKind.AccessThis;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.connect = PLATFORM.noop;\n    this.ancestor = ancestor;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): IBindingContext | undefined {\n    if (scope === undefined) {\n      throw Reporter.error(RuntimeError.UndefinedScope, this);\n    }\n    if (scope === null) {\n      throw Reporter.error(RuntimeError.NullScope, this);\n    }\n    let oc: IOverrideContext | null = scope.overrideContext;\n    let i = this.ancestor;\n    while (i-- && oc) {\n      oc = oc.parentOverrideContext;\n    }\n    return i < 1 && oc ? oc.bindingContext : undefined;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitAccessThis(this);\n  }\n}\n\nexport class AccessScope implements IAccessScopeExpression {\n  public readonly $kind: ExpressionKind.AccessScope;\n  public readonly name: string;\n  public readonly ancestor: number;\n\n  constructor(name: string, ancestor: number = 0) {\n    this.$kind = ExpressionKind.AccessScope;\n    this.name = name;\n    this.ancestor = ancestor;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): IBindingContext | IBinding | IOverrideContext {\n    const name = this.name;\n    return BindingContext.get(scope, name, this.ancestor, flags)[name];\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, value: unknown): unknown {\n    const name = this.name;\n    const context = BindingContext.get(scope, name, this.ancestor, flags);\n    return context ? (context[name] = value) : undefined;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const name = this.name;\n    const context = BindingContext.get(scope, name, this.ancestor, flags);\n    binding.observeProperty(flags, context, name);\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitAccessScope(this);\n  }\n}\n\nexport class AccessMember implements IAccessMemberExpression {\n  public readonly $kind: ExpressionKind.AccessMember;\n  public readonly object: IsLeftHandSide;\n  public readonly name: string;\n\n  constructor(object: IsLeftHandSide, name: string) {\n    this.$kind = ExpressionKind.AccessMember;\n    this.object = object;\n    this.name = name;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    const instance = this.object.evaluate(flags, scope, locator) as IIndexable;\n    return instance === null || instance === undefined ? instance : instance[this.name];\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, value: unknown): unknown {\n    let instance = this.object.evaluate(flags, scope, locator) as IIndexable;\n    if (instance === null || typeof instance !== 'object') {\n      instance = {};\n      this.object.assign(flags, scope, locator, instance);\n    }\n    instance[this.name] = value;\n    return value;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const obj = this.object.evaluate(flags, scope, null) as IIndexable;\n    this.object.connect(flags, scope, binding);\n    if (obj) {\n      binding.observeProperty(flags, obj, this.name);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitAccessMember(this);\n  }\n}\n\nexport class AccessKeyed implements IAccessKeyedExpression {\n  public readonly $kind: ExpressionKind.AccessKeyed;\n  public readonly object: IsLeftHandSide;\n  public readonly key: IsAssign;\n\n  constructor(object: IsLeftHandSide, key: IsAssign) {\n    this.$kind = ExpressionKind.AccessKeyed;\n    this.object = object;\n    this.key = key;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    const instance = this.object.evaluate(flags, scope, locator) as IIndexable;\n    if (instance === null || instance === undefined) {\n      return undefined;\n    }\n    const key = this.key.evaluate(flags, scope, locator) as string;\n    // note: getKeyed and setKeyed are removed because they are identical to the default spec behavior\n    // and the runtime does this this faster\n    return instance[key];\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, value: unknown): unknown {\n    const instance = this.object.evaluate(flags, scope, locator) as IIndexable;\n    const key = this.key.evaluate(flags, scope, locator) as string;\n    return instance[key] = value;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const obj = this.object.evaluate(flags, scope, null);\n    this.object.connect(flags, scope, binding);\n    if (typeof obj === 'object' && obj !== null) {\n      this.key.connect(flags, scope, binding);\n      const key = this.key.evaluate(flags, scope, null);\n      // observe the property represented by the key as long as it's not an array indexer\n      // (note: string indexers behave the same way as numeric indexers as long as they represent numbers)\n      if (!(Array.isArray(obj) && isNumeric(key))) {\n        binding.observeProperty(flags, obj, key as string);\n      }\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitAccessKeyed(this);\n  }\n}\n\nexport class CallScope implements ICallScopeExpression {\n  public readonly $kind: ExpressionKind.CallScope;\n  public assign: IExpression['assign'];\n  public readonly name: string;\n  public readonly args: ReadonlyArray<IsAssign>;\n  public readonly ancestor: number;\n\n  constructor(name: string, args: ReadonlyArray<IsAssign>, ancestor: number = 0) {\n    this.$kind = ExpressionKind.CallScope;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.name = name;\n    this.args = args;\n    this.ancestor = ancestor;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator | null): unknown {\n    const args = evalList(flags, scope, locator, this.args);\n    const context = BindingContext.get(scope, this.name, this.ancestor, flags);\n    const func = getFunction(flags, context, this.name);\n    if (func) {\n      return func.apply(context, args);\n    }\n    return undefined;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const args = this.args;\n    for (let i = 0, ii = args.length; i < ii; ++i) {\n      args[i].connect(flags, scope, binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitCallScope(this);\n  }\n}\n\nexport class CallMember implements ICallMemberExpression {\n  public readonly $kind: ExpressionKind.CallMember;\n  public assign: IExpression['assign'];\n  public readonly object: IsLeftHandSide;\n  public readonly name: string;\n  public readonly args: ReadonlyArray<IsAssign>;\n\n  constructor(object: IsLeftHandSide, name: string, args: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.CallMember;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.object = object;\n    this.name = name;\n    this.args = args;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    const instance = this.object.evaluate(flags, scope, locator) as IIndexable;\n    const args = evalList(flags, scope, locator, this.args);\n    const func = getFunction(flags, instance, this.name);\n    if (func) {\n      return func.apply(instance, args);\n    }\n    return undefined;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const obj = this.object.evaluate(flags, scope, null) as IIndexable;\n    this.object.connect(flags, scope, binding);\n    if (getFunction(flags & ~LifecycleFlags.mustEvaluate, obj, this.name)) {\n      const args = this.args;\n      for (let i = 0, ii = args.length; i < ii; ++i) {\n        args[i].connect(flags, scope, binding);\n      }\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitCallMember(this);\n  }\n}\n\nexport class CallFunction implements ICallFunctionExpression {\n  public readonly $kind: ExpressionKind.CallFunction;\n  public assign: IExpression['assign'];\n  public readonly func: IsLeftHandSide;\n  public readonly args: ReadonlyArray<IsAssign>;\n\n  constructor(func: IsLeftHandSide, args: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.CallFunction;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.func = func;\n    this.args = args;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    const func = this.func.evaluate(flags, scope, locator);\n    if (typeof func === 'function') {\n      return func.apply(null, evalList(flags, scope, locator, this.args));\n    }\n    if (!(flags & LifecycleFlags.mustEvaluate) && (func === null || func === undefined)) {\n      return undefined;\n    }\n    throw Reporter.error(RuntimeError.NotAFunction, this);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const func = this.func.evaluate(flags, scope, null);\n    this.func.connect(flags, scope, binding);\n    if (typeof func === 'function') {\n      const args = this.args;\n      for (let i = 0, ii = args.length; i < ii; ++i) {\n        args[i].connect(flags, scope, binding);\n      }\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitCallFunction(this);\n  }\n}\n\nexport class Binary implements IBinaryExpression {\n  public readonly $kind: ExpressionKind.Binary;\n  public assign: IExpression['assign'];\n  public readonly operation: BinaryOperator;\n  public readonly left: IsBinary;\n  public readonly right: IsBinary;\n\n  constructor(operation: BinaryOperator, left: IsBinary, right: IsBinary) {\n    this.$kind = ExpressionKind.Binary;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.operation = operation;\n    this.left = left;\n    this.right = right;\n\n    // what we're doing here is effectively moving the large switch statement from evaluate to the constructor\n    // so that the check only needs to be done once, and evaluate (which is called many times) will have a lot less\n    // work to do; we can do this because the operation can't change after it's parsed\n    this.evaluate = this[operation] as IExpression['evaluate'];\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    throw Reporter.error(RuntimeError.UnknownOperator, this);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const left = this.left.evaluate(flags, scope, null);\n    this.left.connect(flags, scope, binding);\n    if (this.operation === '&&' && !left || this.operation === '||' && left) {\n      return;\n    }\n    this.right.connect(flags, scope, binding);\n  }\n\n  private ['&&'](f: LifecycleFlags, s: IScope, l: IServiceLocator): unknown {\n    return this.left.evaluate(f, s, l) && this.right.evaluate(f, s, l);\n  }\n  private ['||'](f: LifecycleFlags, s: IScope, l: IServiceLocator): unknown {\n    return this.left.evaluate(f, s, l) || this.right.evaluate(f, s, l);\n  }\n  private ['=='](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    // tslint:disable-next-line:triple-equals\n    return this.left.evaluate(f, s, l) == this.right.evaluate(f, s, l);\n  }\n  private ['==='](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return this.left.evaluate(f, s, l) === this.right.evaluate(f, s, l);\n  }\n  private ['!='](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    // tslint:disable-next-line:triple-equals\n    return this.left.evaluate(f, s, l) != this.right.evaluate(f, s, l);\n  }\n  private ['!=='](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return this.left.evaluate(f, s, l) !== this.right.evaluate(f, s, l);\n  }\n  private ['instanceof'](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    const right = this.right.evaluate(f, s, l);\n    if (typeof right === 'function') {\n      return this.left.evaluate(f, s, l) instanceof right;\n    }\n    return false;\n  }\n  private ['in'](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    const right = this.right.evaluate(f, s, l);\n    if (right !== null && typeof right === 'object') {\n      return this.left.evaluate(f, s, l) as string in right;\n    }\n    return false;\n  }\n  // note: autoConvertAdd (and the null check) is removed because the default spec behavior is already largely similar\n  // and where it isn't, you kind of want it to behave like the spec anyway (e.g. return NaN when adding a number to undefined)\n  // this makes bugs in user code easier to track down for end users\n  // also, skipping these checks and leaving it to the runtime is a nice little perf boost and simplifies our code\n  private ['+'](f: LifecycleFlags, s: IScope, l: IServiceLocator): number {\n    return (this.left.evaluate(f, s, l) as number) + (this.right.evaluate(f, s, l) as number);\n  }\n  private ['-'](f: LifecycleFlags, s: IScope, l: IServiceLocator): number {\n    return (this.left.evaluate(f, s, l) as number) - (this.right.evaluate(f, s, l) as number);\n  }\n  private ['*'](f: LifecycleFlags, s: IScope, l: IServiceLocator): number {\n    return (this.left.evaluate(f, s, l) as number) * (this.right.evaluate(f, s, l) as number);\n  }\n  private ['/'](f: LifecycleFlags, s: IScope, l: IServiceLocator): number {\n    return (this.left.evaluate(f, s, l) as number) / (this.right.evaluate(f, s, l) as number);\n  }\n  private ['%'](f: LifecycleFlags, s: IScope, l: IServiceLocator): number {\n    return (this.left.evaluate(f, s, l) as number) % (this.right.evaluate(f, s, l) as number);\n  }\n  private ['<'](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return (this.left.evaluate(f, s, l) as number) < (this.right.evaluate(f, s, l) as number);\n  }\n  private ['>'](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return (this.left.evaluate(f, s, l) as number) > (this.right.evaluate(f, s, l) as number);\n  }\n  private ['<='](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return (this.left.evaluate(f, s, l) as number) <= (this.right.evaluate(f, s, l) as number);\n  }\n  private ['>='](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return (this.left.evaluate(f, s, l) as number) >= (this.right.evaluate(f, s, l) as number);\n  }\n\n  // tslint:disable-next-line:member-ordering\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitBinary(this);\n  }\n}\n\nexport class Unary implements IUnaryExpression {\n  public readonly $kind: ExpressionKind.Unary;\n  public assign: IExpression['assign'];\n  public readonly operation: UnaryOperator;\n  public readonly expression: IsLeftHandSide;\n\n  constructor(operation: UnaryOperator, expression: IsLeftHandSide) {\n    this.$kind = ExpressionKind.Unary;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.operation = operation;\n    this.expression = expression;\n\n    // see Binary (we're doing the same thing here)\n    this.evaluate = this[operation] as IExpression['evaluate'];\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    throw Reporter.error(RuntimeError.UnknownOperator, this);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    this.expression.connect(flags, scope, binding);\n  }\n\n  public ['void'](f: LifecycleFlags, s: IScope, l: IServiceLocator): undefined {\n    return void this.expression.evaluate(f, s, l);\n  }\n  public ['typeof'](f: LifecycleFlags, s: IScope, l: IServiceLocator): string {\n    return typeof this.expression.evaluate(f, s, l);\n  }\n  public ['!'](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return !this.expression.evaluate(f, s, l);\n  }\n  public ['-'](f: LifecycleFlags, s: IScope, l: IServiceLocator): number {\n    return -(this.expression.evaluate(f, s, l) as number);\n  }\n  public ['+'](f: LifecycleFlags, s: IScope, l: IServiceLocator): number {\n    return +(this.expression.evaluate(f, s, l) as number);\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitUnary(this);\n  }\n}\nexport class PrimitiveLiteral<TValue extends StrictPrimitive = StrictPrimitive> implements IPrimitiveLiteralExpression {\n  public static readonly $undefined: PrimitiveLiteral<undefined> = new PrimitiveLiteral<undefined>(undefined);\n  public static readonly $null: PrimitiveLiteral<null> = new PrimitiveLiteral<null>(null);\n  public static readonly $true: PrimitiveLiteral<true> = new PrimitiveLiteral<true>(true);\n  public static readonly $false: PrimitiveLiteral<false> = new PrimitiveLiteral<false>(false);\n  public static readonly $empty: PrimitiveLiteral<string> = new PrimitiveLiteral<''>('');\n  public readonly $kind: ExpressionKind.PrimitiveLiteral;\n  public connect: IExpression['connect'];\n  public assign: IExpression['assign'];\n  public readonly value: TValue;\n\n  constructor(value: TValue) {\n    this.$kind = ExpressionKind.PrimitiveLiteral;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.connect = PLATFORM.noop;\n    this.value = value;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): TValue {\n    return this.value;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitPrimitiveLiteral(this);\n  }\n}\n\nexport class HtmlLiteral implements IHtmlLiteralExpression {\n  public readonly $kind: ExpressionKind.HtmlLiteral;\n  public assign: IExpression['assign'];\n  public readonly parts: ReadonlyArray<HtmlLiteral>;\n\n  constructor(parts: ReadonlyArray<HtmlLiteral>) {\n    this.$kind = ExpressionKind.HtmlLiteral;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.parts = parts;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): string {\n    const elements = this.parts;\n    let result = '';\n    for (let i = 0, ii = elements.length; i < ii; ++i) {\n      const value = elements[i].evaluate(flags, scope, locator);\n      if (value === undefined || value === null) {\n        continue;\n      }\n      result += value;\n    }\n    return result;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    for (let i = 0, ii = this.parts.length; i < ii; ++i) {\n      this.parts[i].connect(flags, scope, binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitHtmlLiteral(this);\n  }\n}\n\nexport class ArrayLiteral implements IArrayLiteralExpression {\n  public static readonly $empty: ArrayLiteral = new ArrayLiteral(PLATFORM.emptyArray);\n  public readonly $kind: ExpressionKind.ArrayLiteral;\n  public assign: IExpression['assign'];\n  public readonly elements: ReadonlyArray<IsAssign>;\n\n  constructor(elements: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.ArrayLiteral;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.elements = elements;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): ReadonlyArray<unknown> {\n    const elements = this.elements;\n    const length = elements.length;\n    const result = Array(length);\n    for (let i = 0; i < length; ++i) {\n      result[i] = elements[i].evaluate(flags, scope, locator);\n    }\n    return result;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const elements = this.elements;\n    for (let i = 0, ii = elements.length; i < ii; ++i) {\n      elements[i].connect(flags, scope, binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitArrayLiteral(this);\n  }\n}\n\nexport class ObjectLiteral implements IObjectLiteralExpression {\n  public static readonly $empty: ObjectLiteral = new ObjectLiteral(PLATFORM.emptyArray, PLATFORM.emptyArray);\n  public readonly $kind: ExpressionKind.ObjectLiteral;\n  public assign: IExpression['assign'];\n  public readonly keys: ReadonlyArray<number | string>;\n  public readonly values: ReadonlyArray<IsAssign>;\n\n  constructor(keys: ReadonlyArray<number | string>, values: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.ObjectLiteral;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.keys = keys;\n    this.values = values;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): Record<string, unknown> {\n    const instance: Record<string, unknown> = {};\n    const keys = this.keys;\n    const values = this.values;\n    for (let i = 0, ii = keys.length; i < ii; ++i) {\n      instance[keys[i]] = values[i].evaluate(flags, scope, locator);\n    }\n    return instance;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const keys = this.keys;\n    const values = this.values;\n    for (let i = 0, ii = keys.length; i < ii; ++i) {\n      values[i].connect(flags, scope, binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitObjectLiteral(this);\n  }\n}\n\nexport class Template implements ITemplateExpression {\n  public static readonly $empty: Template = new Template(['']);\n  public readonly $kind: ExpressionKind.Template;\n  public assign: IExpression['assign'];\n  public readonly cooked: ReadonlyArray<string>;\n  public readonly expressions: ReadonlyArray<IsAssign>;\n\n  constructor(cooked: ReadonlyArray<string>, expressions?: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.Template;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.cooked = cooked;\n    this.expressions = expressions === undefined ? PLATFORM.emptyArray : expressions;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): string {\n    const expressions = this.expressions;\n    const cooked = this.cooked;\n    let result = cooked[0];\n    for (let i = 0, ii = expressions.length; i < ii; ++i) {\n      result += expressions[i].evaluate(flags, scope, locator);\n      result += cooked[i + 1];\n    }\n    return result;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const expressions = this.expressions;\n    for (let i = 0, ii = expressions.length; i < ii; ++i) {\n      expressions[i].connect(flags, scope, binding);\n      i++;\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitTemplate(this);\n  }\n}\n\nexport class TaggedTemplate implements ITaggedTemplateExpression {\n  public readonly $kind: ExpressionKind.TaggedTemplate;\n  public assign: IExpression['assign'];\n  public readonly cooked: ReadonlyArray<string> & { raw?: ReadonlyArray<string> };\n  public readonly func: IsLeftHandSide;\n  public readonly expressions: ReadonlyArray<IsAssign>;\n\n  constructor(cooked: ReadonlyArray<string> & { raw?: ReadonlyArray<string> }, raw: ReadonlyArray<string>, func: IsLeftHandSide, expressions?: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.TaggedTemplate;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.cooked = cooked;\n    this.cooked.raw = raw;\n    this.func = func;\n    this.expressions = expressions === undefined ? PLATFORM.emptyArray : expressions;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): string {\n    const expressions = this.expressions;\n    const len = expressions.length;\n    const results = Array(len);\n    for (let i = 0, ii = len; i < ii; ++i) {\n      results[i] = expressions[i].evaluate(flags, scope, locator);\n    }\n    const func = this.func.evaluate(flags, scope, locator);\n    if (typeof func !== 'function') {\n      throw Reporter.error(RuntimeError.NotAFunction, this);\n    }\n    return func.apply(null, [this.cooked].concat(results));\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const expressions = this.expressions;\n    for (let i = 0, ii = expressions.length; i < ii; ++i) {\n      expressions[i].connect(flags, scope, binding);\n    }\n    this.func.connect(flags, scope, binding);\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitTaggedTemplate(this);\n  }\n}\n\nexport class ArrayBindingPattern implements IArrayBindingPattern {\n  public readonly $kind: ExpressionKind.ArrayBindingPattern;\n  public readonly elements: ReadonlyArray<IsAssign>;\n\n  // We'll either have elements, or keys+values, but never all 3\n  constructor(elements: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.ArrayBindingPattern;\n    this.elements = elements;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    // TODO\n    return undefined;\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, obj: IIndexable): unknown {\n    // TODO\n    return undefined;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    return;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitArrayBindingPattern(this);\n  }\n}\n\nexport class ObjectBindingPattern implements IObjectBindingPattern {\n  public readonly $kind: ExpressionKind.ObjectBindingPattern;\n  public readonly keys: ReadonlyArray<string | number>;\n  public readonly values: ReadonlyArray<IsAssign>;\n\n  // We'll either have elements, or keys+values, but never all 3\n  constructor(keys: ReadonlyArray<string | number>, values: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.ObjectBindingPattern;\n    this.keys = keys;\n    this.values = values;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    // TODO\n    return undefined;\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, obj: IIndexable): unknown {\n    // TODO\n    return undefined;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    return;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitObjectBindingPattern(this);\n  }\n}\n\nexport class BindingIdentifier implements IBindingIdentifier {\n  public readonly $kind: ExpressionKind.BindingIdentifier;\n  public readonly name: string;\n\n  constructor(name: string) {\n    this.$kind = ExpressionKind.BindingIdentifier;\n    this.name = name;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator | null): string {\n    return this.name;\n  }\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    return;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitBindingIdentifier(this);\n  }\n}\n\nconst toStringTag = Object.prototype.toString;\n\n// https://tc39.github.io/ecma262/#sec-iteration-statements\n// https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements\nexport class ForOfStatement implements IForOfStatement {\n  public readonly $kind: ExpressionKind.ForOfStatement;\n  public assign: IExpression['assign'];\n  public readonly declaration: BindingIdentifierOrPattern;\n  public readonly iterable: IsBindingBehavior;\n\n  constructor(declaration: BindingIdentifierOrPattern, iterable: IsBindingBehavior) {\n    this.$kind = ExpressionKind.ForOfStatement;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.declaration = declaration;\n    this.iterable = iterable;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    return this.iterable.evaluate(flags, scope, locator);\n  }\n\n  public count(result: ObservedCollection | number | null | undefined): number {\n    return CountForOfStatement[toStringTag.call(result)](result);\n  }\n\n  public iterate(result: ObservedCollection | number | null | undefined, func: (arr: Collection, index: number, item: unknown) => void): void {\n    IterateForOfStatement[toStringTag.call(result)](result, func);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    this.declaration.connect(flags, scope, binding);\n    this.iterable.connect(flags, scope, binding);\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitForOfStatement(this);\n  }\n}\n\n/*\n* Note: this implementation is far simpler than the one in vCurrent and might be missing important stuff (not sure yet)\n* so while this implementation is identical to Template and we could reuse that one, we don't want to lock outselves in to potentially the wrong abstraction\n* but this class might be a candidate for removal if it turns out it does provide all we need\n*/\nexport class Interpolation implements IInterpolationExpression {\n  public readonly $kind: ExpressionKind.Interpolation;\n  public assign: IExpression['assign'];\n  public readonly parts: ReadonlyArray<string>;\n  public readonly expressions: ReadonlyArray<IsBindingBehavior>;\n  public readonly isMulti: boolean;\n  public readonly firstExpression: IsBindingBehavior;\n  constructor(parts: ReadonlyArray<string>, expressions?: ReadonlyArray<IsBindingBehavior>) {\n    this.$kind = ExpressionKind.Interpolation;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.parts = parts;\n    this.expressions = expressions === undefined ? PLATFORM.emptyArray : expressions;\n    this.isMulti = this.expressions.length > 1;\n    this.firstExpression = this.expressions[0];\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): string {\n    if (this.isMulti) {\n      const expressions = this.expressions;\n      const parts = this.parts;\n      let result = parts[0];\n      for (let i = 0, ii = expressions.length; i < ii; ++i) {\n        result += expressions[i].evaluate(flags, scope, locator);\n        result += parts[i + 1];\n      }\n      return result;\n    } else {\n      const parts = this.parts;\n      return parts[0] + this.firstExpression.evaluate(flags, scope, locator) + parts[1];\n    }\n  }\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    return;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitInterpolation(this);\n  }\n}\n\n/// Evaluate the [list] in context of the [scope].\nfunction evalList(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator | null, list: ReadonlyArray<IExpression>): unknown[] {\n  const len = list.length;\n  const result = Array(len);\n  for (let i = 0; i < len; ++i) {\n    result[i] = list[i].evaluate(flags, scope, locator);\n  }\n  return result;\n}\n\nfunction getFunction(flags: LifecycleFlags, obj: IIndexable, name: string): (...args: unknown[]) => unknown | null {\n  const func = obj === null || obj === undefined ? null : obj[name];\n  if (typeof func === 'function') {\n    return func as (...args: unknown[]) => unknown;\n  }\n  if (!(flags & LifecycleFlags.mustEvaluate) && (func === null || func === undefined)) {\n    return null;\n  }\n  throw Reporter.error(RuntimeError.NotAFunction, obj, name, func);\n}\n\nfunction isNumeric(value: unknown): value is number {\n  const valueType = typeof value;\n  if (valueType === 'number') return true;\n  if (valueType !== 'string') return false;\n  const len = (value as string).length;\n  if (len === 0) return false;\n  for (let i = 0; i < len; ++i) {\n    const char = (value as string).charCodeAt(i);\n    if (char < 0x30 /*0*/ || char > 0x39/*9*/) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/** @internal */\nexport const IterateForOfStatement = {\n  ['[object Array]'](result: unknown[], func: (arr: Collection, index: number, item: unknown) => void): void {\n    for (let i = 0, ii = result.length; i < ii; ++i) {\n      func(result, i, result[i]);\n    }\n  },\n  ['[object Map]'](result: Map<unknown, unknown>, func: (arr: Collection, index: number, item: unknown) => void): void {\n    const arr = Array(result.size);\n    let i = -1;\n    for (const entry of result.entries()) {\n      arr[++i] = entry;\n    }\n    IterateForOfStatement['[object Array]'](arr, func);\n  },\n  ['[object Set]'](result: Set<unknown>, func: (arr: Collection, index: number, item: unknown) => void): void {\n    const arr = Array(result.size);\n    let i = -1;\n    for (const key of result.keys()) {\n      arr[++i] = key;\n    }\n    IterateForOfStatement['[object Array]'](arr, func);\n  },\n  ['[object Number]'](result: number, func: (arr: Collection, index: number, item: unknown) => void): void {\n    const arr = Array(result);\n    for (let i = 0; i < result; ++i) {\n      arr[i] = i;\n    }\n    IterateForOfStatement['[object Array]'](arr, func);\n  },\n  ['[object Null]'](result: null, func: (arr: Collection, index: number, item: unknown) => void): void {\n    return;\n  },\n  ['[object Undefined]'](result: null, func: (arr: Collection, index: number, item: unknown) => void): void {\n    return;\n  }\n};\n\n/** @internal */\nexport const CountForOfStatement = {\n  ['[object Array]'](result: unknown[]): number { return result.length; },\n  ['[object Map]'](result: Map<unknown, unknown>): number { return result.size; },\n  ['[object Set]'](result: Set<unknown>): number { return result.size; },\n  ['[object Number]'](result: number): number { return result; },\n  ['[object Null]'](result: null): number { return 0; },\n  ['[object Undefined]'](result: null): number { return 0; }\n};\n","import {\n  DI,\n  IContainer,\n  IDisposable,\n  Immutable,\n  InterfaceSymbol,\n  IResolver,\n  IServiceLocator,\n  PLATFORM,\n  Registration,\n  Tracer\n} from '@aurelia/kernel';\nimport { IConnectableBinding } from './binding/connectable';\nimport { ITargetedInstruction, TemplateDefinition, TemplatePartDefinitions } from './definitions';\nimport { INode, INodeSequence, IRenderLocation } from './dom';\nimport { Hooks, LifecycleFlags, State } from './flags';\nimport { IChangeTracker, IScope } from './observation';\n\nconst slice = Array.prototype.slice;\nexport interface IState {\n  $state?: State;\n  $lifecycle?: ILifecycle;\n}\n\nexport interface IBinding {\n  readonly $nextBinding: IBinding | null;\n  readonly $prevBinding: IBinding | null;\n  readonly locator: IServiceLocator;\n  readonly $scope: IScope | null;\n  readonly $state: State;\n  $bind(flags: LifecycleFlags, scope: IScope): void;\n  $unbind(flags: LifecycleFlags): void;\n}\n\n/**\n * An object containing the necessary information to render something for display.\n */\nexport interface IRenderable<T extends INode = INode> extends IState {\n  /**\n   * The Bindings that belong to this instance.\n   */\n  $bindingHead?: IBinding;\n  $bindingTail?: IBinding;\n\n  /**\n   * The Views, CustomElements, CustomAttributes and other components that are children of this instance.\n   */\n  $componentHead?: IComponent;\n  $componentTail?: IComponent;\n\n  /**\n   * The (dependency) context of this instance.\n   *\n   * Contains any dependencies required by this instance or its children.\n   */\n  readonly $context: IRenderContext<T>;\n\n  /**\n   * The nodes that represent the visible aspect of this instance.\n   *\n   * Typically this will be a sequence of `DOM` nodes contained in a `DocumentFragment`\n   */\n  readonly $nodes: INodeSequence<T>;\n\n  /**\n   * The binding scope that the `$bindables` of this instance will be bound to.\n   *\n   * This includes the `BindingContext` which can be either a user-defined view model instance, or a synthetic view model instantiated by a `templateController`\n   */\n  readonly $scope: IScope;\n}\n\nexport const IRenderable = DI.createInterface<IRenderable>('IRenderable').noDefault();\n\nexport interface IRenderContext<T extends INode = INode> extends IServiceLocator {\n  createChild(): IRenderContext<T>;\n  render(flags: LifecycleFlags, renderable: IRenderable<T>, targets: ArrayLike<object>, templateDefinition: TemplateDefinition, host?: T, parts?: TemplatePartDefinitions): void;\n  beginComponentOperation(renderable: IRenderable<T>, target: object, instruction: Immutable<ITargetedInstruction>, factory?: IViewFactory<T>, parts?: TemplatePartDefinitions, location?: IRenderLocation<T>, locationIsContainer?: boolean): IDisposable;\n}\n\nexport interface IView<T extends INode = INode> extends IRenderable<T>, IMountableComponent {\n  readonly cache: IViewCache<T>;\n  readonly isFree: boolean;\n  readonly location: IRenderLocation<T>;\n\n  /**\n   * Reserves this `IView` for mounting at a particular `IRenderLocation`.\n   * Also marks this `IView` such that it cannot be returned to the cache until\n   * it is released again.\n   *\n   * @param location The RenderLocation before which the view will be appended to the DOM.\n   */\n  hold(location: IRenderLocation<T>): void;\n\n  /**\n   * Marks this `IView` such that it can be returned to the cache when it is unmounted.\n   *\n   * If this `IView` is not currently attached, it will be unmounted immediately.\n   *\n   * @param flags The `LifecycleFlags` to pass to the unmount operation (only effective\n   * if the view is already in detached state).\n   *\n   * @returns Whether this `IView` can/will be returned to cache\n   */\n  release(flags: LifecycleFlags): boolean;\n\n  lockScope(scope: IScope): void;\n}\n\nexport interface IViewCache<T extends INode = INode> {\n  readonly isCaching: boolean;\n  setCacheSize(size: number | '*', doNotOverrideIfAlreadySet: boolean): void;\n  canReturnToCache(view: IView<T>): boolean;\n  tryReturnToCache(view: IView<T>): boolean;\n}\n\nexport interface IViewFactory<T extends INode = INode> extends IViewCache<T> {\n  readonly name: string;\n  create(flags?: LifecycleFlags): IView<T>;\n}\n\nexport const IViewFactory = DI.createInterface<IViewFactory>('IViewFactory').noDefault();\n\n/**\n * Defines optional lifecycle hooks that will be called only when they are implemented.\n */\nexport interface ILifecycleHooks extends IState {\n  $hooks?: Hooks;\n  /** @internal */$nextBound?: ILifecycleHooks;\n  /** @internal */$nextUnbound?: ILifecycleHooks;\n  /** @internal */$nextAttached?: ILifecycleHooks;\n  /** @internal */$nextDetached?: ILifecycleHooks;\n\n  /**\n   * Called at the end of `$hydrate`.\n   *\n   * @description\n   * This is the second and last \"hydrate\" lifecycle hook (after `render`). It happens only once per instance (contrary to bind/attach\n   * which can happen many times per instance), though it can happen many times per type (once for each instance)\n   *\n   * This hook is called right before the `$bind` lifecycle starts, making this the last opportunity\n   * for any high-level post processing on initialized properties.\n   */\n  created?(flags: LifecycleFlags): void;\n\n  /**\n   * Called at the start of `$bind`, before this instance and its children (if any) are bound.\n   *\n   * @description\n   * This is the first \"create\" lifecycle hook of the hooks that can occur multiple times per instance,\n   * and the third lifecycle hook (after `render` and `created`) of the very first this.lifecycle.\n   */\n  binding?(flags: LifecycleFlags): void;\n\n  /**\n   * Called at the end of `$bind`, after this instance and its children (if any) are bound.\n   *\n   * @description\n   * This is the second \"create\" lifecycle hook (after `binding`) of the hooks that can occur multiple times per instance,\n   * and the fourth lifecycle hook (after `render`, `created` and `binding`) of the very first this.lifecycle.\n   */\n  bound?(flags: LifecycleFlags): void;\n\n  /**\n   * Called at the start of `$unbind`, before this instance and its children (if any) are unbound.\n   *\n   * @description\n   * This is the fourth \"cleanup\" lifecycle hook (after `detaching`, `caching` and `detached`)\n   *\n   * Last opportunity to perform any source or target updates before the bindings are disconnected.\n   *\n   */\n  unbinding?(flags: LifecycleFlags): void;\n\n  /**\n   * Called at the end of `$unbind`, after this instance and its children (if any) are unbound.\n   *\n   * @description\n   * This is the fifth (and last) \"cleanup\" lifecycle hook (after `detaching`, `caching`, `detached`\n   * and `unbinding`).\n   *\n   * The lifecycle either ends here, or starts at `$bind` again.\n   */\n  unbound?(flags: LifecycleFlags): void;\n\n  /**\n   * Called at the start of `$attach`, before this instance and its children (if any) are attached.\n   *\n   * @description\n   * This is the third \"create\" lifecycle hook (after `binding` and `bound`) of the hooks that can occur multiple times per instance,\n   * and the fifth lifecycle hook (after `render`, `created`, `binding` and `bound`) of the very first lifecycle\n   *\n   * This is the time to add any (sync or async) tasks (e.g. animations) to the lifecycle that need to happen before\n   * the nodes are added to the DOM.\n   */\n  attaching?(flags: LifecycleFlags): void;\n\n  /**\n   * Called at the end of `$attach`, after this instance and its children (if any) are attached.\n   *\n   * @description\n   * This is the fourth (and last) \"create\" lifecycle hook (after `binding`, `bound` and `attaching`) of the hooks that can occur\n   * multiple times per instance, and the sixth lifecycle hook (after `render`, `created`, `binding`, `bound` and `attaching`)\n   * of the very first lifecycle\n   *\n   * This instance and its children (if any) can be assumed\n   * to be fully initialized, bound, rendered, added to the DOM and ready for use.\n   */\n  attached?(flags: LifecycleFlags): void;\n\n  /**\n   * Called at the start of `$detach`, before this instance and its children (if any) are detached.\n   *\n   * @description\n   * This is the first \"cleanup\" lifecycle hook.\n   *\n   * This is the time to add any (sync or async) tasks (e.g. animations) to the lifecycle that need to happen before\n   * the nodes are removed from the DOM.\n   */\n  detaching?(flags: LifecycleFlags): void;\n\n  /**\n   * Called at the end of `$detach`, after this instance and its children (if any) are detached.\n   *\n   * @description\n   * This is the third \"cleanup\" lifecycle hook (after `detaching` and `caching`).\n   *\n   * The `$nodes` are now removed from the DOM and the `View` (if possible) is returned to cache.\n   *\n   * If no `$unbind` lifecycle is queued, this is the last opportunity to make state changes before the lifecycle ends.\n   */\n  detached?(flags: LifecycleFlags): void;\n\n  /**\n   * Called during `$unmount` (which happens during `$detach`), specifically after the\n   * `$nodes` are removed from the DOM, but before the view is actually added to the cache.\n   *\n   * @description\n   * This is the second \"cleanup\" lifecycle hook.\n   *\n   * This lifecycle is invoked if and only if the `ViewFactory` that created the `View` allows the view to be cached.\n   *\n   * Usually this hook is not invoked unless you explicitly set the cache size to to something greater than zero\n   * on the resource description.\n   */\n  caching?(flags: LifecycleFlags): void;\n}\n\nexport interface IComponent {\n  readonly $nextComponent: IComponent | null;\n  readonly $prevComponent: IComponent | null;\n  $nextUnbindAfterDetach: IComponent | null;\n  $bind(flags: LifecycleFlags, scope?: IScope): void;\n  $unbind(flags: LifecycleFlags): void;\n  $attach(flags: LifecycleFlags): void;\n  $detach(flags: LifecycleFlags): void;\n  $cache(flags: LifecycleFlags): void;\n}\n\nexport interface IMountableComponent extends IComponent {\n  /** @internal */$nextMount?: IMountableComponent;\n  /** @internal */$nextUnmount?: IMountableComponent;\n\n  /**\n   * Add the `$nodes` of this instance to the Host or RenderLocation that this instance is holding.\n   */\n  $mount(flags: LifecycleFlags): void;\n\n  /**\n   * Remove the `$nodes` of this instance from the Host or RenderLocation that this instance is holding, optionally returning them to a cache.\n   * @returns\n   * - `true` if the instance has been returned to the cache.\n   * - `false` if the cache (typically ViewFactory) did not allow the instance to be cached.\n   * - `undefined` (void) if the instance does not support caching. Functionally equivalent to `false`\n   */\n  $unmount(flags: LifecycleFlags): boolean | void;\n}\n\nconst marker = Object.freeze(Object.create(null));\n\n/*\n * Note: the lifecycle object ensures that certain callbacks are executed in a particular order that may\n * deviate from the order in which the component tree is walked.\n * The component tree is always walked in a top-down recursive fashion, for example:\n * {\n *   path: \"1\",\n *   children: [\n *     { path: \"1.1\", children: [\n *       { path: \"1.1.1\" },\n *       { path: \"1.1.2\" }\n *     ]},\n *     { path: \"1.2\", children: [\n *       { path: \"1.2.1\" },\n *       { path: \"1.2.2\" }\n *     ]}\n *   ]\n * }\n * The call chain would be: 1 -> 1.1 -> 1.1.1 -> 1.1.2 -> 1.2 -> 1.2.1 -> 1.2.2\n *\n * During mounting, for example, we want to mount the root component *last* (so that the DOM doesn't need to be updated\n * for each mount operation), and we want to invoke the detached callbacks in the same order that the components were mounted.\n * But all mounts need to happen before any of the detach callbacks are invoked, so we store the components in a LinkedList\n * whose execution is deferred until all the normal $attach/$detach calls have occurred.\n * In the example of attach, the call chains would look like this:\n * $attach: 1 -> 1.1 -> 1.1.1 -> 1.1.2 -> 1.2 -> 1.2.1 -> 1.2.2\n * $mount: 1.1.1 -> 1.1.2 -> 1.1 -> 1.2.1 -> 1.2.2 -> 1.2 -> 1\n * attached: 1.1.1 -> 1.1.2 -> 1.1 -> 1.2.1 -> 1.2.2 -> 1.2 -> 1\n *\n * Instead of (without the lifecycles):\n * $attach: 1, $mount: 1, detached: 1 -> $attach: 1.1, $mount: 1.1, detached: 1.1 -> etc..\n *\n * Furthermore, the lifecycle object tracks the call depth so that it will automatically run a list of operations\n * when the top-most component finishes execution, and components themselves don't need to worry about where in the\n * tree they reside.\n */\n\nexport interface ILifecycle {\n  processFlushQueue(flags: LifecycleFlags): void;\n\n  /**\n   * Queue a flush() callback to be executed either on the next promise tick or on the next\n   * bind lifecycle (if during startTask) or on the next attach lifecycle.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   *\n   * This queue is primarily used by DOM target observers and collection observers.\n   */\n  enqueueFlush(requestor: IChangeTracker): Promise<void>;\n\n  processConnectQueue(flags: LifecycleFlags): void;\n  processPatchQueue(flags: LifecycleFlags): void;\n  processBindQueue(flags: LifecycleFlags): void;\n  processUnbindQueue(flags: LifecycleFlags): void;\n\n  /**\n   * Open up / expand a bind batch for enqueueing `bound` callbacks.\n   *\n   * When the top-most caller calls `endBind`, the `bound` callbacks will be invoked.\n   *\n   * Each `beginBind` *must* be matched by an `endBind`.\n   */\n  beginBind(): void;\n\n  /**\n   * Add a `bound` callback to the queue, to be invoked when the current bind batch\n   * is ended via `endBind` by the top-most caller.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   */\n  enqueueBound(requestor: ILifecycleHooks): void;\n\n  /**\n   * Add a `connect` callback to the queue, to be invoked *after* mounting and *before*\n   * `detached` callbacks.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   */\n  enqueueConnect(requestor: IConnectableBinding): void;\n\n  /**\n   * Close / shrink a bind batch for invoking queued `bound` callbacks.\n   * @param flags The flags that will be passed into the `bound` callbacks.\n   *\n   * Flags during bind are primarily for optimization purposes, and to control whether\n   * changes are batched or propagated synchronously.\n   * If unsure which flags to provide, it's OK to use `LifecycleFlags.none` (or simply `0`)\n   * This default will work, but is generally less efficient.\n   */\n  endBind(flags: LifecycleFlags): ILifecycleTask;\n\n  /**\n   * Open up / expand an unbind batch for enqueueing `unbound` callbacks.\n   *\n   * When the top-most caller calls `endUnbind`, the `unbound` callbacks will be invoked.\n   *\n   * Each `beginUnbind` *must* be matched by an `endUnbind`.\n   */\n  beginUnbind(): void;\n\n  /**\n   * Add an `unbound` callback to the queue, to be invoked when the current unbind batch\n   * is ended via `endUnbind` by the top-most caller.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   */\n  enqueueUnbound(requestor: ILifecycleHooks): void;\n\n  /**\n   * Close / shrink an unbind batch for invoking queued `unbound` callbacks.\n   * @param flags The flags that will be passed into the `unbound` callbacks.\n   *\n   * Flags during unbind are primarily for optimization purposes, and to control whether\n   * changes are batched or propagated synchronously.\n   * If unsure which flags to provide, it's OK to use `LifecycleFlags.none` (or simply `0`)\n   * This default will work, but is generally less efficient.\n   */\n  endUnbind(flags: LifecycleFlags): ILifecycleTask;\n\n  processAttachQueue(flags: LifecycleFlags): void;\n  processDetachQueue(flags: LifecycleFlags): void;\n\n  /**\n   * Open up / expand an attach batch for enqueueing `$mount` and `attached` callbacks.\n   *\n   * When the top-most caller calls `endAttach`, the `$mount` and `attached` callbacks\n   * will be invoked (in that order).\n   *\n   * Each `beginAttach` *must* be matched by an `endAttach`.\n   */\n  beginAttach(): void;\n\n  /**\n   * Add a `$mount` callback to the queue, to be invoked when the current attach batch\n   * is ended via `endAttach` by the top-most caller.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   */\n  enqueueMount(requestor: IMountableComponent): void;\n\n  /**\n   * Add an `attached` callback to the queue, to be invoked when the current attach batch\n   * is ended via `endAttach` by the top-most caller.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   */\n  enqueueAttached(requestor: ILifecycleHooks): void;\n\n  /**\n   * Close / shrink an attach batch for invoking queued `$mount` and `attached` callbacks.\n   * @param flags The flags that will be passed into the `$mount` and `attached` callbacks.\n   *\n   * Flags during attach are primarily for optimization purposes.\n   * If unsure which flags to provide, it's OK to use `LifecycleFlags.none` (or simply `0`)\n   * This default will work, but is generally less efficient.\n   */\n  endAttach(flags: LifecycleFlags): ILifecycleTask;\n\n  /**\n   * Open up / expand a detach batch for enqueueing `$unmount` and `detached` callbacks.\n   *\n   * When the top-most caller calls `endAttach`, the `$unmount` and `detached` callbacks\n   * will be invoked (in that order).\n   *\n   * Each `beginAttach` *must* be matched by an `endAttach`.\n   */\n  beginDetach(): void;\n\n  /**\n   * Add a `$unmount` callback to the queue, to be invoked when the current detach batch\n   * is ended via `endAttach` by the top-most caller.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   */\n  enqueueUnmount(requestor: IMountableComponent): void;\n\n  /**\n   * Add a `detached` callback to the queue, to be invoked when the current detach batch\n   * is ended via `endAttach` by the top-most caller.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   */\n  enqueueDetached(requestor: ILifecycleHooks): void;\n\n  /**\n   * Add an `$unbind` callback to the queue, to be invoked when the current detach batch\n   * is ended via `endAttach` by the top-most caller. The callback is invoked after all the\n   * `$unmount` and `detached` callbacks are processed.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   */\n  enqueueUnbindAfterDetach(requestor: IComponent): void;\n\n  /**\n   * Close / shrink a detach batch for invoking queued `$unmount` and `detached` callbacks.\n   * @param flags The flags that will be passed into the `$unmount` and `detached` callbacks.\n   *\n   * Flags during detach are primarily for optimization purposes, and to control whether a\n   * component should be unmounted or not (the default is to only unmount root nodes).\n   * If unsure which flags to provide, it's OK to use `LifecycleFlags.none` (or simply `0`).\n   * This default will work, but is generally less efficient.\n   */\n  endDetach(flags: LifecycleFlags): ILifecycleTask;\n\n  registerTask(task: ILifecycleTask): void;\n  finishTask(task: ILifecycleTask): void;\n}\n\nexport const ILifecycle = DI.createInterface<ILifecycle>('ILifecycle').withDefault(x => x.singleton(Lifecycle));\n\n/** @internal */\nexport class Lifecycle implements ILifecycle {\n  /** @internal */public bindDepth: number;\n  /** @internal */public attachDepth: number;\n  /** @internal */public detachDepth: number;\n  /** @internal */public unbindDepth: number;\n\n  /** @internal */public flushHead: IChangeTracker;\n  /** @internal */public flushTail: IChangeTracker;\n\n  /** @internal */public connectHead: IConnectableBinding;\n  /** @internal */public connectTail: IConnectableBinding;\n\n  /** @internal */public patchHead: IConnectableBinding;\n  /** @internal */public patchTail: IConnectableBinding;\n\n  /** @internal */public boundHead: ILifecycleHooks;\n  /** @internal */public boundTail: ILifecycleHooks;\n\n  /** @internal */public mountHead: IMountableComponent;\n  /** @internal */public mountTail: IMountableComponent;\n\n  /** @internal */public attachedHead: ILifecycleHooks;\n  /** @internal */public attachedTail: ILifecycleHooks;\n\n  /** @internal */public unmountHead: IMountableComponent;\n  /** @internal */public unmountTail: IMountableComponent;\n\n  /** @internal */public detachedHead: ILifecycleHooks;\n  /** @internal */public detachedTail: ILifecycleHooks;\n\n  /** @internal */public unbindAfterDetachHead: IComponent;\n  /** @internal */public unbindAfterDetachTail: IComponent;\n\n  /** @internal */public unboundHead: ILifecycleHooks;\n  /** @internal */public unboundTail: ILifecycleHooks;\n\n  /** @internal */public flushed: Promise<void>;\n  /** @internal */public promise: Promise<void>;\n\n  /** @internal */public flushCount: number;\n  /** @internal */public connectCount: number;\n  /** @internal */public patchCount: number;\n  /** @internal */public boundCount: number;\n  /** @internal */public mountCount: number;\n  /** @internal */public attachedCount: number;\n  /** @internal */public unmountCount: number;\n  /** @internal */public detachedCount: number;\n  /** @internal */public unbindAfterDetachCount: number;\n  /** @internal */public unboundCount: number;\n\n  // These are dummy properties to make the lifecycle conform to the interfaces\n  // of the components it manages. This allows the lifecycle itself to be the first link\n  // in the chain and removes the need for an additional null check on each addition.\n  /** @internal */public $nextFlush: IChangeTracker;\n  /** @internal */public flush: IChangeTracker['flush'];\n  /** @internal */public $nextConnect: IConnectableBinding;\n  /** @internal */public connect: IConnectableBinding['connect'];\n  /** @internal */public $nextPatch: IConnectableBinding;\n  /** @internal */public patch: IConnectableBinding['patch'];\n  /** @internal */public $nextBound: ILifecycleHooks;\n  /** @internal */public bound: ILifecycleHooks['bound'];\n  /** @internal */public $nextMount: IMountableComponent;\n  /** @internal */public $mount: IMountableComponent['$mount'];\n  /** @internal */public $nextAttached: ILifecycleHooks;\n  /** @internal */public attached: ILifecycleHooks['attached'];\n  /** @internal */public $nextUnmount: IMountableComponent;\n  /** @internal */public $unmount: IMountableComponent['$unmount'];\n  /** @internal */public $nextDetached: ILifecycleHooks;\n  /** @internal */public detached: ILifecycleHooks['detached'];\n  /** @internal */public $nextUnbindAfterDetach: IComponent;\n  /** @internal */public $unbind: IComponent['$unbind'];\n  /** @internal */public $nextUnbound: ILifecycleHooks;\n  /** @internal */public unbound: ILifecycleHooks['unbound'];\n\n  /** @internal */public task: AggregateLifecycleTask | null;\n\n  constructor() {\n    this.bindDepth = 0;\n    this.attachDepth = 0;\n    this.detachDepth = 0;\n    this.unbindDepth = 0;\n\n    this.flushHead = this;\n    this.flushTail = this;\n\n    this.connectHead = this as unknown as IConnectableBinding; // this cast is safe because we know exactly which properties we'll use\n    this.connectTail = this as unknown as IConnectableBinding;\n\n    this.patchHead = this as unknown as IConnectableBinding;\n    this.patchTail = this as unknown as IConnectableBinding;\n\n    this.boundHead = this;\n    this.boundTail = this;\n\n    this.mountHead = this as unknown as IMountableComponent;\n    this.mountTail = this as unknown as IMountableComponent;\n\n    this.attachedHead = this;\n    this.attachedTail = this;\n\n    this.unmountHead = this as unknown as IMountableComponent;\n    this.unmountTail = this as unknown as IMountableComponent;\n\n    this.detachedHead = this; //LOL\n    this.detachedTail = this;\n\n    this.unbindAfterDetachHead = this as unknown as IComponent;\n    this.unbindAfterDetachTail = this as unknown as IComponent;\n\n    this.unboundHead = this;\n    this.unboundTail = this;\n\n    this.flushed = null;\n    this.promise = Promise.resolve();\n\n    this.flushCount = 0;\n    this.connectCount = 0;\n    this.patchCount = 0;\n    this.boundCount = 0;\n    this.mountCount = 0;\n    this.attachedCount = 0;\n    this.unmountCount = 0;\n    this.detachedCount = 0;\n    this.unbindAfterDetachCount = 0;\n    this.unboundCount = 0;\n\n    this.$nextFlush = marker;\n    this.flush = PLATFORM.noop;\n    this.$nextConnect = marker;\n    this.connect = PLATFORM.noop;\n    this.$nextPatch = marker;\n    this.patch = PLATFORM.noop;\n    this.$nextBound = marker;\n    this.bound = PLATFORM.noop;\n    this.$nextMount = marker;\n    this.$mount = PLATFORM.noop;\n    this.$nextAttached = marker;\n    this.attached = PLATFORM.noop;\n    this.$nextUnmount = marker;\n    this.$unmount = PLATFORM.noop;\n    this.$nextDetached = marker;\n    this.detached = PLATFORM.noop;\n    this.$nextUnbindAfterDetach = marker;\n    this.$unbind = PLATFORM.noop;\n    this.$nextUnbound = marker;\n    this.unbound = PLATFORM.noop;\n\n    this.task = null;\n  }\n\n  public static register(container: IContainer): IResolver<ILifecycle> {\n    return Registration.singleton(ILifecycle, this).register(container);\n  }\n\n  public registerTask(task: ILifecycleTask): void {\n    if (this.task === null) {\n      this.task = new AggregateLifecycleTask();\n    }\n    this.task.addTask(task);\n  }\n\n  public finishTask(task: ILifecycleTask): void {\n    if (this.task !== null) {\n      if (this.task === task) {\n        this.task = null;\n      } else {\n        this.task.removeTask(task);\n      }\n    }\n  }\n\n  public enqueueFlush(requestor: IChangeTracker): Promise<void> {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.enqueueFlush', slice.call(arguments)); }\n    // Queue a flush() callback; the depth is just for debugging / testing purposes and has\n    // no effect on execution. flush() will automatically be invoked when the promise resolves,\n    // or it can be manually invoked synchronously.\n    if (this.flushHead === this) {\n      this.flushed = this.promise.then(() => { this.processFlushQueue(LifecycleFlags.fromAsyncFlush); });\n    }\n    if (requestor.$nextFlush === null) {\n      requestor.$nextFlush = marker;\n      this.flushTail.$nextFlush = requestor;\n      this.flushTail = requestor;\n      ++this.flushCount;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return this.flushed;\n  }\n\n  public processFlushQueue(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.processFlushQueue', slice.call(arguments)); }\n    flags |= LifecycleFlags.fromSyncFlush;\n    // flush callbacks may lead to additional flush operations, so keep looping until\n    // the flush head is back to `this` (though this will typically happen in the first iteration)\n    while (this.flushCount > 0) {\n      let current = this.flushHead.$nextFlush;\n      this.flushHead = this.flushTail = this;\n      this.flushCount = 0;\n      let next: typeof current;\n      do {\n        next = current.$nextFlush;\n        current.$nextFlush = null;\n        current.flush(flags);\n        current = next;\n      } while (current !== marker);\n      // doNotUpdateDOM will cause DOM updates to be re-queued which results in an infinite loop\n      // unless we break here\n      // Note that breaking on this flag is still not the ideal solution; future improvement would\n      // be something like a separate DOM queue and a non-DOM queue, but for now this fixes the infinite\n      // loop without breaking anything (apart from the edgiest of edge cases which are not yet tested)\n      if (flags & LifecycleFlags.doNotUpdateDOM) {\n        break;\n      }\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public beginBind(): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.beginBind', slice.call(arguments)); }\n    ++this.bindDepth;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public enqueueBound(requestor: ILifecycleHooks): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.enqueueBound', slice.call(arguments)); }\n    // build a standard singly linked list for bound callbacks\n    if (requestor.$nextBound === null) {\n      requestor.$nextBound = marker;\n      this.boundTail.$nextBound = requestor;\n      this.boundTail = requestor;\n      ++this.boundCount;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public enqueueConnect(requestor: IConnectableBinding): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.enqueueConnect', slice.call(arguments)); }\n    // enqueue connect and patch calls in separate lists so that they can be invoked\n    // independently from eachother\n    // TODO: see if we can eliminate/optimize some of this, because this is a relatively hot path\n    // (first get all the necessary integration tests working, then look for optimizations)\n\n    // build a standard singly linked list for connect callbacks\n    if (requestor.$nextConnect === null) {\n      requestor.$nextConnect = marker;\n      this.connectTail.$nextConnect = requestor;\n      this.connectTail = requestor;\n      ++this.connectCount;\n    }\n    // build a standard singly linked list for patch callbacks\n    if (requestor.$nextPatch === null) {\n      requestor.$nextPatch = marker;\n      this.patchTail.$nextPatch = requestor;\n      this.patchTail = requestor;\n      ++this.patchCount;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public processConnectQueue(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.processConnectQueue', slice.call(arguments)); }\n    // connects cannot lead to additional connects, so we don't need to loop here\n    if (this.connectCount > 0) {\n      this.connectCount = 0;\n      let current = this.connectHead.$nextConnect;\n      this.connectHead = this.connectTail = this as unknown as IConnectableBinding;\n      let next: typeof current;\n      do {\n        current.connect(flags);\n        next = current.$nextConnect;\n        current.$nextConnect = null;\n        current = next;\n      } while (current !== marker);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public processPatchQueue(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.processPatchQueue', slice.call(arguments)); }\n    // flush before patching, but only if this is the initial bind;\n    // no DOM is attached yet so we can safely let everything propagate\n    if (flags & LifecycleFlags.fromStartTask) {\n      this.processFlushQueue(flags | LifecycleFlags.fromSyncFlush);\n    }\n    // patch callbacks may lead to additional bind operations, so keep looping until\n    // the patch head is back to `this` (though this will typically happen in the first iteration)\n    while (this.patchCount > 0) {\n      this.patchCount = 0;\n      let current = this.patchHead.$nextPatch;\n      this.patchHead = this.patchTail = this as unknown as IConnectableBinding;\n      let next: typeof current;\n      do {\n        current.patch(flags);\n        next = current.$nextPatch;\n        current.$nextPatch = null;\n        current = next;\n      } while (current !== marker);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public endBind(flags: LifecycleFlags): ILifecycleTask {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.endBind', slice.call(arguments)); }\n    // close / shrink a bind batch\n    if (--this.bindDepth === 0) {\n      if (this.task !== null && !this.task.done) {\n        this.task.owner = this;\n        if (Tracer.enabled) { Tracer.leave(); }\n        return this.task;\n      }\n\n      this.processBindQueue(flags);\n\n      if (Tracer.enabled) { Tracer.leave(); }\n      return LifecycleTask.done;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public processBindQueue(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.processBindQueue', slice.call(arguments)); }\n    // flush before processing bound callbacks, but only if this is the initial bind;\n    // no DOM is attached yet so we can safely let everything propagate\n    if (flags & LifecycleFlags.fromStartTask) {\n      this.processFlushQueue(flags | LifecycleFlags.fromSyncFlush);\n    }\n    // bound callbacks may lead to additional bind operations, so keep looping until\n    // the bound head is back to `this` (though this will typically happen in the first iteration)\n    while (this.boundCount > 0) {\n      this.boundCount = 0;\n      let current = this.boundHead.$nextBound;\n      let next: ILifecycleHooks;\n      this.boundHead = this.boundTail = this;\n      do {\n        current.bound(flags);\n        next = current.$nextBound;\n        current.$nextBound = null;\n        current = next;\n      } while (current !== marker);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public beginUnbind(): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.beginUnbind', slice.call(arguments)); }\n    // open up / expand an unbind batch; the very first caller will close it again with endUnbind\n    ++this.unbindDepth;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public enqueueUnbound(requestor: ILifecycleHooks): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.enqueueUnbound', slice.call(arguments)); }\n    // This method is idempotent; adding the same item more than once has the same effect as\n    // adding it once.\n    // build a standard singly linked list for unbound callbacks\n    if (requestor.$nextUnbound === null) {\n      requestor.$nextUnbound = marker;\n      this.unboundTail.$nextUnbound = requestor;\n      this.unboundTail = requestor;\n      ++this.unboundCount;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public endUnbind(flags: LifecycleFlags): ILifecycleTask {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.endUnbind', slice.call(arguments)); }\n    // close / shrink an unbind batch\n    if (--this.unbindDepth === 0) {\n      if (this.task !== null && !this.task.done) {\n        this.task.owner = this;\n        if (Tracer.enabled) { Tracer.leave(); }\n        return this.task;\n      }\n\n      this.processUnbindQueue(flags);\n\n      if (Tracer.enabled) { Tracer.leave(); }\n      return LifecycleTask.done;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public processUnbindQueue(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.processUnbindQueue', slice.call(arguments)); }\n    // unbound callbacks may lead to additional unbind operations, so keep looping until\n    // the unbound head is back to `this` (though this will typically happen in the first iteration)\n    while (this.unboundCount > 0) {\n      this.unboundCount = 0;\n      let current = this.unboundHead.$nextUnbound;\n      let next: ILifecycleHooks;\n      this.unboundHead = this.unboundTail = this;\n      do {\n        current.unbound(flags);\n        next = current.$nextUnbound;\n        current.$nextUnbound = null;\n        current = next;\n      } while (current !== marker);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public beginAttach(): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.beginAttach', slice.call(arguments)); }\n    // open up / expand an attach batch; the very first caller will close it again with endAttach\n    ++this.attachDepth;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public enqueueMount(requestor: IMountableComponent): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.enqueueMount', slice.call(arguments)); }\n    // This method is idempotent; adding the same item more than once has the same effect as\n    // adding it once.\n    // build a standard singly linked list for mount callbacks\n    if (requestor.$nextMount === null) {\n      requestor.$nextMount = marker;\n      this.mountTail.$nextMount = requestor;\n      this.mountTail = requestor;\n      ++this.mountCount;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public enqueueAttached(requestor: ILifecycleHooks): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.enqueueAttached', slice.call(arguments)); }\n    // This method is idempotent; adding the same item more than once has the same effect as\n    // adding it once.\n    // build a standard singly linked list for attached callbacks\n    if (requestor.$nextAttached === null) {\n      requestor.$nextAttached = marker;\n      this.attachedTail.$nextAttached = requestor;\n      this.attachedTail = requestor;\n      ++this.attachedCount;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public endAttach(flags: LifecycleFlags): ILifecycleTask {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.endAttach', slice.call(arguments)); }\n    // close / shrink an attach batch\n    if (--this.attachDepth === 0) {\n      if (this.task !== null && !this.task.done) {\n        this.task.owner = this;\n        if (Tracer.enabled) { Tracer.leave(); }\n        return this.task;\n      }\n\n      this.processAttachQueue(flags);\n\n      if (Tracer.enabled) { Tracer.leave(); }\n      return LifecycleTask.done;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public processAttachQueue(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.processAttachQueue', slice.call(arguments)); }\n    // flush and patch before starting the attach lifecycle to ensure batched collection changes are propagated to repeaters\n    // and the DOM is updated\n    this.processFlushQueue(flags | LifecycleFlags.fromSyncFlush);\n    // TODO: prevent duplicate updates coming from the patch queue (or perhaps it's just not needed in its entirety?)\n    //this.processPatchQueue(flags | LifecycleFlags.fromSyncFlush);\n\n    if (this.mountCount > 0) {\n      this.mountCount = 0;\n      let currentMount = this.mountHead.$nextMount;\n      this.mountHead = this.mountTail = this as unknown as IMountableComponent;\n      let nextMount: typeof currentMount;\n\n      do {\n        currentMount.$mount(flags);\n        nextMount = currentMount.$nextMount;\n        currentMount.$nextMount = null;\n        currentMount = nextMount;\n      } while (currentMount !== marker);\n    }\n    // Connect all connect-queued bindings AFTER mounting is done, so that the DOM is visible asap,\n    // but connect BEFORE running the attached callbacks to ensure any changes made during those callbacks\n    // are still accounted for.\n    // TODO: add a flag/option to further delay connect with a RAF callback (the tradeoff would be that we'd need\n    // to run an additional patch cycle before that connect, which can be expensive and unnecessary in most real\n    // world scenarios, but can significantly speed things up with nested, highly volatile data like in dbmonster)\n    this.processConnectQueue(LifecycleFlags.mustEvaluate);\n\n    if (this.attachedCount > 0) {\n      this.attachedCount = 0;\n      let currentAttached = this.attachedHead.$nextAttached;\n      this.attachedHead = this.attachedTail = this;\n      let nextAttached: typeof currentAttached;\n\n      do {\n        currentAttached.attached(flags);\n        nextAttached = currentAttached.$nextAttached;\n        currentAttached.$nextAttached = null;\n        currentAttached = nextAttached;\n      } while (currentAttached !== marker);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public beginDetach(): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.beginDetach', slice.call(arguments)); }\n    // open up / expand a detach batch; the very first caller will close it again with endDetach\n    ++this.detachDepth;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public enqueueUnmount(requestor: IMountableComponent): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.enqueueUnmount', slice.call(arguments)); }\n    // This method is idempotent; adding the same item more than once has the same effect as\n    // adding it once.\n    // build a standard singly linked list for unmount callbacks\n    if (requestor.$nextUnmount === null) {\n      requestor.$nextUnmount = marker;\n      this.unmountTail.$nextUnmount = requestor;\n      this.unmountTail = requestor;\n      ++this.unmountCount;\n    }\n    // this is a temporary solution until a cleaner method surfaces.\n    // if an item being queued for unmounting is already in the mount queue,\n    // remove it from the mount queue (this can occur in some very exotic situations\n    // and should be dealt with in a less hacky way)\n    if (requestor.$nextMount !== null) {\n      let current = this.mountHead;\n      let next = current.$nextMount;\n      while (next !== requestor) {\n        current = next;\n        next = current.$nextMount;\n      }\n      current.$nextMount = next.$nextMount;\n      next.$nextMount = null;\n      if (this.mountTail === next) {\n        this.mountTail = this as unknown as IMountableComponent;\n      }\n      --this.mountCount;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public enqueueDetached(requestor: ILifecycleHooks): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.enqueueDetached', slice.call(arguments)); }\n    // This method is idempotent; adding the same item more than once has the same effect as\n    // adding it once.\n    // build a standard singly linked list for detached callbacks\n    if (requestor.$nextDetached === null) {\n      requestor.$nextDetached = marker;\n      this.detachedTail.$nextDetached = requestor;\n      this.detachedTail = requestor;\n      ++this.detachedCount;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public enqueueUnbindAfterDetach(requestor: IComponent): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.enqueueUnbindAfterDetach', slice.call(arguments)); }\n    // This method is idempotent; adding the same item more than once has the same effect as\n    // adding it once.\n    // build a standard singly linked list for unbindAfterDetach callbacks\n    if (requestor.$nextUnbindAfterDetach === null) {\n      requestor.$nextUnbindAfterDetach = marker;\n      this.unbindAfterDetachTail.$nextUnbindAfterDetach = requestor;\n      this.unbindAfterDetachTail = requestor;\n      ++this.unbindAfterDetachCount;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public endDetach(flags: LifecycleFlags): ILifecycleTask {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.endDetach', slice.call(arguments)); }\n    // close / shrink a detach batch\n    if (--this.detachDepth === 0) {\n      if (this.task !== null && !this.task.done) {\n        this.task.owner = this;\n        return this.task;\n      }\n\n      this.processDetachQueue(flags);\n\n      if (Tracer.enabled) { Tracer.leave(); }\n      return LifecycleTask.done;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public processDetachQueue(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.processDetachQueue', slice.call(arguments)); }\n    // flush before unmounting to ensure batched collection changes propagate to the repeaters,\n    // which may lead to additional unmount operations\n    this.processFlushQueue(flags | LifecycleFlags.fromFlush | LifecycleFlags.doNotUpdateDOM);\n\n    if (this.unmountCount > 0) {\n      this.unmountCount = 0;\n      let currentUnmount = this.unmountHead.$nextUnmount;\n      this.unmountHead = this.unmountTail = this as unknown as IMountableComponent;\n      let nextUnmount: typeof currentUnmount;\n\n      do {\n        currentUnmount.$unmount(flags);\n        nextUnmount = currentUnmount.$nextUnmount;\n        currentUnmount.$nextUnmount = null;\n        currentUnmount = nextUnmount;\n      } while (currentUnmount !== marker);\n    }\n\n    if (this.detachedCount > 0) {\n      this.detachedCount = 0;\n      let currentDetached = this.detachedHead.$nextDetached;\n      this.detachedHead = this.detachedTail = this;\n      let nextDetached: typeof currentDetached;\n\n      do {\n        currentDetached.detached(flags);\n        nextDetached = currentDetached.$nextDetached;\n        currentDetached.$nextDetached = null;\n        currentDetached = nextDetached;\n      } while (currentDetached !== marker);\n    }\n\n    if (this.unbindAfterDetachCount > 0) {\n      this.beginUnbind();\n      this.unbindAfterDetachCount = 0;\n      let currentUnbind = this.unbindAfterDetachHead.$nextUnbindAfterDetach;\n      this.unbindAfterDetachHead = this.unbindAfterDetachTail = this as unknown as IComponent;\n      let nextUnbind: typeof currentUnbind;\n\n      do {\n        currentUnbind.$unbind(flags);\n        nextUnbind = currentUnbind.$nextUnbindAfterDetach;\n        currentUnbind.$nextUnbindAfterDetach = null;\n        currentUnbind = nextUnbind;\n      } while (currentUnbind !== marker);\n      this.endUnbind(flags);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\nexport class CompositionCoordinator {\n  public static readonly inject: ReadonlyArray<InterfaceSymbol> = [ILifecycle];\n\n  public readonly $lifecycle: ILifecycle;\n\n  public onSwapComplete: () => void;\n\n  private currentView: IView;\n  private isAttached: boolean;\n  private isBound: boolean;\n  private queue: (IView | PromiseSwap)[] | null;\n  private scope: IScope;\n  private swapTask: ILifecycleTask;\n\n  constructor($lifecycle: ILifecycle) {\n    this.$lifecycle = $lifecycle;\n\n    this.onSwapComplete = PLATFORM.noop;\n\n    this.currentView = null;\n    this.isAttached = false;\n    this.isBound = false;\n    this.queue = null;\n    this.swapTask = LifecycleTask.done;\n  }\n\n  public static register(container: IContainer): IResolver<CompositionCoordinator> {\n    return Registration.transient(this, this).register(container, this);\n  }\n\n  public compose(value: IView | Promise<IView>, flags: LifecycleFlags): void {\n    if (this.swapTask.done) {\n      if (value instanceof Promise) {\n        this.enqueue(new PromiseSwap(this, value));\n        this.processNext();\n      } else {\n        this.swap(value, flags);\n      }\n    } else {\n      if (value instanceof Promise) {\n        this.enqueue(new PromiseSwap(this, value));\n      } else {\n        this.enqueue(value);\n      }\n\n      if (this.swapTask.canCancel()) {\n        this.swapTask.cancel();\n      }\n    }\n  }\n\n  public binding(flags: LifecycleFlags, scope: IScope): void {\n    this.scope = scope;\n    this.isBound = true;\n\n    if (this.currentView !== null) {\n      this.currentView.$bind(flags, scope);\n    }\n  }\n\n  public attaching(flags: LifecycleFlags): void {\n    this.isAttached = true;\n\n    if (this.currentView !== null) {\n      this.currentView.$attach(flags);\n    }\n  }\n\n  public detaching(flags: LifecycleFlags): void {\n    this.isAttached = false;\n\n    if (this.currentView !== null) {\n      this.currentView.$detach(flags);\n    }\n  }\n\n  public unbinding(flags: LifecycleFlags): void {\n    this.isBound = false;\n\n    if (this.currentView !== null) {\n      this.currentView.$unbind(flags);\n    }\n  }\n\n  public caching(flags: LifecycleFlags): void {\n    this.currentView = null;\n  }\n\n  private enqueue(view: IView | PromiseSwap): void {\n    if (Tracer.enabled) { Tracer.enter('CompositionCoordinator.enqueue', slice.call(arguments)); }\n    if (this.queue === null) {\n      this.queue = [];\n    }\n\n    this.queue.push(view);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private swap(view: IView, flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('CompositionCoordinator.swap', slice.call(arguments)); }\n    if (this.currentView === view) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n\n    const $lifecycle = this.$lifecycle;\n    const swapTask = new AggregateLifecycleTask();\n\n    let lifecycleTask: ILifecycleTask;\n    let currentView = this.currentView;\n    if (currentView === null) {\n      lifecycleTask = LifecycleTask.done;\n    } else {\n      $lifecycle.enqueueUnbindAfterDetach(currentView);\n      $lifecycle.beginDetach();\n      currentView.$detach(flags);\n      lifecycleTask = $lifecycle.endDetach(flags);\n    }\n    swapTask.addTask(lifecycleTask);\n\n    currentView = this.currentView = view;\n\n    if (currentView === null) {\n      lifecycleTask = LifecycleTask.done;\n    } else {\n      if (this.isBound) {\n        $lifecycle.beginBind();\n        currentView.$bind(flags, this.scope);\n        $lifecycle.endBind(flags);\n      }\n      if (this.isAttached) {\n        $lifecycle.beginAttach();\n        currentView.$attach(flags);\n        lifecycleTask = $lifecycle.endAttach(flags);\n      } else {\n        lifecycleTask = LifecycleTask.done;\n      }\n    }\n    swapTask.addTask(lifecycleTask);\n\n    if (swapTask.done) {\n      this.swapTask = LifecycleTask.done;\n      this.onSwapComplete();\n    } else {\n      this.swapTask = swapTask;\n      this.swapTask.wait().then(() => {\n        this.onSwapComplete();\n        this.processNext();\n      }).catch(error => { throw error; });\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private processNext(): void {\n    if (Tracer.enabled) { Tracer.enter('CompositionCoordinator.processNext', slice.call(arguments)); }\n    if (this.queue !== null && this.queue.length > 0) {\n      const next = this.queue.pop();\n      this.queue.length = 0;\n\n      if (PromiseSwap.is(next)) {\n        this.swapTask = next.start();\n      } else {\n        this.swap(next, LifecycleFlags.fromLifecycleTask);\n      }\n    } else {\n      this.swapTask = LifecycleTask.done;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\nexport const LifecycleTask = {\n  done: {\n    done: true,\n    canCancel(): boolean { return false; },\n    cancel(): void { return; },\n    wait(): Promise<unknown> { return Promise.resolve(); }\n  }\n};\n\nexport interface ILifecycleTask<T = unknown> {\n  readonly done: boolean;\n  canCancel(): boolean;\n  cancel(): void;\n  wait(): Promise<T>;\n}\n\nexport class AggregateLifecycleTask implements ILifecycleTask<void> {\n  public done: boolean;\n\n  /** @internal */\n  public owner: Lifecycle;\n\n  private readonly tasks: ILifecycleTask[];\n  private resolve: () => void;\n  private waiter: Promise<void>;\n\n  constructor() {\n    this.done = true;\n\n    this.owner = null;\n\n    this.resolve = null;\n    this.tasks = [];\n    this.waiter = null;\n  }\n\n  public addTask(task: ILifecycleTask): void {\n    if (Tracer.enabled) { Tracer.enter('AggregateLifecycleTask.addTask', slice.call(arguments)); }\n    if (!task.done) {\n      this.done = false;\n      this.tasks.push(task);\n      task.wait().then(() => { this.tryComplete(); }).catch(error => { throw error; });\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public removeTask(task: ILifecycleTask): void {\n    if (Tracer.enabled) { Tracer.enter('AggregateLifecycleTask.removeTask', slice.call(arguments)); }\n    if (task.done) {\n      const idx = this.tasks.indexOf(task);\n      if (idx !== -1) {\n        this.tasks.splice(idx, 1);\n      }\n    }\n    if (this.tasks.length === 0 && this.owner !== null) {\n      this.owner.finishTask(this);\n      this.owner = null;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public canCancel(): boolean {\n    if (this.done) {\n      return false;\n    }\n\n    return this.tasks.every(x => x.canCancel());\n  }\n\n  public cancel(): void {\n    if (this.canCancel()) {\n      this.tasks.forEach(x => { x.cancel(); });\n      this.done = false;\n    }\n  }\n\n  public wait(): Promise<void> {\n    if (this.waiter === null) {\n      if (this.done) {\n        this.waiter = Promise.resolve();\n      } else {\n        // tslint:disable-next-line:promise-must-complete\n        this.waiter = new Promise((resolve) => this.resolve = resolve);\n      }\n    }\n\n    return this.waiter;\n  }\n\n  private tryComplete(): void {\n    if (this.done) {\n      return;\n    }\n\n    if (this.tasks.every(x => x.done)) {\n      this.complete(true);\n    }\n  }\n\n  private complete(notCancelled: boolean): void {\n    if (Tracer.enabled) { Tracer.enter('AggregateLifecycleTask.complete', slice.call(arguments)); }\n    this.done = true;\n\n    if (notCancelled && this.owner !== null) {\n      this.owner.processDetachQueue(LifecycleFlags.fromLifecycleTask);\n      this.owner.processUnbindQueue(LifecycleFlags.fromLifecycleTask);\n      this.owner.processBindQueue(LifecycleFlags.fromLifecycleTask);\n      this.owner.processAttachQueue(LifecycleFlags.fromLifecycleTask);\n    }\n    this.owner.finishTask(this);\n\n    if (this.resolve !== null) {\n      this.resolve();\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n/** @internal */\nexport class PromiseSwap implements ILifecycleTask<IView> {\n  public done: boolean;\n\n  private readonly coordinator: CompositionCoordinator;\n  private isCancelled: boolean;\n  private promise: Promise<IView>;\n\n  constructor(coordinator: CompositionCoordinator, promise: Promise<IView>) {\n    this.coordinator = coordinator;\n    this.done = false;\n    this.isCancelled = false;\n    this.promise = promise;\n  }\n\n  public static is(object: object): object is PromiseSwap {\n    return 'start' in object;\n  }\n\n  public start(): ILifecycleTask<IView | unknown> {\n    if (this.isCancelled) {\n      return LifecycleTask.done;\n    }\n\n    this.promise = this.promise.then(x => {\n      this.onResolve(x);\n      return x;\n    });\n\n    return this;\n  }\n\n  public canCancel(): boolean {\n    return !this.done;\n  }\n\n  public cancel(): void {\n    if (this.canCancel()) {\n      this.isCancelled = true;\n    }\n  }\n\n  public wait(): Promise<IView> {\n    return this.promise;\n  }\n\n  private onResolve(value: IView): void {\n    if (this.isCancelled) {\n      return;\n    }\n\n    this.done = true;\n    this.coordinator.compose(value, LifecycleFlags.fromLifecycleTask);\n  }\n}\n\n// tslint:disable:jsdoc-format\n/**\n * A general-purpose ILifecycleTask implementation that can be placed\n * before an attached, detached, bound or unbound hook during attaching,\n * detaching, binding or unbinding, respectively.\n *\n * The provided promise will be awaited before the corresponding lifecycle\n * hook (and any hooks following it) is invoked.\n *\n * The provided callback will be invoked after the promise is resolved\n * and before the next lifecycle hook.\n *\n * Example:\n```ts\nexport class MyViewModel {\n  private $lifecycle: ILifecycle; // set before created() hook\n  private answer: number;\n\n  public binding(flags: LifecycleFlags): void {\n    // this.answer === undefined\n    this.$lifecycle.registerTask(new PromiseTask(\n      this.getAnswerAsync,\n      answer => {\n        this.answer = answer;\n      }\n    ));\n  }\n\n  public bound(flags: LifecycleFlags): void {\n    // this.answer === 42\n  }\n\n  private getAnswerAsync(): Promise<number> {\n    return Promise.resolve().then(() => 42);\n  }\n}\n```\n */\n// tslint:enable:jsdoc-format\nexport class PromiseTask<T = void> implements ILifecycleTask<T> {\n  public done: boolean;\n\n  private isCancelled: boolean;\n  private readonly promise: Promise<T>;\n  private readonly callback: (result?: T) => void;\n\n  constructor(promise: Promise<T>, callback: (result?: T) => void) {\n    this.done = false;\n    this.isCancelled = false;\n    this.callback = callback;\n    this.promise = promise.then(value => {\n      if (this.isCancelled === true) {\n        return;\n      }\n      this.done = true;\n      this.callback(value);\n      return value;\n    });\n  }\n\n  public canCancel(): boolean {\n    return !this.done;\n  }\n\n  public cancel(): void {\n    if (this.canCancel()) {\n      this.isCancelled = true;\n    }\n  }\n\n  public wait(): Promise<T> {\n    return this.promise;\n  }\n}\n","import { Class, IIndexable, Tracer } from '@aurelia/kernel';\nimport { IConnectable } from '../ast';\nimport { LifecycleFlags } from '../flags';\nimport { IBinding } from '../lifecycle';\nimport { IBindingTargetObserver, IPropertySubscriber, ISubscribable, MutationKind } from '../observation';\nimport { IObserverLocator } from '../observation/observer-locator';\n\n// TODO: add connect-queue (or something similar) back in when everything else is working, to improve startup time\n\nconst slice = Array.prototype.slice;\n\nconst slotNames: string[] = [];\nconst versionSlotNames: string[] = [];\nlet lastSlot = -1;\nfunction ensureEnoughSlotNames(currentSlot: number): void {\n  if (currentSlot === lastSlot) {\n    lastSlot += 5;\n    const ii = slotNames.length = versionSlotNames.length = lastSlot + 1;\n    for (let i = currentSlot + 1; i < ii; ++i) {\n      slotNames[i] = `_observer${i}`;\n      versionSlotNames[i] = `_observerVersion${i}`;\n    }\n  }\n}\nensureEnoughSlotNames(-1);\n\nexport interface IPartialConnectableBinding extends IBinding, IPropertySubscriber {\n  observerLocator: IObserverLocator;\n}\n\nexport interface IConnectableBinding extends IPartialConnectableBinding, IConnectable {\n  $nextConnect?: IConnectableBinding;\n  $nextPatch?: IConnectableBinding;\n  observerSlots: number;\n  version: number;\n  addObserver(observer: ISubscribable<MutationKind.instance | MutationKind.proxy>): void;\n  unobserve(all?: boolean): void;\n  connect(flags: LifecycleFlags): void;\n  patch(flags: LifecycleFlags): void;\n}\n\n/** @internal */\nexport function addObserver(this: IConnectableBinding, observer: ISubscribable<MutationKind.instance | MutationKind.proxy>): void {\n  // find the observer.\n  const observerSlots = this.observerSlots === undefined ? 0 : this.observerSlots;\n  let i = observerSlots;\n\n  while (i-- && this[slotNames[i]] !== observer);\n\n  // if we are not already observing, put the observer in an open slot and subscribe.\n  if (i === -1) {\n    i = 0;\n    while (this[slotNames[i]]) {\n      i++;\n    }\n    this[slotNames[i]] = observer;\n    observer.subscribe(this);\n    // increment the slot count.\n    if (i === observerSlots) {\n      this.observerSlots = i + 1;\n    }\n  }\n  // set the \"version\" when the observer was used.\n  if (this.version === undefined) {\n    this.version = 0;\n  }\n  this[versionSlotNames[i]] = this.version;\n  ensureEnoughSlotNames(i);\n}\n\n/** @internal */\nexport function observeProperty(this: IConnectableBinding, flags: LifecycleFlags, obj: IIndexable, propertyName: string): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.observeProperty`, slice.call(arguments)); }\n  const observer = this.observerLocator.getObserver(flags, obj, propertyName) as IBindingTargetObserver;\n  /* Note: we need to cast here because we can indeed get an accessor instead of an observer,\n   *  in which case the call to observer.subscribe will throw. It's not very clean and we can solve this in 2 ways:\n   *  1. Fail earlier: only let the locator resolve observers from .getObserver, and throw if no branches are left (e.g. it would otherwise return an accessor)\n   *  2. Fail silently (without throwing): give all accessors a no-op subscribe method\n   *\n   * We'll probably want to implement some global configuration (like a \"strict\" toggle) so users can pick between enforced correctness vs. ease-of-use\n   */\n  this.addObserver(observer);\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function unobserve(this: IConnectableBinding, all?: boolean): void {\n  const slots = this.observerSlots;\n  let slotName: string;\n  let observer: IBindingTargetObserver;\n  if (all === true) {\n    for (let i = 0; i < slots; ++i) {\n      slotName = slotNames[i];\n      observer = this[slotName];\n      if (observer !== null && observer !== undefined) {\n        this[slotName] = null;\n        observer.unsubscribe(this);\n      }\n    }\n  } else {\n    const version = this.version;\n    for (let i = 0; i < slots; ++i) {\n      if (this[versionSlotNames[i]] !== version) {\n        slotName = slotNames[i];\n        observer = this[slotName];\n        if (observer !== null && observer !== undefined) {\n          this[slotName] = null;\n          observer.unsubscribe(this);\n        }\n      }\n    }\n  }\n}\n\ntype DecoratableConnectable<TProto, TClass> = Class<TProto & Partial<IConnectableBinding> & IPartialConnectableBinding, TClass>;\ntype DecoratedConnectable<TProto, TClass> = Class<TProto & IConnectableBinding, TClass>;\n\nfunction connectableDecorator<TProto, TClass>(target: DecoratableConnectable<TProto, TClass>): DecoratedConnectable<TProto, TClass> {\n  const proto = target.prototype;\n  if (!proto.hasOwnProperty('observeProperty')) proto.observeProperty = observeProperty;\n  if (!proto.hasOwnProperty('unobserve')) proto.unobserve = unobserve;\n  if (!proto.hasOwnProperty('addObserver')) proto.addObserver = addObserver;\n  return target as DecoratedConnectable<TProto, TClass>;\n}\n\nexport function connectable(): typeof connectableDecorator;\nexport function connectable<TProto, TClass>(target: DecoratableConnectable<TProto, TClass>): DecoratedConnectable<TProto, TClass>;\nexport function connectable<TProto, TClass>(target?: DecoratableConnectable<TProto, TClass>): DecoratedConnectable<TProto, TClass> | typeof connectableDecorator {\n  return target === undefined ? connectableDecorator : connectableDecorator(target);\n}\n","import { IServiceLocator, Reporter, Tracer } from '@aurelia/kernel';\nimport { IForOfStatement, IsBindingBehavior } from '../ast';\nimport { BindingMode, ExpressionKind, LifecycleFlags, State } from '../flags';\nimport { IBinding, ILifecycle } from '../lifecycle';\nimport { AccessorOrObserver, IBindingTargetObserver, IObservable, IScope } from '../observation';\nimport { IObserverLocator } from '../observation/observer-locator';\nimport { hasBind, hasUnbind } from './ast';\nimport { connectable, IConnectableBinding, IPartialConnectableBinding } from './connectable';\n\nconst slice = Array.prototype.slice;\n\n// BindingMode is not a const enum (and therefore not inlined), so assigning them to a variable to save a member accessor is a minor perf tweak\nconst { oneTime, toView, fromView } = BindingMode;\n\n// pre-combining flags for bitwise checks is a minor perf tweak\nconst toViewOrOneTime = toView | oneTime;\n\nexport interface Binding extends IConnectableBinding {}\n\n@connectable()\nexport class Binding implements IPartialConnectableBinding {\n  public $nextBinding: IBinding;\n  public $prevBinding: IBinding;\n  public $state: State;\n  public $lifecycle: ILifecycle;\n  public $nextConnect: IConnectableBinding;\n  public $nextPatch: IConnectableBinding;\n  public $scope: IScope;\n\n  public locator: IServiceLocator;\n  public mode: BindingMode;\n  public observerLocator: IObserverLocator;\n  public sourceExpression: IsBindingBehavior | IForOfStatement;\n  public target: IObservable;\n  public targetProperty: string;\n\n  public targetObserver: AccessorOrObserver;\n\n  public persistentFlags: LifecycleFlags;\n\n  constructor(sourceExpression: IsBindingBehavior | IForOfStatement, target: IObservable, targetProperty: string, mode: BindingMode, observerLocator: IObserverLocator, locator: IServiceLocator) {\n    this.$nextBinding = null;\n    this.$prevBinding = null;\n    this.$state = State.none;\n    this.$lifecycle = locator.get(ILifecycle);\n    this.$nextConnect = null;\n    this.$nextPatch = null;\n    this.$scope = null;\n\n    this.locator = locator;\n    this.mode = mode;\n    this.observerLocator = observerLocator;\n    this.sourceExpression = sourceExpression;\n    this.target = target;\n    this.targetProperty = targetProperty;\n    this.persistentFlags = LifecycleFlags.none;\n  }\n\n  public updateTarget(value: unknown, flags: LifecycleFlags): void {\n    flags |= this.persistentFlags;\n    this.targetObserver.setValue(value, flags | LifecycleFlags.updateTargetInstance);\n  }\n\n  public updateSource(value: unknown, flags: LifecycleFlags): void {\n    flags |= this.persistentFlags;\n    this.sourceExpression.assign(flags | LifecycleFlags.updateSourceExpression, this.$scope, this.locator, value);\n  }\n\n  public handleChange(newValue: unknown, _previousValue: unknown, flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Binding.handleChange', slice.call(arguments)); }\n    if (!(this.$state & State.isBound)) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n\n    const sourceExpression = this.sourceExpression;\n    const $scope = this.$scope;\n    const locator = this.locator;\n    flags |= this.persistentFlags;\n\n    if (this.mode === BindingMode.fromView) {\n      flags &= ~LifecycleFlags.updateTargetInstance;\n      flags |= LifecycleFlags.updateSourceExpression;\n    }\n\n    if (flags & LifecycleFlags.updateTargetInstance) {\n      const targetObserver = this.targetObserver;\n      const mode = this.mode;\n\n      const previousValue = targetObserver.getValue();\n      // if the only observable is an AccessScope then we can assume the passed-in newValue is the correct and latest value\n      if (sourceExpression.$kind !== ExpressionKind.AccessScope || this.observerSlots > 1) {\n        newValue = sourceExpression.evaluate(flags, $scope, locator);\n      }\n      if (newValue !== previousValue) {\n        this.updateTarget(newValue, flags);\n      }\n      if ((mode & oneTime) === 0) {\n        this.version++;\n        sourceExpression.connect(flags, $scope, this);\n        this.unobserve(false);\n      }\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n\n    if (flags & LifecycleFlags.updateSourceExpression) {\n      if (newValue !== sourceExpression.evaluate(flags, $scope, locator)) {\n        this.updateSource(newValue, flags);\n      }\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n\n    throw Reporter.error(15, LifecycleFlags[flags]);\n  }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (Tracer.enabled) { Tracer.enter('Binding.$bind', slice.call(arguments)); }\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        if (Tracer.enabled) { Tracer.leave(); }\n        return;\n      }\n      this.$unbind(flags | LifecycleFlags.fromBind);\n    }\n    // add isBinding flag\n    this.$state |= State.isBinding;\n\n    // Store flags which we can only receive during $bind and need to pass on\n    // to the AST during evaluate/connect/assign\n    this.persistentFlags = flags & LifecycleFlags.persistentBindingFlags;\n\n    this.$scope = scope;\n\n    let sourceExpression = this.sourceExpression;\n    if (hasBind(sourceExpression)) {\n      sourceExpression.bind(flags, scope, this);\n    }\n\n    const mode = this.mode;\n    let targetObserver = this.targetObserver as IBindingTargetObserver;\n    if (!targetObserver) {\n      if (mode & fromView) {\n        targetObserver = this.targetObserver = this.observerLocator.getObserver(flags, this.target, this.targetProperty) as IBindingTargetObserver;\n      } else {\n        targetObserver = this.targetObserver = this.observerLocator.getAccessor(flags, this.target, this.targetProperty) as IBindingTargetObserver;\n      }\n    }\n    if (targetObserver.bind) {\n      targetObserver.bind(flags);\n    }\n\n    // during bind, binding behavior might have changed sourceExpression\n    sourceExpression = this.sourceExpression;\n    if (mode & toViewOrOneTime) {\n      this.updateTarget(sourceExpression.evaluate(flags, scope, this.locator), flags);\n    }\n    if (mode & toView) {\n      sourceExpression.connect(flags, scope, this);\n    }\n    if (mode & fromView) {\n      targetObserver.subscribe(this);\n    }\n\n    // add isBound flag and remove isBinding flag\n    this.$state |= State.isBound;\n    this.$state &= ~State.isBinding;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Binding.$unbind', slice.call(arguments)); }\n    if (!(this.$state & State.isBound)) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    // clear persistent flags\n    this.persistentFlags = LifecycleFlags.none;\n\n    const sourceExpression = this.sourceExpression;\n    if (hasUnbind(sourceExpression)) {\n      sourceExpression.unbind(flags, this.$scope, this);\n    }\n    this.$scope = null;\n\n    const targetObserver = this.targetObserver as IBindingTargetObserver;\n    if (targetObserver.unbind) {\n      targetObserver.unbind(flags);\n    }\n    if (targetObserver.unsubscribe) {\n      targetObserver.unsubscribe(this);\n    }\n    this.unobserve(true);\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public connect(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Binding.connect', slice.call(arguments)); }\n    if (this.$state & State.isBound) {\n      flags |= this.persistentFlags;\n      this.sourceExpression.connect(flags | LifecycleFlags.mustEvaluate, this.$scope, this);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public patch(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Binding.patch', slice.call(arguments)); }\n    if (this.$state & State.isBound) {\n      flags |= this.persistentFlags;\n      this.updateTarget(this.sourceExpression.evaluate(flags | LifecycleFlags.mustEvaluate, this.$scope, this.locator), flags);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n","import { IServiceLocator, Tracer } from '@aurelia/kernel';\nimport { IsBindingBehavior } from '../ast';\nimport { LifecycleFlags, State } from '../flags';\nimport { IBinding } from '../lifecycle';\nimport { IAccessor, IBindingContext, IObservable, IScope } from '../observation';\nimport { IObserverLocator } from '../observation/observer-locator';\nimport { hasBind, hasUnbind } from './ast';\nimport { IConnectableBinding } from './connectable';\n\nconst slice = Array.prototype.slice;\n\nexport interface Call extends IConnectableBinding {}\nexport class Call {\n  public $nextBinding: IBinding;\n  public $prevBinding: IBinding;\n  public $state: State;\n  public $scope: IScope;\n\n  public locator: IServiceLocator;\n  public sourceExpression: IsBindingBehavior;\n  public targetObserver: IAccessor;\n\n  constructor(sourceExpression: IsBindingBehavior, target: IObservable | IBindingContext, targetProperty: string, observerLocator: IObserverLocator, locator: IServiceLocator) {\n    this.$nextBinding = null;\n    this.$prevBinding = null;\n    this.$state = State.none;\n\n    this.locator = locator;\n    this.sourceExpression = sourceExpression;\n    this.targetObserver = observerLocator.getObserver(LifecycleFlags.none, target, targetProperty);\n  }\n\n  public callSource(args: object): unknown {\n    if (Tracer.enabled) { Tracer.enter('Call.callSource', slice.call(arguments)); }\n    const overrideContext = this.$scope.overrideContext;\n    Object.assign(overrideContext, args);\n    const result = this.sourceExpression.evaluate(LifecycleFlags.mustEvaluate, this.$scope, this.locator);\n\n    for (const prop in args) {\n      // tslint:disable-next-line:no-dynamic-delete\n      delete overrideContext[prop];\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n    return result;\n  }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (Tracer.enabled) { Tracer.enter('Call.$bind', slice.call(arguments)); }\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        if (Tracer.enabled) { Tracer.leave(); }\n        return;\n      }\n\n      this.$unbind(flags | LifecycleFlags.fromBind);\n    }\n    // add isBinding flag\n    this.$state |= State.isBinding;\n\n    this.$scope = scope;\n\n    const sourceExpression = this.sourceExpression;\n    if (hasBind(sourceExpression)) {\n      sourceExpression.bind(flags, scope, this);\n    }\n\n    this.targetObserver.setValue($args => this.callSource($args), flags);\n\n    // add isBound flag and remove isBinding flag\n    this.$state |= State.isBound;\n    this.$state &= ~State.isBinding;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Call.$unbind', slice.call(arguments)); }\n    if (!(this.$state & State.isBound)) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    const sourceExpression = this.sourceExpression;\n    if (hasUnbind(sourceExpression)) {\n      sourceExpression.unbind(flags, this.$scope, this);\n    }\n\n    this.$scope = null;\n    this.targetObserver.setValue(null, flags);\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public observeProperty(flags: LifecycleFlags, obj: object, propertyName: string): void {\n    return;\n  }\n\n  public handleChange(newValue: unknown, previousValue: unknown, flags: LifecycleFlags): void {\n    return;\n  }\n}\n","import { DI, PLATFORM, Reporter } from '@aurelia/kernel';\nimport {\n  AnyBindingExpression,\n  IForOfStatement,\n  IInterpolationExpression,\n  IsBindingBehavior\n} from '../ast';\nimport { ExpressionKind } from '../flags';\nimport {\n  AccessMember,\n  AccessScope,\n  CallMember,\n  CallScope,\n  ForOfStatement,\n  Interpolation,\n  PrimitiveLiteral\n} from './ast';\n\nexport interface IExpressionParser {\n  cache(expressions: Record<string, AnyBindingExpression>): void;\n  parse(expression: string, bindingType: BindingType.ForCommand): IForOfStatement;\n  parse(expression: string, bindingType: BindingType.Interpolation): IInterpolationExpression;\n  parse(expression: string, bindingType: Exclude<BindingType, BindingType.ForCommand | BindingType.Interpolation>): IsBindingBehavior;\n  parse(expression: string, bindingType: BindingType): AnyBindingExpression;\n}\n\nexport const IExpressionParser = DI.createInterface<IExpressionParser>('IExpressionParser').withDefault(x => x.singleton(ExpressionParser));\n\n/** @internal */\nexport class ExpressionParser implements IExpressionParser {\n  private readonly expressionLookup: Record<string, IsBindingBehavior>;\n  private readonly forOfLookup: Record<string, IForOfStatement>;\n  private readonly interpolationLookup: Record<string, IInterpolationExpression>;\n\n  constructor() {\n    this.expressionLookup = Object.create(null);\n    this.forOfLookup = Object.create(null);\n    this.interpolationLookup = Object.create(null);\n  }\n\n  public parse(expression: string, bindingType: BindingType.ForCommand): IForOfStatement;\n  public parse(expression: string, bindingType: BindingType.Interpolation): IInterpolationExpression;\n  public parse(expression: string, bindingType: Exclude<BindingType, BindingType.ForCommand | BindingType.Interpolation>): IsBindingBehavior;\n  public parse(expression: string, bindingType: BindingType): AnyBindingExpression {\n    switch (bindingType) {\n      case BindingType.Interpolation: {\n        let found = this.interpolationLookup[expression];\n        if (found === undefined) {\n          found = this.interpolationLookup[expression] = this.parseCore(expression, bindingType);\n        }\n        return found;\n      }\n      case BindingType.ForCommand: {\n        let found = this.forOfLookup[expression];\n        if (found === undefined) {\n          found = this.forOfLookup[expression] = this.parseCore(expression, bindingType);\n        }\n        return found;\n      }\n      default: {\n        // Allow empty strings for normal bindings and those that are empty by default (such as a custom attribute without an equals sign)\n        // But don't cache it, because empty strings are always invalid for any other type of binding\n        if (expression.length === 0 && (bindingType & (BindingType.BindCommand | BindingType.OneTimeCommand | BindingType.ToViewCommand))) {\n          return PrimitiveLiteral.$empty;\n        }\n        let found = this.expressionLookup[expression];\n        if (found === undefined) {\n          found = this.expressionLookup[expression] = this.parseCore(expression, bindingType);\n        }\n        return found;\n      }\n    }\n  }\n\n  public cache(expressions: Record<string, AnyBindingExpression>): void {\n    const { forOfLookup, expressionLookup, interpolationLookup } = this;\n    for (const expression in expressions) {\n      const expr = expressions[expression];\n      switch (expr.$kind) {\n        case ExpressionKind.Interpolation:\n          interpolationLookup[expression] = expr;\n          break;\n        case ExpressionKind.ForOfStatement:\n          forOfLookup[expression] = expr;\n          break;\n        default:\n          expressionLookup[expression] = expr;\n      }\n    }\n  }\n\n  private parseCore(expression: string, bindingType: BindingType.ForCommand): ForOfStatement;\n  private parseCore(expression: string, bindingType: BindingType.Interpolation): Interpolation;\n  private parseCore(expression: string, bindingType: Exclude<BindingType, BindingType.ForCommand | BindingType.Interpolation>): IsBindingBehavior;\n  private parseCore(expression: string, bindingType: BindingType): AnyBindingExpression {\n    try {\n      const parts = expression.split('.');\n      const firstPart = parts[0];\n      let current: AnyBindingExpression;\n\n      if (firstPart.endsWith('()')) {\n        current = new CallScope(firstPart.replace('()', ''), PLATFORM.emptyArray);\n      } else {\n        current = new AccessScope(parts[0]);\n      }\n\n      let index = 1;\n\n      while (index < parts.length) {\n        const currentPart = parts[index];\n\n        if (currentPart.endsWith('()')) {\n          current = new CallMember(current, currentPart.replace('()', ''), PLATFORM.emptyArray);\n        } else {\n          current = new AccessMember(current, parts[index]);\n        }\n\n        index++;\n      }\n\n      return current;\n    } catch (e) {\n      throw Reporter.error(3, e);\n    }\n  }\n}\n\nexport const enum BindingType {\n              None = 0,\n     Interpolation = 0b10000000_0000,\n        IsRef      = 0b01010000_0000,\n        IsIterator = 0b00100000_0000,\n        IsCustom   = 0b00010000_0000,\n        IsFunction = 0b00001000_0000,\n        IsEvent    = 0b00000100_0000,\n        IsProperty = 0b00000010_0000,\n        IsCommand  = 0b00000001_0000,\nIsPropertyCommand  = 0b00000011_0000,\n   IsEventCommand  = 0b00000101_0000,\nDelegationStrategyDelta =     0b0110,\n           Command =          0b1111,\n    OneTimeCommand = 0b00000011_0001,\n     ToViewCommand = 0b00000011_0010,\n   FromViewCommand = 0b00000011_0011,\n     TwoWayCommand = 0b00000011_0100,\n       BindCommand = 0b00000011_0101,\n    TriggerCommand = 0b00000101_0110,\n    CaptureCommand = 0b00000101_0111,\n   DelegateCommand = 0b00000101_1000,\n       CallCommand = 0b00001001_1001,\n    OptionsCommand = 0b00000001_1010,\n        ForCommand = 0b00100001_1011,\n     CustomCommand = 0b00010001_1100\n}\n","import { IServiceLocator } from '@aurelia/kernel';\nimport { IExpression, IInterpolationExpression } from '../ast';\nimport { BindingMode, LifecycleFlags, State } from '../flags';\nimport { IBinding } from '../lifecycle';\nimport { IBindingTargetAccessor, IObservable, IScope } from '../observation';\nimport { IObserverLocator } from '../observation/observer-locator';\nimport { connectable, IConnectableBinding, IPartialConnectableBinding } from './connectable';\n\nconst { toView, oneTime } = BindingMode;\n\nexport class MultiInterpolationBinding implements IBinding {\n  public $nextBinding: IBinding;\n  public $prevBinding: IBinding;\n  public $state: State;\n  public $scope: IScope;\n\n  public interpolation: IInterpolationExpression;\n  public observerLocator: IObserverLocator;\n  public locator: IServiceLocator;\n  public mode: BindingMode;\n  public parts: InterpolationBinding[];\n  public target: IObservable;\n  public targetProperty: string;\n\n  constructor(observerLocator: IObserverLocator, interpolation: IInterpolationExpression, target: IObservable, targetProperty: string, mode: BindingMode, locator: IServiceLocator) {\n    this.$nextBinding = null;\n    this.$prevBinding = null;\n    this.$state = State.none;\n    this.$scope = null;\n\n    this.interpolation = interpolation;\n    this.locator = locator;\n    this.mode = mode;\n    this.observerLocator = observerLocator;\n    this.target = target;\n    this.targetProperty = targetProperty;\n\n    // Note: the child expressions of an Interpolation expression are full Aurelia expressions, meaning they may include\n    // value converters and binding behaviors.\n    // Each expression represents one ${interpolation}, and for each we create a child TextBinding unless there is only one,\n    // in which case the renderer will create the TextBinding directly\n    const expressions = interpolation.expressions;\n    const parts = this.parts = Array(expressions.length);\n    for (let i = 0, ii = expressions.length; i < ii; ++i) {\n      parts[i] = new InterpolationBinding(expressions[i], interpolation, target, targetProperty, mode, observerLocator, locator, i === 0);\n    }\n  }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        return;\n      }\n      this.$unbind(flags);\n    }\n    this.$state |= State.isBound;\n    this.$scope = scope;\n\n    const parts = this.parts;\n    for (let i = 0, ii = parts.length; i < ii; ++i) {\n      parts[i].$bind(flags, scope);\n    }\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (!(this.$state & State.isBound)) {\n      return;\n    }\n    this.$state &= ~State.isBound;\n    this.$scope = null;\n    const parts = this.parts;\n    for (let i = 0, ii = parts.length; i < ii; ++i) {\n      parts[i].$unbind(flags);\n    }\n  }\n}\n\nexport interface InterpolationBinding extends IConnectableBinding {}\n\n@connectable()\nexport class InterpolationBinding implements IPartialConnectableBinding {\n  public $scope: IScope;\n  public $state: State;\n\n  public interpolation: IInterpolationExpression;\n  public isFirst: boolean;\n  public locator: IServiceLocator;\n  public mode: BindingMode;\n  public observerLocator: IObserverLocator;\n  public sourceExpression: IExpression;\n  public target: IObservable;\n  public targetProperty: string;\n\n  public targetObserver: IBindingTargetAccessor;\n\n  // tslint:disable-next-line:parameters-max-number\n  constructor(sourceExpression: IExpression, interpolation: IInterpolationExpression, target: IObservable, targetProperty: string, mode: BindingMode, observerLocator: IObserverLocator, locator: IServiceLocator, isFirst: boolean) {\n    this.$state = State.none;\n\n    this.interpolation = interpolation;\n    this.isFirst = isFirst;\n    this.mode = mode;\n    this.locator = locator;\n    this.observerLocator = observerLocator;\n    this.sourceExpression = sourceExpression;\n    this.target = target;\n    this.targetProperty = targetProperty;\n\n    this.targetObserver = observerLocator.getAccessor(LifecycleFlags.none, target, targetProperty);\n  }\n\n  public updateTarget(value: unknown, flags: LifecycleFlags): void {\n    this.targetObserver.setValue(value, flags | LifecycleFlags.updateTargetInstance);\n  }\n\n  public handleChange(_newValue: unknown, _previousValue: unknown, flags: LifecycleFlags): void {\n    if (!(this.$state & State.isBound)) {\n      return;\n    }\n\n    const previousValue = this.targetObserver.getValue();\n    const newValue = this.interpolation.evaluate(flags, this.$scope, this.locator);\n    if (newValue !== previousValue) {\n      this.updateTarget(newValue, flags);\n    }\n\n    if ((this.mode & oneTime) === 0) {\n      this.version++;\n      this.sourceExpression.connect(flags, this.$scope, this);\n      this.unobserve(false);\n    }\n  }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        return;\n      }\n      this.$unbind(flags);\n    }\n\n    this.$state |= State.isBound;\n    this.$scope = scope;\n\n    const sourceExpression = this.sourceExpression;\n    if (sourceExpression.bind) {\n      sourceExpression.bind(flags, scope, this);\n    }\n\n    // since the interpolation already gets the whole value, we only need to let the first\n    // text binding do the update if there are multiple\n    if (this.isFirst) {\n      this.updateTarget(this.interpolation.evaluate(flags, scope, this.locator), flags);\n    }\n    if (this.mode & toView) {\n      sourceExpression.connect(flags, scope, this);\n    }\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (!(this.$state & State.isBound)) {\n      return;\n    }\n    this.$state &= ~State.isBound;\n\n    const sourceExpression = this.sourceExpression;\n    if (sourceExpression.unbind) {\n      sourceExpression.unbind(flags, this.$scope, this);\n    }\n\n    this.$scope = null;\n    this.unobserve(true);\n  }\n}\n","import { IIndexable, IServiceLocator, Reporter, Tracer } from '@aurelia/kernel';\nimport { IExpression } from '../ast';\nimport { LifecycleFlags, State } from '../flags';\nimport { IBinding, ILifecycle } from '../lifecycle';\nimport { IObservable, IScope } from '../observation';\nimport { IObserverLocator } from '../observation/observer-locator';\nimport { connectable, IConnectableBinding, IPartialConnectableBinding } from './connectable';\n\nconst slice = Array.prototype.slice;\n\nexport interface LetBinding extends IConnectableBinding {}\n\n@connectable()\nexport class LetBinding implements IPartialConnectableBinding {\n  public $nextBinding: IBinding;\n  public $prevBinding: IBinding;\n  public $state: State;\n  public $lifecycle: ILifecycle;\n  public $scope: IScope;\n\n  public locator: IServiceLocator;\n  public observerLocator: IObserverLocator;\n  public sourceExpression: IExpression;\n  public target: IObservable | null;\n  public targetProperty: string;\n\n  private readonly toViewModel: boolean;\n\n  constructor(sourceExpression: IExpression, targetProperty: string, observerLocator: IObserverLocator, locator: IServiceLocator, toViewModel: boolean = false) {\n    this.$nextBinding = null;\n    this.$prevBinding = null;\n    this.$state = State.none;\n    this.$lifecycle = locator.get(ILifecycle);\n    this.$scope = null;\n\n    this.locator = locator;\n    this.observerLocator = observerLocator;\n    this.sourceExpression = sourceExpression;\n    this.target = null;\n    this.targetProperty = targetProperty;\n\n    this.toViewModel = toViewModel;\n  }\n\n  public handleChange(_newValue: unknown, _previousValue: unknown, flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('LetBinding.handleChange', slice.call(arguments)); }\n    if (!(this.$state & State.isBound)) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n\n    if (flags & LifecycleFlags.updateTargetInstance) {\n      const { target, targetProperty } = this as {target: IIndexable; targetProperty: string};\n      const previousValue: unknown = target[targetProperty];\n      const newValue: unknown = this.sourceExpression.evaluate(flags, this.$scope, this.locator);\n      if (newValue !== previousValue) {\n        target[targetProperty] = newValue;\n      }\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n\n    throw Reporter.error(15, flags);\n  }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (Tracer.enabled) { Tracer.enter('LetBinding.$bind', slice.call(arguments)); }\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        if (Tracer.enabled) { Tracer.leave(); }\n        return;\n      }\n      this.$unbind(flags | LifecycleFlags.fromBind);\n    }\n    // add isBinding flag\n    this.$state |= State.isBinding;\n\n    this.$scope = scope;\n    this.target = (this.toViewModel ? scope.bindingContext : scope.overrideContext) as IIndexable;\n\n    const sourceExpression = this.sourceExpression;\n    if (sourceExpression.bind) {\n      sourceExpression.bind(flags, scope, this);\n    }\n    // sourceExpression might have been changed during bind\n    this.target[this.targetProperty] = this.sourceExpression.evaluate(LifecycleFlags.fromBind, scope, this.locator);\n    this.sourceExpression.connect(flags, scope, this);\n\n    // add isBound flag and remove isBinding flag\n    this.$state |= State.isBound;\n    this.$state &= ~State.isBinding;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('LetBinding.$unbind', slice.call(arguments)); }\n    if (!(this.$state & State.isBound)) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    const sourceExpression = this.sourceExpression;\n    if (sourceExpression.unbind) {\n      sourceExpression.unbind(flags, this.$scope, this);\n    }\n    this.$scope = null;\n    this.unobserve(true);\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n","import { IIndexable, IServiceLocator, Tracer } from '@aurelia/kernel';\nimport { IsBindingBehavior } from '../ast';\nimport { LifecycleFlags, State } from '../flags';\nimport { IBinding } from '../lifecycle';\nimport { IObservable, IScope } from '../observation';\nimport { hasBind, hasUnbind } from './ast';\nimport { IConnectableBinding } from './connectable';\n\nconst slice = Array.prototype.slice;\n\nexport interface Ref extends IConnectableBinding {}\nexport class Ref implements IBinding {\n  public $nextBinding: IBinding;\n  public $prevBinding: IBinding;\n  public $state: State;\n  public $scope: IScope;\n\n  public locator: IServiceLocator;\n  public sourceExpression: IsBindingBehavior;\n  public target: IObservable;\n\n  constructor(sourceExpression: IsBindingBehavior, target: IObservable, locator: IServiceLocator) {\n    this.$nextBinding = null;\n    this.$prevBinding = null;\n    this.$state = State.none;\n\n    this.locator = locator;\n    this.sourceExpression = sourceExpression;\n    this.target = target;\n  }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (Tracer.enabled) { Tracer.enter('Ref.$bind', slice.call(arguments)); }\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        if (Tracer.enabled) { Tracer.leave(); }\n        return;\n      }\n\n      this.$unbind(flags | LifecycleFlags.fromBind);\n    }\n    // add isBinding flag\n    this.$state |= State.isBinding;\n\n    this.$scope = scope;\n\n    const sourceExpression = this.sourceExpression;\n    if (hasBind(sourceExpression)) {\n      sourceExpression.bind(flags, scope, this);\n    }\n\n    this.sourceExpression.assign(flags, this.$scope, this.locator, this.target);\n\n    // add isBound flag and remove isBinding flag\n    this.$state |= State.isBound;\n    this.$state &= ~State.isBinding;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Ref.$unbind', slice.call(arguments)); }\n    if (!(this.$state & State.isBound)) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    if (this.sourceExpression.evaluate(flags, this.$scope, this.locator) === this.target) {\n      this.sourceExpression.assign(flags, this.$scope, this.locator, null);\n    }\n\n    const sourceExpression = this.sourceExpression;\n    if (hasUnbind(sourceExpression)) {\n      sourceExpression.unbind(flags, this.$scope, this);\n    }\n\n    this.$scope = null;\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public observeProperty(flags: LifecycleFlags, obj: IIndexable, propertyName: string): void {\n    return;\n  }\n\n  public handleChange(newValue: unknown, previousValue: unknown, flags: LifecycleFlags): void {\n    return;\n  }\n}\n","import { Tracer } from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport { ILifecycle } from '../lifecycle';\nimport { IBindingTargetAccessor, MutationKind } from '../observation';\nimport { subscriberCollection } from './subscriber-collection';\n\nconst slice = Array.prototype.slice;\n\ntype BindingTargetAccessor = IBindingTargetAccessor & {\n  lifecycle: ILifecycle;\n  currentFlags: LifecycleFlags;\n  oldValue?: unknown;\n  defaultValue: unknown;\n  $nextFlush?: BindingTargetAccessor;\n  flush(flags: LifecycleFlags): void;\n  setValueCore(value: unknown, flags: LifecycleFlags): void;\n};\n\nfunction setValue(this: BindingTargetAccessor, newValue: unknown, flags: LifecycleFlags): Promise<void> {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.setValue`, slice.call(arguments)); }\n  const currentValue = this.currentValue;\n  newValue = newValue === null || newValue === undefined ? this.defaultValue : newValue;\n  if (currentValue !== newValue) {\n    this.currentValue = newValue;\n    if ((flags & (LifecycleFlags.fromFlush | LifecycleFlags.fromBind)) &&\n      !(this.isDOMObserver && (flags & LifecycleFlags.doNotUpdateDOM))) {\n      this.setValueCore(newValue, flags);\n    } else {\n      this.currentFlags = flags;\n      if (Tracer.enabled) { Tracer.leave(); }\n      return this.lifecycle.enqueueFlush(this);\n    }\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n  return Promise.resolve();\n}\n\nfunction flush(this: BindingTargetAccessor, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.flush`, slice.call(arguments)); }\n  if (this.isDOMObserver && (flags & LifecycleFlags.doNotUpdateDOM)) {\n    // re-queue the change so it will still propagate on flush when it's attached again\n    this.lifecycle.enqueueFlush(this).catch(error => { throw error; });\n    if (Tracer.enabled) { Tracer.leave(); }\n    return;\n  }\n  const currentValue = this.currentValue;\n  // we're doing this check because a value could be set multiple times before a flush, and the final value could be the same as the original value\n  // in which case the target doesn't need to be updated\n  if (this.oldValue !== currentValue) {\n    this.setValueCore(currentValue, this.currentFlags | flags | LifecycleFlags.updateTargetInstance);\n    this.oldValue = this.currentValue;\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\nfunction dispose(this: BindingTargetAccessor): void {\n  this.currentValue = null;\n  this.oldValue = null;\n  this.defaultValue = null;\n\n  this.obj = null;\n  this.propertyKey = '';\n}\n\nexport function targetObserver(defaultValue: unknown = null): ClassDecorator {\n  // tslint:disable-next-line:ban-types // ClassDecorator expects it to be derived from Function\n  return function(target: Function): void {\n    subscriberCollection(MutationKind.instance)(target);\n    const proto = target.prototype as BindingTargetAccessor;\n\n    proto.$nextFlush = null;\n\n    proto.currentValue = defaultValue;\n    proto.oldValue = defaultValue;\n    proto.defaultValue = defaultValue;\n\n    proto.obj = null;\n    proto.propertyKey = '';\n\n    proto.setValue = proto.setValue || setValue;\n    proto.flush = proto.flush || flush;\n    proto.dispose = proto.dispose || dispose;\n  };\n}\n","import { Tracer } from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport {\n  Collection,\n  CollectionKind,\n  CollectionObserver,\n  IBindingTargetObserver,\n  ICollectionObserver,\n  IndexMap,\n  IPatch,\n  IPropertySubscriber,\n  MutationKind\n} from '../observation';\nimport { batchedSubscriberCollection, subscriberCollection } from './subscriber-collection';\nimport { targetObserver } from './target-observer';\n\nconst slice = Array.prototype.slice;\n\nfunction flush(this: CollectionObserver, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.flush`, slice.call(arguments)); }\n  this.callBatchedSubscribers(this.indexMap, flags | this.persistentFlags);\n  if (!!this.lengthObserver) {\n    this.lengthObserver.patch(LifecycleFlags.fromFlush | LifecycleFlags.updateTargetInstance | this.persistentFlags);\n  }\n  this.resetIndexMap();\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\nfunction dispose(this: CollectionObserver): void {\n  this.collection.$observer = undefined;\n  this.collection = null;\n  this.indexMap = null;\n}\n\nfunction resetIndexMapIndexed(this: ICollectionObserver<CollectionKind.indexed>): void {\n  const len = this.collection.length;\n  const indexMap: IndexMap = (this.indexMap = Array(len));\n  let i = 0;\n  while (i < len) {\n    indexMap[i] = i++;\n  }\n  indexMap.deletedItems = [];\n}\n\nfunction resetIndexMapKeyed(this: ICollectionObserver<CollectionKind.keyed>): void {\n  const len = this.collection.size;\n  const indexMap: IndexMap = (this.indexMap = Array(len));\n  let i = 0;\n  while (i < len) {\n    indexMap[i] = i++;\n  }\n  indexMap.deletedItems = [];\n}\n\nfunction getLengthObserver(this: CollectionObserver): CollectionLengthObserver {\n  return this.lengthObserver === undefined ? (this.lengthObserver = new CollectionLengthObserver(this as Collection&ICollectionObserver<CollectionKind>, this.lengthPropertyName)) : this.lengthObserver as CollectionLengthObserver;\n}\n\nexport function collectionObserver(kind: CollectionKind.array | CollectionKind.set | CollectionKind.map): ClassDecorator {\n  // tslint:disable-next-line:ban-types // ClassDecorator expects it to be derived from Function\n  return function(target: Function): void {\n    subscriberCollection(MutationKind.collection)(target);\n    batchedSubscriberCollection()(target);\n    const proto = target.prototype as CollectionObserver;\n\n    proto.$nextFlush = null;\n\n    proto.collection = null;\n    proto.indexMap = null;\n    proto.hasChanges = false;\n    proto.lengthPropertyName = kind & CollectionKind.indexed ? 'length' : 'size';\n    proto.collectionKind = kind;\n    proto.resetIndexMap = kind & CollectionKind.indexed ? resetIndexMapIndexed : resetIndexMapKeyed;\n    proto.flush = flush;\n    proto.dispose = dispose;\n    proto.getLengthObserver = getLengthObserver;\n\n    proto.subscribe = proto.subscribe || proto.addSubscriber;\n    proto.unsubscribe = proto.unsubscribe || proto.removeSubscriber;\n\n    proto.subscribeBatched = proto.subscribeBatched || proto.addBatchedSubscriber;\n    proto.unsubscribeBatched = proto.unsubscribeBatched || proto.removeBatchedSubscriber;\n  };\n}\n\nexport interface CollectionLengthObserver extends IBindingTargetObserver<Collection, string> {}\n\n@targetObserver()\nexport class CollectionLengthObserver implements CollectionLengthObserver, IPatch {\n  public currentValue: number;\n\n  public obj: Collection;\n  public propertyKey: 'length' | 'size';\n\n  constructor(obj: Collection, propertyKey: 'length' | 'size') {\n    this.obj = obj;\n    this.propertyKey = propertyKey;\n\n    this.currentValue = obj[propertyKey];\n  }\n\n  public getValue(): number {\n    return this.obj[this.propertyKey];\n  }\n\n  public setValueCore(newValue: number): void {\n    this.obj[this.propertyKey] = newValue;\n  }\n\n  public patch(flags: LifecycleFlags): void {\n    this.callSubscribers(this.obj[this.propertyKey], this.currentValue, flags);\n    this.currentValue = this.obj[this.propertyKey];\n  }\n\n  public subscribe(subscriber: IPropertySubscriber): void {\n    this.addSubscriber(subscriber);\n  }\n\n  public unsubscribe(subscriber: IPropertySubscriber): void {\n    this.removeSubscriber(subscriber);\n  }\n}\n","import { Tracer } from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport { ILifecycle } from '../lifecycle';\nimport { CollectionKind, ICollectionObserver, IndexMap, IObservedArray } from '../observation';\nimport { collectionObserver } from './collection-observer';\n\n// https://tc39.github.io/ecma262/#sec-sortcompare\nfunction sortCompare(x: unknown, y: unknown): number {\n  if (x === y) {\n    return 0;\n  }\n  x = x === null ? 'null' : (x as {}).toString();\n  y = y === null ? 'null' : (y as {}).toString();\n  return (x as {}) < (y as {}) ? -1 : 1;\n}\n\nfunction preSortCompare(x: unknown, y: unknown): number {\n  if (x === undefined) {\n    if (y === undefined) {\n      return 0;\n    } else {\n      return 1;\n    }\n  }\n  if (y === undefined) {\n    return -1;\n  }\n  return 0;\n}\n\nfunction insertionSort(arr: IObservedArray, indexMap: IndexMap, from: number, to: number, compareFn: (a: unknown, b: unknown) => number): void {\n  let velement, ielement, vtmp, itmp, order;\n  let i, j;\n  for (i = from + 1; i < to; i++) {\n    velement = arr[i];\n    ielement = indexMap[i];\n    for (j = i - 1; j >= from; j--) {\n      vtmp = arr[j];\n      itmp = indexMap[j];\n      order = compareFn(vtmp, velement);\n      if (order > 0) {\n        arr[j + 1] = vtmp;\n        indexMap[j + 1] = itmp;\n      } else {\n        break;\n      }\n    }\n    arr[j + 1] = velement;\n    indexMap[j + 1] = ielement;\n  }\n}\n\n// tslint:disable-next-line:cognitive-complexity\nfunction quickSort(arr: IObservedArray, indexMap: IndexMap, from: number, to: number, compareFn: (a: unknown, b: unknown) => number): void {\n  let thirdIndex = 0, i = 0;\n  let v0, v1, v2;\n  let i0, i1, i2;\n  let c01, c02, c12;\n  let vtmp, itmp;\n  let vpivot, ipivot, lowEnd, highStart;\n  let velement, ielement, order, vtopElement;\n\n  // tslint:disable-next-line:no-constant-condition\n  while (true) {\n    if (to - from <= 10) {\n      insertionSort(arr, indexMap, from, to, compareFn);\n      return;\n    }\n\n    // tslint:disable:no-statements-same-line\n    thirdIndex = from + ((to - from) >> 1);\n    v0 = arr[from];                i0 = indexMap[from];\n    v1 = arr[to - 1];              i1 = indexMap[to - 1];\n    v2 = arr[thirdIndex];          i2 = indexMap[thirdIndex];\n    c01 = compareFn(v0, v1);\n    if (c01 > 0) {\n      vtmp = v0;                   itmp = i0;\n      v0 = v1;                     i0 = i1;\n      v1 = vtmp;                   i1 = itmp;\n    }\n    c02 = compareFn(v0, v2);\n    if (c02 >= 0) {\n      vtmp = v0;                   itmp = i0;\n      v0 = v2;                     i0 = i2;\n      v2 = v1;                     i2 = i1;\n      v1 = vtmp;                   i1 = itmp;\n    } else {\n      c12 = compareFn(v1, v2);\n      if (c12 > 0) {\n        vtmp = v1;                 itmp = i1;\n        v1 = v2;                   i1 = i2;\n        v2 = vtmp;                 i2 = itmp;\n      }\n    }\n    arr[from] = v0;                indexMap[from] = i0;\n    arr[to - 1] = v2;              indexMap[to - 1] = i2;\n    vpivot = v1;                   ipivot = i1;\n    lowEnd = from + 1;\n    highStart = to - 1;\n    arr[thirdIndex] = arr[lowEnd]; indexMap[thirdIndex] = indexMap[lowEnd];\n    arr[lowEnd] = vpivot;          indexMap[lowEnd] = ipivot;\n\n    partition: for (i = lowEnd + 1; i < highStart; i++) {\n      velement = arr[i];           ielement = indexMap[i];\n      order = compareFn(velement, vpivot);\n      if (order < 0) {\n        arr[i] = arr[lowEnd];      indexMap[i] = indexMap[lowEnd];\n        arr[lowEnd] = velement;    indexMap[lowEnd] = ielement;\n        lowEnd++;\n      } else if (order > 0) {\n        do {\n          highStart--;\n          // tslint:disable-next-line:triple-equals\n          if (highStart == i) {\n            break partition;\n          }\n          vtopElement = arr[highStart]; order = compareFn(vtopElement, vpivot);\n        } while (order > 0);\n        arr[i] = arr[highStart];   indexMap[i] = indexMap[highStart];\n        arr[highStart] = velement; indexMap[highStart] = ielement;\n        if (order < 0) {\n          velement = arr[i];       ielement = indexMap[i];\n          arr[i] = arr[lowEnd];    indexMap[i] = indexMap[lowEnd];\n          arr[lowEnd] = velement;  indexMap[lowEnd] = ielement;\n          lowEnd++;\n        }\n      }\n    }\n    // tslint:enable:no-statements-same-line\n\n    if (to - highStart < lowEnd - from) {\n      quickSort(arr, indexMap, highStart, to, compareFn);\n      to = lowEnd;\n    } else {\n      quickSort(arr, indexMap, from, lowEnd, compareFn);\n      from = highStart;\n    }\n  }\n}\n\nconst proto = Array.prototype;\n\nconst $push = proto.push;\nconst $unshift = proto.unshift;\nconst $pop = proto.pop;\nconst $shift = proto.shift;\nconst $splice = proto.splice;\nconst $reverse = proto.reverse;\nconst $sort = proto.sort;\n\nconst native = { push: $push, unshift: $unshift, pop: $pop, shift: $shift, splice: $splice, reverse: $reverse, sort: $sort };\nconst methods = ['push', 'unshift', 'pop', 'shift', 'splice', 'reverse', 'sort'];\n\nconst observe = {\n  // https://tc39.github.io/ecma262/#sec-array.prototype.push\n  push: function(this: IObservedArray): ReturnType<typeof Array.prototype.push> {\n    let $this = this;\n    if ($this.$raw !== undefined) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === undefined) {\n      return $push.apply($this, arguments);\n    }\n    const len = $this.length;\n    const argCount = arguments.length;\n    if (argCount === 0) {\n      return len;\n    }\n    $this.length = o.indexMap.length = len + argCount;\n    let i = len;\n    while (i < $this.length) {\n      $this[i] = arguments[i - len];\n      o.indexMap[i] = - 2;\n      i++;\n    }\n    o.callSubscribers('push', arguments, o.persistentFlags | LifecycleFlags.isCollectionMutation);\n    return $this.length;\n  },\n  // https://tc39.github.io/ecma262/#sec-array.prototype.unshift\n  unshift: function(this: IObservedArray): ReturnType<typeof Array.prototype.unshift>  {\n    let $this = this;\n    if ($this.$raw !== undefined) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === undefined) {\n      return $unshift.apply($this, arguments);\n    }\n    const argCount = arguments.length;\n    const inserts = new Array(argCount);\n    let i = 0;\n    while (i < argCount) {\n      inserts[i++] = - 2;\n    }\n    $unshift.apply(o.indexMap, inserts);\n    const len = $unshift.apply($this, arguments);\n    o.callSubscribers('unshift', arguments, o.persistentFlags | LifecycleFlags.isCollectionMutation);\n    return len;\n  },\n  // https://tc39.github.io/ecma262/#sec-array.prototype.pop\n  pop: function(this: IObservedArray): ReturnType<typeof Array.prototype.pop> {\n    let $this = this;\n    if ($this.$raw !== undefined) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === undefined) {\n      return $pop.call($this);\n    }\n    const indexMap = o.indexMap;\n    const element = $pop.call($this);\n    // only mark indices as deleted if they actually existed in the original array\n    const index = indexMap.length - 1;\n    if (indexMap[index] > -1) {\n      $pop.call(indexMap.deletedItems, element);\n    }\n    $pop.call(indexMap);\n    o.callSubscribers('pop', arguments, o.persistentFlags | LifecycleFlags.isCollectionMutation);\n    return element;\n  },\n  // https://tc39.github.io/ecma262/#sec-array.prototype.shift\n  shift: function(this: IObservedArray): ReturnType<typeof Array.prototype.shift> {\n    let $this = this;\n    if ($this.$raw !== undefined) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === undefined) {\n      return $shift.call($this);\n    }\n    const indexMap = o.indexMap;\n    const element = $shift.call($this);\n    // only mark indices as deleted if they actually existed in the original array\n    if (indexMap[0] > -1) {\n      $shift.call(indexMap.deletedItems, element);\n    }\n    $shift.call(indexMap);\n    o.callSubscribers('shift', arguments, o.persistentFlags | LifecycleFlags.isCollectionMutation);\n    return element;\n  },\n  // https://tc39.github.io/ecma262/#sec-array.prototype.splice\n  splice: function(this: IObservedArray, start: number, deleteCount?: number): ReturnType<typeof Array.prototype.splice> {\n    let $this = this;\n    if ($this.$raw !== undefined) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === undefined) {\n      return $splice.apply($this, arguments);\n    }\n    const indexMap = o.indexMap;\n    if (deleteCount > 0) {\n      let i = isNaN(start) ? 0 : start;\n      const to = i + deleteCount;\n      while (i < to) {\n        if (indexMap[i] > -1) {\n          $splice.call(indexMap.deletedItems, $this[i]);\n        }\n        i++;\n      }\n    }\n    const argCount = arguments.length;\n    if (argCount > 2) {\n      const itemCount = argCount - 2;\n      const inserts = new Array(itemCount);\n      let i = 0;\n      while (i < itemCount) {\n        inserts[i++] = - 2;\n      }\n      $splice.call(indexMap, start, deleteCount, ...inserts);\n    } else if (argCount === 2) {\n      $splice.call(indexMap, start, deleteCount);\n    }\n    const deleted = $splice.apply($this, arguments);\n    o.callSubscribers('splice', arguments, o.persistentFlags | LifecycleFlags.isCollectionMutation);\n    return deleted;\n  },\n  // https://tc39.github.io/ecma262/#sec-array.prototype.reverse\n  reverse: function(this: IObservedArray): ReturnType<typeof Array.prototype.reverse> {\n    let $this = this;\n    if ($this.$raw !== undefined) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === undefined) {\n      $reverse.call($this);\n      return this;\n    }\n    const len = $this.length;\n    const middle = (len / 2) | 0;\n    let lower = 0;\n    // tslint:disable:no-statements-same-line\n    while (lower !== middle) {\n      const upper = len - lower - 1;\n      const lowerValue = $this[lower];  const lowerIndex = o.indexMap[lower];\n      const upperValue = $this[upper];  const upperIndex = o.indexMap[upper];\n      $this[lower] = upperValue;        o.indexMap[lower] = upperIndex;\n      $this[upper] = lowerValue;        o.indexMap[upper] = lowerIndex;\n      lower++;\n    }\n    // tslint:enable:no-statements-same-line\n    o.callSubscribers('reverse', arguments, o.persistentFlags | LifecycleFlags.isCollectionMutation);\n    return this;\n  },\n  // https://tc39.github.io/ecma262/#sec-array.prototype.sort\n  // https://github.com/v8/v8/blob/master/src/js/array.js\n  sort: function(this: IObservedArray, compareFn?: (a: unknown, b: unknown) => number): IObservedArray {\n    let $this = this;\n    if ($this.$raw !== undefined) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === undefined) {\n      $sort.call($this, compareFn);\n      return this;\n    }\n    const len = $this.length;\n    if (len < 2) {\n      return this;\n    }\n    quickSort($this, o.indexMap, 0, len, preSortCompare);\n    let i = 0;\n    while (i < len) {\n      if ($this[i] === undefined) {\n        break;\n      }\n      i++;\n    }\n    if (compareFn === undefined || typeof compareFn !== 'function'/*spec says throw a TypeError, should we do that too?*/) {\n      compareFn = sortCompare;\n    }\n    quickSort($this, o.indexMap, 0, i, compareFn);\n    o.callSubscribers('sort', arguments, o.persistentFlags | LifecycleFlags.isCollectionMutation);\n    return this;\n  }\n};\n\nconst descriptorProps = {\n  writable: true,\n  enumerable: false,\n  configurable: true\n};\n\nconst def = Object.defineProperty;\n\nfor (const method of methods) {\n  def(observe[method], 'observing', { value: true, writable: false, configurable: false, enumerable: false });\n}\n\nexport function enableArrayObservation(): void {\n  for (const method of methods) {\n    if (proto[method].observing !== true) {\n      def(proto, method, { ...descriptorProps, value: observe[method] });\n    }\n  }\n}\n\nenableArrayObservation();\n\nexport function disableArrayObservation(): void {\n  for (const method of methods) {\n    if (proto[method].observing === true) {\n      def(proto, method, { ...descriptorProps, value: native[method] });\n    }\n  }\n}\n\nconst slice = Array.prototype.slice;\n\nexport interface ArrayObserver extends ICollectionObserver<CollectionKind.array> {}\n\n@collectionObserver(CollectionKind.array)\nexport class ArrayObserver implements ArrayObserver {\n  public resetIndexMap: () => void;\n\n  public collection: IObservedArray;\n  public readonly flags: LifecycleFlags;\n\n  constructor(flags: LifecycleFlags, lifecycle: ILifecycle, array: IObservedArray) {\n    if (Tracer.enabled) { Tracer.enter('ArrayObserver.constructor', slice.call(arguments)); }\n    this.lifecycle = lifecycle;\n    array.$observer = this;\n    this.collection = array;\n    this.flags = flags & LifecycleFlags.persistentBindingFlags;\n    this.resetIndexMap();\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\nexport function getArrayObserver(flags: LifecycleFlags, lifecycle: ILifecycle, array: IObservedArray): ArrayObserver {\n  return (array.$observer as ArrayObserver) || new ArrayObserver(flags, lifecycle, array);\n}\n","import { Tracer } from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport { ILifecycle } from '../lifecycle';\nimport { CollectionKind, ICollectionObserver, IObservedMap } from '../observation';\nimport { collectionObserver } from './collection-observer';\n\nconst proto = Map.prototype;\n\nconst $set = proto.set;\nconst $clear = proto.clear;\nconst $delete = proto.delete;\n\nconst native = { set: $set, clear: $clear, delete: $delete };\nconst methods = ['set', 'clear', 'delete'];\n\n// note: we can't really do much with Map due to the internal data structure not being accessible so we're just using the native calls\n// fortunately, map/delete/clear are easy to reconstruct for the indexMap\n\nconst observe = {\n  // https://tc39.github.io/ecma262/#sec-map.prototype.map\n  set: function(this: IObservedMap, key: unknown, value: unknown): ReturnType<typeof $set> {\n    let $this = this;\n    if ($this.$raw !== undefined) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === undefined) {\n      $set.call($this, key, value);\n      return this;\n    }\n    const oldSize = $this.size;\n    $set.call($this, key, value);\n    const newSize = $this.size;\n    if (newSize === oldSize) {\n      let i = 0;\n      for (const entry of $this.entries()) {\n        if (entry[0] === key) {\n          if (entry[1] !== value) {\n            o.indexMap[i] = -2;\n          }\n          return this;\n        }\n        i++;\n      }\n      return this;\n    }\n    o.indexMap[oldSize] = -2;\n    o.callSubscribers('set', arguments, o.persistentFlags | LifecycleFlags.isCollectionMutation);\n    return this;\n  },\n  // https://tc39.github.io/ecma262/#sec-map.prototype.clear\n  clear: function(this: IObservedMap): ReturnType<typeof $clear>  {\n    let $this = this;\n    if ($this.$raw !== undefined) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === undefined) {\n      return $clear.call($this);\n    }\n    const size = $this.size;\n    if (size > 0) {\n      const indexMap = o.indexMap;\n      let i = 0;\n      for (const entry of $this.keys()) {\n        if (indexMap[i] > -1) {\n          indexMap.deletedItems.push(entry);\n        }\n        i++;\n      }\n      $clear.call($this);\n      indexMap.length = 0;\n      o.callSubscribers('clear', arguments, o.persistentFlags | LifecycleFlags.isCollectionMutation);\n    }\n    return undefined;\n  },\n  // https://tc39.github.io/ecma262/#sec-map.prototype.delete\n  delete: function(this: IObservedMap, value: unknown): ReturnType<typeof $delete> {\n    let $this = this;\n    if ($this.$raw !== undefined) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === undefined) {\n      return $delete.call($this, value);\n    }\n    const size = $this.size;\n    if (size === 0) {\n      return false;\n    }\n    let i = 0;\n    const indexMap = o.indexMap;\n    for (const entry of $this.keys()) {\n      if (entry === value) {\n        if (indexMap[i] > -1) {\n          indexMap.deletedItems.push(entry);\n        }\n        indexMap.splice(i, 1);\n        return $delete.call($this, value);\n      }\n      i++;\n    }\n    o.callSubscribers('delete', arguments, o.persistentFlags | LifecycleFlags.isCollectionMutation);\n    return false;\n  }\n};\n\nconst descriptorProps = {\n  writable: true,\n  enumerable: false,\n  configurable: true\n};\n\nconst def = Object.defineProperty;\n\nfor (const method of methods) {\n  def(observe[method], 'observing', { value: true, writable: false, configurable: false, enumerable: false });\n}\n\nexport function enableMapObservation(): void {\n  for (const method of methods) {\n    if (proto[method].observing !== true) {\n      def(proto, method, { ...descriptorProps, value: observe[method] });\n    }\n  }\n}\n\nenableMapObservation();\n\nexport function disableMapObservation(): void {\n  for (const method of methods) {\n    if (proto[method].observing === true) {\n      def(proto, method, { ...descriptorProps, value: native[method] });\n    }\n  }\n}\n\nconst slice = Array.prototype.slice;\n\nexport interface MapObserver extends ICollectionObserver<CollectionKind.map> {}\n\n@collectionObserver(CollectionKind.map)\nexport class MapObserver implements MapObserver {\n  public resetIndexMap: () => void;\n  public lifecycle: ILifecycle;\n\n  public collection: IObservedMap;\n  public readonly flags: LifecycleFlags;\n\n  constructor(flags: LifecycleFlags, lifecycle: ILifecycle, map: IObservedMap) {\n    if (Tracer.enabled) { Tracer.enter('MapObserver.constructor', slice.call(arguments)); }\n    this.lifecycle = lifecycle;\n    map.$observer = this;\n    this.collection = map;\n    this.flags = flags & LifecycleFlags.persistentBindingFlags;\n    this.resetIndexMap();\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\nexport function getMapObserver(flags: LifecycleFlags, lifecycle: ILifecycle, map: IObservedMap): MapObserver {\n  return (map.$observer as MapObserver) || new MapObserver(flags, lifecycle, map);\n}\n","import { Tracer } from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport { ILifecycle } from '../lifecycle';\nimport { CollectionKind, ICollectionObserver, IObservedSet } from '../observation';\nimport { collectionObserver } from './collection-observer';\n\nconst proto = Set.prototype;\n\nconst $add = proto.add;\nconst $clear = proto.clear;\nconst $delete = proto.delete;\n\nconst native = { add: $add, clear: $clear, delete: $delete };\nconst methods = ['add', 'clear', 'delete'];\n\n// note: we can't really do much with Set due to the internal data structure not being accessible so we're just using the native calls\n// fortunately, add/delete/clear are easy to reconstruct for the indexMap\n\nconst observe = {\n  // https://tc39.github.io/ecma262/#sec-set.prototype.add\n  add: function(this: IObservedSet, value: unknown): ReturnType<typeof $add> {\n    let $this = this;\n    if ($this.$raw !== undefined) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === undefined) {\n      $add.call($this, value);\n      return this;\n    }\n    const oldSize = $this.size;\n    $add.call($this, value);\n    const newSize = $this.size;\n    if (newSize === oldSize) {\n      return this;\n    }\n    o.indexMap[oldSize] = -2;\n    o.callSubscribers('add', arguments, o.persistentFlags | LifecycleFlags.isCollectionMutation);\n    return this;\n  },\n  // https://tc39.github.io/ecma262/#sec-set.prototype.clear\n  clear: function(this: IObservedSet): ReturnType<typeof $clear>  {\n    let $this = this;\n    if ($this.$raw !== undefined) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === undefined) {\n      return $clear.call($this);\n    }\n    const size = $this.size;\n    if (size > 0) {\n      const indexMap = o.indexMap;\n      let i = 0;\n      for (const entry of $this.keys()) {\n        if (indexMap[i] > -1) {\n        indexMap.deletedItems.push(entry);\n        }\n        i++;\n      }\n      $clear.call($this);\n      indexMap.length = 0;\n      o.callSubscribers('clear', arguments, o.persistentFlags | LifecycleFlags.isCollectionMutation);\n    }\n    return undefined;\n  },\n  // https://tc39.github.io/ecma262/#sec-set.prototype.delete\n  delete: function(this: IObservedSet, value: unknown): ReturnType<typeof $delete> {\n    let $this = this;\n    if ($this.$raw !== undefined) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === undefined) {\n      return $delete.call($this, value);\n    }\n    const size = $this.size;\n    if (size === 0) {\n      return false;\n    }\n    let i = 0;\n    const indexMap = o.indexMap;\n    for (const entry of $this.keys()) {\n      if (entry === value) {\n        if (indexMap[i] > -1) {\n          indexMap.deletedItems.push(entry);\n        }\n        indexMap.splice(i, 1);\n        return $delete.call($this, value);\n      }\n      i++;\n    }\n    o.callSubscribers('delete', arguments, o.persistentFlags | LifecycleFlags.isCollectionMutation);\n    return false;\n  }\n};\n\nconst descriptorProps = {\n  writable: true,\n  enumerable: false,\n  configurable: true\n};\n\nconst def = Object.defineProperty;\n\nfor (const method of methods) {\n  def(observe[method], 'observing', { value: true, writable: false, configurable: false, enumerable: false });\n}\n\nexport function enableSetObservation(): void {\n  for (const method of methods) {\n    if (proto[method].observing !== true) {\n      def(proto, method, { ...descriptorProps, value: observe[method] });\n    }\n  }\n}\n\nenableSetObservation();\n\nexport function disableSetObservation(): void {\n  for (const method of methods) {\n    if (proto[method].observing === true) {\n      def(proto, method, { ...descriptorProps, value: native[method] });\n    }\n  }\n}\n\nconst slice = Array.prototype.slice;\n\nexport interface SetObserver extends ICollectionObserver<CollectionKind.set> {}\n\n@collectionObserver(CollectionKind.set)\nexport class SetObserver implements SetObserver {\n  public resetIndexMap: () => void;\n\n  public collection: IObservedSet;\n  public readonly flags: LifecycleFlags;\n\n  constructor(flags: LifecycleFlags, lifecycle: ILifecycle, observedSet: IObservedSet) {\n    if (Tracer.enabled) { Tracer.enter('SetObserver.constructor', slice.call(arguments)); }\n    this.lifecycle = lifecycle;\n    observedSet.$observer = this;\n    this.collection = observedSet;\n    this.flags = flags & LifecycleFlags.persistentBindingFlags;\n    this.resetIndexMap();\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\nexport function getSetObserver(flags: LifecycleFlags, lifecycle: ILifecycle, observedSet: IObservedSet): SetObserver {\n  return (observedSet.$observer as SetObserver) || new SetObserver(flags, lifecycle, observedSet);\n}\n","import { Constructable, PLATFORM, Reporter, Tracer } from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport { ILifecycle } from '../lifecycle';\nimport {\n  IBatchedSubscribable,\n  IBindingTargetObserver,\n  IObservable,\n  IPropertySubscriber,\n  ISubscribable,\n  MutationKind\n} from '../observation';\nimport { IDirtyChecker } from './dirty-checker';\nimport { IObserverLocator } from './observer-locator';\nimport { subscriberCollection } from './subscriber-collection';\n\nconst slice = Array.prototype.slice;\n\nexport interface ComputedOverrides {\n  // Indicates that a getter doesn't need to re-calculate its dependencies after the first observation.\n  static?: boolean;\n\n  // Indicates that the getter of a getter/setter pair can change its value based on side-effects outside the setter.\n  volatile?: boolean;\n}\n\nexport type ComputedLookup = { computed?: Record<string, ComputedOverrides> };\n\nexport function computed(config: ComputedOverrides): PropertyDecorator {\n  return function(target: Constructable & ComputedLookup, key: string): void {\n    (target.computed || (target.computed = {}))[key] = config;\n  };\n}\n\nconst computedOverrideDefaults: ComputedOverrides = { static: false, volatile: false };\n\n/* @internal */\nexport function createComputedObserver(\n  flags: LifecycleFlags,\n  observerLocator: IObserverLocator,\n  dirtyChecker: IDirtyChecker,\n  lifecycle: ILifecycle,\n  instance: IObservable & { constructor: IObservable & ComputedLookup },\n  propertyName: string,\n  descriptor: PropertyDescriptor): IBindingTargetObserver {\n\n  if (descriptor.configurable === false) {\n    return dirtyChecker.createProperty(instance, propertyName);\n  }\n\n  if (descriptor.get) {\n    const overrides = instance.constructor.computed && instance.constructor.computed[propertyName] || computedOverrideDefaults;\n\n    if (descriptor.set) {\n      if (overrides.volatile) {\n        return new GetterObserver(flags, overrides, instance, propertyName, descriptor, observerLocator, lifecycle);\n      }\n      return new CustomSetterObserver(instance, propertyName, descriptor);\n    }\n    return new GetterObserver(flags, overrides, instance, propertyName, descriptor, observerLocator, lifecycle);\n  }\n  throw Reporter.error(18, propertyName);\n}\n\nexport interface CustomSetterObserver extends IBindingTargetObserver { }\n\n// Used when the getter is dependent solely on changes that happen within the setter.\n@subscriberCollection(MutationKind.instance)\nexport class CustomSetterObserver implements CustomSetterObserver {\n  public readonly obj: IObservable;\n  public readonly propertyKey: string;\n  public currentValue: unknown;\n  public oldValue: unknown;\n\n  private readonly descriptor: PropertyDescriptor;\n  private observing: boolean;\n\n  constructor(obj: IObservable, propertyKey: string, descriptor: PropertyDescriptor) {\n    this.obj = obj;\n    this.propertyKey = propertyKey;\n    this.currentValue = this.oldValue = undefined;\n    this.descriptor = descriptor;\n    this.observing = false;\n  }\n\n  public setValue(newValue: unknown): void {\n    if (Tracer.enabled) { Tracer.enter('CustomSetterObserver.setValue', slice.call(arguments)); }\n    this.descriptor.set.call(this.obj, newValue);\n    if (this.currentValue !== newValue) {\n      this.oldValue = this.currentValue;\n      this.currentValue = newValue;\n      this.callSubscribers(newValue, this.oldValue, LifecycleFlags.updateTargetInstance);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public subscribe(subscriber: IPropertySubscriber): void {\n    if (!this.observing) {\n      this.convertProperty();\n    }\n    this.addSubscriber(subscriber);\n  }\n\n  public unsubscribe(subscriber: IPropertySubscriber): void {\n    this.removeSubscriber(subscriber);\n  }\n\n  public convertProperty(): void {\n    if (Tracer.enabled) { Tracer.enter('CustomSetterObserver.convertProperty', slice.call(arguments)); }\n    this.observing = true;\n    this.currentValue = this.obj[this.propertyKey];\n\n    const set = (newValue: unknown): void => { this.setValue(newValue); };\n    Reflect.defineProperty(this.obj, this.propertyKey, { set });\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\nexport interface GetterObserver extends IBindingTargetObserver { }\n\n// Used when there is no setter, and the getter is dependent on other properties of the object;\n// Used when there is a setter but the value of the getter can change based on properties set outside of the setter.\n/** @internal */\n@subscriberCollection(MutationKind.instance)\nexport class GetterObserver implements GetterObserver {\n  public readonly obj: IObservable;\n  public readonly propertyKey: string;\n  public currentValue: unknown;\n  public oldValue: unknown;\n\n  private readonly proxy: ProxyHandler<object>;\n  private readonly propertyDeps: ISubscribable<MutationKind.instance>[];\n  private readonly collectionDeps: IBatchedSubscribable<MutationKind.collection>[];\n  private readonly overrides: ComputedOverrides;\n  private readonly descriptor: PropertyDescriptor;\n  private subscriberCount: number;\n  private isCollecting: boolean;\n\n  constructor(flags: LifecycleFlags, overrides: ComputedOverrides, obj: IObservable, propertyKey: string, descriptor: PropertyDescriptor, observerLocator: IObserverLocator, lifecycle: ILifecycle) {\n    this.obj = obj;\n    this.propertyKey = propertyKey;\n    this.isCollecting = false;\n    this.currentValue = this.oldValue = undefined;\n\n    this.propertyDeps = [];\n    this.collectionDeps = [];\n    this.overrides = overrides;\n    this.subscriberCount = 0;\n    this.descriptor = descriptor;\n    this.proxy = new Proxy(obj, createGetterTraps(flags, observerLocator, this));\n\n    const get = (): unknown => this.getValue();\n    Reflect.defineProperty(obj, propertyKey, { get });\n  }\n\n  public addPropertyDep(subscribable: ISubscribable<MutationKind.instance>): void {\n    if (this.propertyDeps.indexOf(subscribable) === -1) {\n      this.propertyDeps.push(subscribable);\n    }\n  }\n\n  public addCollectionDep(subscribable: IBatchedSubscribable<MutationKind.collection>): void {\n    if (this.collectionDeps.indexOf(subscribable) === -1) {\n      this.collectionDeps.push(subscribable);\n    }\n  }\n\n  public getValue(): unknown {\n    if (Tracer.enabled) { Tracer.enter('GetterObserver.getValue', slice.call(arguments)); }\n    if (this.subscriberCount === 0 || this.isCollecting) {\n      this.currentValue = Reflect.apply(this.descriptor.get, this.proxy, PLATFORM.emptyArray);\n    } else {\n      this.currentValue = Reflect.apply(this.descriptor.get, this.obj, PLATFORM.emptyArray);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return this.currentValue;\n  }\n\n  public subscribe(subscriber: IPropertySubscriber): void {\n    this.addSubscriber(subscriber);\n    if (++this.subscriberCount === 1) {\n      this.getValueAndCollectDependencies(true);\n    }\n  }\n\n  public unsubscribe(subscriber: IPropertySubscriber): void {\n    this.removeSubscriber(subscriber);\n    if (--this.subscriberCount === 0) {\n      this.unsubscribeAllDependencies();\n    }\n  }\n\n  public handleChange(): void {\n    const oldValue = this.currentValue;\n    const newValue = this.getValueAndCollectDependencies(false);\n    if (oldValue !== newValue) {\n      this.callSubscribers(newValue, oldValue, LifecycleFlags.updateTargetInstance);\n    }\n  }\n\n  public handleBatchedChange(): void {\n    const oldValue = this.currentValue;\n    const newValue = this.getValueAndCollectDependencies(false);\n    if (oldValue !== newValue) {\n      this.callSubscribers(newValue, oldValue, LifecycleFlags.fromFlush | LifecycleFlags.updateTargetInstance);\n    }\n  }\n\n  public getValueAndCollectDependencies(requireCollect: boolean): unknown {\n    if (Tracer.enabled) { Tracer.enter('GetterObserver.getValueAndCollectDependencies', slice.call(arguments)); }\n    const dynamicDependencies = !this.overrides.static || requireCollect;\n\n    if (dynamicDependencies) {\n      this.unsubscribeAllDependencies();\n      this.isCollecting = true;\n    }\n\n    this.currentValue = this.getValue();\n\n    if (dynamicDependencies) {\n      this.propertyDeps.forEach(x => { x.subscribe(this); });\n      this.collectionDeps.forEach(x => { x.subscribeBatched(this); });\n      this.isCollecting = false;\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n    return this.currentValue;\n  }\n\n  public doNotCollect(key: PropertyKey): boolean {\n    return !this.isCollecting || key === '$observers';\n  }\n\n  private unsubscribeAllDependencies(): void {\n    this.propertyDeps.forEach(x => { x.unsubscribe(this); });\n    this.propertyDeps.length = 0;\n    this.collectionDeps.forEach(x => { x.unsubscribeBatched(this); });\n    this.collectionDeps.length = 0;\n  }\n}\n\nconst toStringTag = Object.prototype.toString;\n\nfunction createGetterTraps(flags: LifecycleFlags, observerLocator: IObserverLocator, observer: GetterObserver): ProxyHandler<object> {\n  if (Tracer.enabled) { Tracer.enter('computed.createGetterTraps', slice.call(arguments)); }\n  const traps = {\n    get: function(target: object, key: PropertyKey, receiver?: unknown): unknown {\n      if (Tracer.enabled) { Tracer.enter('computed.get', slice.call(arguments)); }\n      if (observer.doNotCollect(key)) {\n        if (Tracer.enabled) { Tracer.leave(); }\n        return Reflect.get(target, key, receiver);\n      }\n\n      // The length and iterator properties need to be invoked on the original object (for Map and Set\n      // at least) or they will throw.\n      switch (toStringTag.call(target)) {\n        case '[object Array]':\n          observer.addCollectionDep(observerLocator.getArrayObserver(flags, target as unknown[]));\n          if (key === 'length') {\n            if (Tracer.enabled) { Tracer.leave(); }\n            return Reflect.get(target, key, target);\n          }\n        case '[object Map]':\n          observer.addCollectionDep(observerLocator.getMapObserver(flags, target as Map<unknown, unknown>));\n          if (key === 'size') {\n            if (Tracer.enabled) { Tracer.leave(); }\n            return Reflect.get(target, key, target);\n          }\n        case '[object Set]':\n          observer.addCollectionDep(observerLocator.getSetObserver(flags, target as Set<unknown>));\n          if (key === 'size') {\n            if (Tracer.enabled) { Tracer.leave(); }\n            return Reflect.get(target, key, target);\n          }\n        default:\n          observer.addPropertyDep(observerLocator.getObserver(flags, target, key as string) as IBindingTargetObserver);\n      }\n\n      if (Tracer.enabled) { Tracer.leave(); }\n      return proxyOrValue(flags, target, key, observerLocator, observer);\n    }\n  };\n  if (Tracer.enabled) { Tracer.leave(); }\n  return traps;\n}\n\nfunction proxyOrValue(flags: LifecycleFlags, target: object, key: PropertyKey, observerLocator: IObserverLocator, observer: GetterObserver): ProxyHandler<object> {\n  const value = Reflect.get(target, key, target);\n  if (typeof value === 'function') {\n    return target[key].bind(target);\n  }\n  if (typeof value !== 'object' || value === null) {\n    return value;\n  }\n  return new Proxy(value, createGetterTraps(flags, observerLocator, observer));\n}\n","import { DI, PLATFORM, Reporter, Tracer } from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport { IBindingTargetObserver, IObservable, IPropertySubscriber } from '../observation';\nimport { propertyObserver } from './property-observer';\n\nexport interface IDirtyChecker {\n  createProperty(obj: IObservable, propertyName: string): IBindingTargetObserver;\n  addProperty(property: DirtyCheckProperty): void;\n  removeProperty(property: DirtyCheckProperty): void;\n}\n\nexport const IDirtyChecker = DI.createInterface<IDirtyChecker>('IDirtyChecker').withDefault(x => x.singleton(DirtyChecker));\n\nexport const DirtyCheckSettings = {\n  /**\n   * Default: `6`\n   *\n   * Adjust the global dirty check frequency.\n   * Measures in \"frames per check\", such that (given an FPS of 60):\n   * - A value of 1 will result in 60 dirty checks per second\n   * - A value of 6 will result in 10 dirty checks per second\n   */\n  framesPerCheck: 6,\n  /**\n   * Default: `false`\n   *\n   * Disable dirty-checking entirely. Properties that cannot be observed without dirty checking\n   * or an adapter, will simply not be observed.\n   */\n  disabled: false,\n  /**\n   * Default: `true`\n   *\n   * Log a warning message to the console if a property is being dirty-checked.\n   */\n  warn: true,\n  /**\n   * Default: `false`\n   *\n   * Throw an error if a property is being dirty-checked.\n   */\n  throw: false,\n  /**\n   * Resets all dirty checking settings to the framework's defaults.\n   */\n  resetToDefault(): void {\n    this.framesPerCheck = 6;\n    this.disabled = false;\n    this.warn = true;\n    this.throw = false;\n  }\n};\n\n/** @internal */\nexport class DirtyChecker {\n  private readonly tracked: DirtyCheckProperty[];\n\n  private elapsedFrames: number;\n\n  public constructor() {\n    this.elapsedFrames = 0;\n    this.tracked = [];\n  }\n\n  public createProperty(obj: IObservable, propertyName: string): DirtyCheckProperty {\n    if (DirtyCheckSettings.throw) {\n      throw Reporter.error(800); // TODO: create/organize error code\n    }\n    if (DirtyCheckSettings.warn) {\n      Reporter.write(801);\n    }\n    return new DirtyCheckProperty(this, obj, propertyName);\n  }\n\n  public addProperty(property: DirtyCheckProperty): void {\n    this.tracked.push(property);\n\n    if (this.tracked.length === 1) {\n      PLATFORM.ticker.add(this.check, this);\n    }\n  }\n\n  public removeProperty(property: DirtyCheckProperty): void {\n    this.tracked.splice(this.tracked.indexOf(property), 1);\n    if (this.tracked.length === 0) {\n      PLATFORM.ticker.remove(this.check, this);\n    }\n  }\n\n  public check(delta: number): void {\n    if (DirtyCheckSettings.disabled) {\n      return;\n    }\n    if (++this.elapsedFrames < DirtyCheckSettings.framesPerCheck) {\n      return;\n    }\n    this.elapsedFrames = 0;\n    const tracked = this.tracked;\n    const len = tracked.length;\n    let current: DirtyCheckProperty;\n    let i = 0;\n    for (; i < len; ++i) {\n      current = tracked[i];\n      if (current.isDirty()) {\n        current.flush(LifecycleFlags.fromTick);\n      }\n    }\n  }\n}\n\nconst slice = Array.prototype.slice;\n\nexport interface DirtyCheckProperty extends IBindingTargetObserver { }\n\n@propertyObserver()\nexport class DirtyCheckProperty implements DirtyCheckProperty {\n  public obj: IObservable;\n  public oldValue: unknown;\n  public propertyKey: string;\n\n  private readonly dirtyChecker: IDirtyChecker;\n\n  constructor(dirtyChecker: IDirtyChecker, obj: IObservable, propertyKey: string) {\n    if (Tracer.enabled) { Tracer.enter('DirtyCheckProperty.constructor', slice.call(arguments)); }\n    this.obj = obj;\n    this.propertyKey = propertyKey;\n\n    this.dirtyChecker = dirtyChecker;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public isDirty(): boolean {\n    return this.oldValue !== this.obj[this.propertyKey];\n  }\n\n  public flush(flags: LifecycleFlags): void {\n    const oldValue = this.oldValue;\n    const newValue = this.obj[this.propertyKey];\n\n    this.callSubscribers(newValue, oldValue, flags | LifecycleFlags.updateTargetInstance);\n\n    this.oldValue = newValue;\n  }\n\n  public subscribe(subscriber: IPropertySubscriber): void {\n    if (!this.hasSubscribers()) {\n      this.oldValue = this.obj[this.propertyKey];\n      this.dirtyChecker.addProperty(this);\n    }\n    this.addSubscriber(subscriber);\n  }\n\n  public unsubscribe(subscriber: IPropertySubscriber): void {\n    if (this.removeSubscriber(subscriber) && !this.hasSubscribers()) {\n      this.dirtyChecker.removeProperty(this);\n    }\n  }\n}\n","import { PLATFORM, Primitive, Tracer } from '@aurelia/kernel';\nimport { IAccessor, ISubscribable, MutationKind } from '../observation';\n\nconst slice = Array.prototype.slice;\n\nconst noop = PLATFORM.noop;\n\n// note: string.length is the only property of any primitive that is not a function,\n// so we can hardwire it to that and simply return undefined for anything else\n// note#2: a modified primitive constructor prototype would not work (and really, it shouldn't..)\nexport class PrimitiveObserver implements IAccessor, ISubscribable<MutationKind.instance> {\n  public getValue: () => undefined | number;\n  // removed the error reporter here because technically any primitive property that can get, can also set,\n  // but since that never serves any purpose (e.g. setting string.length doesn't throw but doesn't change the length either),\n  // we could best just leave this as a no-op and so don't need to store the propertyName\n  public setValue: () => void;\n  public subscribe: () => void;\n  public unsubscribe: () => void;\n  public dispose: () => void;\n\n  public doNotCache: boolean = true;\n  public obj: Primitive;\n\n  constructor(obj: Primitive, propertyKey: PropertyKey) {\n    if (Tracer.enabled) { Tracer.enter('PrimitiveObserver.constructor', slice.call(arguments)); }\n    // we don't need to store propertyName because only 'length' can return a useful value\n    if (propertyKey === 'length') {\n      // deliberately not checking for typeof string as users probably still want to know via an error that their string is undefined\n      this.obj = obj;\n      this.getValue = this.getStringLength;\n    } else {\n      this.getValue = this.returnUndefined;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private getStringLength(): number {\n    return (this.obj as string).length;\n  }\n  private returnUndefined(): undefined {\n    return undefined;\n  }\n}\nPrimitiveObserver.prototype.setValue = noop;\nPrimitiveObserver.prototype.subscribe = noop;\nPrimitiveObserver.prototype.unsubscribe = noop;\nPrimitiveObserver.prototype.dispose = noop;\n","import { Tracer } from '@aurelia/kernel';\nimport { IBindingTargetAccessor } from '../observation';\n\nexport interface PropertyAccessor extends IBindingTargetAccessor<Record<string, unknown>, string> {}\nconst slice = Array.prototype.slice;\n\nexport class PropertyAccessor implements PropertyAccessor {\n  public obj: Record<string, unknown>;\n  public propertyKey: string;\n\n  constructor(obj: Record<string, unknown>, propertyKey: string) {\n    if (Tracer.enabled) { Tracer.enter('ArrayObserver.constructor', slice.call(arguments)); }\n    this.obj = obj;\n    this.propertyKey = propertyKey;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public getValue(): unknown {\n    return this.obj[this.propertyKey];\n  }\n\n  public setValue(value: unknown): void {\n    this.obj[this.propertyKey] = value;\n  }\n}\n","import { DI, IContainer, InterfaceSymbol, IResolver, Primitive, Registration, Reporter } from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport { ILifecycle } from '../lifecycle';\nimport {\n  AccessorOrObserver,\n  CollectionKind,\n  CollectionObserver,\n  IBindingContext,\n  IBindingTargetAccessor,\n  IBindingTargetObserver,\n  ICollectionObserver,\n  IObservable,\n  IObservedArray,\n  IObservedMap,\n  IObservedSet\n} from '../observation';\nimport { getArrayObserver } from './array-observer';\nimport { createComputedObserver } from './computed-observer';\nimport { IDirtyChecker } from './dirty-checker';\nimport { getMapObserver } from './map-observer';\nimport { PrimitiveObserver } from './primitive-observer';\nimport { PropertyAccessor } from './property-accessor';\nimport { ProxyObserver } from './proxy-observer';\nimport { getSetObserver } from './set-observer';\nimport { SetterObserver } from './setter-observer';\n\nconst toStringTag = Object.prototype.toString;\n\nexport interface IObjectObservationAdapter {\n  getObserver(flags: LifecycleFlags, object: unknown, propertyName: string, descriptor: PropertyDescriptor): IBindingTargetObserver;\n}\n\nexport interface IObserverLocator {\n  getObserver(flags: LifecycleFlags, obj: IObservable|IBindingContext, propertyName: string): AccessorOrObserver;\n  getAccessor(flags: LifecycleFlags, obj: IObservable, propertyName: string): IBindingTargetAccessor;\n  addAdapter(adapter: IObjectObservationAdapter): void;\n  getArrayObserver(flags: LifecycleFlags, observedArray: unknown[]): ICollectionObserver<CollectionKind.array>;\n  getMapObserver(flags: LifecycleFlags, observedMap: Map<unknown, unknown>): ICollectionObserver<CollectionKind.map>;\n  getSetObserver(flags: LifecycleFlags, observedSet: Set<unknown>): ICollectionObserver<CollectionKind.set>;\n}\n\nexport const IObserverLocator = DI.createInterface<IObserverLocator>('IObserverLocator').noDefault();\n\nexport interface ITargetObserverLocator {\n  getObserver(flags: LifecycleFlags, lifecycle: ILifecycle, observerLocator: IObserverLocator, obj: unknown, propertyName: string): IBindingTargetAccessor | IBindingTargetObserver;\n  overridesAccessor(flags: LifecycleFlags, obj: unknown, propertyName: string): boolean;\n  handles(flags: LifecycleFlags, obj: unknown): boolean;\n}\nexport const ITargetObserverLocator = DI.createInterface<ITargetObserverLocator>('ITargetObserverLocator').noDefault();\n\nexport interface ITargetAccessorLocator {\n  getAccessor(flags: LifecycleFlags, lifecycle: ILifecycle, obj: unknown, propertyName: string): IBindingTargetAccessor;\n  handles(flags: LifecycleFlags, obj: unknown): boolean;\n}\nexport const ITargetAccessorLocator = DI.createInterface<ITargetAccessorLocator>('ITargetAccessorLocator').noDefault();\n\nfunction getPropertyDescriptor(subject: object, name: string): PropertyDescriptor {\n  let pd = Object.getOwnPropertyDescriptor(subject, name);\n  let proto = Object.getPrototypeOf(subject);\n\n  while (pd === undefined && proto !== null) {\n    pd = Object.getOwnPropertyDescriptor(proto, name);\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return pd;\n}\n\n/** @internal */\nexport class ObserverLocator implements IObserverLocator {\n  public static readonly inject: ReadonlyArray<InterfaceSymbol> = [ILifecycle, IDirtyChecker, ITargetObserverLocator, ITargetAccessorLocator];\n\n  private readonly adapters: IObjectObservationAdapter[];\n  private readonly dirtyChecker: IDirtyChecker;\n  private readonly lifecycle: ILifecycle;\n  private readonly targetObserverLocator: ITargetObserverLocator;\n  private readonly targetAccessorLocator: ITargetAccessorLocator;\n\n  constructor(\n    lifecycle: ILifecycle,\n    dirtyChecker: IDirtyChecker,\n    targetObserverLocator: ITargetObserverLocator,\n    targetAccessorLocator: ITargetAccessorLocator\n  ) {\n    this.adapters = [];\n    this.dirtyChecker = dirtyChecker;\n    this.lifecycle = lifecycle;\n    this.targetObserverLocator = targetObserverLocator;\n    this.targetAccessorLocator = targetAccessorLocator;\n  }\n\n  public static register(container: IContainer): IResolver<IObserverLocator> {\n    return Registration.singleton(IObserverLocator, this).register(container);\n  }\n\n  public getObserver(flags: LifecycleFlags, obj: IObservable|IBindingContext, propertyName: string): AccessorOrObserver {\n    if (flags & LifecycleFlags.useProxies && typeof obj === 'object') {\n      return ProxyObserver.getOrCreate(obj, propertyName) as unknown as AccessorOrObserver; // TODO: fix typings (and ensure proper contracts ofc)\n    }\n    if (isBindingContext(obj)) {\n      return obj.getObservers(flags).getOrCreate(flags, obj, propertyName);\n    }\n    let observersLookup = obj.$observers;\n    let observer: AccessorOrObserver & { doNotCache?: boolean };\n\n    if (observersLookup && propertyName in observersLookup) {\n      return observersLookup[propertyName];\n    }\n\n    observer = this.createPropertyObserver(flags, obj, propertyName);\n\n    if (!observer.doNotCache) {\n      if (observersLookup === undefined) {\n        observersLookup = this.getOrCreateObserversLookup(obj);\n      }\n\n      observersLookup[propertyName] = observer;\n    }\n\n    return observer;\n  }\n\n  public addAdapter(adapter: IObjectObservationAdapter): void {\n    this.adapters.push(adapter);\n  }\n\n  public getAccessor(flags: LifecycleFlags, obj: IObservable, propertyName: string): IBindingTargetAccessor {\n    if (this.targetAccessorLocator.handles(flags, obj)) {\n      if (this.targetObserverLocator.overridesAccessor(flags, obj, propertyName)) {\n        return this.getObserver(flags, obj, propertyName);\n      }\n      return this.targetAccessorLocator.getAccessor(flags, this.lifecycle, obj, propertyName);\n    }\n\n    if (flags & LifecycleFlags.useProxies) {\n      return ProxyObserver.getOrCreate(obj, propertyName) as unknown as AccessorOrObserver;\n    }\n    return new PropertyAccessor(obj, propertyName);\n  }\n\n  public getArrayObserver(flags: LifecycleFlags, observedArray: IObservedArray): ICollectionObserver<CollectionKind.array> {\n    return getArrayObserver(flags, this.lifecycle, observedArray);\n  }\n\n  public getMapObserver(flags: LifecycleFlags, observedMap: IObservedMap): ICollectionObserver<CollectionKind.map>  {\n    return getMapObserver(flags, this.lifecycle, observedMap);\n  }\n\n  public getSetObserver(flags: LifecycleFlags, observedSet: IObservedSet): ICollectionObserver<CollectionKind.set>  {\n    return getSetObserver(flags, this.lifecycle, observedSet);\n  }\n\n  private getOrCreateObserversLookup(obj: IObservable): Record<string, AccessorOrObserver | IBindingTargetObserver> {\n    return obj.$observers || this.createObserversLookup(obj);\n  }\n\n  private createObserversLookup(obj: IObservable): Record<string, IBindingTargetObserver> {\n    const value: Record<string, IBindingTargetObserver> = {};\n    if (!Reflect.defineProperty(obj, '$observers', {\n      enumerable: false,\n      configurable: false,\n      writable: false,\n      value: value\n    })) {\n      Reporter.write(0, obj);\n    }\n    return value;\n  }\n\n  private getAdapterObserver(flags: LifecycleFlags, obj: IObservable, propertyName: string, descriptor: PropertyDescriptor): IBindingTargetObserver | null {\n    for (let i = 0, ii = this.adapters.length; i < ii; i++) {\n      const adapter = this.adapters[i];\n      const observer = adapter.getObserver(flags, obj, propertyName, descriptor);\n      if (observer) {\n        return observer;\n      }\n    }\n    return null;\n  }\n\n  private createPropertyObserver(flags: LifecycleFlags, obj: IObservable, propertyName: string): AccessorOrObserver {\n    if (!(obj instanceof Object)) {\n      return new PrimitiveObserver(obj as unknown as Primitive, propertyName) as IBindingTargetAccessor;\n    }\n\n    let isNode = false;\n    if (this.targetObserverLocator.handles(flags, obj)) {\n      const observer = this.targetObserverLocator.getObserver(flags, this.lifecycle, this, obj, propertyName);\n      if (observer !== null) {\n        return observer;\n      }\n      if (observer !== null) {\n        return observer;\n      }\n      isNode = true;\n    }\n\n    const tag = toStringTag.call(obj);\n    switch (tag) {\n      case '[object Array]':\n        if (propertyName === 'length') {\n          return this.getArrayObserver(flags, obj as IObservedArray).getLengthObserver(flags);\n        }\n        return this.dirtyChecker.createProperty(obj, propertyName);\n      case '[object Map]':\n        if (propertyName === 'size') {\n          return this.getMapObserver(flags, obj as IObservedMap).getLengthObserver(flags);\n        }\n        return this.dirtyChecker.createProperty(obj, propertyName);\n      case '[object Set]':\n        if (propertyName === 'size') {\n          return this.getSetObserver(flags, obj as IObservedSet).getLengthObserver(flags);\n        }\n        return this.dirtyChecker.createProperty(obj, propertyName);\n    }\n\n    const descriptor = getPropertyDescriptor(obj, propertyName) as PropertyDescriptor & {\n      get: PropertyDescriptor['get'] & { getObserver(obj: IObservable): IBindingTargetObserver };\n    };\n\n    if (descriptor && (descriptor.get || descriptor.set)) {\n      if (descriptor.get && descriptor.get.getObserver) {\n        return descriptor.get.getObserver(obj);\n      }\n\n      // attempt to use an adapter before resorting to dirty checking.\n      const adapterObserver = this.getAdapterObserver(flags, obj, propertyName, descriptor);\n      if (adapterObserver) {\n        return adapterObserver;\n      }\n      if (isNode) {\n        // TODO: use MutationObserver\n        return this.dirtyChecker.createProperty(obj, propertyName);\n      }\n\n      return createComputedObserver(flags, this, this.dirtyChecker, this.lifecycle, obj, propertyName, descriptor);\n    }\n    return new SetterObserver(flags, obj, propertyName);\n  }\n}\n\nexport function getCollectionObserver(flags: LifecycleFlags, lifecycle: ILifecycle, collection: IObservedMap | IObservedSet | IObservedArray): CollectionObserver {\n  switch (toStringTag.call(collection)) {\n    case '[object Array]':\n      return getArrayObserver(flags, lifecycle, collection as IObservedArray);\n    case '[object Map]':\n      return getMapObserver(flags, lifecycle, collection as IObservedMap);\n    case '[object Set]':\n      return getSetObserver(flags, lifecycle, collection as IObservedSet);\n  }\n  return null;\n}\n\nfunction isBindingContext(obj: unknown): obj is IBindingContext {\n  return (obj as IBindingContext).$synthetic === true;\n}\n","import { IIndexable, PLATFORM, Tracer } from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport { IPropertyObserver } from '../observation';\nimport { propertyObserver } from './property-observer';\nimport { ProxyObserver } from './proxy-observer';\n\nconst slice = Array.prototype.slice;\nconst noop = PLATFORM.noop;\n\nexport interface SelfObserver extends IPropertyObserver<IIndexable, string> {}\n\n@propertyObserver()\nexport class SelfObserver implements SelfObserver {\n  public readonly persistentFlags: LifecycleFlags;\n  public obj: IIndexable;\n  public propertyKey: string;\n  public currentValue: unknown;\n\n  private readonly callback: (newValue: unknown, oldValue: unknown, flags?: LifecycleFlags) => unknown;\n\n  constructor(\n    flags: LifecycleFlags,\n    instance: object,\n    propertyName: string,\n    callbackName: string\n  ) {\n    if (Tracer.enabled) { Tracer.enter('SelfObserver.constructor', slice.call(arguments)); }\n    this.persistentFlags = flags & LifecycleFlags.persistentBindingFlags;\n    if (ProxyObserver.isProxy(instance)) {\n      instance.$observer.subscribe(this, propertyName);\n      this.obj = instance.$raw;\n      this.propertyKey = propertyName;\n      this.currentValue = instance.$raw[propertyName];\n      this.callback = callbackName in instance.$raw\n        ? instance[callbackName].bind(instance)\n        : noop;\n    } else {\n      this.obj = instance;\n      this.propertyKey = propertyName;\n      this.currentValue = instance[propertyName];\n      this.callback = callbackName in instance\n        ? instance[callbackName].bind(instance)\n        : noop;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public handleChange(newValue: unknown, oldValue: unknown, flags: LifecycleFlags): void {\n    this.setValue(newValue, flags);\n  }\n\n  public getValue(): unknown {\n    return this.currentValue;\n  }\n\n  public setValue(newValue: unknown, flags: LifecycleFlags): void {\n    const currentValue = this.currentValue;\n\n    if (currentValue !== newValue) {\n      this.currentValue = newValue;\n\n      if (!(flags & LifecycleFlags.fromBind)) {\n        const coercedValue = this.callback(newValue, currentValue, flags);\n\n        if (coercedValue !== undefined) {\n          this.currentValue = newValue = coercedValue;\n        }\n\n        this.callSubscribers(newValue, currentValue, flags);\n      }\n    }\n  }\n}\n","import { IRegistry } from '@aurelia/kernel';\nimport { Binding } from '../../binding/binding';\nimport { BindingMode, LifecycleFlags } from '../../flags';\nimport { IScope } from '../../observation';\nimport { BindingBehaviorResource } from '../binding-behavior';\n\nconst { oneTime, toView, fromView, twoWay } = BindingMode;\n\nexport type WithMode = { mode: BindingMode; originalMode?: BindingMode };\n\nexport abstract class BindingModeBehavior {\n  private readonly mode: BindingMode;\n\n  constructor(mode: BindingMode) {\n    this.mode = mode;\n  }\n\n  public bind(flags: LifecycleFlags, scope: IScope, binding: Binding & WithMode): void {\n    binding.originalMode = binding.mode;\n    binding.mode = this.mode;\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: Binding & WithMode): void {\n    binding.mode = binding.originalMode;\n    binding.originalMode = null;\n  }\n}\n\nexport class OneTimeBindingBehavior extends BindingModeBehavior {\n  public static register: IRegistry['register'];\n\n  constructor() {\n    super(oneTime);\n  }\n}\nBindingBehaviorResource.define('oneTime', OneTimeBindingBehavior);\n\nexport class ToViewBindingBehavior extends BindingModeBehavior {\n  public static register: IRegistry['register'];\n\n  constructor() {\n    super(toView);\n  }\n}\nBindingBehaviorResource.define('toView', ToViewBindingBehavior);\n\nexport class FromViewBindingBehavior extends BindingModeBehavior {\n  public static register: IRegistry['register'];\n\n  constructor() {\n    super(fromView);\n  }\n}\nBindingBehaviorResource.define('fromView', FromViewBindingBehavior);\n\nexport class TwoWayBindingBehavior extends BindingModeBehavior {\n  public static register: IRegistry['register'];\n\n  constructor() {\n    super(twoWay);\n  }\n}\nBindingBehaviorResource.define('twoWay', TwoWayBindingBehavior);\n","import { IRegistry, PLATFORM } from '@aurelia/kernel';\nimport { Binding } from '../../binding/binding';\nimport { BindingMode, LifecycleFlags } from '../../flags';\nimport { IBinding } from '../../lifecycle';\nimport { IScope } from '../../observation';\nimport { BindingBehaviorResource } from '../binding-behavior';\n\nexport type DebounceableBinding = IBinding & {\n  debouncedMethod: ((newValue: unknown, oldValue: unknown, flags: LifecycleFlags) => void) & { originalName: string };\n  debounceState: {\n    callContextToDebounce: LifecycleFlags;\n    delay: number;\n    timeoutId: number;\n    oldValue: unknown;\n  };\n};\n\nconst unset = {};\n\n/** @internal */\nexport function debounceCallSource(this: DebounceableBinding, newValue: unknown, oldValue: unknown, flags: LifecycleFlags): void {\n  const state = this.debounceState;\n  PLATFORM.global.clearTimeout(state.timeoutId);\n  state.timeoutId = PLATFORM.global.setTimeout(() => { this.debouncedMethod(newValue, oldValue, flags); }, state.delay);\n}\n\n/** @internal */\nexport function debounceCall(this: DebounceableBinding, newValue: unknown, oldValue: unknown, flags: LifecycleFlags): void {\n  const state = this.debounceState;\n  PLATFORM.global.clearTimeout(state.timeoutId);\n  if (!(flags & state.callContextToDebounce)) {\n    state.oldValue = unset;\n    this.debouncedMethod(newValue, oldValue, flags);\n    return;\n  }\n  if (state.oldValue === unset) {\n    state.oldValue = oldValue;\n  }\n  const timeoutId = PLATFORM.global.setTimeout(\n    () => {\n      const ov = state.oldValue;\n      state.oldValue = unset;\n      this.debouncedMethod(newValue, ov, flags);\n    },\n    state.delay\n  );\n  state.timeoutId = timeoutId;\n}\n\nconst fromView = BindingMode.fromView;\n\nexport class DebounceBindingBehavior {\n  public static register: IRegistry['register'];\n\n  public bind(flags: LifecycleFlags, scope: IScope, binding: DebounceableBinding, delay: number = 200): void {\n    let methodToDebounce;\n    let callContextToDebounce;\n    let debouncer;\n\n    if (binding instanceof Binding) {\n      methodToDebounce = 'handleChange';\n      debouncer = debounceCall;\n      callContextToDebounce = binding.mode & fromView ? LifecycleFlags.updateSourceExpression : LifecycleFlags.updateTargetInstance;\n    } else {\n      methodToDebounce = 'callSource';\n      debouncer = debounceCallSource;\n      callContextToDebounce = LifecycleFlags.updateTargetInstance;\n    }\n\n    // stash the original method and it's name.\n    // note: a generic name like \"originalMethod\" is not used to avoid collisions\n    // with other binding behavior types.\n    binding.debouncedMethod = binding[methodToDebounce];\n    binding.debouncedMethod.originalName = methodToDebounce;\n\n    // replace the original method with the debouncing version.\n    binding[methodToDebounce] = debouncer;\n\n    // create the debounce state.\n    binding.debounceState = {\n      callContextToDebounce,\n      delay,\n      timeoutId: 0,\n      oldValue: unset\n    };\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: DebounceableBinding): void {\n    // restore the state of the binding.\n    const methodToRestore = binding.debouncedMethod.originalName;\n    binding[methodToRestore] = binding.debouncedMethod;\n    binding.debouncedMethod = null;\n    PLATFORM.global.clearTimeout(binding.debounceState.timeoutId);\n    binding.debounceState = null;\n  }\n}\nBindingBehaviorResource.define('debounce', DebounceBindingBehavior);\n","import { InterfaceSymbol, IRegistry, Reporter } from '@aurelia/kernel';\nimport { Binding } from '../../binding/binding';\nimport { LifecycleFlags } from '../../flags';\nimport { IScope } from '../../observation';\nimport { ISignaler } from '../../observation/signaler';\nimport { BindingBehaviorResource } from '../binding-behavior';\n\nexport type SignalableBinding = Binding & {\n  signal: string | string[];\n};\n\nexport class SignalBindingBehavior {\n  public static readonly inject: ReadonlyArray<InterfaceSymbol> = [ISignaler];\n\n  public static register: IRegistry['register'];\n\n  private readonly signaler: ISignaler;\n\n  constructor(signaler: ISignaler) {\n    this.signaler = signaler;\n  }\n\n  public bind(flags: LifecycleFlags, scope: IScope, binding: SignalableBinding, ...args: string[]): void {\n    if (!binding.updateTarget) {\n      throw Reporter.error(11);\n    }\n\n    if (arguments.length === 4) {\n      const name = args[0];\n      this.signaler.addSignalListener(name, binding);\n      binding.signal = name;\n    } else if (arguments.length > 4) {\n      const names = Array.prototype.slice.call(arguments, 3);\n      let i = names.length;\n\n      while (i--) {\n        const name = names[i];\n        this.signaler.addSignalListener(name, binding);\n      }\n\n      binding.signal = names;\n    } else {\n      throw Reporter.error(12);\n    }\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: SignalableBinding): void {\n    const name = binding.signal;\n    binding.signal = null;\n\n    if (Array.isArray(name)) {\n      const names = name;\n      let i = names.length;\n\n      while (i--) {\n        this.signaler.removeSignalListener(names[i], binding);\n      }\n    } else {\n      this.signaler.removeSignalListener(name, binding);\n    }\n  }\n}\nBindingBehaviorResource.define('signal', SignalBindingBehavior);\n","import { IRegistry, PLATFORM } from '@aurelia/kernel';\nimport { Binding } from '../../binding/binding';\nimport { BindingMode, LifecycleFlags } from '../../flags';\nimport { IBinding } from '../../lifecycle';\nimport { IScope } from '../../observation';\nimport { BindingBehaviorResource } from '../binding-behavior';\n\nexport type ThrottleableBinding = IBinding & {\n  throttledMethod: ((value: unknown) => unknown) & { originalName: string };\n  throttleState: {\n    delay: number;\n    timeoutId: number;\n    last: number;\n    newValue?: unknown;\n  };\n};\n\n/** @internal */\nexport function throttle(this: ThrottleableBinding, newValue: unknown): void {\n  const state = this.throttleState;\n  const elapsed = +new Date() - state.last;\n\n  if (elapsed >= state.delay) {\n    PLATFORM.global.clearTimeout(state.timeoutId);\n    state.timeoutId = -1;\n    state.last = +new Date();\n    this.throttledMethod(newValue);\n    return;\n  }\n\n  state.newValue = newValue;\n\n  if (state.timeoutId === -1) {\n    const timeoutId = PLATFORM.global.setTimeout(\n      () => {\n        state.timeoutId = -1;\n        state.last = +new Date();\n        this.throttledMethod(state.newValue);\n      },\n      state.delay - elapsed\n    );\n    state.timeoutId = timeoutId;\n  }\n}\n\nexport class ThrottleBindingBehavior {\n  public static register: IRegistry['register'];\n\n  public bind(flags: LifecycleFlags, scope: IScope, binding: ThrottleableBinding, delay: number = 200): void {\n    let methodToThrottle: string;\n\n    if (binding instanceof Binding) {\n      if (binding.mode === BindingMode.twoWay) {\n        methodToThrottle = 'updateSource';\n      } else {\n        methodToThrottle = 'updateTarget';\n      }\n    } else {\n      methodToThrottle = 'callSource';\n    }\n\n    // stash the original method and it's name.\n    // note: a generic name like \"originalMethod\" is not used to avoid collisions\n    // with other binding behavior types.\n    binding.throttledMethod = binding[methodToThrottle];\n    binding.throttledMethod.originalName = methodToThrottle;\n\n    // replace the original method with the throttling version.\n    binding[methodToThrottle] = throttle;\n\n    // create the throttle state.\n    binding.throttleState = {\n      delay: delay,\n      last: 0,\n      timeoutId: -1\n    };\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: ThrottleableBinding): void {\n    // restore the state of the binding.\n    const methodToRestore = binding.throttledMethod.originalName;\n    binding[methodToRestore] = binding.throttledMethod;\n    binding.throttledMethod = null;\n    PLATFORM.global.clearTimeout(binding.throttleState.timeoutId);\n    binding.throttleState = null;\n  }\n}\nBindingBehaviorResource.define('throttle', ThrottleBindingBehavior);\n","import {\n  Constructable,\n  DI,\n  Immutable,\n  IRegistry,\n  IResourceDefinition,\n  Omit,\n  PLATFORM,\n  ResourceDescription,\n  ResourcePartDescription\n} from '@aurelia/kernel';\nimport { IForOfStatement, IInterpolationExpression, IsBindingBehavior } from './ast';\nimport { BindingMode } from './flags';\nimport { CustomElementHost, ICustomElement } from './resources/custom-element';\n\n/** @internal */\nexport const customElementName = 'custom-element';\n/** @internal */\nexport function customElementKey(name: string): string {\n  return `${customElementName}:${name}`;\n}\n/** @internal */\nexport function customElementBehavior(node: unknown): ICustomElement | null {\n  return (node as CustomElementHost).$customElement === undefined ? null : (node as CustomElementHost).$customElement;\n}\n\n/** @internal */\nexport const customAttributeName = 'custom-attribute';\n/** @internal */\nexport function customAttributeKey(name: string): string {\n  return `${customAttributeName}:${name}`;\n}\n\nexport type IElementHydrationOptions = { parts?: Record<string, TemplateDefinition> };\n\nexport type BindableSource = Omit<IBindableDescription, 'property'>;\n\nexport interface IBindableDescription {\n  mode?: BindingMode;\n  callback?: string;\n  attribute?: string;\n  property?: string;\n  useProxies?: boolean;\n}\n\n/**\n * TargetedInstructionType enum values become the property names for the associated renderers when they are injected\n * into the `Renderer`.\n *\n * Additional instruction types can be added as long as they are 2 characters long and do not clash with existing ones.\n *\n * By convention, the instruction types for a particular runtime start with the same first letter, and the second letter\n * starts counting from letter `a`. The standard runtime instruction types all start with the letter `r`.\n */\nexport const enum TargetedInstructionType {\n  hydrateElement = 'ra',\n  hydrateAttribute = 'rb',\n  hydrateTemplateController = 'rc',\n  hydrateLetElement = 'rd',\n  setProperty = 're',\n  interpolation = 'rf',\n  propertyBinding = 'rg',\n  callBinding = 'rh',\n  letBinding = 'ri',\n  refBinding = 'rj',\n  iteratorBinding = 'rk',\n}\n\nexport interface IBuildInstruction {\n  required: boolean;\n  compiler?: string;\n}\n\nexport interface ITemplateDefinition extends IResourceDefinition {\n  cache?: '*' | number;\n  template?: unknown;\n  instructions?: ITargetedInstruction[][];\n  dependencies?: IRegistry[];\n  build?: IBuildInstruction;\n  surrogates?: ITargetedInstruction[];\n  bindables?: Record<string, IBindableDescription>;\n  containerless?: boolean;\n  shadowOptions?: { mode: 'open' | 'closed' };\n  hasSlots?: boolean;\n  useProxies?: boolean;\n}\n\nexport type TemplateDefinition = ResourceDescription<ITemplateDefinition>;\n\nexport type TemplatePartDefinitions = Record<string, ResourcePartDescription<ITemplateDefinition>>;\nexport type BindableDefinitions = Record<string, Immutable<IBindableDescription>>;\n\nexport interface IAttributeDefinition extends IResourceDefinition {\n  defaultBindingMode?: BindingMode;\n  aliases?: string[];\n  isTemplateController?: boolean;\n  hasDynamicOptions?: boolean;\n  bindables?: Record<string, IBindableDescription>;\n  useProxies?: boolean;\n}\n\nexport type AttributeDefinition = Immutable<Required<IAttributeDefinition>> | null;\n\nexport type InstructionTypeName = string;\n\nexport const ITargetedInstruction = DI.createInterface<ITargetedInstruction>('createInterface').noDefault();\nexport interface ITargetedInstruction {\n  type: InstructionTypeName;\n}\n\nexport type NodeInstruction =\n  IHydrateElementInstruction |\n  IHydrateTemplateController |\n  IHydrateLetElementInstruction;\n\nexport type AttributeInstruction =\n  IInterpolationInstruction |\n  IPropertyBindingInstruction |\n  IIteratorBindingInstruction |\n  ICallBindingInstruction |\n  IRefBindingInstruction |\n  ISetPropertyInstruction |\n  ILetBindingInstruction |\n  IHydrateAttributeInstruction;\n\nexport type TargetedInstruction = NodeInstruction | AttributeInstruction;\n\n// TODO: further improve specificity and integrate with the definitions;\nexport type InstructionRow = [TargetedInstruction, ...AttributeInstruction[]];\n\nexport function isTargetedInstruction(value: unknown): value is TargetedInstruction {\n  const type = (value as { type?: string }).type;\n  return typeof type === 'string' && type.length === 2;\n}\n\nexport interface IInterpolationInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.interpolation;\n  from: string | IInterpolationExpression;\n  to: string;\n}\n\nexport interface IPropertyBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.propertyBinding;\n  mode: BindingMode;\n  from: string | IsBindingBehavior;\n  to: string;\n  oneTime?: boolean;\n}\n\nexport interface IIteratorBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.iteratorBinding;\n  from: string | IForOfStatement;\n  to: string;\n}\n\nexport interface ICallBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.callBinding;\n  from: string | IsBindingBehavior;\n  to: string;\n}\n\nexport interface IRefBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.refBinding;\n  from: string | IsBindingBehavior;\n}\n\nexport interface ISetPropertyInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.setProperty;\n  value: unknown;\n  to: string;\n}\n\nexport interface IHydrateElementInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.hydrateElement;\n  res: string;\n  instructions: ITargetedInstruction[];\n  parts?: Record<string, ITemplateDefinition>;\n}\n\nexport interface IHydrateAttributeInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.hydrateAttribute;\n  res: string;\n  instructions: ITargetedInstruction[];\n}\n\nexport interface IHydrateTemplateController extends ITargetedInstruction {\n  type: TargetedInstructionType.hydrateTemplateController;\n  res: string;\n  instructions: ITargetedInstruction[];\n  def: ITemplateDefinition;\n  link?: boolean;\n}\n\nexport interface IHydrateLetElementInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.hydrateLetElement;\n  instructions: ILetBindingInstruction[];\n  toViewModel: boolean;\n}\n\nexport interface ILetBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.letBinding;\n  from: string | IsBindingBehavior | IInterpolationExpression;\n  to: string;\n}\n\n/** @internal */\nexport const buildRequired: IBuildInstruction = Object.freeze({\n  required: true,\n  compiler: 'default'\n});\n\nconst buildNotRequired: IBuildInstruction = Object.freeze({\n  required: false,\n  compiler: 'default'\n});\n\n// Note: this is a little perf thing; having one predefined class with the properties always\n// assigned in the same order ensures the browser can keep reusing the same generated hidden\n// class\nclass DefaultTemplateDefinition implements Required<ITemplateDefinition> {\n  public name: ITemplateDefinition['name'];\n  public cache: ITemplateDefinition['cache'];\n  public template: ITemplateDefinition['template'];\n  public instructions: ITemplateDefinition['instructions'];\n  public dependencies: ITemplateDefinition['dependencies'];\n  public build: ITemplateDefinition['build'];\n  public surrogates: ITemplateDefinition['surrogates'];\n  public bindables: ITemplateDefinition['bindables'];\n  public containerless: ITemplateDefinition['containerless'];\n  public shadowOptions: ITemplateDefinition['shadowOptions'];\n  public hasSlots: ITemplateDefinition['hasSlots'];\n  public useProxies: ITemplateDefinition['useProxies'];\n\n  constructor() {\n    this.name = 'unnamed';\n    this.template = null;\n    this.cache = 0;\n    this.build = buildNotRequired;\n    this.bindables = PLATFORM.emptyObject;\n    this.instructions = PLATFORM.emptyArray as this['instructions'];\n    this.dependencies = PLATFORM.emptyArray as this['dependencies'];\n    this.surrogates = PLATFORM.emptyArray as this['surrogates'];\n    this.containerless = false;\n    this.shadowOptions = null;\n    this.hasSlots = false;\n    this.useProxies = false;\n  }\n}\n\nconst templateDefinitionAssignables = [\n  'name',\n  'template',\n  'cache',\n  'build',\n  'containerless',\n  'shadowOptions',\n  'hasSlots',\n  'useProxies'\n];\n\nconst templateDefinitionArrays = [\n  'instructions',\n  'dependencies',\n  'surrogates'\n];\n\nexport type CustomElementConstructor = Constructable & {\n  containerless?: TemplateDefinition['containerless'];\n  shadowOptions?: TemplateDefinition['shadowOptions'];\n  bindables?: TemplateDefinition['bindables'];\n};\n\nexport function buildTemplateDefinition(\n  ctor: CustomElementConstructor,\n  name: string): TemplateDefinition;\nexport function buildTemplateDefinition(\n  ctor: null,\n  def: Immutable<ITemplateDefinition>): TemplateDefinition;\nexport function buildTemplateDefinition(\n  ctor: CustomElementConstructor | null,\n  nameOrDef: string | Immutable<ITemplateDefinition>): TemplateDefinition;\n// tslint:disable-next-line:parameters-max-number\nexport function buildTemplateDefinition(\n  ctor: CustomElementConstructor | null,\n  name: string | null,\n  template: unknown,\n  cache?: number | '*' | null,\n  build?: IBuildInstruction | boolean | null,\n  bindables?: Record<string, IBindableDescription> | null,\n  instructions?: ReadonlyArray<ReadonlyArray<ITargetedInstruction>> | null,\n  dependencies?: ReadonlyArray<unknown> | null,\n  surrogates?: ReadonlyArray<ITargetedInstruction> | null,\n  containerless?: boolean | null,\n  shadowOptions?: { mode: 'open' | 'closed' } | null,\n  hasSlots?: boolean | null,\n  useProxies?: boolean | null): TemplateDefinition;\n// tslint:disable-next-line:parameters-max-number // TODO: Reduce complexity (currently at 64)\nexport function buildTemplateDefinition(\n  ctor: CustomElementConstructor | null,\n  nameOrDef: string | Immutable<ITemplateDefinition> | null,\n  template?: unknown | null,\n  cache?: number | '*' | null,\n  build?: IBuildInstruction | boolean | null,\n  bindables?: Record<string, IBindableDescription> | null,\n  instructions?: ReadonlyArray<ReadonlyArray<ITargetedInstruction>> | null,\n  dependencies?: ReadonlyArray<IRegistry> | null,\n  surrogates?: ReadonlyArray<ITargetedInstruction> | null,\n  containerless?: boolean | null,\n  shadowOptions?: { mode: 'open' | 'closed' } | null,\n  hasSlots?: boolean | null,\n  useProxies?: boolean | null): TemplateDefinition {\n\n  const def = new DefaultTemplateDefinition();\n\n  // all cases fall through intentionally\n  const argLen = arguments.length;\n  switch (argLen) {\n    case 13: if (useProxies !== null) def.useProxies = useProxies;\n    case 12: if (hasSlots !== null) def.hasSlots = hasSlots;\n    case 11: if (shadowOptions !== null) def.shadowOptions = shadowOptions;\n    case 10: if (containerless !== null) def.containerless = containerless;\n    case 9: if (surrogates !== null) def.surrogates = PLATFORM.toArray(surrogates);\n    case 8: if (dependencies !== null) def.dependencies = PLATFORM.toArray(dependencies);\n    case 7: if (instructions !== null) def.instructions = PLATFORM.toArray(instructions) as ITargetedInstruction[][];\n    case 6: if (bindables !== null) def.bindables = { ...bindables };\n    case 5: if (build !== null) def.build = build === true ? buildRequired : build === false ? buildNotRequired : { ...build };\n    case 4: if (cache !== null) def.cache = cache;\n    case 3: if (template !== null) def.template = template;\n    case 2:\n      if (ctor !== null) {\n        if (ctor['bindables']) {\n          def.bindables = { ...ctor.bindables };\n        }\n        if (ctor['containerless']) {\n          def.containerless = ctor.containerless;\n        }\n        if (ctor['shadowOptions']) {\n          def.shadowOptions = ctor.shadowOptions as unknown as { mode: 'open' | 'closed' };\n        }\n      }\n      if (typeof nameOrDef === 'string') {\n        if (nameOrDef.length > 0) {\n          def.name = nameOrDef;\n        }\n      } else if (nameOrDef !== null) {\n        templateDefinitionAssignables.forEach(prop => {\n          if (nameOrDef[prop]) {\n            def[prop] = nameOrDef[prop];\n          }\n        });\n        templateDefinitionArrays.forEach(prop => {\n          if (nameOrDef[prop]) {\n            def[prop] = PLATFORM.toArray(nameOrDef[prop]);\n          }\n        });\n        if (nameOrDef['bindables']) {\n          if (def.bindables === PLATFORM.emptyObject) {\n            def.bindables = { ...nameOrDef.bindables };\n          } else {\n            Object.assign(def.bindables, nameOrDef.bindables);\n          }\n        }\n      }\n  }\n\n  // special handling for invocations that quack like a @customElement decorator\n  if (argLen === 2 && ctor !== null && (typeof nameOrDef === 'string' || !('build' in nameOrDef))) {\n    def.build = buildRequired;\n  }\n\n  return def;\n}\n","import { Profiler, Tracer, Writable } from '@aurelia/kernel';\nimport { Hooks, LifecycleFlags, State } from '../flags';\nimport { IComponent, ILifecycleHooks, IMountableComponent, IRenderable, IView } from '../lifecycle';\nimport { ICustomElement } from '../resources/custom-element';\n\ninterface IAttachable extends IRenderable, ILifecycleHooks, IComponent { }\n\nconst slice = Array.prototype.slice;\n\nconst { enter, leave } = Profiler.createTimer('AttachLifecycle');\n\n/** @internal */\n// tslint:disable-next-line:no-ignored-initial-value\nexport function $attachAttribute(this: Writable<IAttachable>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$attachAttribute`, slice.call(arguments)); }\n  if (Profiler.enabled) { enter(); }\n  if (this.$state & State.isAttached) {\n    if (Profiler.enabled) { leave(); }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return;\n  }\n  const lifecycle = this.$lifecycle;\n  lifecycle.beginAttach();\n  // add isAttaching flag\n  this.$state |= State.isAttaching;\n  flags |= LifecycleFlags.fromAttach;\n\n  const hooks = this.$hooks;\n\n  if (hooks & Hooks.hasAttaching) {\n    this.attaching(flags);\n  }\n\n  // add isAttached flag, remove isAttaching flag\n  this.$state |= State.isAttached;\n  this.$state &= ~State.isAttaching;\n\n  if (hooks & Hooks.hasAttached) {\n    lifecycle.enqueueAttached(this as Required<typeof this>);\n  }\n  lifecycle.endAttach(flags);\n  if (Profiler.enabled) { leave(); }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\n// tslint:disable-next-line:no-ignored-initial-value\nexport function $attachElement(this: Writable<IAttachable & IMountableComponent>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$attachElement`, slice.call(arguments)); }\n  if (Profiler.enabled) { enter(); }\n  if (this.$state & State.isAttached) {\n    if (Profiler.enabled) { leave(); }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return;\n  }\n  const lifecycle = this.$lifecycle;\n  lifecycle.beginAttach();\n  // add isAttaching flag\n  this.$state |= State.isAttaching;\n  flags |= LifecycleFlags.fromAttach;\n\n  const hooks = this.$hooks;\n\n  if (hooks & Hooks.hasAttaching) {\n    this.attaching(flags);\n  }\n\n  let current = this.$componentHead;\n  while (current !== null) {\n    current.$attach(flags);\n    current = current.$nextComponent;\n  }\n\n  lifecycle.enqueueMount(this);\n\n  // add isAttached flag, remove isAttaching flag\n  this.$state |= State.isAttached;\n  this.$state &= ~State.isAttaching;\n\n  if (hooks & Hooks.hasAttached) {\n    lifecycle.enqueueAttached(this as Required<typeof this>);\n  }\n  lifecycle.endAttach(flags);\n  if (Profiler.enabled) { leave(); }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $attachView(this: Writable<IAttachable & IMountableComponent>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$attachView`, slice.call(arguments)); }\n  if (this.$state & State.isAttached) {\n    if (Tracer.enabled) { Tracer.leave(); }\n    return;\n  }\n  // add isAttaching flag\n  this.$state |= State.isAttaching;\n  flags |= LifecycleFlags.fromAttach;\n\n  let current = this.$componentHead;\n  while (current !== null) {\n    current.$attach(flags);\n    current = current.$nextComponent;\n  }\n\n  this.$lifecycle.enqueueMount(this);\n\n  // add isAttached flag, remove isAttaching flag\n  this.$state |= State.isAttached;\n  this.$state &= ~State.isAttaching;\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\n// tslint:disable-next-line:no-ignored-initial-value\nexport function $detachAttribute(this: Writable<IAttachable>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$detachAttribute`, slice.call(arguments)); }\n  if (this.$state & State.isAttached) {\n    const lifecycle = this.$lifecycle;\n    lifecycle.beginDetach();\n    // add isDetaching flag\n    this.$state |= State.isDetaching;\n    flags |= LifecycleFlags.fromDetach;\n\n    const hooks = this.$hooks;\n    if (hooks & Hooks.hasDetaching) {\n      this.detaching(flags);\n    }\n\n    // remove isAttached and isDetaching flags\n    this.$state &= ~(State.isAttached | State.isDetaching);\n\n    if (hooks & Hooks.hasDetached) {\n      lifecycle.enqueueDetached(this as Required<typeof this>);\n    }\n    lifecycle.endDetach(flags);\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\n// tslint:disable-next-line:no-ignored-initial-value\nexport function $detachElement(this: Writable<IAttachable & IMountableComponent>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$detachElement`, slice.call(arguments)); }\n  if (this.$state & State.isAttached) {\n    const lifecycle = this.$lifecycle;\n    lifecycle.beginDetach();\n    // add isDetaching flag\n    this.$state |= State.isDetaching;\n    flags |= LifecycleFlags.fromDetach;\n\n    // Only unmount if either:\n    // - No parent view/element is queued for unmount yet, or\n    // - Aurelia is stopping (in which case all nodes need to return to their fragments for a clean mount on next start)\n    if (((flags & LifecycleFlags.parentUnmountQueued) ^ LifecycleFlags.parentUnmountQueued) | (flags & LifecycleFlags.fromStopTask)) {\n      lifecycle.enqueueUnmount(this);\n      flags |= LifecycleFlags.parentUnmountQueued;\n    }\n\n    const hooks = this.$hooks;\n    if (hooks & Hooks.hasDetaching) {\n      this.detaching(flags);\n    }\n\n    let current = this.$componentTail;\n    while (current !== null) {\n      current.$detach(flags);\n      current = current.$prevComponent;\n    }\n\n    // remove isAttached and isDetaching flags\n    this.$state &= ~(State.isAttached | State.isDetaching);\n\n    if (hooks & Hooks.hasDetached) {\n      lifecycle.enqueueDetached(this as Required<typeof this>);\n    }\n    lifecycle.endDetach(flags);\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $detachView(this: Writable<IAttachable & IMountableComponent>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$detachView`, slice.call(arguments)); }\n  if (this.$state & State.isAttached) {\n    // add isDetaching flag\n    this.$state |= State.isDetaching;\n    flags |= LifecycleFlags.fromDetach;\n\n    // Only unmount if either:\n    // - No parent view/element is queued for unmount yet, or\n    // - Aurelia is stopping (in which case all nodes need to return to their fragments for a clean mount on next start)\n    if (((flags & LifecycleFlags.parentUnmountQueued) ^ LifecycleFlags.parentUnmountQueued) | (flags & LifecycleFlags.fromStopTask)) {\n      this.$lifecycle.enqueueUnmount(this);\n      flags |= LifecycleFlags.parentUnmountQueued;\n    }\n\n    let current = this.$componentTail;\n    while (current !== null) {\n      current.$detach(flags);\n      current = current.$prevComponent;\n    }\n\n    // remove isAttached and isDetaching flags\n    this.$state &= ~(State.isAttached | State.isDetaching);\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $cacheAttribute(this: Writable<IAttachable>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$cacheAttribute`, slice.call(arguments)); }\n  flags |= LifecycleFlags.fromCache;\n  if (this.$hooks & Hooks.hasCaching) {\n    this.caching(flags);\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $cacheElement(this: Writable<IAttachable>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$cacheElement`, slice.call(arguments)); }\n  flags |= LifecycleFlags.fromCache;\n  if (this.$hooks & Hooks.hasCaching) {\n    this.caching(flags);\n  }\n\n  let current = this.$componentTail;\n  while (current !== null) {\n    current.$cache(flags);\n    current = current.$prevComponent;\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $cacheView(this: Writable<IAttachable>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$cacheView`, slice.call(arguments)); }\n  flags |= LifecycleFlags.fromCache;\n  let current = this.$componentTail;\n  while (current !== null) {\n    current.$cache(flags);\n    current = current.$prevComponent;\n  }\n}\n\n/** @internal */\nexport function $mountElement(this: Writable<ICustomElement>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$mountElement`, slice.call(arguments)); }\n  if (!(this.$state & State.isMounted)) {\n    this.$state |= State.isMounted;\n    this.$projector.project(this.$nodes);\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $unmountElement(this: Writable<ICustomElement>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$unmountElement`, slice.call(arguments)); }\n  if (this.$state & State.isMounted) {\n    this.$state &= ~State.isMounted;\n    this.$projector.take(this.$nodes);\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $mountView(this: Writable<IView>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$mountView`, slice.call(arguments)); }\n  if (!(this.$state & State.isMounted)) {\n    this.$state |= State.isMounted;\n    this.$nodes.insertBefore(this.location);\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $unmountView(this: Writable<IView>, flags: LifecycleFlags): boolean {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$unmountView`, slice.call(arguments)); }\n  if (this.$state & State.isMounted) {\n    this.$state &= ~State.isMounted;\n    this.$nodes.remove();\n\n    if (this.isFree) {\n      this.isFree = false;\n      if (this.cache.tryReturnToCache(this)) {\n        this.$state |= State.isCached;\n        if (Tracer.enabled) { Tracer.leave(); }\n        return true;\n      }\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return false;\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n  return false;\n}\n","import { Profiler, Tracer, Writable } from '@aurelia/kernel';\nimport { Hooks, LifecycleFlags, State } from '../flags';\nimport { IComponent, ILifecycleHooks, IRenderable } from '../lifecycle';\nimport { IScope } from '../observation';\n\nconst slice = Array.prototype.slice;\n\nconst { enter, leave } = Profiler.createTimer('BindLifecycle');\n\ninterface IBindable extends IRenderable, ILifecycleHooks, IComponent { }\n\n/** @internal */\nexport function $bindAttribute(this: Writable<IBindable>, flags: LifecycleFlags, scope: IScope): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$bindAttribute`, slice.call(arguments)); }\n  if (Profiler.enabled) { enter(); }\n  flags |= LifecycleFlags.fromBind;\n\n  if (this.$state & State.isBound) {\n    if (this.$scope === scope) {\n      if (Profiler.enabled) { leave(); }\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n\n    this.$unbind(flags);\n  }\n  const lifecycle = this.$lifecycle;\n  lifecycle.beginBind();\n  // add isBinding flag\n  this.$state |= State.isBinding;\n\n  const hooks = this.$hooks;\n\n  if (hooks & Hooks.hasBound) {\n    lifecycle.enqueueBound(this);\n  }\n\n  this.$scope = scope;\n\n  if (hooks & Hooks.hasBinding) {\n    this.binding(flags);\n  }\n\n  // add isBound flag and remove isBinding flag\n  this.$state |= State.isBound;\n  this.$state &= ~State.isBinding;\n\n  lifecycle.endBind(flags);\n  if (Profiler.enabled) { leave(); }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $bindElement(this: Writable<IBindable>, flags: LifecycleFlags, parentScope: IScope | null): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$bindElement`, slice.call(arguments)); }\n  if (Profiler.enabled) { enter(); }\n  if (this.$state & State.isBound) {\n    if (Profiler.enabled) { leave(); }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return;\n  }\n  const scope = this.$scope;\n  (scope as Writable<IScope>).parentScope = parentScope;\n\n  const lifecycle = this.$lifecycle;\n  lifecycle.beginBind();\n  // add isBinding flag\n  this.$state |= State.isBinding;\n\n  const hooks = this.$hooks;\n  flags |= LifecycleFlags.fromBind;\n\n  if (hooks & Hooks.hasBound) {\n    lifecycle.enqueueBound(this);\n  }\n\n  let binding = this.$bindingHead;\n  while (binding !== null) {\n    binding.$bind(flags, scope);\n    binding = binding.$nextBinding;\n  }\n\n  if (hooks & Hooks.hasBinding) {\n    this.binding(flags);\n  }\n\n  let component = this.$componentHead;\n  while (component !== null) {\n    component.$bind(flags, scope);\n    component = component.$nextComponent;\n  }\n\n  // add isBound flag and remove isBinding flag\n  this.$state |= State.isBound;\n  this.$state &= ~State.isBinding;\n\n  lifecycle.endBind(flags);\n  if (Profiler.enabled) { leave(); }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $bindView(this: Writable<IBindable>, flags: LifecycleFlags, scope: IScope): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$bindView`, slice.call(arguments)); }\n  flags |= LifecycleFlags.fromBind;\n\n  if (this.$state & State.isBound) {\n    if (this.$scope === scope) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n\n    this.$unbind(flags);\n  }\n  // add isBinding flag\n  this.$state |= State.isBinding;\n\n  this.$scope = scope;\n\n  let binding = this.$bindingHead;\n  while (binding !== null) {\n    binding.$bind(flags, scope);\n    binding = binding.$nextBinding;\n  }\n\n  let component = this.$componentHead;\n  while (component !== null) {\n    component.$bind(flags, scope);\n    component = component.$nextComponent;\n  }\n\n  // add isBound flag and remove isBinding flag\n  this.$state |= State.isBound;\n  this.$state &= ~State.isBinding;\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $lockedBind(this: IBindable, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.lockedBind`, slice.call(arguments)); }\n  flags |= LifecycleFlags.fromBind;\n\n  if (this.$state & State.isBound) {\n    if (Tracer.enabled) { Tracer.leave(); }\n    return;\n  }\n  // add isBinding flag\n  this.$state |= State.isBinding;\n\n  const scope = this.$scope;\n\n  let binding = this.$bindingHead;\n  while (binding !== null) {\n    binding.$bind(flags, scope);\n    binding = binding.$nextBinding;\n  }\n\n  let component = this.$componentHead;\n  while (component !== null) {\n    component.$bind(flags, scope);\n    component = component.$nextComponent;\n  }\n\n  // add isBound flag and remove isBinding flag\n  this.$state |= State.isBound;\n  this.$state &= ~State.isBinding;\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $unbindAttribute(this: Writable<IBindable>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$unbindAttribute`, slice.call(arguments)); }\n  if (this.$state & State.isBound) {\n    const lifecycle = this.$lifecycle;\n    lifecycle.beginUnbind();\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    const hooks = this.$hooks;\n    flags |= LifecycleFlags.fromUnbind;\n\n    if (hooks & Hooks.hasUnbound) {\n      lifecycle.enqueueUnbound(this);\n    }\n\n    if (hooks & Hooks.hasUnbinding) {\n      this.unbinding(flags);\n    }\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n\n    lifecycle.endUnbind(flags);\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $unbindElement(this: Writable<IBindable>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$unbindElement`, slice.call(arguments)); }\n  if (this.$state & State.isBound) {\n    const lifecycle = this.$lifecycle;\n    lifecycle.beginUnbind();\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    const hooks = this.$hooks;\n    flags |= LifecycleFlags.fromUnbind;\n\n    if (hooks & Hooks.hasUnbound) {\n      lifecycle.enqueueUnbound(this);\n    }\n\n    let binding = this.$bindingTail;\n    while (binding !== null) {\n      binding.$unbind(flags);\n      binding = binding.$prevBinding;\n    }\n\n    if (hooks & Hooks.hasUnbinding) {\n      this.unbinding(flags);\n    }\n\n    let component = this.$componentTail;\n    while (component !== null) {\n      component.$unbind(flags);\n      component = component.$prevComponent;\n    }\n\n    (this.$scope as Writable<IScope>).parentScope = null;\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n\n    lifecycle.endUnbind(flags);\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $unbindView(this: Writable<IBindable>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$unbindView`, slice.call(arguments)); }\n  if (this.$state & State.isBound) {\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    flags |= LifecycleFlags.fromUnbind;\n\n    let binding = this.$bindingTail;\n    while (binding !== null) {\n      binding.$unbind(flags);\n      binding = binding.$prevBinding;\n    }\n\n    let component = this.$componentTail;\n    while (component !== null) {\n      component.$unbind(flags);\n      component = component.$prevComponent;\n    }\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n    this.$scope = null;\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $lockedUnbind(this: IBindable, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.lockedUnbind`, slice.call(arguments)); }\n  if (this.$state & State.isBound) {\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    flags |= LifecycleFlags.fromUnbind;\n\n    let binding = this.$bindingTail;\n    while (binding !== null) {\n      binding.$unbind(flags);\n      binding = binding.$prevBinding;\n    }\n\n    let component = this.$componentTail;\n    while (component !== null) {\n      component.$unbind(flags);\n      component = component.$prevComponent;\n    }\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n","import { DI, IContainer, IResolver, PLATFORM } from '@aurelia/kernel';\n\nexport interface INode extends Object {}\n\nexport const INode = DI.createInterface<INode>('INode').noDefault();\n\nexport const IRenderLocation = DI.createInterface<IRenderLocation>('IRenderLocation').noDefault();\nexport interface IRenderLocation<T extends INode = INode> extends INode {\n  $start?: IRenderLocation<T>;\n  $nodes?: INodeSequence<T> | Readonly<{}>;\n}\n\n/**\n * Represents a DocumentFragment\n */\nexport interface INodeSequence<T extends INode = INode> extends INode {\n  /**\n   * The nodes of this sequence.\n   */\n  readonly childNodes: ArrayLike<T>;\n\n  readonly firstChild: T;\n\n  readonly lastChild: T;\n\n  /**\n   * Find all instruction targets in this sequence.\n   */\n  findTargets(): ArrayLike<T>;\n\n  /**\n   * Insert this sequence as a sibling before refNode\n   */\n  insertBefore(refNode: T | IRenderLocation<T>): void;\n\n  /**\n   * Append this sequence as a child to parent\n   */\n  appendTo(parent: T): void;\n\n  /**\n   * Remove this sequence from its parent.\n   */\n  remove(): void;\n}\n\nexport const IDOM = DI.createInterface<IDOM>('IDOM').noDefault();\n\nexport interface IDOM<T extends INode = INode> {\n  addEventListener(eventName: string, subscriber: unknown, publisher?: unknown, options?: unknown): void;\n  appendChild(parent: T, child: T): void;\n  cloneNode<TClone extends T>(node: TClone, deep?: boolean): TClone;\n  convertToRenderLocation(node: T): IRenderLocation<T>;\n  createDocumentFragment(markupOrNode?: string | T): T;\n  createElement(name: string): T;\n  createNodeObserver?(node: T, cb: (...args: unknown[]) => void, init: unknown): unknown;\n  createTemplate(markup?: string): T;\n  createTextNode(text: string): T;\n  insertBefore(nodeToInsert: T, referenceNode: T): void;\n  isMarker(node: unknown): node is T;\n  isNodeInstance(potentialNode: unknown): potentialNode is T;\n  isRenderLocation(node: unknown): node is IRenderLocation<T>;\n  makeTarget(node: T): void;\n  registerElementResolver(container: IContainer, resolver: IResolver): void;\n  remove(node: T): void;\n  removeEventListener(eventName: string, subscriber: unknown, publisher?: unknown, options?: unknown): void;\n  setAttribute(node: T, name: string, value: unknown): void;\n}\n\n// This is an implementation of INodeSequence that represents \"no DOM\" to render.\n// It's used in various places to avoid null and to encode\n// the explicit idea of \"no view\".\nconst emptySequence: INodeSequence = {\n  childNodes: PLATFORM.emptyArray,\n  firstChild: null,\n  lastChild: null,\n  findTargets(): ArrayLike<INode> { return PLATFORM.emptyArray; },\n  insertBefore(refNode: INode): void { /*do nothing*/ },\n  appendTo(parent: INode): void { /*do nothing*/ },\n  remove(): void { /*do nothing*/ }\n};\n\nexport const NodeSequence = {\n  empty: emptySequence\n};\n\nexport interface INodeSequenceFactory<T extends INode = INode> {\n  createNodeSequence(): INodeSequence<T>;\n}\n","import { Reporter, Tracer } from '@aurelia/kernel';\nimport { INode, INodeSequence, IRenderLocation } from '../dom';\nimport { LifecycleFlags, State } from '../flags';\nimport {\n  IBinding,\n  IComponent,\n  ILifecycle,\n  IMountableComponent,\n  IRenderContext,\n  IView,\n  IViewCache,\n  IViewFactory\n} from '../lifecycle';\nimport { IScope } from '../observation';\nimport { ITemplate } from '../rendering-engine';\nimport { $attachView, $cacheView, $detachView, $mountView, $unmountView } from './lifecycle-attach';\nimport { $bindView, $lockedBind, $lockedUnbind, $unbindView } from './lifecycle-bind';\n\nconst slice = Array.prototype.slice;\n\n/** @internal */\nexport interface View<T extends INode = INode> extends IView<T> {}\n\n/** @internal */\nexport class View<T extends INode = INode> implements IView<T> {\n  public $bindingHead: IBinding;\n  public $bindingTail: IBinding;\n\n  public $componentHead: IComponent;\n  public $componentTail: IComponent;\n\n  public $nextComponent: IComponent;\n  public $prevComponent: IComponent;\n\n  public $nextMount: IMountableComponent;\n  public $nextUnmount: IMountableComponent;\n\n  public $nextUnbindAfterDetach: IComponent;\n\n  public $state: State;\n  public $scope: IScope;\n  public $nodes: INodeSequence<T>;\n  public $context: IRenderContext<T>;\n  public cache: IViewCache<T>;\n  public location: IRenderLocation<T>;\n  public isFree: boolean;\n\n  public readonly $lifecycle: ILifecycle;\n\n  constructor($lifecycle: ILifecycle, cache: IViewCache<T>) {\n    this.$bindingHead = null;\n    this.$bindingTail = null;\n\n    this.$componentHead = null;\n    this.$componentTail = null;\n\n    this.$componentHead = null;\n    this.$componentTail = null;\n\n    this.$nextComponent = null;\n    this.$prevComponent = null;\n\n    this.$nextMount = null;\n    this.$nextUnmount = null;\n\n    this.$nextUnbindAfterDetach = null;\n\n    this.$state = State.none;\n    this.$scope = null;\n    this.isFree = false;\n\n    this.$lifecycle = $lifecycle;\n    this.cache = cache;\n  }\n\n  /**\n   * Reserves this `View` for mounting at a particular `IRenderLocation`.\n   * Also marks this `View` such that it cannot be returned to the cache until\n   * it is released again.\n   *\n   * @param location The RenderLocation before which the view will be appended to the DOM.\n   */\n  public hold(location: IRenderLocation<T>): void {\n    if (Tracer.enabled) { Tracer.enter('View.hold', slice.call(arguments)); }\n    this.isFree = false;\n    this.location = location;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  /**\n   * Marks this `View` such that it can be returned to the cache when it is unmounted.\n   *\n   * If this `View` is not currently attached, it will be unmounted immediately.\n   *\n   * @param flags The `LifecycleFlags` to pass to the unmount operation (only effective\n   * if the view is already in detached state).\n   *\n   * @returns Whether this `View` can/will be returned to cache\n   */\n  public release(flags: LifecycleFlags): boolean {\n    if (Tracer.enabled) { Tracer.enter('View.release', slice.call(arguments)); }\n    this.isFree = true;\n    if (this.$state & State.isAttached) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return this.cache.canReturnToCache(this);\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n    return !!this.$unmount(flags);\n  }\n\n  public lockScope(scope: IScope): void {\n    if (Tracer.enabled) { Tracer.enter('View.lockScope', slice.call(arguments)); }\n    this.$scope = scope;\n    this.$bind = $lockedBind;\n    this.$unbind = $lockedUnbind;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n}\n\n/** @internal */\nexport class ViewFactory<T extends INode = INode> implements IViewFactory<T> {\n  public static maxCacheSize: number = 0xFFFF;\n\n  public isCaching: boolean;\n  public name: string;\n\n  private cache: View<T>[];\n  private cacheSize: number;\n  private readonly lifecycle: ILifecycle;\n  private readonly template: ITemplate<T>;\n\n  constructor(name: string, template: ITemplate<T>, lifecycle: ILifecycle) {\n    this.isCaching = false;\n\n    this.cacheSize = -1;\n    this.cache = null;\n    this.lifecycle = lifecycle;\n    this.name = name;\n    this.template = template;\n  }\n\n  public setCacheSize(size: number | '*', doNotOverrideIfAlreadySet: boolean): void {\n    if (size) {\n      if (size === '*') {\n        size = ViewFactory.maxCacheSize;\n      } else if (typeof size === 'string') {\n        size = parseInt(size, 10);\n      }\n\n      if (this.cacheSize === -1 || !doNotOverrideIfAlreadySet) {\n        this.cacheSize = size;\n      }\n    }\n\n    if (this.cacheSize > 0) {\n      this.cache = [];\n    } else {\n      this.cache = null;\n    }\n\n    this.isCaching = this.cacheSize > 0;\n  }\n\n  public canReturnToCache(view: IView<T>): boolean {\n    return this.cache !== null && this.cache.length < this.cacheSize;\n  }\n\n  public tryReturnToCache(view: View<T>): boolean {\n    if (this.canReturnToCache(view)) {\n      view.$cache(LifecycleFlags.none);\n      this.cache.push(view);\n      return true;\n    }\n\n    return false;\n  }\n\n  public create(flags?: LifecycleFlags): IView<T> {\n    const cache = this.cache;\n    let view: View<T>;\n\n    if (cache !== null && cache.length > 0) {\n      view = cache.pop();\n      view.$state &= ~State.isCached;\n      return view;\n    }\n\n    view = new View<T>(this.lifecycle, this);\n    this.template.render(view, null, null, flags);\n    if (!view.$nodes) {\n      throw Reporter.error(90);\n    }\n    return view;\n  }\n}\n\n((proto: IView): void => {\n  proto.$bind = $bindView;\n  proto.$unbind = $unbindView;\n  proto.$attach = $attachView;\n  proto.$detach = $detachView;\n  proto.$cache = $cacheView;\n  proto.$mount = $mountView;\n  proto.$unmount = $unmountView;\n})(View.prototype);\n","import {\n  all,\n  DI,\n  IContainer,\n  IDisposable,\n  IIndexable,\n  Immutable,\n  ImmutableArray,\n  InterfaceSymbol,\n  IRegistry,\n  IResolver,\n  IResourceDescriptions,\n  IServiceLocator,\n  PLATFORM,\n  Reporter,\n  RuntimeCompilationResources,\n  Writable\n} from '@aurelia/kernel';\nimport {\n  BindableDefinitions,\n  buildTemplateDefinition,\n  customElementBehavior,\n  InstructionTypeName,\n  ITargetedInstruction,\n  ITemplateDefinition,\n  TemplateDefinition,\n  TemplatePartDefinitions\n} from './definitions';\nimport { IDOM, INode, INodeSequenceFactory, IRenderLocation, NodeSequence } from './dom';\nimport { LifecycleFlags } from './flags';\nimport {\n  ILifecycle,\n  IRenderable,\n  IRenderContext,\n  IViewFactory\n} from './lifecycle';\nimport {\n  IAccessor,\n  IPropertySubscriber,\n  ISubscribable,\n  ISubscriberCollection,\n  MutationKind\n} from './observation';\nimport { ProxyObserver } from './observation/proxy-observer';\nimport { SelfObserver } from './observation/self-observer';\nimport { subscriberCollection } from './observation/subscriber-collection';\nimport { ICustomAttribute, ICustomAttributeType } from './resources/custom-attribute';\nimport { ICustomElement, ICustomElementType } from './resources/custom-element';\nimport { ViewFactory } from './templating/view';\n\nexport interface ITemplateCompiler {\n  readonly name: string;\n  compile(dom: IDOM, definition: ITemplateDefinition, resources: IResourceDescriptions, viewCompileFlags?: ViewCompileFlags): TemplateDefinition;\n}\n\nexport const ITemplateCompiler = DI.createInterface<ITemplateCompiler>('ITemplateCompiler').noDefault();\n\nexport enum ViewCompileFlags {\n  none        = 0b0_001,\n  surrogate   = 0b0_010,\n  shadowDOM   = 0b0_100,\n}\n\nexport interface ITemplateFactory<T extends INode = INode> {\n  create(parentRenderContext: IRenderContext<T>, definition: TemplateDefinition): ITemplate<T>;\n}\n\nexport const ITemplateFactory = DI.createInterface<ITemplateFactory>('ITemplateFactory').noDefault();\n\n// The basic template abstraction that allows consumers to create\n// instances of an INodeSequence on-demand. Templates are contextual in that they are, in the very least,\n// part of a particular application, with application-level resources, but they also may have their\n// own scoped resources or be part of another view (via a template controller) which provides a\n// context for the template.\nexport interface ITemplate<T extends INode = INode> {\n  readonly renderContext: IRenderContext<T>;\n  readonly dom: IDOM<T>;\n  render(renderable: IRenderable<T>, host?: T, parts?: Immutable<Record<string, ITemplateDefinition>>, flags?: LifecycleFlags): void;\n}\n\n// This is the main implementation of ITemplate.\n// It is used to create instances of IView based on a compiled TemplateDefinition.\n// TemplateDefinitions are hand-coded today, but will ultimately be the output of the\n// TemplateCompiler either through a JIT or AOT process.\n// Essentially, CompiledTemplate wraps up the small bit of code that is needed to take a TemplateDefinition\n// and create instances of it on demand.\nexport class CompiledTemplate<T extends INode = INode> implements ITemplate {\n  public readonly factory: INodeSequenceFactory<T>;\n  public readonly renderContext: IRenderContext<T>;\n  public readonly dom: IDOM<T>;\n\n  private readonly definition: TemplateDefinition;\n\n  constructor(dom: IDOM<T>, definition: TemplateDefinition, factory: INodeSequenceFactory<T>, renderContext: IRenderContext<T>) {\n    this.dom = dom;\n    this.definition = definition;\n    this.factory = factory;\n    this.renderContext = renderContext;\n  }\n\n  public render(renderable: IRenderable<T>, host?: T, parts?: TemplatePartDefinitions, flags: LifecycleFlags = LifecycleFlags.none): void {\n    const nodes = (renderable as Writable<IRenderable>).$nodes = this.factory.createNodeSequence();\n    (renderable as Writable<IRenderable>).$context = this.renderContext;\n    if (this.definition.useProxies) {\n      flags |= LifecycleFlags.useProxies;\n    }\n    this.renderContext.render(flags, renderable, nodes.findTargets(), this.definition, host, parts);\n  }\n}\n\n// This is an implementation of ITemplate that always returns a node sequence representing \"no DOM\" to render.\n/** @internal */\nexport const noViewTemplate: ITemplate = {\n  renderContext: null,\n  dom: null,\n  render(renderable: IRenderable): void {\n    (renderable as Writable<IRenderable>).$nodes = NodeSequence.empty;\n    (renderable as Writable<IRenderable>).$context = null;\n  }\n};\n\nconst defaultCompilerName = 'default';\n\nexport interface IInstructionTypeClassifier<TType extends string = string> {\n  instructionType: TType;\n}\n\nexport interface IInstructionRenderer<TType extends InstructionTypeName = InstructionTypeName> extends Partial<IInstructionTypeClassifier<TType>> {\n  render(flags: LifecycleFlags, dom: IDOM, context: IRenderContext, renderable: IRenderable, target: unknown, instruction: ITargetedInstruction, ...rest: unknown[]): void;\n}\n\nexport const IInstructionRenderer = DI.createInterface<IInstructionRenderer>('IInstructionRenderer').noDefault();\n\nexport interface IRenderer {\n  instructionRenderers: Record<string, IInstructionRenderer>;\n  render(\n    flags: LifecycleFlags,\n    dom: IDOM,\n    context: IRenderContext,\n    renderable: IRenderable,\n    targets: ArrayLike<INode>,\n    templateDefinition: TemplateDefinition,\n    host?: INode,\n    parts?: TemplatePartDefinitions\n  ): void;\n}\n\nexport const IRenderer = DI.createInterface<IRenderer>('IRenderer').noDefault();\n\nexport interface IRenderingEngine {\n  getElementTemplate<T extends INode = INode>(\n    dom: IDOM<T>,\n    definition: TemplateDefinition,\n    parentContext: IServiceLocator,\n    componentType: ICustomElementType<T> | null\n  ): ITemplate<T>;\n\n  getViewFactory<T extends INode = INode>(\n    dom: IDOM<T>,\n    source: Immutable<ITemplateDefinition>,\n    parentContext: IRenderContext<T> | null\n  ): IViewFactory<T>;\n\n  applyRuntimeBehavior<T extends INode = INode>(flags: LifecycleFlags, Type: ICustomAttributeType<T>, instance: ICustomAttribute<T>): void;\n  applyRuntimeBehavior<T extends INode = INode>(flags: LifecycleFlags, Type: ICustomElementType<T>, instance: ICustomElement<T>): void;\n}\n\nexport const IRenderingEngine = DI.createInterface<IRenderingEngine>('IRenderingEngine').withDefault(x => x.singleton(RenderingEngine));\n\n/** @internal */\nexport class RenderingEngine implements IRenderingEngine {\n  public static readonly inject: ReadonlyArray<InterfaceSymbol> = [IContainer, ITemplateFactory, ILifecycle, all(ITemplateCompiler)];\n\n  private readonly behaviorLookup: Map<ICustomElementType | ICustomAttributeType, RuntimeBehavior>;\n  private readonly compilers: Record<string, ITemplateCompiler>;\n  private readonly container: IContainer;\n  private readonly templateFactory: ITemplateFactory;\n  private readonly viewFactoryLookup: Map<Immutable<ITemplateDefinition>, IViewFactory>;\n  private readonly lifecycle: ILifecycle;\n  private readonly templateLookup: Map<TemplateDefinition, ITemplate>;\n\n  constructor(container: IContainer, templateFactory: ITemplateFactory, lifecycle: ILifecycle, templateCompilers: ITemplateCompiler[]) {\n    this.behaviorLookup = new Map();\n    this.container = container;\n    this.templateFactory = templateFactory;\n    this.viewFactoryLookup = new Map();\n    this.lifecycle = lifecycle;\n    this.templateLookup = new Map();\n\n    this.compilers = templateCompilers.reduce(\n      (acc, item) => {\n        acc[item.name] = item;\n        return acc;\n      },\n      Object.create(null)\n    );\n  }\n\n  public getElementTemplate<T extends INode = INode>(\n    dom: IDOM<T>,\n    definition: TemplateDefinition,\n    parentContext: IRenderContext<T> | null,\n    componentType: ICustomElementType<T> | null\n  ): ITemplate<T> {\n    if (!definition) {\n      return null;\n    }\n\n    let found = this.templateLookup.get(definition);\n\n    if (!found) {\n      found = this.templateFromSource(dom, definition, parentContext, componentType);\n\n      this.templateLookup.set(definition, found);\n    }\n\n    return found as ITemplate<T>;\n  }\n\n  public getViewFactory<T extends INode = INode>(\n    dom: IDOM<T>,\n    definition: Immutable<ITemplateDefinition>,\n    parentContext: IRenderContext<T> | null\n  ): IViewFactory<T> {\n    if (!definition) {\n      return null;\n    }\n\n    let factory = this.viewFactoryLookup.get(definition);\n\n    if (!factory) {\n      const validSource = buildTemplateDefinition(null, definition);\n      const template = this.templateFromSource(dom, validSource, parentContext, null);\n      factory = new ViewFactory(validSource.name, template, this.lifecycle);\n      factory.setCacheSize(validSource.cache, true);\n      this.viewFactoryLookup.set(definition, factory);\n    }\n\n    return factory as IViewFactory<T>;\n  }\n\n  public applyRuntimeBehavior(flags: LifecycleFlags, Type: ICustomAttributeType | ICustomElementType, instance: ICustomAttribute | ICustomElement): void {\n    let found = this.behaviorLookup.get(Type);\n\n    if (!found) {\n      found = RuntimeBehavior.create(Type);\n      this.behaviorLookup.set(Type, found);\n    }\n\n    found.applyTo(flags, instance, this.lifecycle);\n  }\n\n  private templateFromSource(\n    dom: IDOM,\n    definition: TemplateDefinition,\n    parentContext: IRenderContext | null,\n    componentType: ICustomElementType | null\n  ): ITemplate {\n    if (parentContext === null) {\n      parentContext = this.container as ExposedContext;\n    }\n\n    if (definition.template !== null) {\n      const renderContext = createRenderContext(dom, parentContext, definition.dependencies, componentType) as ExposedContext;\n\n      if (definition.build.required) {\n        const compilerName = definition.build.compiler || defaultCompilerName;\n        const compiler = this.compilers[compilerName];\n\n        if (compiler === undefined) {\n          throw Reporter.error(20, compilerName);\n        }\n\n        definition = compiler.compile(dom, definition as ITemplateDefinition, new RuntimeCompilationResources(renderContext), ViewCompileFlags.surrogate);\n      }\n\n      return this.templateFactory.create(renderContext, definition);\n    }\n\n    return noViewTemplate;\n  }\n}\n\nexport function createRenderContext(\n  dom: IDOM,\n  parentRenderContext: IRenderContext,\n  dependencies: ImmutableArray<IRegistry>,\n  componentType: ICustomElementType | null\n): IRenderContext {\n  const context = parentRenderContext.createChild() as ExposedContext;\n  const renderableProvider = new InstanceProvider();\n  const elementProvider = new InstanceProvider();\n  const instructionProvider = new InstanceProvider<ITargetedInstruction>();\n  const factoryProvider = new ViewFactoryProvider();\n  const renderLocationProvider = new InstanceProvider<IRenderLocation>();\n  const renderer = context.get(IRenderer);\n\n  dom.registerElementResolver(context, elementProvider);\n\n  context.registerResolver(IViewFactory, factoryProvider);\n  context.registerResolver(IRenderable, renderableProvider);\n  context.registerResolver(ITargetedInstruction, instructionProvider);\n  context.registerResolver(IRenderLocation, renderLocationProvider);\n\n  if (dependencies) {\n    context.register(...dependencies);\n  }\n\n  //If the element has a view, support Recursive Components by adding self to own view template container.\n  if (componentType) {\n    componentType.register(context);\n  }\n\n  context.render = function(this: IRenderContext, flags: LifecycleFlags, renderable: IRenderable, targets: ArrayLike<INode>, templateDefinition: TemplateDefinition, host?: INode, parts?: TemplatePartDefinitions): void {\n    renderer.render(flags, dom, this, renderable, targets, templateDefinition, host, parts);\n  };\n\n  context.beginComponentOperation = function(renderable: IRenderable, target: INode, instruction: ITargetedInstruction, factory: IViewFactory | null, parts?: TemplatePartDefinitions, location?: IRenderLocation): IDisposable {\n    renderableProvider.prepare(renderable);\n    elementProvider.prepare(target);\n    instructionProvider.prepare(instruction);\n\n    if (factory) {\n      factoryProvider.prepare(factory, parts);\n    }\n\n    if (location) {\n      renderLocationProvider.prepare(location);\n    }\n\n    return context;\n  };\n\n  context.dispose = function(): void {\n    factoryProvider.dispose();\n    renderableProvider.dispose();\n    instructionProvider.dispose();\n    elementProvider.dispose();\n    renderLocationProvider.dispose();\n  };\n\n  return context;\n}\n\n/** @internal */\nexport class InstanceProvider<T> implements IResolver {\n  private instance: T | null;\n\n  constructor() {\n    this.instance = null;\n  }\n\n  public prepare(instance: T): void {\n    this.instance = instance;\n  }\n\n  public resolve(handler: IContainer, requestor: IContainer): T | null {\n    if (this.instance === undefined) { // unmet precondition: call prepare\n      throw Reporter.error(50); // TODO: organize error codes\n    }\n    return this.instance;\n  }\n\n  public dispose(): void {\n    this.instance = null;\n  }\n}\n\n/** @internal */\nexport class ViewFactoryProvider implements IResolver {\n  private factory: IViewFactory | null;\n  private replacements: TemplatePartDefinitions;\n\n  public prepare(factory: IViewFactory, parts: TemplatePartDefinitions): void {\n    this.factory = factory;\n    this.replacements = parts || PLATFORM.emptyObject;\n  }\n\n  public resolve(handler: IContainer, requestor: ExposedContext): IViewFactory {\n    const factory = this.factory;\n    if (factory === undefined || factory === null) { // unmet precondition: call prepare\n      throw Reporter.error(50); // TODO: organize error codes\n    }\n    if (!factory.name || !factory.name.length) { // unmet invariant: factory must have a name\n      throw Reporter.error(51); // TODO: organize error codes\n    }\n    const found = this.replacements[factory.name];\n    if (found) {\n      const renderingEngine = handler.get(IRenderingEngine);\n      const dom = handler.get(IDOM);\n      return renderingEngine.getViewFactory(dom, found, requestor);\n    }\n\n    return factory;\n  }\n\n  public dispose(): void {\n    this.factory = null;\n    this.replacements = PLATFORM.emptyObject;\n  }\n}\n\nexport interface IChildrenObserver extends\n  IAccessor,\n  ISubscribable<MutationKind.instance>,\n  ISubscriberCollection<MutationKind.instance> { }\n\n/** @internal */\n@subscriberCollection(MutationKind.instance)\nexport class ChildrenObserver implements Partial<IChildrenObserver> {\n  public hasChanges: boolean;\n\n  private readonly customElement: ICustomElement & { $childrenChanged?(): void };\n  private readonly lifecycle: ILifecycle;\n  private children: ICustomElement[];\n  private observing: boolean;\n\n  constructor(lifecycle: ILifecycle, customElement: ICustomElement & { $childrenChanged?(): void }) {\n    this.hasChanges = false;\n\n    this.children = null;\n    this.customElement = customElement;\n    this.lifecycle = lifecycle;\n    this.observing = false;\n  }\n\n  public getValue(): ICustomElement[] {\n    if (!this.observing) {\n      this.observing = true;\n      this.customElement.$projector.subscribeToChildrenChange(() => { this.onChildrenChanged(); });\n      this.children = findElements(this.customElement.$projector.children);\n    }\n\n    return this.children;\n  }\n\n  public setValue(newValue: unknown): void { /* do nothing */ }\n\n  public flush(this: ChildrenObserver & IChildrenObserver, flags: LifecycleFlags): void {\n    this.callSubscribers(this.children, undefined, flags | LifecycleFlags.updateTargetInstance);\n    this.hasChanges = false;\n  }\n\n  public subscribe(this: ChildrenObserver & IChildrenObserver, subscriber: IPropertySubscriber): void {\n    this.addSubscriber(subscriber);\n  }\n\n  public unsubscribe(this: ChildrenObserver & IChildrenObserver, subscriber: IPropertySubscriber): void {\n    this.removeSubscriber(subscriber);\n  }\n\n  private onChildrenChanged(): void {\n    this.children = findElements(this.customElement.$projector.children);\n\n    if ('$childrenChanged' in this.customElement) {\n      this.customElement.$childrenChanged();\n    }\n\n    this.lifecycle.enqueueFlush(this).catch(error => { throw error; });\n    this.hasChanges = true;\n  }\n}\n\n/** @internal */\nexport function findElements(nodes: ArrayLike<unknown>): ICustomElement[] {\n  const components: ICustomElement[] = [];\n\n  for (let i = 0, ii = nodes.length; i < ii; ++i) {\n    const current = nodes[i];\n    const component = customElementBehavior(current);\n\n    if (component !== null) {\n      components.push(component);\n    }\n  }\n\n  return components;\n}\n\n/** @internal */\nexport class RuntimeBehavior {\n  public bindables: BindableDefinitions;\n\n  private constructor() {}\n\n  public static create(Component: ICustomElementType | ICustomAttributeType): RuntimeBehavior {\n    const behavior = new RuntimeBehavior();\n\n    behavior.bindables = Component.description.bindables;\n\n    return behavior;\n  }\n\n  public applyTo(flags: LifecycleFlags, instance: ICustomAttribute | ICustomElement, lifecycle: ILifecycle): void {\n    instance.$lifecycle = lifecycle;\n    if ('$projector' in instance) {\n      this.applyToElement(flags, lifecycle, instance);\n    } else {\n      this.applyToCore(flags, instance);\n    }\n  }\n\n  private applyToElement(flags: LifecycleFlags, lifecycle: ILifecycle, instance: ICustomElement): void {\n    const observers = this.applyToCore(flags, instance);\n\n    observers.$children = new ChildrenObserver(lifecycle, instance);\n\n    Reflect.defineProperty(instance, '$children', {\n      enumerable: false,\n      get: function(): unknown {\n        return this['$observers'].$children.getValue();\n      }\n    });\n  }\n\n  private applyToCore(flags: LifecycleFlags, instance: ICustomAttribute | ICustomElement): IIndexable {\n    const observers = {};\n    const bindables = this.bindables;\n    const observableNames = Object.getOwnPropertyNames(bindables);\n\n    if (flags & LifecycleFlags.useProxies) {\n      for (let i = 0, ii = observableNames.length; i < ii; ++i) {\n        const name = observableNames[i];\n\n        observers[name] = new SelfObserver(\n          flags,\n          ProxyObserver.getOrCreate(instance).proxy,\n          name,\n          bindables[name].callback\n        );\n      }\n    } else {\n      for (let i = 0, ii = observableNames.length; i < ii; ++i) {\n        const name = observableNames[i];\n\n        observers[name] = new SelfObserver(\n          flags,\n          instance,\n          name,\n          bindables[name].callback\n        );\n\n        createGetterSetter(flags, instance, name);\n      }\n\n      Reflect.defineProperty(instance, '$observers', {\n        enumerable: false,\n        value: observers\n      });\n    }\n\n    return observers;\n  }\n}\n\nfunction createGetterSetter(flags: LifecycleFlags, instance: ICustomAttribute | ICustomElement, name: string): void {\n  Reflect.defineProperty(instance, name, {\n    enumerable: true,\n    get: function(): unknown { return this['$observers'][name].getValue(); },\n    set: function(value: unknown): void { this['$observers'][name].setValue(value, (flags & LifecycleFlags.persistentBindingFlags) | LifecycleFlags.updateTargetInstance); }\n  });\n}\n\n/** @internal */\nexport type ExposedContext = IRenderContext & IDisposable & IContainer;\n","import {\n  Class,\n  Constructable,\n  DI,\n  IContainer,\n  IResourceKind,\n  IResourceType,\n  IServiceLocator,\n  Registration,\n  Reporter,\n  Writable\n} from '@aurelia/kernel';\nimport {\n  buildTemplateDefinition,\n  customElementBehavior,\n  customElementKey,\n  customElementName,\n  IElementHydrationOptions,\n  ITemplateDefinition,\n  TemplateDefinition\n} from '../definitions';\nimport { IDOM, INode, INodeSequence, IRenderLocation } from '../dom';\nimport { Hooks, LifecycleFlags } from '../flags';\nimport {\n  ILifecycleHooks,\n  IMountableComponent,\n  IRenderable\n} from '../lifecycle';\nimport { IChangeTracker } from '../observation';\nimport {\n  $attachElement,\n  $cacheElement,\n  $detachElement,\n  $mountElement,\n  $unmountElement\n} from '../templating/lifecycle-attach';\nimport {\n  $bindElement,\n  $unbindElement\n} from '../templating/lifecycle-bind';\nimport {\n  $hydrateElement,\n  ILifecycleRender\n} from '../templating/lifecycle-render';\n\nexport interface ICustomElementType<T extends INode = INode> extends IResourceType<ITemplateDefinition, ICustomElement<T>>, ICustomElementStaticProperties {\n  description: TemplateDefinition;\n}\n\nexport type CustomElementHost<T extends INode = INode> = IRenderLocation<T> & T & {\n  $customElement?: ICustomElement<T>;\n};\n\nexport interface IElementProjector<T extends INode = INode> {\n  readonly host: CustomElementHost<T>;\n  readonly children: ArrayLike<CustomElementHost<T>>;\n\n  provideEncapsulationSource(): T;\n  project(nodes: INodeSequence<T>): void;\n  take(nodes: INodeSequence<T>): void;\n\n  subscribeToChildrenChange(callback: () => void): void;\n}\n\nexport const IProjectorLocator = DI.createInterface<IProjectorLocator>('IProjectorLocator').noDefault();\n\nexport interface IProjectorLocator<T extends INode = INode> {\n  getElementProjector(dom: IDOM<T>, $component: ICustomElement<T>, host: CustomElementHost<T>, def: TemplateDefinition): IElementProjector<T>;\n}\n\nexport interface ICustomElementStaticProperties {\n  containerless?: TemplateDefinition['containerless'];\n  shadowOptions?: TemplateDefinition['shadowOptions'];\n  bindables?: TemplateDefinition['bindables'];\n  useProxies?: TemplateDefinition['useProxies'];\n}\n\nexport interface ICustomElement<T extends INode = INode> extends\n  Partial<IChangeTracker>,\n  ILifecycleHooks,\n  ILifecycleRender,\n  IMountableComponent,\n  IRenderable<T> {\n\n  readonly $projector: IElementProjector;\n  readonly $host: CustomElementHost;\n\n  $hydrate(flags: LifecycleFlags, parentContext: IServiceLocator, host: INode, options?: IElementHydrationOptions): void;\n}\n\nexport interface ICustomElementResource<T extends INode = INode> extends\n  IResourceKind<ITemplateDefinition, ICustomElement<T>, Class<ICustomElement<T>> & ICustomElementStaticProperties> {\n  behaviorFor(node: T): ICustomElement<T> | null;\n}\n\n/** @internal */\nexport function registerElement(this: ICustomElementType, container: IContainer): void {\n  const resourceKey = this.kind.keyFrom(this.description.name);\n  container.register(Registration.transient(resourceKey, this));\n}\n\n/**\n * Decorator: Indicates that the decorated class is a custom element.\n */\nexport function customElement(name: string): ICustomElementDecorator;\nexport function customElement(definition: ITemplateDefinition): ICustomElementDecorator;\nexport function customElement(nameOrDefinition: string | ITemplateDefinition): ICustomElementDecorator;\nexport function customElement(nameOrDefinition: string | ITemplateDefinition): ICustomElementDecorator {\n  return (target => CustomElementResource.define(nameOrDefinition, target)) as ICustomElementDecorator;\n}\n\nfunction isType<T>(this: ICustomElementResource, Type: T & Partial<ICustomElementType>): Type is T & ICustomElementType {\n  return Type.kind === this;\n}\n\nfunction define<T extends Constructable>(this: ICustomElementResource, name: string, ctor: T | null): T & ICustomElementType;\nfunction define<T extends Constructable>(this: ICustomElementResource, definition: ITemplateDefinition, ctor: T | null): T & ICustomElementType;\nfunction define<T extends Constructable>(this: ICustomElementResource, nameOrDefinition: string | ITemplateDefinition, ctor: T | null = null): T & ICustomElementType {\n  if (!nameOrDefinition) {\n    throw Reporter.error(70);\n  }\n  const Type = (ctor === null ? class HTMLOnlyElement { /* HTML Only */ } : ctor) as T & Writable<ICustomElementType>;\n  const description = buildTemplateDefinition(Type as unknown as ICustomElementType, nameOrDefinition);\n  const proto: Writable<ICustomElement> = Type.prototype;\n\n  Type.kind = CustomElementResource;\n  Type.description = description;\n  Type.register = registerElement;\n\n  proto.$hydrate = $hydrateElement;\n  proto.$bind = $bindElement;\n  proto.$attach = $attachElement;\n  proto.$detach = $detachElement;\n  proto.$unbind = $unbindElement;\n  proto.$cache = $cacheElement;\n\n  proto.$prevComponent = null;\n  proto.$nextComponent = null;\n\n  proto.$nextUnbindAfterDetach = null;\n\n  proto.$scope = null;\n  proto.$hooks = 0;\n\n  proto.$bindingHead = null;\n  proto.$bindingTail = null;\n  proto.$componentHead = null;\n  proto.$componentTail = null;\n\n  proto.$mount = $mountElement;\n  proto.$unmount = $unmountElement;\n\n  proto.$nextMount = null;\n  proto.$nextUnmount = null;\n\n  proto.$projector = null;\n\n  if ('flush' in proto) {\n    proto.$nextFlush = null;\n  }\n\n  if ('binding' in proto) proto.$hooks |= Hooks.hasBinding;\n  if ('bound' in proto) {\n    proto.$hooks |= Hooks.hasBound;\n    proto.$nextBound = null;\n  }\n\n  if ('unbinding' in proto) proto.$hooks |= Hooks.hasUnbinding;\n  if ('unbound' in proto) {\n    proto.$hooks |= Hooks.hasUnbound;\n    proto.$nextUnbound = null;\n  }\n\n  if ('render' in proto) proto.$hooks |= Hooks.hasRender;\n  if ('created' in proto) proto.$hooks |= Hooks.hasCreated;\n  if ('attaching' in proto) proto.$hooks |= Hooks.hasAttaching;\n  if ('attached' in proto) {\n    proto.$hooks |= Hooks.hasAttached;\n    proto.$nextAttached = null;\n  }\n  if ('detaching' in proto) proto.$hooks |= Hooks.hasDetaching;\n  if ('caching' in proto) proto.$hooks |= Hooks.hasCaching;\n  if ('detached' in proto) {\n    proto.$hooks |= Hooks.hasDetached;\n    proto.$nextDetached = null;\n  }\n\n  return Type as ICustomElementType & T;\n}\n\nexport const CustomElementResource: ICustomElementResource = {\n  name: customElementName,\n  keyFrom: customElementKey,\n  isType,\n  behaviorFor: customElementBehavior as ICustomElementResource['behaviorFor'],\n  define\n};\n\n// tslint:enable:align\n\n// TODO\n// ## DefaultSlotProjector\n// An implementation of IElementProjector that can handle a subset of default\n// slot projection scenarios without needing real Shadow DOM.\n// ### Conditions\n// We can do a one-time, static composition of the content and view,\n// to emulate shadow DOM, if the following constraints are met:\n// * There must be exactly one slot and it must be a default slot.\n// * The default slot must not have any fallback content.\n// * The default slot must not have a custom element as its immediate parent or\n//   a slot attribute (re-projection).\n// ### Projection\n// The projector copies all content nodes to the slot's location.\n// The copy process should inject a comment node before and after the slotted\n// content, so that the bounds of the content can be clearly determined,\n// even if the slotted content has template controllers or string interpolation.\n// ### Encapsulation Source\n// Uses the same strategy as HostProjector.\n// ### Children\n// The projector adds a mutation observer to the parent node of the\n// slot comment. When direct children of that node change, the projector\n// will gather up all nodes between the start and end slot comments.\n\nexport interface ICustomElementDecorator {\n  // Using a type breaks syntax highlighting: https://github.com/Microsoft/TypeScript-TmLanguage/issues/481\n  // tslint:disable-next-line:callable-types\n  <T extends Constructable>(target: T): T & ICustomElementType;\n}\n\ntype HasShadowOptions = Pick<ITemplateDefinition, 'shadowOptions'>;\n\nconst defaultShadowOptions = {\n  mode: 'open' as 'open' | 'closed'\n};\n\n/**\n * Decorator: Indicates that the custom element should render its view in ShadowDOM.\n */\nexport function useShadowDOM<T extends Constructable>(options?: HasShadowOptions['shadowOptions']): (target: T & HasShadowOptions) => T & Required<HasShadowOptions>;\n/**\n * Decorator: Indicates that the custom element should render its view in ShadowDOM.\n */\nexport function useShadowDOM<T extends Constructable>(target: T & HasShadowOptions): T & Required<HasShadowOptions>;\nexport function useShadowDOM<T extends Constructable>(targetOrOptions?: (T & HasShadowOptions) | HasShadowOptions['shadowOptions']): (T & Required<HasShadowOptions>) | ((target: T & HasShadowOptions) => (T & Required<HasShadowOptions>)) {\n  const options = typeof targetOrOptions === 'function' || !targetOrOptions\n    ? defaultShadowOptions\n    : targetOrOptions as HasShadowOptions['shadowOptions'];\n\n  function useShadowDOMDecorator(target: T & HasShadowOptions): T & Required<HasShadowOptions> {\n    target.shadowOptions = options;\n    return target as T & Required<HasShadowOptions>;\n  }\n\n  return typeof targetOrOptions === 'function' ? useShadowDOMDecorator(targetOrOptions) : useShadowDOMDecorator;\n}\n\ntype HasContainerless = Pick<ITemplateDefinition, 'containerless'>;\n\nfunction containerlessDecorator<T extends Constructable>(target: T & HasContainerless): T & Required<HasContainerless> {\n  target.containerless = true;\n  return target as T & Required<HasContainerless>;\n}\n\n/**\n * Decorator: Indicates that the custom element should be rendered without its element container.\n */\nexport function containerless(): typeof containerlessDecorator;\n/**\n * Decorator: Indicates that the custom element should be rendered without its element container.\n */\nexport function containerless<T extends Constructable>(target: T & HasContainerless): T & Required<HasContainerless>;\nexport function containerless<T extends Constructable>(target?: T & HasContainerless): T & Required<HasContainerless> | typeof containerlessDecorator {\n  return target === undefined ? containerlessDecorator : containerlessDecorator<T>(target);\n}\n","import { IServiceLocator, PLATFORM, Profiler, Tracer, Writable } from '@aurelia/kernel';\nimport { IElementHydrationOptions, TemplateDefinition } from '../definitions';\nimport { IDOM, INode } from '../dom';\nimport { Hooks, LifecycleFlags } from '../flags';\nimport { Scope } from '../observation/binding-context';\nimport { ProxyObserver } from '../observation/proxy-observer';\nimport { IRenderingEngine, ITemplate } from '../rendering-engine';\nimport { ICustomAttribute, ICustomAttributeType } from '../resources/custom-attribute';\nimport { ICustomElement, ICustomElementType, IProjectorLocator } from '../resources/custom-element';\n\nconst slice = Array.prototype.slice;\n\nconst { enter, leave } = Profiler.createTimer('RenderLifecycle');\n\nexport interface IElementTemplateProvider {\n  getElementTemplate(renderingEngine: IRenderingEngine, customElementType: ICustomElementType | null, parentContext: IServiceLocator): ITemplate;\n}\n\nexport interface ILifecycleRender {\n  /**\n   * Only applies to `@customElement`. This hook is not invoked for `@customAttribute`s\n   *\n   * Called during `$hydrate`, after `this.$scope` and `this.$projector` are set.\n   *\n   * If this hook is implemented, it will be used instead of `renderingEngine.getElementTemplate`.\n   * This allows you to completely override the default rendering behavior.\n   *\n   * It is the responsibility of the implementer to:\n   * - Populate `this.$bindables` with any Bindings, child Views, custom elements and custom attributes\n   * - Populate `this.$attachables` with any child Views, custom elements and custom attributes\n   * - Populate `this.$nodes` with the nodes that need to be appended to the host\n   * - Populate `this.$context` with the RenderContext / Container scoped to this instance\n   *\n   * @param host The DOM node that declares this custom element\n   * @param parts Replaceable parts, if any\n   *\n   * @returns Either an implementation of `IElementTemplateProvider`, or void\n   *\n   * @description\n   * This is the first \"hydrate\" lifecycle hook. It happens only once per instance (contrary to bind/attach\n   * which can happen many times per instance), though it can happen many times per type (once for each instance)\n   */\n  render?(flags: LifecycleFlags, host: INode, parts: Record<string, TemplateDefinition>, parentContext: IServiceLocator): IElementTemplateProvider | void;\n}\n\n/** @internal */\nexport function $hydrateAttribute(this: Writable<ICustomAttribute>, flags: LifecycleFlags, parentContext: IServiceLocator): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$hydrateAttribute`, slice.call(arguments)); }\n  if (Profiler.enabled) { enter(); }\n  const Type = this.constructor as ICustomAttributeType;\n  const renderingEngine = parentContext.get(IRenderingEngine);\n\n  renderingEngine.applyRuntimeBehavior(flags, Type, this);\n\n  if (this.$hooks & Hooks.hasCreated) {\n    this.created(flags);\n  }\n  if (Profiler.enabled) { leave(); }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $hydrateElement(this: Writable<ICustomElement>, flags: LifecycleFlags, parentContext: IServiceLocator, host: INode, options: IElementHydrationOptions = PLATFORM.emptyObject): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$hydrateElement`, slice.call(arguments)); }\n  if (Profiler.enabled) { enter(); }\n  const Type = this.constructor as ICustomElementType;\n  const description = Type.description;\n  const projectorLocator = parentContext.get(IProjectorLocator);\n  const renderingEngine = parentContext.get(IRenderingEngine);\n  const dom = parentContext.get(IDOM);\n\n  let bindingContext: typeof this;\n  if (flags & LifecycleFlags.useProxies) {\n    bindingContext = ProxyObserver.getOrCreate(this).proxy;\n  } else {\n    bindingContext = this;\n  }\n  this.$scope = Scope.create(flags, bindingContext, null);\n  this.$host = host;\n  this.$projector = projectorLocator.getElementProjector(dom, this, host, description);\n\n  renderingEngine.applyRuntimeBehavior(flags, Type, this);\n\n  if (this.$hooks & Hooks.hasRender) {\n    const result = this.render(flags, host, options.parts, parentContext);\n\n    if (result && 'getElementTemplate' in result) {\n      const template = result.getElementTemplate(renderingEngine, Type, parentContext);\n      template.render(this, host, options.parts);\n    }\n  } else {\n    const template = renderingEngine.getElementTemplate(dom, description, parentContext, Type);\n    template.render(this, host, options.parts);\n  }\n\n  if (this.$hooks & Hooks.hasCreated) {\n    this.created(flags);\n  }\n  if (Profiler.enabled) { leave(); }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n","import {\n  Class,\n  Constructable,\n  IContainer,\n  Immutable,\n  IResourceKind,\n  IResourceType,\n  IServiceLocator,\n  Omit,\n  PLATFORM,\n  Registration,\n  ResourceDescription,\n  Writable\n} from '@aurelia/kernel';\nimport {\n  customAttributeKey,\n  customAttributeName,\n  IAttributeDefinition\n} from '../definitions';\nimport { INode } from '../dom';\nimport { BindingMode, Hooks, LifecycleFlags } from '../flags';\nimport {\n  IComponent,\n  ILifecycleHooks,\n  IRenderable\n} from '../lifecycle';\nimport { IChangeTracker } from '../observation';\nimport {\n  $attachAttribute,\n  $cacheAttribute,\n  $detachAttribute\n} from '../templating/lifecycle-attach';\nimport {\n  $bindAttribute,\n  $unbindAttribute\n} from '../templating/lifecycle-bind';\nimport { $hydrateAttribute } from '../templating/lifecycle-render';\n\ntype CustomAttributeStaticProperties = Pick<Immutable<Required<IAttributeDefinition>>, 'bindables'>;\n\nexport type CustomAttributeConstructor = Constructable & CustomAttributeStaticProperties;\n\nexport interface ICustomAttributeType<T extends INode = INode> extends\n  IResourceType<IAttributeDefinition, ICustomAttribute<T>>,\n  CustomAttributeStaticProperties { }\n\nexport interface ICustomAttribute<T extends INode = INode> extends\n  Partial<IChangeTracker>,\n  ILifecycleHooks,\n  IComponent,\n  IRenderable<T> {\n\n  $hydrate(flags: LifecycleFlags, parentContext: IServiceLocator): void;\n}\n\nexport interface ICustomAttributeResource<T extends INode = INode> extends\n  IResourceKind<IAttributeDefinition, ICustomAttribute<T>, Class<ICustomAttribute<T>> & CustomAttributeStaticProperties> {\n}\n\n/** @internal */\nexport function registerAttribute(this: ICustomAttributeType, container: IContainer): void {\n  const description = this.description;\n  const resourceKey = this.kind.keyFrom(description.name);\n  const aliases = description.aliases;\n\n  container.register(Registration.transient(resourceKey, this));\n\n  for (let i = 0, ii = aliases.length; i < ii; ++i) {\n    const aliasKey = this.kind.keyFrom(aliases[i]);\n    container.register(Registration.alias(resourceKey, aliasKey));\n  }\n}\n\n/**\n * Decorator: Indicates that the decorated class is a custom attribute.\n */\nexport function customAttribute(name: string): CustomAttributeDecorator;\nexport function customAttribute(definition: IAttributeDefinition): CustomAttributeDecorator;\nexport function customAttribute(nameOrDefinition: string | IAttributeDefinition): CustomAttributeDecorator;\nexport function customAttribute(nameOrDefinition: string | IAttributeDefinition): CustomAttributeDecorator {\n  return target => CustomAttributeResource.define(nameOrDefinition, target);\n}\n\n/**\n * Decorator: Applied to custom attributes. Indicates that whatever element the\n * attribute is placed on should be converted into a template and that this\n * attribute controls the instantiation of the template.\n */\nexport function templateController(name: string): CustomAttributeDecorator;\nexport function templateController(definition: IAttributeDefinition): CustomAttributeDecorator;\nexport function templateController(nameOrDefinition: string | Omit<IAttributeDefinition, 'isTemplateController'>): CustomAttributeDecorator;\nexport function templateController(nameOrDefinition: string | Omit<IAttributeDefinition, 'isTemplateController'>): CustomAttributeDecorator {\n  return target => CustomAttributeResource.define(\n    typeof nameOrDefinition === 'string'\n    ? { isTemplateController: true , name: nameOrDefinition }\n    : { isTemplateController: true, ...nameOrDefinition },\n    target);\n}\n\ntype HasDynamicOptions = Pick<IAttributeDefinition, 'hasDynamicOptions'>;\n\nfunction dynamicOptionsDecorator<T extends Constructable>(target: T & HasDynamicOptions): T & Required<HasDynamicOptions> {\n  target.hasDynamicOptions = true;\n  return target as T & Required<HasDynamicOptions>;\n}\n\n/**\n * Decorator: Indicates that the custom attributes has dynamic options.\n */\nexport function dynamicOptions(): typeof dynamicOptionsDecorator;\n/**\n * Decorator: Indicates that the custom attributes has dynamic options.\n */\nexport function dynamicOptions<T extends Constructable>(target: T & HasDynamicOptions): T & Required<HasDynamicOptions>;\nexport function dynamicOptions<T extends Constructable>(target?: T & HasDynamicOptions): T & Required<HasDynamicOptions> | typeof dynamicOptionsDecorator {\n  return target === undefined ? dynamicOptionsDecorator : dynamicOptionsDecorator<T>(target);\n}\n\nfunction isType<T>(this: ICustomAttributeResource, Type: T & Partial<ICustomAttributeType>): Type is T & ICustomAttributeType {\n  return Type.kind === this;\n}\n\nfunction define<T extends Constructable>(this: ICustomAttributeResource, name: string, ctor: T): T & ICustomAttributeType;\nfunction define<T extends Constructable>(this: ICustomAttributeResource, definition: IAttributeDefinition, ctor: T): T & ICustomAttributeType;\nfunction define<T extends Constructable>(this: ICustomAttributeResource, nameOrDefinition: string | IAttributeDefinition, ctor: T): T & ICustomAttributeType {\n  const Type = ctor as T & Writable<ICustomAttributeType>;\n  const description = createCustomAttributeDescription(typeof nameOrDefinition === 'string' ? { name: nameOrDefinition } : nameOrDefinition, Type as T & ICustomAttributeType);\n  const proto: Writable<ICustomAttribute> = Type.prototype;\n\n  Type.kind = CustomAttributeResource;\n  Type.description = description;\n  Type.register = registerAttribute;\n\n  proto.$hydrate = $hydrateAttribute;\n  proto.$bind = $bindAttribute;\n  proto.$attach = $attachAttribute;\n  proto.$detach = $detachAttribute;\n  proto.$unbind = $unbindAttribute;\n  proto.$cache = $cacheAttribute;\n\n  proto.$prevComponent = null;\n  proto.$nextComponent = null;\n\n  proto.$nextUnbindAfterDetach = null;\n\n  proto.$scope = null;\n  proto.$hooks = 0;\n  proto.$state = 0;\n\n  if ('flush' in proto) {\n    proto.$nextFlush = null;\n  }\n\n  if ('binding' in proto) proto.$hooks |= Hooks.hasBinding;\n  if ('bound' in proto) {\n    proto.$hooks |= Hooks.hasBound;\n    proto.$nextBound = null;\n  }\n\n  if ('unbinding' in proto) proto.$hooks |= Hooks.hasUnbinding;\n  if ('unbound' in proto) {\n    proto.$hooks |= Hooks.hasUnbound;\n    proto.$nextUnbound = null;\n  }\n\n  if ('created' in proto) proto.$hooks |= Hooks.hasCreated;\n  if ('attaching' in proto) proto.$hooks |= Hooks.hasAttaching;\n  if ('attached' in proto) {\n    proto.$hooks |= Hooks.hasAttached;\n    proto.$nextAttached = null;\n  }\n  if ('detaching' in proto) proto.$hooks |= Hooks.hasDetaching;\n  if ('caching' in proto) proto.$hooks |= Hooks.hasCaching;\n  if ('detached' in proto) {\n    proto.$hooks |= Hooks.hasDetached;\n    proto.$nextDetached = null;\n  }\n\n  return Type as ICustomAttributeType & T;\n}\n\nexport const CustomAttributeResource: ICustomAttributeResource = {\n  name: customAttributeName,\n  keyFrom: customAttributeKey,\n  isType,\n  define\n};\n\n/** @internal */\nexport function createCustomAttributeDescription(def: IAttributeDefinition, Type: ICustomAttributeType): ResourceDescription<IAttributeDefinition> {\n  const aliases = def. aliases;\n  const defaultBindingMode = def.defaultBindingMode;\n  return {\n    name: def.name,\n    aliases: aliases === undefined || aliases === null ? PLATFORM.emptyArray : aliases,\n    defaultBindingMode: defaultBindingMode === undefined || defaultBindingMode === null ? BindingMode.toView : defaultBindingMode,\n    hasDynamicOptions: def.hasDynamicOptions === undefined ? false : def.hasDynamicOptions,\n    isTemplateController: def.isTemplateController === undefined ? false : def.isTemplateController,\n    bindables: {...Type.bindables, ...def.bindables},\n    useProxies: def.useProxies === undefined ? false : def.useProxies\n  };\n}\n\nexport type CustomAttributeDecorator = <T extends Constructable>(target: T) => T & ICustomAttributeType;\n","import { Constructable, PLATFORM } from '@aurelia/kernel';\nimport { BindableSource, IBindableDescription } from '../definitions';\nimport { BindingMode } from '../flags';\n\n/**\n * Decorator: Specifies custom behavior for a bindable property.\n * @param config The overrides\n */\nexport function bindable(config?: BindableSource): BindableDecorator;\n/**\n * Decorator: Specifies a bindable property on a class.\n * @param prop The property name\n */\nexport function bindable(prop: string): ClassDecorator;\n/**\n * Decorator: Specifies a bindable property on a class.\n * @param target The class\n * @param prop The property name\n */\nexport function bindable<T extends InstanceType<Constructable & Partial<WithBindables>>>(target: T, prop: string): void;\nexport function bindable<T extends InstanceType<Constructable & Partial<WithBindables>>>(configOrTarget?: BindableSource | T, prop?: string): void | BindableDecorator | ClassDecorator {\n  let config: IBindableDescription;\n\n  const decorator = function decorate($target: T, $prop: string): void {\n    const Type = $target.constructor as Constructable & Partial<WithBindables>;\n    let bindables = Type.bindables;\n    if (bindables === undefined) {\n      bindables = Type.bindables = {};\n    }\n    if (!config.attribute) {\n      config.attribute = PLATFORM.kebabCase($prop);\n    }\n    if (!config.callback) {\n      config.callback = `${$prop}Changed`;\n    }\n    if (config.mode === undefined) {\n      config.mode = BindingMode.toView;\n    }\n    if (config.useProxies === undefined) {\n      config.useProxies = false;\n    }\n    if (arguments.length > 1) {\n      // Non invocation:\n      // - @bindable\n      // Invocation with or w/o opts:\n      // - @bindable()\n      // - @bindable({...opts})\n      config.property = $prop;\n    }\n    bindables[config.property] = config;\n  };\n  if (arguments.length > 1) {\n    // Non invocation:\n    // - @bindable\n    config = {};\n    decorator(configOrTarget as T, prop);\n    return;\n  } else if (typeof configOrTarget === 'string') {\n    // ClassDecorator\n    // - @bindable('bar')\n    // Direct call:\n    // - @bindable('bar')(Foo)\n    config = {};\n    return decorator as BindableDecorator;\n  }\n\n  // Invocation with or w/o opts:\n  // - @bindable()\n  // - @bindable({...opts})\n  config = (configOrTarget || {}) as IBindableDescription;\n  return decorator as BindableDecorator;\n}\n\nexport type WithBindables = { bindables: Record<string, IBindableDescription> };\nexport type BindableDecorator = <T extends InstanceType<Constructable & Partial<WithBindables>>>\n  (target: T, prop: string) => void;\n","import { Constructable, InterfaceSymbol, IRegistry } from '@aurelia/kernel';\nimport { AttributeDefinition, IAttributeDefinition } from '../../definitions';\nimport { INode, IRenderLocation } from '../../dom';\nimport { LifecycleFlags, State } from '../../flags';\nimport { CompositionCoordinator, IView, IViewFactory } from '../../lifecycle';\nimport { ProxyObserver } from '../../observation/proxy-observer';\nimport { bindable } from '../../templating/bindable';\nimport { CustomAttributeResource, ICustomAttribute, ICustomAttributeResource } from '../custom-attribute';\n\nexport interface If<T extends INode = INode> extends ICustomAttribute<T> {}\nexport class If<T extends INode = INode> implements If<T> {\n  public static readonly inject: ReadonlyArray<InterfaceSymbol|Constructable> = [IViewFactory, IRenderLocation, CompositionCoordinator];\n\n  public static readonly register: IRegistry['register'];\n  public static readonly bindables: IAttributeDefinition['bindables'];\n  public static readonly kind: ICustomAttributeResource;\n  public static readonly description: AttributeDefinition;\n\n  @bindable public value: boolean;\n\n  public elseFactory: IViewFactory<T> | null;\n  public elseView: IView<T> | null;\n  public ifFactory: IViewFactory<T>;\n  public ifView: IView<T> | null;\n  public location: IRenderLocation<T>;\n  public coordinator: CompositionCoordinator;\n\n  constructor(\n    ifFactory: IViewFactory<T>,\n    location: IRenderLocation<T>,\n    coordinator: CompositionCoordinator\n  ) {\n    this.value = false;\n\n    this.coordinator = coordinator;\n    this.elseFactory = null;\n    this.elseView = null;\n    this.ifFactory = ifFactory;\n    this.ifView = null;\n    this.location = location;\n  }\n\n  public binding(flags: LifecycleFlags): void {\n    const view = this.updateView(flags);\n    this.coordinator.compose(view, flags);\n    this.coordinator.binding(flags, this.$scope);\n  }\n\n  public attaching(flags: LifecycleFlags): void {\n    this.coordinator.attaching(flags);\n  }\n\n  public detaching(flags: LifecycleFlags): void {\n    this.coordinator.detaching(flags);\n  }\n\n  public unbinding(flags: LifecycleFlags): void {\n    this.coordinator.unbinding(flags);\n  }\n\n  public caching(flags: LifecycleFlags): void {\n    if (this.ifView !== null && this.ifView.release(flags)) {\n      this.ifView = null;\n    }\n\n    if (this.elseView !== null && this.elseView.release(flags)) {\n      this.elseView = null;\n    }\n\n    this.coordinator.caching(flags);\n  }\n\n  public valueChanged(newValue: boolean, oldValue: boolean, flags: LifecycleFlags): void {\n    if (this.$state & (State.isBound | State.isBinding)) {\n      if (ProxyObserver.isProxy(this)) {\n        flags |= LifecycleFlags.useProxies;\n      }\n      if (flags & LifecycleFlags.fromFlush) {\n        const view = this.updateView(flags);\n        this.coordinator.compose(view, flags);\n      } else {\n        this.$lifecycle.enqueueFlush(this).catch(error => { throw error; });\n      }\n    }\n  }\n\n  public flush(flags: LifecycleFlags): void {\n    if (ProxyObserver.isProxy(this)) {\n      flags |= LifecycleFlags.useProxies;\n    }\n    const view = this.updateView(flags);\n    this.coordinator.compose(view, flags);\n  }\n\n  /** @internal */\n  public updateView(flags: LifecycleFlags): IView<T> | null {\n    let view: IView<T> | null;\n\n    if (this.value) {\n      view = this.ifView = this.ensureView(this.ifView, this.ifFactory, flags);\n    } else if (this.elseFactory !== null) {\n      view = this.elseView  = this.ensureView(this.elseView, this.elseFactory, flags);\n    } else {\n      view = null;\n    }\n\n    return view;\n  }\n\n  /** @internal */\n  public ensureView(view: IView<T> | null, factory: IViewFactory<T>, flags: LifecycleFlags): IView<T> {\n    if (view === null) {\n      view = factory.create(flags);\n    }\n\n    view.hold(this.location);\n\n    return view;\n  }\n}\nCustomAttributeResource.define({ name: 'if', isTemplateController: true }, If);\n\nexport interface Else<T extends INode = INode> extends ICustomAttribute<T> {}\nexport class Else<T extends INode = INode> implements Else<T> {\n  public static readonly inject: ReadonlyArray<InterfaceSymbol> = [IViewFactory];\n\n  public static readonly register: IRegistry['register'];\n  public static readonly bindables: IAttributeDefinition['bindables'];\n  public static readonly kind: ICustomAttributeResource;\n  public static readonly description: AttributeDefinition;\n\n  private readonly factory: IViewFactory<T>;\n\n  constructor(factory: IViewFactory<T>) {\n    this.factory = factory;\n  }\n\n  public link(ifBehavior: If<T>): void {\n    ifBehavior.elseFactory = this.factory;\n  }\n}\nCustomAttributeResource.define({ name: 'else', isTemplateController: true }, Else);\n","import { IIndexable, InterfaceSymbol, IRegistry } from '@aurelia/kernel';\nimport { ForOfStatement } from '../../binding/ast';\nimport { Binding } from '../../binding/binding';\nimport { AttributeDefinition, IAttributeDefinition } from '../../definitions';\nimport { INode, IRenderLocation } from '../../dom';\nimport { LifecycleFlags, State } from '../../flags';\nimport { IRenderable, IView, IViewFactory } from '../../lifecycle';\nimport { CollectionObserver, IBatchedCollectionSubscriber, IObservedArray, IScope, ObservedCollection } from '../../observation';\nimport { BindingContext, Scope } from '../../observation/binding-context';\nimport { getCollectionObserver } from '../../observation/observer-locator';\nimport { ProxyObserver } from '../../observation/proxy-observer';\nimport { SetterObserver } from '../../observation/setter-observer';\nimport { bindable } from '../../templating/bindable';\nimport { CustomAttributeResource, ICustomAttribute, ICustomAttributeResource } from '../custom-attribute';\n\nexport interface Repeat<C extends ObservedCollection, T extends INode = INode> extends ICustomAttribute<T>, IBatchedCollectionSubscriber {}\nexport class Repeat<C extends ObservedCollection = IObservedArray, T extends INode = INode> implements Repeat<C, T> {\n  public static readonly inject: ReadonlyArray<InterfaceSymbol> = [IRenderLocation, IRenderable, IViewFactory];\n\n  public static readonly register: IRegistry['register'];\n  public static readonly bindables: IAttributeDefinition['bindables'];\n  public static readonly kind: ICustomAttributeResource;\n  public static readonly description: AttributeDefinition;\n\n  @bindable public items: C;\n\n  public $scope: IScope;\n  public $observers: { items: SetterObserver };\n\n  public forOf: ForOfStatement;\n  public hasPendingInstanceMutation: boolean;\n  public local: string;\n  public location: IRenderLocation<T>;\n  public observer: CollectionObserver | null;\n  public renderable: IRenderable<T>;\n  public factory: IViewFactory<T>;\n  public views: IView<T>[];\n\n  constructor(\n    location: IRenderLocation<T>,\n    renderable: IRenderable<T>,\n    factory: IViewFactory<T>\n  ) {\n    this.factory = factory;\n    this.hasPendingInstanceMutation = false;\n    this.location = location;\n    this.observer = null;\n    this.renderable = renderable;\n    this.views = [];\n  }\n\n  public binding(flags: LifecycleFlags): void {\n    this.checkCollectionObserver(flags);\n    let current = this.renderable.$bindingHead as Binding;\n    while (current !== null) {\n      if (ProxyObserver.getRawIfProxy(current.target) === ProxyObserver.getRawIfProxy(this) && current.targetProperty === 'items') {\n        this.forOf = current.sourceExpression as ForOfStatement;\n        break;\n      }\n      current = current.$nextBinding as Binding;\n    }\n    this.local = this.forOf.declaration.evaluate(flags, this.$scope, null) as string;\n\n    this.processViews(null, flags);\n  }\n\n  public attaching(flags: LifecycleFlags): void {\n    const { views, location } = this;\n    for (let i = 0, ii = views.length; i < ii; ++i) {\n      const view = views[i];\n      view.hold(location);\n      view.$attach(flags);\n    }\n  }\n\n  public detaching(flags: LifecycleFlags): void {\n    const { views } = this;\n    for (let i = 0, ii = views.length; i < ii; ++i) {\n      const view = views[i];\n      view.$detach(flags);\n      view.release(flags);\n    }\n  }\n\n  public unbinding(flags: LifecycleFlags): void {\n    this.checkCollectionObserver(flags);\n\n    const { views } = this;\n    for (let i = 0, ii = views.length; i < ii; ++i) {\n      const view = views[i];\n      view.$unbind(flags);\n    }\n  }\n\n  // called by SetterObserver (sync)\n  public itemsChanged(newValue: C, oldValue: C, flags: LifecycleFlags): void {\n    this.checkCollectionObserver(flags);\n    this.processViews(null, flags | LifecycleFlags.updateTargetInstance);\n  }\n\n  // called by a CollectionObserver (async)\n  public handleBatchedChange(indexMap: number[] | null, flags: LifecycleFlags): void {\n    this.processViews(indexMap, flags | LifecycleFlags.fromFlush | LifecycleFlags.updateTargetInstance);\n  }\n\n  // if the indexMap === null, it is an instance mutation, otherwise it's an items mutation\n  // TODO: Reduce complexity (currently at 46)\n  private processViews(indexMap: number[] | null, flags: LifecycleFlags): void {\n    if (ProxyObserver.isProxy(this)) {\n      flags |= LifecycleFlags.useProxies;\n    }\n    const { views, $lifecycle } = this;\n    if (this.$state & (State.isBound | State.isBinding)) {\n      const { local, $scope, factory, forOf, items } = this;\n      const oldLength = views.length;\n      const newLength = forOf.count(items);\n      if (oldLength < newLength) {\n        views.length = newLength;\n        for (let i = oldLength; i < newLength; ++i) {\n          views[i] = factory.create(flags);\n        }\n      } else if (newLength < oldLength) {\n        $lifecycle.beginDetach();\n        for (let i = newLength, view = views[i]; i < oldLength; view = views[++i]) {\n          view.release(flags);\n          view.$detach(flags);\n        }\n        $lifecycle.endDetach(flags);\n        $lifecycle.beginUnbind();\n        for (let i = newLength, view = views[i]; i < oldLength; view = views[++i]) {\n          view.$unbind(flags);\n        }\n        $lifecycle.endUnbind(flags);\n        views.length = newLength;\n        if (newLength === 0) {\n          return;\n        }\n      } else if (newLength === 0) {\n        return;\n      }\n\n      $lifecycle.beginBind();\n      if (indexMap === null) {\n        forOf.iterate(items, (arr, i, item: (string | number | boolean | ObservedCollection | IIndexable)) => {\n          const view = views[i];\n          if (!!view.$scope && view.$scope.bindingContext[local] === item) {\n            view.$bind(flags, Scope.fromParent(flags, $scope, view.$scope.bindingContext));\n          } else {\n            view.$bind(flags, Scope.fromParent(flags, $scope, BindingContext.create(flags, local, item)));\n          }\n        });\n      } else {\n        forOf.iterate(items, (arr, i, item: (string | number | boolean | ObservedCollection | IIndexable)) => {\n          const view = views[i];\n          if (!!view.$scope && (indexMap[i] === i || view.$scope.bindingContext[local] === item)) {\n            view.$bind(flags, Scope.fromParent(flags, $scope, view.$scope.bindingContext));\n          } else {\n            view.$bind(flags, Scope.fromParent(flags, $scope, BindingContext.create(flags, local, item)));\n          }\n        });\n      }\n      $lifecycle.endBind(flags);\n    }\n\n    if (this.$state & (State.isAttached | State.isAttaching)) {\n      const { location } = this;\n      $lifecycle.beginAttach();\n      if (indexMap === null) {\n        for (let i = 0, ii = views.length; i < ii; ++i) {\n          const view = views[i];\n          view.hold(location);\n          view.$attach(flags);\n        }\n      } else {\n        for (let i = 0, ii = views.length; i < ii; ++i) {\n          if (indexMap[i] !== i) {\n            const view = views[i];\n            view.hold(location);\n            view.$attach(flags);\n          }\n        }\n      }\n      $lifecycle.endAttach(flags);\n    }\n  }\n\n  private checkCollectionObserver(flags: LifecycleFlags): void {\n    const oldObserver = this.observer;\n    if (this.$state & (State.isBound | State.isBinding)) {\n      const newObserver = this.observer = getCollectionObserver(flags, this.$lifecycle, this.items);\n      if (oldObserver !== newObserver && oldObserver) {\n        oldObserver.unsubscribeBatched(this);\n      }\n      if (newObserver) {\n        newObserver.subscribeBatched(this);\n      }\n    } else if (oldObserver) {\n      oldObserver.unsubscribeBatched(this);\n    }\n  }\n}\nCustomAttributeResource.define({ name: 'repeat', isTemplateController: true }, Repeat);\n","import { InterfaceSymbol, IRegistry } from '@aurelia/kernel';\nimport { AttributeDefinition, IAttributeDefinition } from '../../definitions';\nimport { INode, IRenderLocation } from '../../dom';\nimport { LifecycleFlags } from '../../flags';\nimport { IView, IViewFactory } from '../../lifecycle';\nimport { CustomAttributeResource, ICustomAttribute, ICustomAttributeResource } from '../custom-attribute';\n\nexport interface Replaceable<T extends INode = INode> extends ICustomAttribute<T> {}\nexport class Replaceable<T extends INode = INode> implements Replaceable<T> {\n  public static readonly inject: ReadonlyArray<InterfaceSymbol> = [IViewFactory, IRenderLocation];\n\n  public static readonly register: IRegistry['register'];\n  public static readonly bindables: IAttributeDefinition['bindables'];\n  public static readonly kind: ICustomAttributeResource;\n  public static readonly description: AttributeDefinition;\n\n  private readonly currentView: IView<T>;\n  private readonly factory: IViewFactory<T>;\n\n  constructor(\n    factory: IViewFactory<T>,\n    location: IRenderLocation<T>\n  ) {\n    this.factory = factory;\n\n    this.currentView = this.factory.create();\n    this.currentView.hold(location);\n  }\n\n  public binding(flags: LifecycleFlags): void {\n    this.currentView.$bind(flags | LifecycleFlags.allowParentScopeTraversal, this.$scope);\n  }\n\n  public attaching(flags: LifecycleFlags): void {\n    this.currentView.$attach(flags);\n  }\n\n  public detaching(flags: LifecycleFlags): void {\n    this.currentView.$detach(flags);\n  }\n\n  public unbinding(flags: LifecycleFlags): void {\n    this.currentView.$unbind(flags);\n  }\n}\nCustomAttributeResource.define({ name: 'replaceable', isTemplateController: true }, Replaceable);\n","import { InterfaceSymbol, IRegistry } from '@aurelia/kernel';\nimport { AttributeDefinition, IAttributeDefinition } from '../../definitions';\nimport { INode, IRenderLocation } from '../../dom';\nimport { LifecycleFlags, State } from '../../flags';\nimport { IBinding, IView, IViewFactory } from '../../lifecycle';\nimport { IBindingContext } from '../../observation';\nimport { Scope } from '../../observation/binding-context';\nimport { bindable } from '../../templating/bindable';\nimport { CustomAttributeResource, ICustomAttribute, ICustomAttributeResource } from '../custom-attribute';\n\nexport interface With<T extends INode = INode> extends ICustomAttribute<T> {}\nexport class With<T extends INode = INode> implements With<T>  {\n  public static readonly inject: ReadonlyArray<InterfaceSymbol> = [IViewFactory, IRenderLocation];\n\n  public static readonly register: IRegistry['register'];\n  public static readonly bindables: IAttributeDefinition['bindables'];\n  public static readonly kind: ICustomAttributeResource;\n  public static readonly description: AttributeDefinition;\n\n  // TODO: this type is incorrect (it can be any user-provided object), need to fix and double check Scope.\n  @bindable public value: IBinding | IBindingContext;\n\n  private readonly currentView: IView<T>;\n  private readonly factory: IViewFactory<T>;\n\n  constructor(\n    factory: IViewFactory<T>,\n    location: IRenderLocation<T>\n  ) {\n    this.value = null;\n\n    this.factory = factory;\n    this.currentView = this.factory.create();\n    this.currentView.hold(location);\n  }\n\n  public valueChanged(this: With): void {\n    if (this.$state & (State.isBound | State.isBinding)) {\n      this.bindChild(LifecycleFlags.fromBindableHandler);\n    }\n  }\n\n  public binding(flags: LifecycleFlags): void {\n    this.bindChild(flags);\n  }\n\n  public attaching(flags: LifecycleFlags): void {\n    this.currentView.$attach(flags);\n  }\n\n  public detaching(flags: LifecycleFlags): void {\n    this.currentView.$detach(flags);\n  }\n\n  public unbinding(flags: LifecycleFlags): void {\n    this.currentView.$unbind(flags);\n  }\n\n  private bindChild(flags: LifecycleFlags): void {\n    const scope = Scope.fromParent(flags, this.$scope, this.value);\n    this.currentView.$bind(flags, scope);\n  }\n}\nCustomAttributeResource.define({ name: 'with', isTemplateController: true }, With);\n","import { DI, InterfaceSymbol, IRegistry } from '@aurelia/kernel';\nimport { ValueConverterResource } from '../value-converter';\n\nconst SCRIPT_REGEX = /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi;\n\nexport interface ISanitizer {\n /**\n  * Sanitizes the provided input.\n  * @param input The input to be sanitized.\n  */\n  sanitize(input: string): string;\n}\n\nexport const ISanitizer = DI.createInterface<ISanitizer>('ISanitizer').withDefault(x => x.singleton(class {\n    public sanitize(input: string): string {\n      return input.replace(SCRIPT_REGEX, '');\n    }\n  })\n);\n\n/**\n * Simple html sanitization converter to preserve whitelisted elements and attributes on a bound property containing html.\n */\nexport class SanitizeValueConverter {\n  public static readonly inject: ReadonlyArray<InterfaceSymbol> = [ISanitizer];\n\n  public static register: IRegistry['register'];\n\n  private readonly sanitizer: ISanitizer;\n\n  constructor(sanitizer: ISanitizer) {\n    this.sanitizer = sanitizer;\n  }\n\n /**\n  * Process the provided markup that flows to the view.\n  * @param untrustedMarkup The untrusted markup to be sanitized.\n  */\n  public toView(untrustedMarkup: string): string|null {\n    if (untrustedMarkup === null || untrustedMarkup === undefined) {\n      return null;\n    }\n\n    return this.sanitizer.sanitize(untrustedMarkup);\n  }\n}\nValueConverterResource.define('sanitize', SanitizeValueConverter);\n","import { DI, IContainer, IRegistry, PLATFORM, Profiler, Registration } from '@aurelia/kernel';\nimport { IDOM, INode } from './dom';\nimport { LifecycleFlags } from './flags';\nimport { ProxyObserver } from './observation/proxy-observer';\nimport { ExposedContext } from './rendering-engine';\nimport { CustomElementResource, ICustomElement, ICustomElementType } from './resources/custom-element';\n\nconst { enter: enterStart, leave: leaveStart } = Profiler.createTimer('Aurelia.start');\nconst { enter: enterStop, leave: leaveStop } = Profiler.createTimer('Aurelia.stop');\n\nexport interface ISinglePageApp<THost extends INode = INode> {\n  useProxies?: boolean;\n  dom?: IDOM;\n  host: THost;\n  component: unknown;\n}\n\nexport class Aurelia {\n  private readonly container: IContainer;\n  private readonly components: ICustomElement[];\n  private readonly startTasks: (() => void)[];\n  private readonly stopTasks: (() => void)[];\n  private isStarted: boolean;\n  private _root: ICustomElement | null;\n\n  constructor(container: IContainer = DI.createContainer()) {\n    this.container = container;\n    this.components = [];\n    this.startTasks = [];\n    this.stopTasks = [];\n    this.isStarted = false;\n    this._root = null;\n\n    Registration\n      .instance(Aurelia, this)\n      .register(container, Aurelia);\n  }\n\n  public register(...params: (IRegistry | Record<string, Partial<IRegistry>>)[]): this {\n    this.container.register(...params);\n    return this;\n  }\n\n  public app(config: ISinglePageApp): this {\n    const host = config.host as INode & {$au?: Aurelia | null};\n\n    const domInitializer = this.container.get(IDOMInitializer);\n    domInitializer.initialize(config);\n\n    let startFlags = LifecycleFlags.fromStartTask;\n    let stopFlags = LifecycleFlags.fromStopTask;\n    if (config.useProxies) {\n      startFlags |= LifecycleFlags.useProxies;\n      stopFlags |= LifecycleFlags.useProxies;\n    }\n    let component: ICustomElement;\n    const componentOrType = config.component as ICustomElement | ICustomElementType;\n    if (CustomElementResource.isType(componentOrType as ICustomElementType)) {\n      this.container.register(componentOrType as ICustomElementType);\n      component = this.container.get<ICustomElement>(CustomElementResource.keyFrom((componentOrType as ICustomElementType).description.name));\n    } else {\n      component = componentOrType as ICustomElement;\n    }\n    component = ProxyObserver.getRawIfProxy(component);\n\n    const startTask = () => {\n      host.$au = this;\n      if (!this.components.includes(component)) {\n        this._root = component;\n        this.components.push(component);\n        component.$hydrate(startFlags, this.container as ExposedContext, host);\n      }\n\n      component.$bind(startFlags | LifecycleFlags.fromBind, null);\n      component.$attach(startFlags | LifecycleFlags.fromAttach);\n    };\n\n    this.startTasks.push(startTask);\n\n    this.stopTasks.push(() => {\n      component.$detach(stopFlags | LifecycleFlags.fromDetach);\n      component.$unbind(stopFlags | LifecycleFlags.fromUnbind);\n      host.$au = null;\n    });\n\n    if (this.isStarted) {\n      startTask();\n    }\n\n    return this;\n  }\n\n  public root(): ICustomElement | null {\n    return ProxyObserver.getProxyOrSelf(this._root);\n  }\n\n  public start(): this {\n    if (Profiler.enabled) { enterStart(); }\n    for (const runStartTask of this.startTasks) {\n      runStartTask();\n    }\n    this.isStarted = true;\n    if (Profiler.enabled) { leaveStart(); }\n    return this;\n  }\n\n  public stop(): this {\n    if (Profiler.enabled) { enterStop(); }\n    this.isStarted = false;\n    for (const runStopTask of this.stopTasks) {\n      runStopTask();\n    }\n    if (Profiler.enabled) { leaveStop(); }\n    return this;\n  }\n}\n(PLATFORM.global as typeof PLATFORM.global & {Aurelia: unknown}).Aurelia = Aurelia;\n\nexport const IDOMInitializer = DI.createInterface<IDOMInitializer>('IDOMInitializer').noDefault();\n\nexport interface IDOMInitializer {\n  initialize(config?: ISinglePageApp): IDOM;\n}\n","import {\n  all,\n  Class,\n  IContainer,\n  InterfaceSymbol,\n  IRegistry,\n  IResolver,\n  Registration,\n  Reporter,\n  Tracer,\n  Writable\n} from '@aurelia/kernel';\nimport { Binding } from './binding/binding';\nimport { Call } from './binding/call';\nimport { BindingType, IExpressionParser } from './binding/expression-parser';\nimport { InterpolationBinding, MultiInterpolationBinding } from './binding/interpolation-binding';\nimport { LetBinding } from './binding/let-binding';\nimport { Ref } from './binding/ref';\nimport {\n  customAttributeKey,\n  customElementKey,\n  ICallBindingInstruction,\n  IElementHydrationOptions,\n  IHydrateAttributeInstruction,\n  IHydrateElementInstruction,\n  IHydrateLetElementInstruction,\n  IHydrateTemplateController,\n  IInterpolationInstruction,\n  IIteratorBindingInstruction,\n  InstructionTypeName,\n  IPropertyBindingInstruction,\n  IRefBindingInstruction,\n  ISetPropertyInstruction,\n  TargetedInstructionType,\n  TemplateDefinition,\n  TemplatePartDefinitions\n} from './definitions';\nimport { IDOM, INode } from './dom';\nimport { BindingMode, LifecycleFlags } from './flags';\nimport {\n  IBinding,\n  IComponent,\n  IRenderable,\n  IRenderContext,\n} from './lifecycle';\nimport { IObserverLocator } from './observation/observer-locator';\nimport {\n  IInstructionRenderer,\n  IInstructionTypeClassifier,\n  IRenderer,\n  IRenderingEngine\n} from './rendering-engine';\nimport { ICustomAttribute } from './resources/custom-attribute';\nimport { ICustomElement } from './resources/custom-element';\n\nconst slice = Array.prototype.slice;\n\ntype DecoratableInstructionRenderer<TType extends string, TProto, TClass> = Class<TProto & Partial<IInstructionTypeClassifier<TType> & Pick<IInstructionRenderer, 'render'>>, TClass> & Partial<IRegistry>;\ntype DecoratedInstructionRenderer<TType extends string, TProto, TClass> =  Class<TProto & IInstructionTypeClassifier<TType> & Pick<IInstructionRenderer, 'render'>, TClass> & IRegistry;\n\ntype InstructionRendererDecorator<TType extends string> = <TProto, TClass>(target: DecoratableInstructionRenderer<TType, TProto, TClass>) => DecoratedInstructionRenderer<TType, TProto, TClass>;\n\nexport function instructionRenderer<TType extends string>(instructionType: TType): InstructionRendererDecorator<TType> {\n  return function decorator<TProto, TClass>(target: DecoratableInstructionRenderer<TType, TProto, TClass>): DecoratedInstructionRenderer<TType, TProto, TClass> {\n    // wrap the constructor to set the instructionType to the instance (for better performance than when set on the prototype)\n    const decoratedTarget = function(...args: unknown[]): TProto {\n      const instance = new target(...args);\n      instance.instructionType = instructionType;\n      return instance;\n    } as unknown as DecoratedInstructionRenderer<TType, TProto, TClass>;\n    // make sure we register the decorated constructor with DI\n    decoratedTarget.register = function register(container: IContainer): IResolver {\n      return Registration.singleton(IInstructionRenderer, decoratedTarget).register(container, IInstructionRenderer);\n    };\n    // copy over any static properties such as inject (set by preceding decorators)\n    // also copy the name, to be less confusing to users (so they can still use constructor.name for whatever reason)\n    // the length (number of ctor arguments) is copied for the same reason\n    const ownProperties = Object.getOwnPropertyDescriptors(target);\n    Object.keys(ownProperties).filter(prop => prop !== 'prototype').forEach(prop => {\n      Reflect.defineProperty(decoratedTarget, prop, ownProperties[prop]);\n    });\n    return decoratedTarget;\n  };\n}\n\n/* @internal */\nexport class Renderer implements IRenderer {\n  public static readonly inject: ReadonlyArray<InterfaceSymbol> = [all(IInstructionRenderer)];\n\n  public instructionRenderers: Record<InstructionTypeName, IInstructionRenderer>;\n\n  constructor(instructionRenderers: IInstructionRenderer[]) {\n    const record = this.instructionRenderers = {};\n    instructionRenderers.forEach(item => {\n      record[item.instructionType] = item;\n    });\n  }\n\n  public static register(container: IContainer): IResolver<IRenderer> {\n    return Registration.singleton(IRenderer, this).register(container);\n  }\n\n  public render(flags: LifecycleFlags, dom: IDOM, context: IRenderContext, renderable: IRenderable, targets: ArrayLike<INode>, definition: TemplateDefinition, host?: INode, parts?: TemplatePartDefinitions): void {\n    if (Tracer.enabled) { Tracer.enter('Renderer.render', slice.call(arguments)); }\n    const targetInstructions = definition.instructions;\n    const instructionRenderers = this.instructionRenderers;\n\n    if (targets.length !== targetInstructions.length) {\n      if (targets.length > targetInstructions.length) {\n        throw Reporter.error(30);\n      } else {\n        throw Reporter.error(31);\n      }\n    }\n    for (let i = 0, ii = targets.length; i < ii; ++i) {\n      const instructions = targetInstructions[i];\n      const target = targets[i];\n\n      for (let j = 0, jj = instructions.length; j < jj; ++j) {\n        const current = instructions[j];\n        instructionRenderers[current.type].render(flags, dom, context, renderable, target, current, parts);\n      }\n    }\n\n    if (host) {\n      const surrogateInstructions = definition.surrogates;\n\n      for (let i = 0, ii = surrogateInstructions.length; i < ii; ++i) {\n        const current = surrogateInstructions[i];\n        instructionRenderers[current.type].render(flags, dom, context, renderable, host, current, parts);\n      }\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\nexport function ensureExpression<TFrom>(parser: IExpressionParser, srcOrExpr: TFrom, bindingType: BindingType): Exclude<TFrom, string> {\n  if (typeof srcOrExpr === 'string') {\n    return parser.parse(srcOrExpr, bindingType) as unknown as Exclude<TFrom, string>;\n  }\n  return srcOrExpr as Exclude<TFrom, string>;\n}\n\nexport function addBinding(renderable: IRenderable, binding: IBinding): void {\n  if (Tracer.enabled) { Tracer.enter('addBinding', slice.call(arguments)); }\n  (binding as Writable<IBinding>).$prevBinding = renderable.$bindingTail;\n  (binding as Writable<IBinding>).$nextBinding = null;\n  if (renderable.$bindingTail === null) {\n    renderable.$bindingHead = binding;\n  } else {\n    (renderable.$bindingTail as Writable<IBinding>).$nextBinding = binding;\n  }\n  renderable.$bindingTail = binding;\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\nexport function addComponent(renderable: IRenderable, component: IComponent): void {\n  if (Tracer.enabled) { Tracer.enter('addComponent', slice.call(arguments)); }\n  (component as Writable<IComponent>).$prevComponent = renderable.$componentTail;\n  (component as Writable<IComponent>).$nextComponent = null;\n  if (renderable.$componentTail === null) {\n    renderable.$componentHead = component;\n  } else {\n    (renderable.$componentTail as Writable<IComponent>).$nextComponent = component;\n  }\n  renderable.$componentTail = component;\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n@instructionRenderer(TargetedInstructionType.setProperty)\n/** @internal */\nexport class SetPropertyRenderer implements IInstructionRenderer {\n  public static readonly register: IRegistry['register'];\n\n  public render(flags: LifecycleFlags, dom: IDOM, context: IRenderContext, renderable: IRenderable, target: object, instruction: ISetPropertyInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('SetPropertyRenderer.render', slice.call(arguments)); }\n    target[instruction.to] = instruction.value;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@instructionRenderer(TargetedInstructionType.hydrateElement)\n/** @internal */\nexport class CustomElementRenderer implements IInstructionRenderer {\n  public static readonly register: IRegistry['register'];\n\n  public render(flags: LifecycleFlags, dom: IDOM, context: IRenderContext, renderable: IRenderable, target: INode, instruction: IHydrateElementInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('CustomElementRenderer.render', slice.call(arguments)); }\n    const operation = context.beginComponentOperation(renderable, target, instruction, null, null, target, true);\n    const component = context.get<ICustomElement>(customElementKey(instruction.res));\n    const instructionRenderers = context.get(IRenderer).instructionRenderers;\n    const childInstructions = instruction.instructions;\n\n    component.$hydrate(flags, context, target, instruction as IElementHydrationOptions);\n\n    for (let i = 0, ii = childInstructions.length; i < ii; ++i) {\n      const current = childInstructions[i];\n      instructionRenderers[current.type].render(flags, dom, context, renderable, component, current);\n    }\n\n    addComponent(renderable, component);\n\n    operation.dispose();\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@instructionRenderer(TargetedInstructionType.hydrateAttribute)\n/** @internal */\nexport class CustomAttributeRenderer implements IInstructionRenderer {\n  public static readonly register: IRegistry['register'];\n\n  public render(flags: LifecycleFlags, dom: IDOM, context: IRenderContext, renderable: IRenderable, target: INode, instruction: IHydrateAttributeInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('CustomAttributeRenderer.render', slice.call(arguments)); }\n    const operation = context.beginComponentOperation(renderable, target, instruction);\n    const component = context.get<ICustomAttribute>(customAttributeKey(instruction.res));\n    const instructionRenderers = context.get(IRenderer).instructionRenderers;\n    const childInstructions = instruction.instructions;\n\n    component.$hydrate(flags, context);\n\n    for (let i = 0, ii = childInstructions.length; i < ii; ++i) {\n      const current = childInstructions[i];\n      instructionRenderers[current.type].render(flags, dom, context, renderable, component, current);\n    }\n\n    addComponent(renderable, component);\n\n    operation.dispose();\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@instructionRenderer(TargetedInstructionType.hydrateTemplateController)\n/** @internal */\nexport class TemplateControllerRenderer implements IInstructionRenderer {\n  public static readonly inject: ReadonlyArray<InterfaceSymbol> = [IRenderingEngine];\n  public static readonly register: IRegistry['register'];\n\n  private readonly renderingEngine: IRenderingEngine;\n\n  constructor(renderingEngine: IRenderingEngine) {\n    this.renderingEngine = renderingEngine;\n  }\n\n  public render(flags: LifecycleFlags, dom: IDOM, context: IRenderContext, renderable: IRenderable, target: INode, instruction: IHydrateTemplateController, parts?: TemplatePartDefinitions): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateControllerRenderer.render', slice.call(arguments)); }\n    const factory = this.renderingEngine.getViewFactory(dom, instruction.def, context);\n    const operation = context.beginComponentOperation(renderable, target, instruction, factory, parts, dom.convertToRenderLocation(target), false);\n    const component = context.get<ICustomAttribute>(customAttributeKey(instruction.res));\n    const instructionRenderers = context.get(IRenderer).instructionRenderers;\n    const childInstructions = instruction.instructions;\n\n    component.$hydrate(flags, context);\n\n    if (instruction.link) {\n      (component as ICustomAttribute & { link(componentTail: IComponent): void}).link(renderable.$componentTail);\n    }\n\n    for (let i = 0, ii = childInstructions.length; i < ii; ++i) {\n      const current = childInstructions[i];\n      instructionRenderers[current.type].render(flags, dom, context, renderable, component, current);\n    }\n\n    addComponent(renderable, component);\n\n    operation.dispose();\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@instructionRenderer(TargetedInstructionType.hydrateLetElement)\n/** @internal */\nexport class LetElementRenderer implements IInstructionRenderer {\n  public static readonly inject: ReadonlyArray<InterfaceSymbol> = [IExpressionParser, IObserverLocator];\n  public static readonly register: IRegistry['register'];\n\n  private readonly parser: IExpressionParser;\n  private readonly observerLocator: IObserverLocator;\n\n  constructor(parser: IExpressionParser, observerLocator: IObserverLocator) {\n    this.parser = parser;\n    this.observerLocator = observerLocator;\n  }\n\n  public render(flags: LifecycleFlags, dom: IDOM, context: IRenderContext, renderable: IRenderable, target: INode, instruction: IHydrateLetElementInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('LetElementRenderer.render', slice.call(arguments)); }\n    dom.remove(target);\n    const childInstructions = instruction.instructions;\n    const toViewModel = instruction.toViewModel;\n    for (let i = 0, ii = childInstructions.length; i < ii; ++i) {\n      const childInstruction = childInstructions[i];\n      const expr = ensureExpression(this.parser, childInstruction.from, BindingType.IsPropertyCommand);\n      const binding = new LetBinding(expr, childInstruction.to, this.observerLocator, context, toViewModel);\n      addBinding(renderable, binding);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@instructionRenderer(TargetedInstructionType.callBinding)\n/** @internal */\nexport class CallBindingRenderer implements IInstructionRenderer {\n  public static readonly inject: ReadonlyArray<InterfaceSymbol> = [IExpressionParser, IObserverLocator];\n  public static readonly register: IRegistry['register'];\n\n  private readonly parser: IExpressionParser;\n  private readonly observerLocator: IObserverLocator;\n\n  constructor(parser: IExpressionParser, observerLocator: IObserverLocator) {\n    this.parser = parser;\n    this.observerLocator = observerLocator;\n  }\n\n  public render(flags: LifecycleFlags, dom: IDOM, context: IRenderContext, renderable: IRenderable, target: INode, instruction: ICallBindingInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('CallBindingRenderer.render', slice.call(arguments)); }\n    const expr = ensureExpression(this.parser, instruction.from, BindingType.CallCommand);\n    const binding = new Call(expr, target, instruction.to, this.observerLocator, context);\n    addBinding(renderable, binding);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@instructionRenderer(TargetedInstructionType.refBinding)\n/** @internal */\nexport class RefBindingRenderer implements IInstructionRenderer {\n  public static readonly inject: ReadonlyArray<InterfaceSymbol> = [IExpressionParser];\n  public static readonly register: IRegistry['register'];\n\n  private readonly parser: IExpressionParser;\n\n  constructor(parser: IExpressionParser) {\n    this.parser = parser;\n  }\n\n  public render(flags: LifecycleFlags, dom: IDOM, context: IRenderContext, renderable: IRenderable, target: INode, instruction: IRefBindingInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('RefBindingRenderer.render', slice.call(arguments)); }\n    const expr = ensureExpression(this.parser, instruction.from, BindingType.IsRef);\n    const binding = new Ref(expr, target, context);\n    addBinding(renderable, binding);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@instructionRenderer(TargetedInstructionType.interpolation)\n/** @internal */\nexport class InterpolationBindingRenderer implements IInstructionRenderer {\n  public static readonly inject: ReadonlyArray<InterfaceSymbol> = [IExpressionParser, IObserverLocator];\n  public static readonly register: IRegistry['register'];\n\n  private readonly parser: IExpressionParser;\n  private readonly observerLocator: IObserverLocator;\n\n  constructor(parser: IExpressionParser, observerLocator: IObserverLocator) {\n    this.parser = parser;\n    this.observerLocator = observerLocator;\n  }\n\n  public render(flags: LifecycleFlags, dom: IDOM, context: IRenderContext, renderable: IRenderable, target: INode, instruction: IInterpolationInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('InterpolationBindingRenderer.render', slice.call(arguments)); }\n    let binding: MultiInterpolationBinding | InterpolationBinding;\n    const expr = ensureExpression(this.parser, instruction.from, BindingType.Interpolation);\n    if (expr.isMulti) {\n      binding = new MultiInterpolationBinding(this.observerLocator, expr, target, instruction.to, BindingMode.toView, context);\n    } else {\n      binding = new InterpolationBinding(expr.firstExpression, expr, target, instruction.to, BindingMode.toView, this.observerLocator, context, true);\n    }\n    addBinding(renderable, binding);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@instructionRenderer(TargetedInstructionType.propertyBinding)\n/** @internal */\nexport class PropertyBindingRenderer implements IInstructionRenderer {\n  public static readonly inject: ReadonlyArray<InterfaceSymbol> = [IExpressionParser, IObserverLocator];\n  public static readonly register: IRegistry['register'];\n\n  private readonly parser: IExpressionParser;\n  private readonly observerLocator: IObserverLocator;\n\n  constructor(parser: IExpressionParser, observerLocator: IObserverLocator) {\n    this.parser = parser;\n    this.observerLocator = observerLocator;\n  }\n\n  public render(flags: LifecycleFlags, dom: IDOM, context: IRenderContext, renderable: IRenderable, target: INode, instruction: IPropertyBindingInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('PropertyBindingRenderer.render', slice.call(arguments)); }\n    const expr = ensureExpression(this.parser, instruction.from, BindingType.IsPropertyCommand | instruction.mode);\n    const binding = new Binding(expr, target, instruction.to, instruction.mode, this.observerLocator, context);\n    addBinding(renderable, binding);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@instructionRenderer(TargetedInstructionType.iteratorBinding)\n/** @internal */\nexport class IteratorBindingRenderer implements IInstructionRenderer {\n  public static readonly inject: ReadonlyArray<InterfaceSymbol> = [IExpressionParser, IObserverLocator];\n  public static readonly register: IRegistry['register'];\n\n  private readonly parser: IExpressionParser;\n  private readonly observerLocator: IObserverLocator;\n\n  constructor(parser: IExpressionParser, observerLocator: IObserverLocator) {\n    this.parser = parser;\n    this.observerLocator = observerLocator;\n  }\n\n  public render(flags: LifecycleFlags, dom: IDOM, context: IRenderContext, renderable: IRenderable, target: INode, instruction: IIteratorBindingInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('IteratorBindingRenderer.render', slice.call(arguments)); }\n    const expr = ensureExpression(this.parser, instruction.from, BindingType.ForCommand);\n    const binding = new Binding(expr, target, instruction.to, BindingMode.toView, this.observerLocator, context);\n    addBinding(renderable, binding);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n","import { DI, IContainer, IRegistry } from '@aurelia/kernel';\nimport { Lifecycle } from './lifecycle';\nimport { ObserverLocator } from './observation/observer-locator';\nimport {\n  CallBindingRenderer,\n  CustomAttributeRenderer,\n  CustomElementRenderer,\n  InterpolationBindingRenderer,\n  IteratorBindingRenderer,\n  LetElementRenderer,\n  PropertyBindingRenderer,\n  RefBindingRenderer,\n  Renderer,\n  SetPropertyRenderer,\n  TemplateControllerRenderer\n} from './renderer';\nimport { FromViewBindingBehavior, OneTimeBindingBehavior, ToViewBindingBehavior, TwoWayBindingBehavior } from './resources/binding-behaviors/binding-mode';\nimport { DebounceBindingBehavior } from './resources/binding-behaviors/debounce';\nimport { SignalBindingBehavior } from './resources/binding-behaviors/signals';\nimport { ThrottleBindingBehavior } from './resources/binding-behaviors/throttle';\nimport { Else, If } from './resources/custom-attributes/if';\nimport { Repeat } from './resources/custom-attributes/repeat';\nimport { Replaceable } from './resources/custom-attributes/replaceable';\nimport { With } from './resources/custom-attributes/with';\nimport { SanitizeValueConverter } from './resources/value-converters/sanitize';\n\nexport const IObserverLocatorRegistration = ObserverLocator as IRegistry;\nexport const ILifecycleRegistration = Lifecycle as IRegistry;\nexport const IRendererRegistration = Renderer as IRegistry;\n\n/**\n * Default implementations for the following interfaces:\n * - `IObserverLocator`\n * - `ILifecycle`\n * - `IRenderer`\n */\nexport const DefaultComponents = [\n  IObserverLocatorRegistration,\n  ILifecycleRegistration,\n  IRendererRegistration\n];\n\nexport const IfRegistration = If as IRegistry;\nexport const ElseRegistration = Else as IRegistry;\nexport const RepeatRegistration = Repeat as IRegistry;\nexport const ReplaceableRegistration = Replaceable as IRegistry;\nexport const WithRegistration = With as IRegistry;\nexport const SanitizeValueConverterRegistration = SanitizeValueConverter as IRegistry;\nexport const DebounceBindingBehaviorRegistration = DebounceBindingBehavior as IRegistry;\nexport const OneTimeBindingBehaviorRegistration = OneTimeBindingBehavior as IRegistry;\nexport const ToViewBindingBehaviorRegistration = ToViewBindingBehavior as IRegistry;\nexport const FromViewBindingBehaviorRegistration = FromViewBindingBehavior as IRegistry;\nexport const SignalBindingBehaviorRegistration = SignalBindingBehavior as IRegistry;\nexport const ThrottleBindingBehaviorRegistration = ThrottleBindingBehavior as IRegistry;\nexport const TwoWayBindingBehaviorRegistration = TwoWayBindingBehavior as IRegistry;\n\n/**\n * Default resources:\n * - Template controllers (`if`/`else`, `repeat`, `replaceable`, `with`)\n * - Value Converters (`sanitize`)\n * - Binding Behaviors (`oneTime`, `toView`, `fromView`, `twoWay`, `signal`, `debounce`, `throttle`)\n */\nexport const DefaultResources = [\n  IfRegistration,\n  ElseRegistration,\n  RepeatRegistration,\n  ReplaceableRegistration,\n  WithRegistration,\n  SanitizeValueConverterRegistration,\n  DebounceBindingBehaviorRegistration,\n  OneTimeBindingBehaviorRegistration,\n  ToViewBindingBehaviorRegistration,\n  FromViewBindingBehaviorRegistration,\n  SignalBindingBehaviorRegistration,\n  ThrottleBindingBehaviorRegistration,\n  TwoWayBindingBehaviorRegistration\n];\n\nexport const CallBindingRendererRegistration = CallBindingRenderer as IRegistry;\nexport const CustomAttributeRendererRegistration = CustomAttributeRenderer as IRegistry;\nexport const CustomElementRendererRegistration = CustomElementRenderer as IRegistry;\nexport const InterpolationBindingRendererRegistration = InterpolationBindingRenderer as IRegistry;\nexport const IteratorBindingRendererRegistration = IteratorBindingRenderer as IRegistry;\nexport const LetElementRendererRegistration = LetElementRenderer as IRegistry;\nexport const PropertyBindingRendererRegistration = PropertyBindingRenderer as IRegistry;\nexport const RefBindingRendererRegistration = RefBindingRenderer as IRegistry;\nexport const SetPropertyRendererRegistration = SetPropertyRenderer as IRegistry;\nexport const TemplateControllerRendererRegistration = TemplateControllerRenderer as IRegistry;\n\n/**\n * Default renderers for:\n * - PropertyBinding: `bind`, `one-time`, `to-view`, `from-view`, `two-way`\n * - IteratorBinding: `for`\n * - CallBinding: `call`\n * - RefBinding: `ref`\n * - InterpolationBinding: `${}`\n * - SetProperty\n * - `customElement` hydration\n * - `customAttribute` hydration\n * - `templateController` hydration\n * - `let` element hydration\n */\nexport const DefaultRenderers = [\n  PropertyBindingRendererRegistration,\n  IteratorBindingRendererRegistration,\n  CallBindingRendererRegistration,\n  RefBindingRendererRegistration,\n  InterpolationBindingRendererRegistration,\n  SetPropertyRendererRegistration,\n  CustomElementRendererRegistration,\n  CustomAttributeRendererRegistration,\n  TemplateControllerRendererRegistration,\n  LetElementRendererRegistration\n];\n\n/**\n * A DI configuration object containing environment/runtime-agnostic registrations:\n * - `DefaultComponents`\n * - `DefaultResources`\n * - `DefaultRenderers`\n */\nexport const RuntimeBasicConfiguration = {\n  /**\n   * Apply this configuration to the provided container.\n   */\n  register(container: IContainer): IContainer {\n    return container.register(\n      ...DefaultComponents,\n      ...DefaultResources,\n      ...DefaultRenderers\n    );\n  },\n  /**\n   * Create a new container with this configuration applied to it.\n   */\n  createContainer(): IContainer {\n    return this.register(DI.createContainer());\n  }\n};\n","import { IForOfStatement, IInterpolationExpression, IsBindingBehavior } from './ast';\nimport {\n  ICallBindingInstruction,\n  IHydrateAttributeInstruction,\n  IHydrateElementInstruction,\n  IHydrateLetElementInstruction,\n  IHydrateTemplateController,\n  IInterpolationInstruction,\n  IIteratorBindingInstruction,\n  ILetBindingInstruction,\n  IPropertyBindingInstruction,\n  IRefBindingInstruction,\n  ISetPropertyInstruction,\n  ITargetedInstruction,\n  ITemplateDefinition,\n  TargetedInstructionType\n} from './definitions';\nimport { BindingMode } from './flags';\n\nexport class InterpolationInstruction implements IInterpolationInstruction {\n  public type: TargetedInstructionType.interpolation;\n\n  public from: string | IInterpolationExpression;\n  public to: string;\n\n  constructor(from: string | IInterpolationExpression, to: string) {\n    this.type = TargetedInstructionType.interpolation;\n\n    this.from = from;\n    this.to = to;\n  }\n}\n\nexport class OneTimeBindingInstruction implements IPropertyBindingInstruction {\n  public type: TargetedInstructionType.propertyBinding;\n\n  public from: string | IsBindingBehavior;\n  public mode: BindingMode.oneTime;\n  public oneTime: true;\n  public to: string;\n\n  constructor(from: string | IsBindingBehavior, to: string) {\n    this.type = TargetedInstructionType.propertyBinding;\n\n    this.from = from;\n    this.mode = BindingMode.oneTime;\n    this.oneTime = true;\n    this.to = to;\n  }\n}\n\nexport class ToViewBindingInstruction implements IPropertyBindingInstruction {\n  public type: TargetedInstructionType.propertyBinding;\n\n  public from: string | IsBindingBehavior;\n  public mode: BindingMode.toView;\n  public oneTime: false;\n  public to: string;\n\n  constructor(from: string | IsBindingBehavior, to: string) {\n    this.type = TargetedInstructionType.propertyBinding;\n\n    this.from = from;\n    this.mode = BindingMode.toView;\n    this.oneTime = false;\n    this.to = to;\n  }\n}\n\nexport class FromViewBindingInstruction implements IPropertyBindingInstruction {\n  public type: TargetedInstructionType.propertyBinding;\n\n  public from: string | IsBindingBehavior;\n  public mode: BindingMode.fromView;\n  public oneTime: false;\n  public to: string;\n\n  constructor(from: string | IsBindingBehavior, to: string) {\n    this.type = TargetedInstructionType.propertyBinding;\n\n    this.from = from;\n    this.mode = BindingMode.fromView;\n    this.oneTime = false;\n    this.to = to;\n  }\n}\n\nexport class TwoWayBindingInstruction implements IPropertyBindingInstruction {\n  public type: TargetedInstructionType.propertyBinding = TargetedInstructionType.propertyBinding;\n\n  public from: string | IsBindingBehavior;\n  public mode: BindingMode.twoWay;\n  public oneTime: false;\n  public to: string;\n\n  constructor(from: string | IsBindingBehavior, to: string) {\n    this.type = TargetedInstructionType.propertyBinding;\n\n    this.from = from;\n    this.mode = BindingMode.twoWay;\n    this.oneTime = false;\n    this.to = to;\n  }\n}\n\nexport class IteratorBindingInstruction implements IIteratorBindingInstruction {\n  public type: TargetedInstructionType.iteratorBinding;\n\n  public from: string | IForOfStatement;\n  public to: string;\n\n  constructor(from: string | IForOfStatement, to: string) {\n    this.type = TargetedInstructionType.iteratorBinding;\n\n    this.from = from;\n    this.to = to;\n  }\n}\n\nexport class CallBindingInstruction implements ICallBindingInstruction {\n  public type: TargetedInstructionType.callBinding;\n\n  public from: string | IsBindingBehavior;\n  public to: string;\n\n  constructor(from: string | IsBindingBehavior, to: string) {\n    this.type = TargetedInstructionType.callBinding;\n\n    this.from = from;\n    this.to = to;\n  }\n}\n\nexport class RefBindingInstruction implements IRefBindingInstruction {\n  public type: TargetedInstructionType.refBinding;\n\n  public from: string | IsBindingBehavior;\n\n  constructor(from: string | IsBindingBehavior) {\n    this.type = TargetedInstructionType.refBinding;\n\n    this.from = from;\n  }\n}\n\nexport class SetPropertyInstruction implements ISetPropertyInstruction {\n  public type: TargetedInstructionType.setProperty;\n\n  public to: string;\n  public value: unknown;\n\n  constructor(value: unknown, to: string) {\n    this.type = TargetedInstructionType.setProperty;\n\n    this.to = to;\n    this.value = value;\n  }\n}\n\nexport class HydrateElementInstruction implements IHydrateElementInstruction {\n  public type: TargetedInstructionType.hydrateElement;\n\n  public instructions: ITargetedInstruction[];\n  public parts?: Record<string, ITemplateDefinition>;\n  public res: string;\n\n  constructor(res: string, instructions: ITargetedInstruction[], parts?: Record<string, ITemplateDefinition>) {\n    this.type = TargetedInstructionType.hydrateElement;\n\n    this.instructions = instructions;\n    this.parts = parts;\n    this.res = res;\n  }\n}\n\nexport class HydrateAttributeInstruction implements IHydrateAttributeInstruction {\n  public type: TargetedInstructionType.hydrateAttribute;\n\n  public instructions: ITargetedInstruction[];\n  public res: string;\n\n  constructor(res: string, instructions: ITargetedInstruction[]) {\n    this.type = TargetedInstructionType.hydrateAttribute;\n\n    this.instructions = instructions;\n    this.res = res;\n  }\n}\n\nexport class HydrateTemplateController implements IHydrateTemplateController {\n  public type: TargetedInstructionType.hydrateTemplateController;\n\n  public def: ITemplateDefinition;\n  public instructions: ITargetedInstruction[];\n  public link?: boolean;\n  public res: string;\n\n  constructor(def: ITemplateDefinition, res: string, instructions: ITargetedInstruction[], link?: boolean) {\n    this.type = TargetedInstructionType.hydrateTemplateController;\n\n    this.def = def;\n    this.instructions = instructions;\n    this.link = link;\n    this.res = res;\n  }\n}\n\nexport class LetElementInstruction implements IHydrateLetElementInstruction {\n  public type: TargetedInstructionType.hydrateLetElement;\n\n  public instructions: ILetBindingInstruction[];\n  public toViewModel: boolean;\n\n  constructor(instructions: ILetBindingInstruction[], toViewModel: boolean) {\n    this.type = TargetedInstructionType.hydrateLetElement;\n\n    this.instructions = instructions;\n    this.toViewModel = toViewModel;\n  }\n}\n\nexport class LetBindingInstruction implements ILetBindingInstruction {\n  public type: TargetedInstructionType.letBinding;\n\n  public from: string | IsBindingBehavior | IInterpolationExpression;\n  public to: string;\n\n  constructor(from: string | IsBindingBehavior | IInterpolationExpression, to: string) {\n    this.type = TargetedInstructionType.letBinding;\n\n    this.from = from;\n    this.to = to;\n  }\n}\n"],"names":["BindingMode","State","Hooks","LifecycleFlags","ExpressionKind","DelegationStrategy","MutationKind","CollectionKind","ProxyObserver","Reporter","SetterObserver","DI","Registration","register","keyFrom","isType","define","RuntimeError","PLATFORM","Binding","BindingType","toView","oneTime","InterpolationBinding","LetBinding","dispose","flush","CollectionLengthObserver","ArrayObserver","proto","native","methods","observe","descriptorProps","def","MapObserver","$clear","$delete","SetObserver","GetterObserver","CustomSetterObserver","toStringTag","DirtyCheckProperty","noop","SelfObserver","fromView","TargetedInstructionType","Profiler","enter","leave","ViewCompileFlags","RuntimeCompilationResources","IContainer","all","tslib_1.__decorate"],"mappings":"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"}