{"version":3,"file":"index.umd.js","sources":["../../../node_modules/tslib/tslib.es6.js","../src/observation.ts","../src/lifecycle.ts","../src/binding/binding-behavior.ts","../src/dom.ts","../src/binding/subscriber-collection.ts","../src/binding/target-observer.ts","../src/binding/target-accessors.ts","../src/binding/resources/attr-binding-behavior.ts","../src/binding/binding-mode.ts","../src/binding/resources/binding-mode-behaviors.ts","../src/binding/property-observer.ts","../src/binding/property-observation.ts","../src/binding/binding-context.ts","../src/binding/signaler.ts","../src/binding/value-converter.ts","../src/binding/ast.ts","../src/binding/connectable.ts","../src/binding/binding.ts","../src/binding/resources/debounce-binding-behavior.ts","../src/binding/resources/sanitize.ts","../src/binding/event-manager.ts","../src/binding/resources/self-binding-behavior.ts","../src/binding/resources/signals.ts","../src/binding/resources/throttle-binding-behavior.ts","../src/binding/collection-observer.ts","../src/binding/array-observer.ts","../src/binding/computed-observer.ts","../src/binding/dirty-checker.ts","../src/binding/element-observation.ts","../src/binding/map-observer.ts","../src/binding/set-observer.ts","../src/binding/svg-analyzer.ts","../src/binding/observer-locator.ts","../src/binding/resources/update-trigger-binding-behavior.ts","../src/binding/call.ts","../src/binding/expression-parser.ts","../src/binding/interpolation-binding.ts","../src/binding/let-binding.ts","../src/binding/listener.ts","../src/binding/ref.ts","../src/definitions.ts","../src/templating/bindable.ts","../src/templating/create-element.ts","../src/templating/lifecycle-attach.ts","../src/templating/lifecycle-bind.ts","../src/templating/view.ts","../src/templating/lifecycle-render.ts","../src/templating/custom-element.ts","../src/templating/resources/compose.ts","../src/templating/custom-attribute.ts","../src/templating/resources/if.ts","../src/templating/resources/repeat.ts","../src/templating/resources/replaceable.ts","../src/templating/resources/with.ts","../src/aurelia.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { IDisposable, IIndexable } from '@aurelia/kernel';\nimport { ILifecycle } from './lifecycle';\n\nexport enum LifecycleFlags {\n  none                   = 0b0000_00000000000000_000_00,\n  mustEvaluate           = 0b0001_00000000000000_000_00,\n  mutation               = 0b0000_00000000000000_000_11,\n  isCollectionMutation   = 0b0000_00000000000000_000_01,\n  isInstanceMutation     = 0b0000_00000000000000_000_10,\n  update                 = 0b0000_00000000000000_111_00,\n  updateTargetObserver   = 0b0000_00000000000000_001_00,\n  updateTargetInstance   = 0b0000_00000000000000_010_00,\n  updateSourceExpression = 0b0000_00000000000000_100_00,\n  from                   = 0b0000_11111111111111_000_00,\n  fromFlush              = 0b0000_00000000000011_000_00,\n  fromAsyncFlush         = 0b0000_00000000000001_000_00,\n  fromSyncFlush          = 0b0000_00000000000010_000_00,\n  fromStartTask          = 0b0000_00000000000100_000_00,\n  fromStopTask           = 0b0000_00000000001000_000_00,\n  fromBind               = 0b0000_00000000010000_000_00,\n  fromUnbind             = 0b0000_00000000100000_000_00,\n  fromAttach             = 0b0000_00000001000000_000_00,\n  fromDetach             = 0b0000_00000010000000_000_00,\n  fromCache              = 0b0000_00000100000000_000_00,\n  fromCreate             = 0b0000_00001000000000_000_00,\n  fromDOMEvent           = 0b0000_00010000000000_000_00,\n  fromObserverSetter     = 0b0000_00100000000000_000_00,\n  fromBindableHandler    = 0b0000_01000000000000_000_00,\n  fromLifecycleTask      = 0b0000_10000000000000_000_00,\n  parentUnmountQueued    = 0b0010_00000000000000_000_00,\n  // this flag is for the synchronous flush before detach (no point in updating the\n  // DOM if it's about to be detached)\n  doNotUpdateDOM         = 0b0100_00000000000000_000_00,\n}\n\n/*@internal*/\nexport const enum SubscriberFlags {\n  None            = 0,\n  Subscriber0     = 0b0001,\n  Subscriber1     = 0b0010,\n  Subscriber2     = 0b0100,\n  SubscribersRest = 0b1000,\n  Any             = 0b1111,\n}\n\n/**\n * Describes a type that tracks changes and can flush those changes in some way\n */\nexport interface IChangeTracker {\n  $nextFlush?: IChangeTracker;\n  hasChanges?: boolean;\n  flush(flags: LifecycleFlags): void;\n}\n\n/**\n * Basic interface to normalize getting/setting a value of any property on any object\n */\nexport interface IAccessor<TValue = any> {\n  getValue(): TValue;\n  setValue(newValue: TValue, flags: LifecycleFlags): void;\n}\n\n/**\n * Describes a target observer for to-view bindings (in other words, an observer without the observation).\n */\nexport interface IBindingTargetAccessor<\n  TObj = any,\n  TProp = keyof TObj,\n  TValue = any>\n  extends IDisposable,\n          IAccessor<TValue>,\n          IPropertyChangeTracker<TObj, TProp> { }\n\n/**\n * Describes a target observer for from-view or two-way bindings.\n */\nexport interface IBindingTargetObserver<\n  TObj = any,\n  TProp = keyof TObj,\n  TValue = any>\n  extends IBindingTargetAccessor<TObj, TProp, TValue>,\n          ISubscribable<MutationKind.instance>,\n          ISubscriberCollection<MutationKind.instance> {\n\n  bind?(flags: LifecycleFlags): void;\n  unbind?(flags: LifecycleFlags): void;\n}\n\nexport type AccessorOrObserver = IBindingTargetAccessor | IBindingTargetObserver;\n\n\n/**\n * An array of indices, where the index of an element represents the index to map FROM, and the numeric value of the element itself represents the index to map TO\n *\n * The deletedItems property contains the items (in case of an array) or keys (in case of map or set) that have been deleted.\n */\nexport type IndexMap = number[] & {\n  deletedItems?: any[];\n};\n\n/**\n * Mostly just a marker enum to help with typings (specifically to reduce duplication)\n */\nexport enum MutationKind {\n  instance   = 0b01,\n  collection = 0b10\n}\n\n/**\n * Describes a type that specifically tracks changes in an object property, or simply something that can have a getter and/or setter\n */\nexport interface IPropertyChangeTracker<TObj extends Object, TProp = keyof TObj, TValue = any> {\n  obj: TObj;\n  propertyKey?: TProp;\n  currentValue?: TValue;\n}\n\n/**\n * Describes a type that specifically tracks changes in a collection (map, set or array)\n */\nexport interface ICollectionChangeTracker<T extends Collection> extends IChangeTracker {\n  collection: T;\n  indexMap: IndexMap;\n  resetIndexMap(): void;\n}\n\n/**\n * Represents a (subscriber) function that can be called by a PropertyChangeNotifier\n */\nexport type IPropertyChangeHandler<TValue = any> = (newValue: TValue, previousValue: TValue, flags: LifecycleFlags) => void;\n/**\n * Represents a (observer) function that can notify subscribers of mutations on a property\n */\nexport interface IPropertyChangeNotifier extends IPropertyChangeHandler {}\n\n/**\n * Describes a (subscriber) type that has a function conforming to the IPropertyChangeHandler interface\n */\nexport interface IPropertySubscriber<TValue = any> { handleChange(newValue: TValue, previousValue: TValue, flags: LifecycleFlags): void; }\n\n/**\n * Represents a (subscriber) function that can be called by a CollectionChangeNotifier\n */\nexport type ICollectionChangeHandler = (origin: string, args: IArguments | null, flags?: LifecycleFlags) => void;\n/**\n * Represents a (observer) function that can notify subscribers of mutations in a collection\n */\nexport interface ICollectionChangeNotifier extends ICollectionChangeHandler {}\n\n/**\n * Represents a (subscriber) function that can be called by a BatchedCollectionChangeNotifier\n */\nexport type IBatchedCollectionChangeHandler = (indexMap: number[]) => void;\n/**\n * Represents a (observer) function that can notify subscribers of batched mutations in a collection\n */\nexport interface IBatchedCollectionChangeNotifier extends IBatchedCollectionChangeHandler {}\n\n/**\n * Describes a (subscriber) type that has a function conforming to the ICollectionChangeHandler interface\n */\nexport interface ICollectionSubscriber { handleChange(origin: string, args: IArguments | null, flags: LifecycleFlags): void; }\n/**\n * Describes a (subscriber) type that has a function conforming to the IBatchedCollectionChangeNotifier interface\n */\nexport interface IBatchedCollectionSubscriber { handleBatchedChange(indexMap: number[]): void; }\n\n/**\n * Either a property or collection subscriber\n */\nexport type Subscriber = ICollectionSubscriber | IPropertySubscriber;\n/**\n * Either a batched property or batched collection subscriber\n */\nexport type BatchedSubscriber = IBatchedCollectionSubscriber;\n\n/**\n * Helper type that translates from mutationKind enum to the correct subscriber interface\n */\nexport type MutationKindToSubscriber<T> =\n  T extends MutationKind.instance ? IPropertySubscriber :\n  T extends MutationKind.collection ? ICollectionSubscriber :\n  never;\n\n/**\n * Helper type that translates from mutationKind enum to the correct batched subscriber interface\n */\nexport type MutationKindToBatchedSubscriber<T> =\n  T extends MutationKind.collection ? IBatchedCollectionSubscriber :\n  never;\n\n/**\n * Helper type that translates from mutationKind enum to the correct notifier interface\n */\nexport type MutationKindToNotifier<T> =\n  T extends MutationKind.instance ? IPropertyChangeNotifier :\n  T extends MutationKind.collection ? ICollectionChangeNotifier :\n  never;\n\n/**\n * Helper type that translates from mutationKind enum to the correct batched notifier interface\n */\nexport type MutationKindToBatchedNotifier<T> =\n  T extends MutationKind.collection ? IBatchedCollectionChangeNotifier :\n  never;\n\nexport interface ISubscribable<T extends MutationKind> {\n  subscribe(subscriber: MutationKindToSubscriber<T>): void;\n  unsubscribe(subscriber: MutationKindToSubscriber<T>): void;\n}\n\n\n/**\n * A collection of property or collection subscribers\n */\nexport interface ISubscriberCollection<T extends MutationKind> extends ISubscribable<T> {\n  /*@internal*/_subscriberFlags?: SubscriberFlags;\n  /*@internal*/_subscriber0?: MutationKindToSubscriber<T>;\n  /*@internal*/_subscriber1?: MutationKindToSubscriber<T>;\n  /*@internal*/_subscriber2?: MutationKindToSubscriber<T>;\n  /*@internal*/_subscribersRest?: MutationKindToSubscriber<T>[];\n\n  callSubscribers: MutationKindToNotifier<T>;\n  hasSubscribers(): boolean;\n  hasSubscriber(subscriber: MutationKindToSubscriber<T>): boolean;\n  removeSubscriber(subscriber: MutationKindToSubscriber<T>): boolean;\n  addSubscriber(subscriber: MutationKindToSubscriber<T>): boolean;\n}\n\n/**\n * A collection of batched property or collection subscribers\n */\nexport interface IBatchedSubscriberCollection<T extends MutationKind> extends IBatchedSubscribable<T> {\n  /*@internal*/_batchedSubscriberFlags?: SubscriberFlags;\n  /*@internal*/_batchedSubscriber0?: MutationKindToBatchedSubscriber<T>;\n  /*@internal*/_batchedSubscriber1?: MutationKindToBatchedSubscriber<T>;\n  /*@internal*/_batchedSubscriber2?: MutationKindToBatchedSubscriber<T>;\n  /*@internal*/_batchedSubscribersRest?: MutationKindToBatchedSubscriber<T>[];\n\n  /*@internal*/lifecycle?: ILifecycle;\n  callBatchedSubscribers: MutationKindToBatchedNotifier<T>;\n\n  /*@internal*/flush(flags: LifecycleFlags): void;\n  hasBatchedSubscribers(): boolean;\n  hasBatchedSubscriber(subscriber: MutationKindToBatchedSubscriber<T>): boolean;\n  removeBatchedSubscriber(subscriber: MutationKindToBatchedSubscriber<T>): boolean;\n  addBatchedSubscriber(subscriber: MutationKindToBatchedSubscriber<T>): boolean;\n}\n\nexport interface IBatchedSubscribable<T extends MutationKind> {\n  subscribeBatched(subscriber: MutationKindToBatchedSubscriber<T>): void;\n  unsubscribeBatched(subscriber: MutationKindToBatchedSubscriber<T>): void;\n}\n\n/**\n * Describes a complete property observer with an accessor, change tracking fields, normal and batched subscribers\n */\nexport interface IPropertyObserver<TObj extends Object, TProp extends keyof TObj> extends\n  IDisposable,\n  IAccessor<TObj[TProp]>,\n  IPropertyChangeTracker<TObj, TProp>,\n  ISubscriberCollection<MutationKind.instance> {\n  /*@internal*/observing: boolean;\n}\n\n/**\n * An any-typed property observer\n */\nexport type PropertyObserver = IPropertyObserver<any, PropertyKey>;\n\n/**\n * A collection (array, set or map)\n */\nexport type Collection = any[] | Set<any> | Map<any, any>;\ninterface IObservedCollection {\n  $observer?: CollectionObserver;\n}\n\n/**\n * An array that is being observed for mutations\n */\nexport interface IObservedArray<T = any> extends IObservedCollection, Array<T> { }\n/**\n * A set that is being observed for mutations\n */\nexport interface IObservedSet<T = any> extends IObservedCollection, Set<T> { }\n/**\n * A map that is being observed for mutations\n */\nexport interface IObservedMap<K = any, V = any> extends IObservedCollection, Map<K, V> { }\n/**\n * A collection that is being observed for mutations\n */\nexport type ObservedCollection = IObservedArray | IObservedSet | IObservedMap;\n\nexport const enum CollectionKind {\n  indexed = 0b1000,\n  keyed   = 0b0100,\n  array   = 0b1001,\n  map     = 0b0110,\n  set     = 0b0111\n}\n\nexport type LengthPropertyName<T> =\n  T extends any[] ? 'length' :\n  T extends Set<any> ? 'size' :\n  T extends Map<any, any> ? 'size' :\n  never;\n\nexport type CollectionTypeToKind<T> =\n  T extends any[] ? CollectionKind.array | CollectionKind.indexed :\n  T extends Set<any> ? CollectionKind.set | CollectionKind.keyed :\n  T extends Map<any, any> ? CollectionKind.map | CollectionKind.keyed :\n  never;\n\nexport type CollectionKindToType<T> =\n  T extends CollectionKind.array ? any[] :\n  T extends CollectionKind.indexed ? any[] :\n  T extends CollectionKind.map ? Map<any, any> :\n  T extends CollectionKind.set ? Set<any> :\n  T extends CollectionKind.keyed ? Set<any> | Map<any, any> :\n  never;\n\nexport type ObservedCollectionKindToType<T> =\n  T extends CollectionKind.array ? IObservedArray :\n  T extends CollectionKind.indexed ? IObservedArray :\n  T extends CollectionKind.map ? IObservedMap :\n  T extends CollectionKind.set ? IObservedSet :\n  T extends CollectionKind.keyed ? IObservedSet | IObservedMap :\n  never;\n\n/**\n * An observer that tracks collection mutations and notifies subscribers (either directly or in batches)\n */\nexport interface ICollectionObserver<T extends CollectionKind> extends\n  IDisposable,\n  ICollectionChangeTracker<CollectionKindToType<T>>,\n  ISubscriberCollection<MutationKind.collection>,\n  IBatchedSubscriberCollection<MutationKind.collection> {\n    collection: ObservedCollectionKindToType<T>;\n    lengthPropertyName: LengthPropertyName<CollectionKindToType<T>>;\n    collectionKind: T;\n    lengthObserver: IBindingTargetObserver;\n    getLengthObserver(): IBindingTargetObserver;\n}\nexport type CollectionObserver = ICollectionObserver<CollectionKind>;\n\n\nexport interface IBindingContext {\n  [key: string]: unknown;\n\n  readonly $synthetic?: true;\n  readonly $observers?: ObserversLookup<IOverrideContext>;\n  getObservers?(): ObserversLookup<IOverrideContext>;\n}\n\nexport interface IOverrideContext {\n  [key: string]: unknown;\n\n  readonly $synthetic?: true;\n  readonly $observers?: ObserversLookup<IOverrideContext>;\n  readonly bindingContext: IBindingContext;\n  readonly parentOverrideContext: IOverrideContext | null;\n  getObservers(): ObserversLookup<IOverrideContext>;\n}\n\nexport interface IScope {\n  readonly bindingContext: IBindingContext;\n  readonly overrideContext: IOverrideContext;\n}\n\nexport interface IObserversLookup<TObj extends IIndexable = IIndexable, TKey extends keyof TObj =\nExclude<keyof TObj, '$synthetic' | '$observers' | 'bindingContext' | 'overrideContext' | 'parentOverrideContext'>> {\n\n}\n\nexport type ObserversLookup<TObj extends IIndexable = IIndexable, TKey extends keyof TObj =\n  Exclude<keyof TObj, '$synthetic' | '$observers' | 'bindingContext' | 'overrideContext' | 'parentOverrideContext'>> =\n  { [P in TKey]: PropertyObserver; } & { getOrCreate(obj: IBindingContext | IOverrideContext, key: string): PropertyObserver };\n\nexport type IObservable = IIndexable & {\n  readonly $synthetic?: false;\n  $observers?: Record<string, AccessorOrObserver>;\n};\n","import { DI, IContainer, IDisposable, Immutable, inject, InterfaceSymbol, IResolver, IServiceLocator, Omit, PLATFORM, Registration } from '@aurelia/kernel';\nimport { IConnectableBinding } from './binding/connectable';\nimport { ITargetedInstruction, TemplateDefinition, TemplatePartDefinitions } from './definitions';\nimport { IEncapsulationSource, INode, INodeSequence, IRenderLocation } from './dom';\nimport { IChangeTracker, IScope, LifecycleFlags } from './observation';\n\nexport const enum State {\n  none                  = 0b000000000000,\n  isBinding             = 0b000000000001,\n  isBound               = 0b000000000010,\n  isAttaching           = 0b000000000100,\n  isAttached            = 0b000000001000,\n  isMounted             = 0b000000010000,\n  isDetaching           = 0b000000100000,\n  isUnbinding           = 0b000001000000,\n  isCached              = 0b000010000000,\n  needsMount            = 0b000100000000\n}\n\nexport const enum Hooks {\n  none                   = 0b000000000001,\n  hasCreated             = 0b000000000010,\n  hasBinding             = 0b000000000100,\n  hasBound               = 0b000000001000,\n  hasAttaching           = 0b000000010000,\n  hasAttached            = 0b000000100000,\n  hasDetaching           = 0b000001000000,\n  hasDetached            = 0b000010000000,\n  hasUnbinding           = 0b000100000000,\n  hasUnbound             = 0b001000000000,\n  hasRender              = 0b010000000000,\n  hasCaching             = 0b100000000000\n}\n\nexport interface IHooks {\n  $hooks?: Hooks;\n}\n\nexport interface IState {\n  $state?: State;\n  $lifecycle?: ILifecycle;\n}\n\nexport interface IBindables {\n  /**\n   * The Bindings, Views, CustomElements, CustomAttributes and other bindable components that belong to this instance.\n   */\n  $bindableHead?: IBindScope;\n  $bindableTail?: IBindScope;\n}\n\nexport interface IAttachables {\n\n  /**\n   * The Views, CustomElements, CustomAttributes and other attachable components that belong to this instance.\n   */\n  $attachableHead?: IAttach;\n  $attachableTail?: IAttach;\n}\n\n/**\n * An object containing the necessary information to render something for display.\n */\nexport interface IRenderable extends IBindables, IAttachables, IState {\n\n  /**\n   * The (dependency) context of this instance.\n   *\n   * Contains any dependencies required by this instance or its children.\n   */\n  readonly $context: IRenderContext;\n\n  /**\n   * The nodes that represent the visible aspect of this instance.\n   *\n   * Typically this will be a sequence of `DOM` nodes contained in a `DocumentFragment`\n   */\n  readonly $nodes: INodeSequence;\n\n  /**\n   * The binding scope that the `$bindables` of this instance will be bound to.\n   *\n   * This includes the `BindingContext` which can be either a user-defined view model instance, or a synthetic view model instantiated by a `templateController`\n   */\n  readonly $scope: IScope;\n}\n\nexport const IRenderable = DI.createInterface<IRenderable>().noDefault();\n\nexport interface IRenderContext extends IServiceLocator {\n  createChild(): IRenderContext;\n  render(renderable: IRenderable, targets: ArrayLike<INode>, templateDefinition: TemplateDefinition, host?: INode, parts?: TemplatePartDefinitions): void;\n  beginComponentOperation(renderable: IRenderable, target: INode, instruction: Immutable<ITargetedInstruction>, factory?: IViewFactory, parts?: TemplatePartDefinitions, location?: IRenderLocation, locationIsContainer?: boolean): IDisposable;\n}\n\nexport interface IView extends IBindScope, IRenderable, IAttach, IMountable {\n  readonly cache: IViewCache;\n  readonly isFree: boolean;\n  readonly location: IRenderLocation;\n\n  hold(location: IRenderLocation, flags: LifecycleFlags): void;\n  release(flags: LifecycleFlags): boolean;\n\n  lockScope(scope: IScope): void;\n}\n\nexport interface IViewCache {\n  readonly isCaching: boolean;\n  setCacheSize(size: number | '*', doNotOverrideIfAlreadySet: boolean): void;\n  canReturnToCache(view: IView): boolean;\n  tryReturnToCache(view: IView): boolean;\n}\n\nexport interface IViewFactory extends IViewCache {\n  readonly name: string;\n  create(): IView;\n}\n\nexport const IViewFactory = DI.createInterface<IViewFactory>().noDefault();\n\nexport interface ILifecycleCreated extends IHooks, IState {\n  /**\n   * Called at the end of `$hydrate`.\n   *\n   * The following key properties are now assigned and initialized (see `IRenderable` for more detail):\n   * - `this.$bindables`\n   * - `this.$attachables`\n   * - `this.$scope` (null if this is a custom attribute, or contains the view model if this is a custom element)\n   * - `this.$nodes`\n   *\n   * @description\n   * This is the second and last \"hydrate\" lifecycle hook (after `render`). It happens only once per instance (contrary to bind/attach\n   * which can happen many times per instance), though it can happen many times per type (once for each instance)\n   *\n   * This hook is called right before the `$bind` lifecycle starts, making this the last opportunity\n   * for any high-level post processing on initialized properties.\n   */\n  created?(): void;\n}\n\nexport interface ILifecycleBinding extends IHooks, IState {\n  /**\n   * Called at the start of `$bind`, before this instance and its children (if any) are bound.\n   *\n   * - `this.$isBound` is false.\n   * - `this.$scope` is initialized.\n   *\n   * @param flags Contextual information about the lifecycle, such as what triggered it.\n   * Some uses for this hook:\n   * - `flags & LifecycleFlags.fromStartTask`: the Aurelia app is starting (this is the initial bind)\n   * - `flags & LifecycleFlags.fromBind`: this is a normal `$bind` lifecycle\n   * - `flags & LifecycleFlags.updateTargetInstance`: this `$bind` was triggered by some upstream observer and is not a real `$bind` lifecycle\n   * - `flags & LifecycleFlags.fromFlush` (only occurs in conjunction with updateTargetInstance): the update was queued to a `LinkedChangeList` which is now being flushed\n   *\n   * @description\n   * This is the first \"create\" lifecycle hook of the hooks that can occur multiple times per instance,\n   * and the third lifecycle hook (after `render` and `created`) of the very first this.lifecycle.\n   */\n  binding?(flags: LifecycleFlags): void;\n}\n\nexport interface ILifecycleBound extends IHooks, IState {\n  /*@internal*/$nextBound?: ILifecycleBound;\n\n  /**\n   * Called at the end of `$bind`, after this instance and its children (if any) are bound.\n   *\n   * - `$isBound` is true.\n   * - `this.$scope` is initialized.\n   *\n   * @param flags Contextual information about the lifecycle, such as what triggered it.\n   * Some uses for this hook:\n   * - `flags & LifecycleFlags.fromStartTask`: the Aurelia app is starting (this is the initial bind)\n   * - `flags & LifecycleFlags.fromBind`: this is a normal `$bind` lifecycle\n   * - `flags & LifecycleFlags.updateTargetInstance`: this `$bind` was triggered by some upstream observer and is not a real `$bind` lifecycle\n   * - `flags & LifecycleFlags.fromFlush` (only occurs in conjunction with updateTargetInstance): the update was queued to a `LinkedChangeList` which is now being flushed\n   *\n   * @description\n   * This is the second \"create\" lifecycle hook (after `binding`) of the hooks that can occur multiple times per instance,\n   * and the fourth lifecycle hook (after `render`, `created` and `binding`) of the very first this.lifecycle.\n   */\n  bound?(flags: LifecycleFlags): void;\n}\n\nexport interface ILifecycleUnbinding extends IHooks, IState {\n  /**\n   * Called at the start of `$unbind`, before this instance and its children (if any) are unbound.\n   *\n   * - `this.$isBound` is true.\n   * - `this.$scope` is still available.\n   *\n   * @param flags Contextual information about the lifecycle, such as what triggered it.\n   * Some uses for this hook:\n   * - `flags & LifecycleFlags.fromBind`: the component is just switching scope\n   * - `flags & LifecycleFlags.fromUnbind`: the component is really disposing\n   * - `flags & LifecycleFlags.fromStopTask`: the Aurelia app is stopping\n   *\n   * @description\n   * This is the fourth \"cleanup\" lifecycle hook (after `detaching`, `caching` and `detached`)\n   *\n   * Last opportunity to perform any source or target updates before the bindings are disconnected.\n   *\n   */\n  unbinding?(flags: LifecycleFlags): void;\n}\n\nexport interface ILifecycleUnbound extends IHooks, IState {\n  /*@internal*/$nextUnbound?: ILifecycleUnbound;\n\n  /**\n   * Called at the end of `$unbind`, after this instance and its children (if any) are unbound.\n   *\n   * - `this.$isBound` is false at this point.\n   *\n   * - `this.$scope` may not be available anymore (unless it's a `@customElement`)\n   *\n   * @param flags Contextual information about the lifecycle, such as what triggered it.\n   * Some uses for this hook:\n   * - `flags & LifecycleFlags.fromBind`: the component is just switching scope\n   * - `flags & LifecycleFlags.fromUnbind`: the component is really disposing\n   * - `flags & LifecycleFlags.fromStopTask`: the Aurelia app is stopping\n   *\n   * @description\n   * This is the fifth (and last) \"cleanup\" lifecycle hook (after `detaching`, `caching`, `detached`\n   * and `unbinding`).\n   *\n   * The lifecycle either ends here, or starts at `$bind` again.\n   */\n  unbound?(flags: LifecycleFlags): void;\n}\n\nexport interface ILifecycleAttaching extends IHooks, IState {\n  /**\n   * Called at the start of `$attach`, before this instance and its children (if any) are attached.\n   *\n   * `$isAttached` is false.\n   *\n   * @param encapsulationSource Ask Rob.\n   * @param lifecycle Utility that encapsulates the attach sequence for a hierarchy of attachables and guarantees the correct attach order.\n   *\n   * @description\n   * This is the third \"create\" lifecycle hook (after `binding` and `bound`) of the hooks that can occur multiple times per instance,\n   * and the fifth lifecycle hook (after `render`, `created`, `binding` and `bound`) of the very first lifecycle\n   *\n   * This is the time to add any (sync or async) tasks (e.g. animations) to the lifecycle that need to happen before\n   * the nodes are added to the DOM.\n   */\n  attaching?(flags: LifecycleFlags, encapsulationSource?: IEncapsulationSource): void;\n}\n\nexport interface ILifecycleAttached extends IHooks, IState {\n  /*@internal*/$nextAttached?: ILifecycleAttached;\n\n  /**\n   * Called at the end of `$attach`, after this instance and its children (if any) are attached.\n   *\n   * - `$isAttached` is true.\n   *\n   * @description\n   * This is the fourth (and last) \"create\" lifecycle hook (after `binding`, `bound` and `attaching`) of the hooks that can occur\n   * multiple times per instance, and the sixth lifecycle hook (after `render`, `created`, `binding`, `bound` and `attaching`)\n   * of the very first lifecycle\n   *\n   * This instance and its children (if any) can be assumed\n   * to be fully initialized, bound, rendered, added to the DOM and ready for use.\n   */\n  attached?(flags: LifecycleFlags): void;\n}\n\nexport interface ILifecycleDetaching extends IHooks, IState {\n  /**\n   * Called at the start of `$detach`, before this instance and its children (if any) are detached.\n   *\n   * - `$isAttached` is true.\n   *\n   * @param lifecycle Utility that encapsulates the detach sequence for a hierarchy of attachables and guarantees the correct detach order.\n   *\n   * @description\n   * This is the first \"cleanup\" lifecycle hook.\n   *\n   * This is the time to add any (sync or async) tasks (e.g. animations) to the lifecycle that need to happen before\n   * the nodes are removed from the DOM.\n   */\n  detaching?(flags: LifecycleFlags): void;\n}\n\nexport interface ILifecycleDetached extends IHooks, IState {\n  /*@internal*/$nextDetached?: ILifecycleDetached;\n\n  /**\n   * Called at the end of `$detach`, after this instance and its children (if any) are detached.\n   *\n   * - `$isAttached` is false.\n   *\n   * @description\n   * This is the third \"cleanup\" lifecycle hook (after `detaching` and `caching`).\n   *\n   * The `$nodes` are now removed from the DOM and the `View` (if possible) is returned to cache.\n   *\n   * If no `$unbind` lifecycle is queued, this is the last opportunity to make state changes before the lifecycle ends.\n   */\n  detached?(flags: LifecycleFlags): void;\n}\n\nexport interface ILifecycleCaching extends IHooks, IState {\n  /**\n   * Called during `$unmount` (which happens during `$detach`), specifically after the\n   * `$nodes` are removed from the DOM, but before the view is actually added to the cache.\n   *\n   * @description\n   * This is the second \"cleanup\" lifecycle hook.\n   *\n   * This lifecycle is invoked if and only if the `ViewFactory` that created the `View` allows the view to be cached.\n   *\n   * Usually this hook is not invoked unless you explicitly set the cache size to to something greater than zero\n   * on the resource description.\n   */\n  caching?(flags: LifecycleFlags): void;\n}\n\n/**\n * Defines optional lifecycle hooks that will be called only when they are implemented.\n */\nexport interface ILifecycleHooks extends\n  ILifecycleCreated,\n  ILifecycleBinding,\n  ILifecycleBound,\n  ILifecycleUnbinding,\n  ILifecycleUnbound,\n  ILifecycleAttaching,\n  ILifecycleAttached,\n  ILifecycleDetaching,\n  ILifecycleDetached,\n  ILifecycleCaching { }\n\nexport interface ILifecycleCache {\n  $cache(flags: LifecycleFlags): void;\n}\n\nexport interface ICachable extends ILifecycleCache { }\n\nexport interface ILifecycleAttach {\n  $attach(flags: LifecycleFlags, encapsulationSource?: IEncapsulationSource): void;\n}\n\nexport interface ILifecycleDetach {\n  $detach(flags: LifecycleFlags): void;\n}\n\nexport interface IAttach extends ILifecycleAttach, ILifecycleDetach, ICachable {\n  /*@internal*/$nextAttach: IAttach;\n  /*@internal*/$prevAttach: IAttach;\n}\n\nexport interface ILifecycleMount {\n  /*@internal*/$nextMount?: ILifecycleMount;\n\n  /**\n   * Add the `$nodes` of this instance to the Host or RenderLocation that this instance is holding.\n   */\n  $mount(flags: LifecycleFlags): void;\n}\n\nexport interface ILifecycleUnmount {\n  /*@internal*/$nextUnmount?: ILifecycleUnmount;\n\n  /**\n   * Remove the `$nodes` of this instance from the Host or RenderLocation that this instance is holding, optionally returning them to a cache.\n   * @returns\n   * - `true` if the instance has been returned to the cache.\n   * - `false` if the cache (typically ViewFactory) did not allow the instance to be cached.\n   * - `undefined` (void) if the instance does not support caching. Functionally equivalent to `false`\n   */\n  $unmount(flags: LifecycleFlags): boolean | void;\n}\nexport interface IMountable extends ILifecycleMount, ILifecycleUnmount { }\n\nexport interface ILifecycleUnbind {\n  $state?: State;\n  $unbind(flags: LifecycleFlags): void;\n}\n\nexport interface ILifecycleUnbindAfterDetach extends ILifecycleUnbind {\n  $nextUnbindAfterDetach?: ILifecycleUnbindAfterDetach;\n}\n\nexport interface ILifecycleBind {\n  $state?: State;\n  $bind(flags: LifecycleFlags, scope?: IScope): void;\n}\n\nexport interface ILifecycleBindSelf {\n  $state?: State;\n  $bind(flags: LifecycleFlags): void;\n}\n\nexport interface ILifecycleBindScope {\n  $state?: State;\n  $bind(flags: LifecycleFlags, scope: IScope): void;\n}\n\nexport interface IBind extends ILifecycleBind, ILifecycleUnbind {\n  /*@internal*/$nextBind: IBindSelf | IBindScope;\n  /*@internal*/$prevBind: IBindSelf | IBindScope;\n}\n\nexport interface IBindScope extends Omit<IBind, '$bind'>, ILifecycleBindScope { }\n\nexport interface IBindSelf extends Omit<IBind, '$bind'>, ILifecycleBindSelf { }\n\nconst marker = Object.freeze(Object.create(null));\n\n/*\n * Note: the lifecycle object ensures that certain callbacks are executed in a particular order that may\n * deviate from the order in which the component tree is walked.\n * The component tree is always walked in a top-down recursive fashion, for example:\n * {\n *   path: \"1\",\n *   children: [\n *     { path: \"1.1\", children: [\n *       { path: \"1.1.1\" },\n *       { path: \"1.1.2\" }\n *     ]},\n *     { path: \"1.2\", children: [\n *       { path: \"1.2.1\" },\n *       { path: \"1.2.2\" }\n *     ]}\n *   ]\n * }\n * The call chain would be: 1 -> 1.1 -> 1.1.1 -> 1.1.2 -> 1.2 -> 1.2.1 -> 1.2.2\n *\n * During mounting, for example, we want to mount the root component *last* (so that the DOM doesn't need to be updated\n * for each mount operation), and we want to invoke the detached callbacks in the same order that the components were mounted.\n * But all mounts need to happen before any of the detach callbacks are invoked, so we store the components in a LinkedList\n * whose execution is deferred until all the normal $attach/$detach calls have occurred.\n * In the example of attach, the call chains would look like this:\n * $attach: 1 -> 1.1 -> 1.1.1 -> 1.1.2 -> 1.2 -> 1.2.1 -> 1.2.2\n * $mount: 1.1.1 -> 1.1.2 -> 1.1 -> 1.2.1 -> 1.2.2 -> 1.2 -> 1\n * attached: 1.1.1 -> 1.1.2 -> 1.1 -> 1.2.1 -> 1.2.2 -> 1.2 -> 1\n *\n * Instead of (without the lifecycles):\n * $attach: 1, $mount: 1, detached: 1 -> $attach: 1.1, $mount: 1.1, detached: 1.1 -> etc..\n *\n * Furthermore, the lifecycle object tracks the call depth so that it will automatically run a list of operations\n * when the top-most component finishes execution, and components themselves don't need to worry about where in the\n * tree they reside.\n */\n\nexport interface IFlushLifecycle {\n  processFlushQueue(flags: LifecycleFlags): void;\n\n  /**\n   * Queue a flush() callback to be executed either on the next promise tick or on the next\n   * bind lifecycle (if during startTask) or on the next attach lifecycle.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   *\n   * This queue is primarily used by DOM target observers and collection observers.\n   */\n  enqueueFlush(requestor: IChangeTracker): Promise<void>;\n}\n\nexport interface IBindLifecycle extends IFlushLifecycle {\n  /**\n   * Open up / expand a bind batch for enqueueing `bound` callbacks.\n   *\n   * When the top-most caller calls `endBind`, the `bound` callbacks will be invoked.\n   *\n   * Each `beginBind` *must* be matched by an `endBind`.\n   */\n  beginBind(): void;\n\n  /**\n   * Add a `bound` callback to the queue, to be invoked when the current bind batch\n   * is ended via `endBind` by the top-most caller.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   */\n  enqueueBound(requestor: ILifecycleBound): void;\n\n  /**\n   * Add a `connect` callback to the queue, to be invoked *after* mounting and *before*\n   * `detached` callbacks.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   */\n  enqueueConnect(requestor: IConnectableBinding): void;\n\n  /**\n   * Close / shrink a bind batch for invoking queued `bound` callbacks.\n   * @param flags The flags that will be passed into the `bound` callbacks.\n   *\n   * Flags during bind are primarily for optimization purposes, and to control whether\n   * changes are batched or propagated synchronously.\n   * If unsure which flags to provide, it's OK to use `LifecycleFlags.none` (or simply `0`)\n   * This default will work, but is generally less efficient.\n   */\n  endBind(flags: LifecycleFlags): ILifecycleTask;\n\n  /**\n   * Open up / expand an unbind batch for enqueueing `unbound` callbacks.\n   *\n   * When the top-most caller calls `endUnbind`, the `unbound` callbacks will be invoked.\n   *\n   * Each `beginUnbind` *must* be matched by an `endUnbind`.\n   */\n  beginUnbind(): void;\n\n  /**\n   * Add an `unbound` callback to the queue, to be invoked when the current unbind batch\n   * is ended via `endUnbind` by the top-most caller.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   */\n  enqueueUnbound(requestor: ILifecycleUnbound): void;\n\n  /**\n   * Close / shrink an unbind batch for invoking queued `unbound` callbacks.\n   * @param flags The flags that will be passed into the `unbound` callbacks.\n   *\n   * Flags during unbind are primarily for optimization purposes, and to control whether\n   * changes are batched or propagated synchronously.\n   * If unsure which flags to provide, it's OK to use `LifecycleFlags.none` (or simply `0`)\n   * This default will work, but is generally less efficient.\n   */\n  endUnbind(flags: LifecycleFlags): ILifecycleTask;\n}\n\nexport interface IAttachLifecycle extends IFlushLifecycle {\n  /**\n   * Open up / expand an attach batch for enqueueing `$mount` and `attached` callbacks.\n   *\n   * When the top-most caller calls `endAttach`, the `$mount` and `attached` callbacks\n   * will be invoked (in that order).\n   *\n   * Each `beginAttach` *must* be matched by an `endAttach`.\n   */\n  beginAttach(): void;\n\n  /**\n   * Add a `$mount` callback to the queue, to be invoked when the current attach batch\n   * is ended via `endAttach` by the top-most caller.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   */\n  enqueueMount(requestor: ILifecycleMount): void;\n\n  /**\n   * Add an `attached` callback to the queue, to be invoked when the current attach batch\n   * is ended via `endAttach` by the top-most caller.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   */\n  enqueueAttached(requestor: ILifecycleAttached): void;\n\n  /**\n   * Close / shrink an attach batch for invoking queued `$mount` and `attached` callbacks.\n   * @param flags The flags that will be passed into the `$mount` and `attached` callbacks.\n   *\n   * Flags during attach are primarily for optimization purposes.\n   * If unsure which flags to provide, it's OK to use `LifecycleFlags.none` (or simply `0`)\n   * This default will work, but is generally less efficient.\n   */\n  endAttach(flags: LifecycleFlags): ILifecycleTask;\n\n  /**\n   * Open up / expand a detach batch for enqueueing `$unmount` and `detached` callbacks.\n   *\n   * When the top-most caller calls `endAttach`, the `$unmount` and `detached` callbacks\n   * will be invoked (in that order).\n   *\n   * Each `beginAttach` *must* be matched by an `endAttach`.\n   */\n  beginDetach(): void;\n\n  /**\n   * Add a `$unmount` callback to the queue, to be invoked when the current detach batch\n   * is ended via `endAttach` by the top-most caller.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   */\n  enqueueUnmount(requestor: ILifecycleUnmount): void;\n\n  /**\n   * Add a `detached` callback to the queue, to be invoked when the current detach batch\n   * is ended via `endAttach` by the top-most caller.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   */\n  enqueueDetached(requestor: ILifecycleDetached): void;\n\n  /**\n   * Add an `$unbind` callback to the queue, to be invoked when the current detach batch\n   * is ended via `endAttach` by the top-most caller. The callback is invoked after all the\n   * `$unmount` and `detached` callbacks are processed.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   */\n  enqueueUnbindAfterDetach(requestor: ILifecycleUnbind): void;\n\n  /**\n   * Close / shrink a detach batch for invoking queued `$unmount` and `detached` callbacks.\n   * @param flags The flags that will be passed into the `$unmount` and `detached` callbacks.\n   *\n   * Flags during detach are primarily for optimization purposes, and to control whether a\n   * component should be unmounted or not (the default is to only unmount root nodes).\n   * If unsure which flags to provide, it's OK to use `LifecycleFlags.none` (or simply `0`).\n   * This default will work, but is generally less efficient.\n   */\n  endDetach(flags: LifecycleFlags): ILifecycleTask;\n}\n\nexport interface ILifecycle extends IBindLifecycle, IAttachLifecycle {\n  registerTask(task: ILifecycleTask): void;\n  finishTask(task: ILifecycleTask): void;\n}\n\nexport const ILifecycle = DI.createInterface<ILifecycle>().withDefault(x => x.singleton(Lifecycle));\nexport const IFlushLifecycle = ILifecycle as InterfaceSymbol<IFlushLifecycle>;\nexport const IBindLifecycle = ILifecycle as InterfaceSymbol<IBindLifecycle>;\nexport const IAttachLifecycle = ILifecycle as InterfaceSymbol<IAttachLifecycle>;\n\n/*@internal*/\nexport class Lifecycle implements ILifecycle {\n  /*@internal*/public bindDepth: number = 0;\n  /*@internal*/public attachDepth: number = 0;\n  /*@internal*/public detachDepth: number = 0;\n  /*@internal*/public unbindDepth: number = 0;\n\n  /*@internal*/public flushHead: IChangeTracker = this;\n  /*@internal*/public flushTail: IChangeTracker = this;\n\n  /*@internal*/public connectHead: IConnectableBinding = <IConnectableBinding><unknown>this; // this cast is safe because we know exactly which properties we'll use\n  /*@internal*/public connectTail: IConnectableBinding = <IConnectableBinding><unknown>this;\n\n  /*@internal*/public patchHead: IConnectableBinding = <IConnectableBinding><unknown>this;\n  /*@internal*/public patchTail: IConnectableBinding = <IConnectableBinding><unknown>this;\n\n  /*@internal*/public boundHead: ILifecycleBound = this;\n  /*@internal*/public boundTail: ILifecycleBound = this;\n\n  /*@internal*/public mountHead: ILifecycleMount = this;\n  /*@internal*/public mountTail: ILifecycleMount = this;\n\n  /*@internal*/public attachedHead: ILifecycleAttached = this;\n  /*@internal*/public attachedTail: ILifecycleAttached = this;\n\n  /*@internal*/public unmountHead: ILifecycleUnmount = this;\n  /*@internal*/public unmountTail: ILifecycleUnmount = this;\n\n  /*@internal*/public detachedHead: ILifecycleDetached = this; //LOL\n  /*@internal*/public detachedTail: ILifecycleDetached = this;\n\n  /*@internal*/public unbindAfterDetachHead: ILifecycleUnbindAfterDetach = this;\n  /*@internal*/public unbindAfterDetachTail: ILifecycleUnbindAfterDetach = this;\n\n  /*@internal*/public unboundHead: ILifecycleUnbound = this;\n  /*@internal*/public unboundTail: ILifecycleUnbound = this;\n\n  /*@internal*/public flushed: Promise<void> = null;\n  /*@internal*/public promise: Promise<void> = Promise.resolve();\n\n  /*@internal*/public flushCount: number = 0;\n  /*@internal*/public connectCount: number = 0;\n  /*@internal*/public patchCount: number = 0;\n  /*@internal*/public boundCount: number = 0;\n  /*@internal*/public mountCount: number = 0;\n  /*@internal*/public attachedCount: number = 0;\n  /*@internal*/public unmountCount: number = 0;\n  /*@internal*/public detachedCount: number = 0;\n  /*@internal*/public unbindAfterDetachCount: number = 0;\n  /*@internal*/public unboundCount: number = 0;\n\n  // These are dummy properties to make the lifecycle conform to the interfaces\n  // of the components it manages. This allows the lifecycle itself to be the first link\n  // in the chain and removes the need for an additional null check on each addition.\n  /*@internal*/public $nextFlush: IChangeTracker = marker;\n  /*@internal*/public flush: IChangeTracker['flush'] = PLATFORM.noop;\n  /*@internal*/public $nextConnect: IConnectableBinding = marker;\n  /*@internal*/public connect: IConnectableBinding['connect'] = PLATFORM.noop;\n  /*@internal*/public $nextPatch: IConnectableBinding = marker;\n  /*@internal*/public patch: IConnectableBinding['patch'] = PLATFORM.noop;\n  /*@internal*/public $nextBound: ILifecycleBound = marker;\n  /*@internal*/public bound: ILifecycleBound['bound'] = PLATFORM.noop;\n  /*@internal*/public $nextMount: ILifecycleMount = marker;\n  /*@internal*/public $mount: ILifecycleMount['$mount'] = PLATFORM.noop;\n  /*@internal*/public $nextAttached: ILifecycleAttached = marker;\n  /*@internal*/public attached: ILifecycleAttached['attached'] = PLATFORM.noop;\n  /*@internal*/public $nextUnmount: ILifecycleUnmount = marker;\n  /*@internal*/public $unmount: ILifecycleUnmount['$unmount'] = PLATFORM.noop;\n  /*@internal*/public $nextDetached: ILifecycleDetached = marker;\n  /*@internal*/public detached: ILifecycleDetached['detached'] = PLATFORM.noop;\n  /*@internal*/public $nextUnbindAfterDetach: ILifecycleUnbindAfterDetach = marker;\n  /*@internal*/public $unbind: ILifecycleUnbindAfterDetach['$unbind'] = PLATFORM.noop;\n  /*@internal*/public $nextUnbound: ILifecycleUnbound = marker;\n  /*@internal*/public unbound: ILifecycleUnbound['unbound'] = PLATFORM.noop;\n\n  /*@internal*/public task: AggregateLifecycleTask = null;\n\n  public registerTask(task: ILifecycleTask): void {\n    if (this.task === null) {\n      this.task = new AggregateLifecycleTask();\n    }\n    this.task.addTask(task);\n  }\n\n  public finishTask(task: ILifecycleTask): void {\n    if (this.task !== null) {\n      if (this.task === task) {\n        this.task = null;\n      } else {\n        this.task.removeTask(task);\n      }\n    }\n  }\n\n  public enqueueFlush(requestor: IChangeTracker): Promise<void> {\n    // Queue a flush() callback; the depth is just for debugging / testing purposes and has\n    // no effect on execution. flush() will automatically be invoked when the promise resolves,\n    // or it can be manually invoked synchronously.\n    if (this.flushHead === this) {\n      this.flushed = this.promise.then(() => this.processFlushQueue(LifecycleFlags.fromAsyncFlush));\n    }\n    if (requestor.$nextFlush === null) {\n      requestor.$nextFlush = marker;\n      this.flushTail.$nextFlush = requestor;\n      this.flushTail = requestor;\n      ++this.flushCount;\n    }\n    return this.flushed;\n  }\n\n  public processFlushQueue(flags: LifecycleFlags): void {\n    flags |= LifecycleFlags.fromSyncFlush;\n    // flush callbacks may lead to additional flush operations, so keep looping until\n    // the flush head is back to `this` (though this will typically happen in the first iteration)\n    while (this.flushCount > 0) {\n      let current = this.flushHead.$nextFlush;\n      this.flushHead = this.flushTail = this;\n      this.flushCount = 0;\n      let next: typeof current;\n      do {\n        next = current.$nextFlush;\n        current.$nextFlush = null;\n        current.flush(flags);\n        current = next;\n      } while (current !== marker);\n    }\n  }\n\n  public beginBind(): void {\n    ++this.bindDepth;\n  }\n\n  public enqueueBound(requestor: ILifecycleBound): void {\n    // build a standard singly linked list for bound callbacks\n    if (requestor.$nextBound === null) {\n      requestor.$nextBound = marker;\n      this.boundTail.$nextBound = requestor;\n      this.boundTail = requestor;\n      ++this.boundCount;\n    }\n  }\n\n  public enqueueConnect(requestor: IConnectableBinding): void {\n    // enqueue connect and patch calls in separate lists so that they can be invoked\n    // independently from eachother\n    // TODO: see if we can eliminate/optimize some of this, because this is a relatively hot path\n    // (first get all the necessary integration tests working, then look for optimizations)\n\n    // build a standard singly linked list for connect callbacks\n    if (requestor.$nextConnect === null) {\n      requestor.$nextConnect = marker;\n      this.connectTail.$nextConnect = requestor;\n      this.connectTail = requestor;\n      ++this.connectCount;\n    }\n    // build a standard singly linked list for patch callbacks\n    if (requestor.$nextPatch === null) {\n      requestor.$nextPatch = marker;\n      this.patchTail.$nextPatch = requestor;\n      this.patchTail = requestor;\n      ++this.patchCount;\n    }\n  }\n\n  public processConnectQueue(flags: LifecycleFlags): void {\n    // connects cannot lead to additional connects, so we don't need to loop here\n    if (this.connectCount > 0) {\n      this.connectCount = 0;\n      let current = this.connectHead.$nextConnect;\n      this.connectHead = this.connectTail = <IConnectableBinding><unknown>this;\n      let next: typeof current;\n      do {\n        current.connect(flags);\n        next = current.$nextConnect;\n        current.$nextConnect = null;\n        current = next;\n      } while (current !== marker);\n    }\n  }\n\n  public processPatchQueue(flags: LifecycleFlags): void {\n    // flush before patching, but only if this is the initial bind;\n    // no DOM is attached yet so we can safely let everything propagate\n    if (flags & LifecycleFlags.fromStartTask) {\n      this.processFlushQueue(flags | LifecycleFlags.fromSyncFlush);\n    }\n    // patch callbacks may lead to additional bind operations, so keep looping until\n    // the patch head is back to `this` (though this will typically happen in the first iteration)\n    while (this.patchCount > 0) {\n      this.patchCount = 0;\n      let current = this.patchHead.$nextPatch;\n      this.patchHead = this.patchTail = <IConnectableBinding><unknown>this;\n      let next: typeof current;\n      do {\n        current.patch(flags);\n        next = current.$nextPatch;\n        current.$nextPatch = null;\n        current = next;\n      } while (current !== marker);\n    }\n  }\n\n  public endBind(flags: LifecycleFlags): ILifecycleTask {\n    // close / shrink a bind batch\n    if (--this.bindDepth === 0) {\n      if (this.task !== null && !this.task.done) {\n        this.task.owner = this;\n        return this.task;\n      }\n\n      this.processBindQueue(flags);\n\n      return LifecycleTask.done;\n    }\n  }\n\n  public processBindQueue(flags: LifecycleFlags): void {\n    // flush before processing bound callbacks, but only if this is the initial bind;\n    // no DOM is attached yet so we can safely let everything propagate\n    if (flags & LifecycleFlags.fromStartTask) {\n      this.processFlushQueue(flags | LifecycleFlags.fromSyncFlush);\n    }\n    // bound callbacks may lead to additional bind operations, so keep looping until\n    // the bound head is back to `this` (though this will typically happen in the first iteration)\n    while (this.boundCount > 0) {\n      this.boundCount = 0;\n      let current = this.boundHead.$nextBound;\n      let next: ILifecycleBound;\n      this.boundHead = this.boundTail = this;\n      do {\n        current.bound(flags);\n        next = current.$nextBound;\n        current.$nextBound = null;\n        current = next;\n      } while (current !== marker);\n    }\n  }\n\n  public beginUnbind(): void {\n    // open up / expand an unbind batch; the very first caller will close it again with endUnbind\n    ++this.unbindDepth;\n  }\n\n  public enqueueUnbound(requestor: ILifecycleUnbound): void {\n    // This method is idempotent; adding the same item more than once has the same effect as\n    // adding it once.\n    // build a standard singly linked list for unbound callbacks\n    if (requestor.$nextUnbound === null) {\n      requestor.$nextUnbound = marker;\n      this.unboundTail.$nextUnbound = requestor;\n      this.unboundTail = requestor;\n      ++this.unboundCount;\n    }\n  }\n\n  public endUnbind(flags: LifecycleFlags): ILifecycleTask {\n    // close / shrink an unbind batch\n    if (--this.unbindDepth === 0) {\n      if (this.task !== null && !this.task.done) {\n        this.task.owner = this;\n        return this.task;\n      }\n\n      this.processUnbindQueue(flags);\n\n      return LifecycleTask.done;\n    }\n  }\n\n  public processUnbindQueue(flags: LifecycleFlags): void {\n    // unbound callbacks may lead to additional unbind operations, so keep looping until\n    // the unbound head is back to `this` (though this will typically happen in the first iteration)\n    while (this.unboundCount > 0) {\n      this.unboundCount = 0;\n      let current = this.unboundHead.$nextUnbound;\n      let next: ILifecycleUnbound;\n      this.unboundHead = this.unboundTail = this;\n      do {\n        current.unbound(flags);\n        next = current.$nextUnbound;\n        current.$nextUnbound = null;\n        current = next;\n      } while (current !== marker);\n    }\n  }\n\n  public beginAttach(): void {\n    // open up / expand an attach batch; the very first caller will close it again with endAttach\n    ++this.attachDepth;\n  }\n\n  public enqueueMount(requestor: ILifecycleMount): void {\n    // This method is idempotent; adding the same item more than once has the same effect as\n    // adding it once.\n    // build a standard singly linked list for mount callbacks\n    if (requestor.$nextMount === null) {\n      requestor.$nextMount = marker;\n      this.mountTail.$nextMount = requestor;\n      this.mountTail = requestor;\n      ++this.mountCount;\n    }\n  }\n\n  public enqueueAttached(requestor: ILifecycleAttached): void {\n    // This method is idempotent; adding the same item more than once has the same effect as\n    // adding it once.\n    // build a standard singly linked list for attached callbacks\n    if (requestor.$nextAttached === null) {\n      requestor.$nextAttached = marker;\n      this.attachedTail.$nextAttached = requestor;\n      this.attachedTail = requestor;\n      ++this.attachedCount;\n    }\n  }\n\n  public endAttach(flags: LifecycleFlags): ILifecycleTask {\n    // close / shrink an attach batch\n    if (--this.attachDepth === 0) {\n      if (this.task !== null && !this.task.done) {\n        this.task.owner = this;\n        return this.task;\n      }\n\n      this.processAttachQueue(flags);\n\n      return LifecycleTask.done;\n    }\n  }\n\n  public processAttachQueue(flags: LifecycleFlags): void {\n    // flush and patch before starting the attach lifecycle to ensure batched collection changes are propagated to repeaters\n    // and the DOM is updated\n    this.processFlushQueue(flags | LifecycleFlags.fromSyncFlush);\n    // TODO: prevent duplicate updates coming from the patch queue (or perhaps it's just not needed in its entirety?)\n    //this.processPatchQueue(flags | LifecycleFlags.fromSyncFlush);\n\n    if (this.mountCount > 0) {\n      this.mountCount = 0;\n      let currentMount = this.mountHead.$nextMount;\n      this.mountHead = this.mountTail = this;\n      let nextMount: typeof currentMount;\n\n      do {\n        currentMount.$mount(flags);\n        nextMount = currentMount.$nextMount;\n        currentMount.$nextMount = null;\n        currentMount = nextMount;\n      } while (currentMount !== marker);\n    }\n    // Connect all connect-queued bindings AFTER mounting is done, so that the DOM is visible asap,\n    // but connect BEFORE running the attached callbacks to ensure any changes made during those callbacks\n    // are still accounted for.\n    // TODO: add a flag/option to further delay connect with a RAF callback (the tradeoff would be that we'd need\n    // to run an additional patch cycle before that connect, which can be expensive and unnecessary in most real\n    // world scenarios, but can significantly speed things up with nested, highly volatile data like in dbmonster)\n    this.processConnectQueue(LifecycleFlags.mustEvaluate);\n\n    if (this.attachedCount > 0) {\n      this.attachedCount = 0;\n      let currentAttached = this.attachedHead.$nextAttached;\n      this.attachedHead = this.attachedTail = this;\n      let nextAttached: typeof currentAttached;\n\n      do {\n        currentAttached.attached(flags);\n        nextAttached = currentAttached.$nextAttached;\n        currentAttached.$nextAttached = null;\n        currentAttached = nextAttached;\n      } while (currentAttached !== marker);\n    }\n  }\n\n  public beginDetach(): void {\n    // open up / expand a detach batch; the very first caller will close it again with endDetach\n    ++this.detachDepth;\n  }\n\n  public enqueueUnmount(requestor: ILifecycleUnmount): void {\n    // This method is idempotent; adding the same item more than once has the same effect as\n    // adding it once.\n    // build a standard singly linked list for unmount callbacks\n    if (requestor.$nextUnmount === null) {\n      requestor.$nextUnmount = marker;\n      this.unmountTail.$nextUnmount = requestor;\n      this.unmountTail = requestor;\n      ++this.unmountCount;\n    }\n  }\n\n  public enqueueDetached(requestor: ILifecycleDetached): void {\n    // This method is idempotent; adding the same item more than once has the same effect as\n    // adding it once.\n    // build a standard singly linked list for detached callbacks\n    if (requestor.$nextDetached === null) {\n      requestor.$nextDetached = marker;\n      this.detachedTail.$nextDetached = requestor;\n      this.detachedTail = requestor;\n      ++this.detachedCount;\n    }\n  }\n\n  public enqueueUnbindAfterDetach(requestor: ILifecycleUnbindAfterDetach): void {\n    // This method is idempotent; adding the same item more than once has the same effect as\n    // adding it once.\n    // build a standard singly linked list for unbindAfterDetach callbacks\n    if (requestor.$nextUnbindAfterDetach === null) {\n      requestor.$nextUnbindAfterDetach = marker;\n      this.unbindAfterDetachTail.$nextUnbindAfterDetach = requestor;\n      this.unbindAfterDetachTail = requestor;\n      ++this.unbindAfterDetachCount;\n    }\n  }\n\n  public endDetach(flags: LifecycleFlags): ILifecycleTask {\n    // close / shrink a detach batch\n    if (--this.detachDepth === 0) {\n      if (this.task !== null && !this.task.done) {\n        this.task.owner = this;\n        return this.task;\n      }\n\n      this.processDetachQueue(flags);\n\n      return LifecycleTask.done;\n    }\n  }\n\n  public processDetachQueue(flags: LifecycleFlags): void {\n    // flush before unmounting to ensure batched collection changes propagate to the repeaters,\n    // which may lead to additional unmount operations\n    this.processFlushQueue(flags | LifecycleFlags.fromFlush | LifecycleFlags.doNotUpdateDOM);\n\n    if (this.unmountCount > 0) {\n      this.unmountCount = 0;\n      let currentUnmount = this.unmountHead.$nextUnmount;\n      this.unmountHead = this.unmountTail = this;\n      let nextUnmount: typeof currentUnmount;\n\n      do {\n        currentUnmount.$unmount(flags);\n        nextUnmount = currentUnmount.$nextUnmount;\n        currentUnmount.$nextUnmount = null;\n        currentUnmount = nextUnmount;\n      } while (currentUnmount !== marker);\n    }\n\n    if (this.detachedCount > 0) {\n      this.detachedCount = 0;\n      let currentDetached = this.detachedHead.$nextDetached;\n      this.detachedHead = this.detachedTail = this;\n      let nextDetached: typeof currentDetached;\n\n      do {\n        currentDetached.detached(flags);\n        nextDetached = currentDetached.$nextDetached;\n        currentDetached.$nextDetached = null;\n        currentDetached = nextDetached;\n      } while (currentDetached !== marker);\n    }\n\n    if (this.unbindAfterDetachCount > 0) {\n      this.beginUnbind();\n      this.unbindAfterDetachCount = 0;\n      let currentUnbind = this.unbindAfterDetachHead.$nextUnbindAfterDetach;\n      this.unbindAfterDetachHead = this.unbindAfterDetachTail = this;\n      let nextUnbind: typeof currentUnbind;\n\n      do {\n        currentUnbind.$unbind(flags);\n        nextUnbind = currentUnbind.$nextUnbindAfterDetach;\n        currentUnbind.$nextUnbindAfterDetach = null;\n        currentUnbind = nextUnbind;\n      } while (currentUnbind !== marker);\n      this.endUnbind(flags);\n    }\n  }\n}\n\n@inject(ILifecycle)\nexport class CompositionCoordinator {\n  public onSwapComplete: () => void = PLATFORM.noop;\n\n  private queue: (IView | PromiseSwap)[] = null;\n  private swapTask: ILifecycleTask = LifecycleTask.done;\n\n  private currentView: IView = null;\n  private scope: IScope;\n  private isBound: boolean = false;\n  private isAttached: boolean = false;\n\n  constructor(public readonly $lifecycle: ILifecycle) {}\n\n  public static register(container: IContainer): IResolver<CompositionCoordinator> {\n    return Registration.transient(this, this).register(container, this);\n  }\n\n  public compose(value: IView, flags: LifecycleFlags): void {\n    if (this.swapTask.done) {\n      if (value instanceof Promise) {\n        this.enqueue(new PromiseSwap(this, value));\n        this.processNext();\n      } else {\n        this.swap(value, flags);\n      }\n    } else {\n      if (value instanceof Promise) {\n        this.enqueue(new PromiseSwap(this, value));\n      } else {\n        this.enqueue(value);\n      }\n\n      if (this.swapTask.canCancel()) {\n        this.swapTask.cancel();\n      }\n    }\n  }\n\n  public binding(flags: LifecycleFlags, scope: IScope): void {\n    this.scope = scope;\n    this.isBound = true;\n\n    if (this.currentView !== null) {\n      this.currentView.$bind(flags, scope);\n    }\n  }\n\n  public attaching(flags: LifecycleFlags): void {\n    this.isAttached = true;\n\n    if (this.currentView !== null) {\n      this.currentView.$attach(flags);\n    }\n  }\n\n  public detaching(flags: LifecycleFlags): void {\n    this.isAttached = false;\n\n    if (this.currentView !== null) {\n      this.currentView.$detach(flags);\n    }\n  }\n\n  public unbinding(flags: LifecycleFlags): void {\n    this.isBound = false;\n\n    if (this.currentView !== null) {\n      this.currentView.$unbind(flags);\n    }\n  }\n\n  public caching(flags: LifecycleFlags): void {\n    this.currentView = null;\n  }\n\n  private enqueue(view: IView | PromiseSwap): void {\n    if (this.queue === null) {\n      this.queue = [];\n    }\n\n    this.queue.push(view);\n  }\n\n  private swap(view: IView, flags: LifecycleFlags): void {\n    if (this.currentView === view) {\n      return;\n    }\n\n    const $lifecycle = this.$lifecycle;\n    const swapTask = new AggregateLifecycleTask();\n\n    let lifecycleTask: ILifecycleTask;\n    let currentView = this.currentView;\n    if (currentView === null) {\n      lifecycleTask = LifecycleTask.done;\n    } else {\n      $lifecycle.enqueueUnbindAfterDetach(currentView);\n      $lifecycle.beginDetach();\n      currentView.$detach(flags);\n      lifecycleTask = $lifecycle.endDetach(flags);\n    }\n    swapTask.addTask(lifecycleTask);\n\n    currentView = this.currentView = view;\n\n    if (currentView === null) {\n      lifecycleTask = LifecycleTask.done;\n    } else {\n      if (this.isBound) {\n        $lifecycle.beginBind();\n        currentView.$bind(flags, this.scope);\n        $lifecycle.endBind(flags);\n      }\n      if (this.isAttached) {\n        $lifecycle.beginAttach();\n        currentView.$attach(flags);\n        lifecycleTask = $lifecycle.endAttach(flags);\n      } else {\n        lifecycleTask = LifecycleTask.done;\n      }\n    }\n    swapTask.addTask(lifecycleTask);\n\n    if (swapTask.done) {\n      this.swapTask = LifecycleTask.done;\n      this.onSwapComplete();\n    } else {\n      this.swapTask = swapTask;\n      this.swapTask.wait().then(() => {\n        this.onSwapComplete();\n        this.processNext();\n      });\n    }\n  }\n\n  private processNext(): void {\n    if (this.queue !== null && this.queue.length > 0) {\n      const next = this.queue.pop();\n      this.queue.length = 0;\n\n      if (PromiseSwap.is(next)) {\n        this.swapTask = next.start();\n      } else {\n        this.swap(next, LifecycleFlags.fromLifecycleTask);\n      }\n    } else {\n      this.swapTask = LifecycleTask.done;\n    }\n  }\n}\n\nexport const LifecycleTask = {\n  done: {\n    done: true,\n    canCancel(): boolean { return false; },\n    // tslint:disable-next-line:no-empty\n    cancel(): void {},\n    wait(): Promise<unknown> { return Promise.resolve(); }\n  }\n};\n\nexport interface ILifecycleTask<T = unknown> {\n  readonly done: boolean;\n  canCancel(): boolean;\n  cancel(): void;\n  wait(): Promise<T>;\n}\n\nexport class AggregateLifecycleTask implements ILifecycleTask<void> {\n  public done: boolean = true;\n\n  /*@internal*/\n  public owner: Lifecycle = null;\n\n  private tasks: ILifecycleTask[] = [];\n  private waiter: Promise<void> = null;\n  private resolve: () => void = null;\n\n  public addTask(task: ILifecycleTask): void {\n    if (!task.done) {\n      this.done = false;\n      this.tasks.push(task);\n      task.wait().then(() => this.tryComplete());\n    }\n  }\n\n  public removeTask(task: ILifecycleTask): void {\n    if (task.done) {\n      const idx = this.tasks.indexOf(task);\n      if (idx !== -1) {\n        this.tasks.splice(idx, 1);\n      }\n    }\n    if (this.tasks.length === 0) {\n      if (this.owner !== null) {\n        this.owner.finishTask(this);\n        this.owner = null;\n      }\n    }\n  }\n\n  public canCancel(): boolean {\n    if (this.done) {\n      return false;\n    }\n\n    return this.tasks.every(x => x.canCancel());\n  }\n\n  public cancel(): void {\n    if (this.canCancel()) {\n      this.tasks.forEach(x => x.cancel());\n      this.done = false;\n    }\n  }\n\n  public wait(): Promise<void> {\n    if (this.waiter === null) {\n      if (this.done) {\n        this.waiter = Promise.resolve();\n      } else {\n        // tslint:disable-next-line:promise-must-complete\n        this.waiter = new Promise((resolve) => this.resolve = resolve);\n      }\n    }\n\n    return this.waiter;\n  }\n\n  private tryComplete(): void {\n    if (this.done) {\n      return;\n    }\n\n    if (this.tasks.every(x => x.done)) {\n      this.complete(true);\n    }\n  }\n\n  private complete(notCancelled: boolean): void {\n    this.done = true;\n\n    if (notCancelled && this.owner !== null) {\n      this.owner.processDetachQueue(LifecycleFlags.fromLifecycleTask);\n      this.owner.processUnbindQueue(LifecycleFlags.fromLifecycleTask);\n      this.owner.processBindQueue(LifecycleFlags.fromLifecycleTask);\n      this.owner.processAttachQueue(LifecycleFlags.fromLifecycleTask);\n    }\n    this.owner.finishTask(this);\n\n    if (this.resolve !== null) {\n      this.resolve();\n    }\n  }\n}\n\n/*@internal*/\nexport class PromiseSwap implements ILifecycleTask<IView> {\n  public done: boolean = false;\n  private isCancelled: boolean = false;\n\n  constructor(\n    private coordinator: CompositionCoordinator,\n    private promise: Promise<IView>\n  ) {}\n\n  public static is(object: object): object is PromiseSwap {\n    return 'start' in object;\n  }\n\n  public start(): ILifecycleTask<IView | unknown> {\n    if (this.isCancelled) {\n      return LifecycleTask.done;\n    }\n\n    this.promise = this.promise.then(x => {\n      this.onResolve(x);\n      return x;\n    });\n\n    return this;\n  }\n\n  public canCancel(): boolean {\n    return !this.done;\n  }\n\n  public cancel(): void {\n    if (this.canCancel()) {\n      this.isCancelled = true;\n    }\n  }\n\n  public wait(): Promise<IView> {\n    return this.promise;\n  }\n\n  private onResolve(value: IView): void {\n    if (this.isCancelled) {\n      return;\n    }\n\n    this.done = true;\n    this.coordinator.compose(value, LifecycleFlags.fromLifecycleTask);\n  }\n}\n\n// tslint:disable:jsdoc-format\n/**\n * A general-purpose ILifecycleTask implementation that can be placed\n * before an attached, detached, bound or unbound hook during attaching,\n * detaching, binding or unbinding, respectively.\n *\n * The provided promise will be awaited before the corresponding lifecycle\n * hook (and any hooks following it) is invoked.\n *\n * The provided callback will be invoked after the promise is resolved\n * and before the next lifecycle hook.\n *\n * Example:\n```ts\nexport class MyViewModel {\n  private $lifecycle: ILifecycle; // set before created() hook\n  private answer: number;\n\n  public binding(flags: LifecycleFlags): void {\n    // this.answer === undefined\n    this.$lifecycle.registerTask(new PromiseTask(\n      this.getAnswerAsync,\n      answer => {\n        this.answer = answer;\n      }\n    ));\n  }\n\n  public bound(flags: LifecycleFlags): void {\n    // this.answer === 42\n  }\n\n  private getAnswerAsync(): Promise<number> {\n    return Promise.resolve().then(() => 42);\n  }\n}\n```\n */\n// tslint:enable:jsdoc-format\nexport class PromiseTask<T = void> implements ILifecycleTask<T> {\n  public done: boolean;\n  private isCancelled: boolean;\n  private promise: Promise<T>;\n  private callback: (result?: T) => void;\n\n  constructor(\n    promise: Promise<T>,\n    callback: (result?: T) => void\n  ) {\n    this.done = false;\n    this.isCancelled = false;\n    this.callback = callback;\n    this.promise = promise.then(value => {\n      if (this.isCancelled === true) {\n        return;\n      }\n      this.done = true;\n      this.callback(value);\n      return value;\n    });\n  }\n\n  public canCancel(): boolean {\n    return !this.done;\n  }\n\n  public cancel(): void {\n    if (this.canCancel()) {\n      this.isCancelled = true;\n    }\n  }\n\n  public wait(): Promise<T> {\n    return this.promise;\n  }\n}\n","import { Constructable, IContainer, Registration, Writable } from '@aurelia/kernel';\nimport { IResourceKind, IResourceType } from '../resource';\n\nexport interface IBindingBehaviorSource {\n  name: string;\n}\n\nexport type IBindingBehaviorType = IResourceType<IBindingBehaviorSource>;\n\nexport function bindingBehavior(nameOrSource: string | IBindingBehaviorSource): <T extends Constructable>(target: T) => T & IResourceType<IBindingBehaviorSource> {\n  return function<T extends Constructable>(target: T): T & IResourceType<IBindingBehaviorSource> {\n    return BindingBehaviorResource.define(nameOrSource, target);\n  };\n}\n\nexport const BindingBehaviorResource: IResourceKind<IBindingBehaviorSource, IBindingBehaviorType> = {\n  name: 'binding-behavior',\n\n  keyFrom(name: string): string {\n    return `${this.name}:${name}`;\n  },\n\n  isType<T extends Constructable>(Type: T): Type is T & IBindingBehaviorType {\n    return (Type as T & IBindingBehaviorType).kind === this;\n  },\n\n  define<T extends Constructable>(nameOrSource: string | IBindingBehaviorSource, ctor: T): T & IBindingBehaviorType {\n    const Type = ctor as T & IBindingBehaviorType;\n    const description = typeof nameOrSource === 'string'\n      ? { name: nameOrSource }\n      : nameOrSource;\n\n    (Type as Writable<IBindingBehaviorType>).kind = BindingBehaviorResource;\n    (Type as Writable<IBindingBehaviorType>).description = description;\n    Type.register = register;\n\n    return Type;\n  }\n};\n\nfunction register(this: IBindingBehaviorType, container: IContainer): void {\n  container.register(\n    Registration.singleton(\n      BindingBehaviorResource.keyFrom(this.description.name),\n      this\n    )\n  );\n}\n","import { Constructable, DI, IContainer, IResolver, PLATFORM, Reporter, Writable } from '@aurelia/kernel';\n\nexport const ELEMENT_NODE = 1;\nexport const ATTRIBUTE_NODE = 2;\nexport const TEXT_NODE = 3;\nexport const COMMENT_NODE = 8;\nexport const DOCUMENT_FRAGMENT_NODE = 11;\n\nfunction isRenderLocation(node: INode): node is IRenderLocation {\n  return node.textContent === 'au-end';\n}\n\nexport interface INodeLike {\n  readonly firstChild: INode | null;\n  readonly lastChild: INode | null;\n  readonly childNodes: ArrayLike<INode>;\n}\nexport const INode = DI.createInterface<INode>().noDefault();\nexport interface INode extends INodeLike {\n  textContent: string;\n  readonly parentNode: INode | null;\n  readonly nextSibling: INode | null;\n  readonly previousSibling: INode | null;\n  readonly nodeName: string;\n  readonly nodeType: number;\n}\nexport const IEncapsulationSource = DI.createInterface<IEncapsulationSource>().noDefault();\nexport interface IEncapsulationSource extends INode {}\n\nexport interface IAttr extends Partial<INode> {\n  readonly name: string;\n  value: string;\n}\n\nexport interface IElement extends INode {\n  readonly content?: IDocumentFragment;\n}\n\nexport interface IStyleDeclaration {\n  cssText: string;\n  setProperty(propertyName: string, value: string, priority?: string): void;\n  removeProperty(propertyName: string): void;\n}\nexport interface IHTMLElement extends IElement {\n  readonly style: IStyleDeclaration;\n  setAttributeNS(namespace: string, qualifiedName: string, value: string): void;\n  getAttributeNS(namespace: string, qualifiedName: string): string;\n}\n\nexport interface IInputElement extends IElement {\n  // tslint:disable-next-line:no-reserved-keywords\n  readonly type: string;\n  value: string;\n  checked: boolean;\n}\n\nexport interface IText extends INode {\n  readonly nodeName: '#text';\n  readonly nodeType: typeof TEXT_NODE;\n}\n\nexport interface IComment extends INode {\n  readonly nodeName: '#comment';\n  readonly nodeType: typeof COMMENT_NODE;\n}\n\nexport interface IDocumentFragment extends INode {\n  readonly nodeName: '#document-fragment';\n  readonly nodeType: typeof DOCUMENT_FRAGMENT_NODE;\n}\n\nexport const IRenderLocation = DI.createInterface<IRenderLocation>().noDefault();\nexport interface IRenderLocation extends INode {\n  $start?: IRenderLocation;\n  $nodes?: INodeSequence | typeof PLATFORM['emptyObject'];\n}\n\n/**\n * Represents a DocumentFragment\n */\nexport interface INodeSequence extends INodeLike {\n  /**\n   * The nodes of this sequence.\n   */\n  childNodes: ReadonlyArray<INode>;\n\n  /**\n   * Find all instruction targets in this sequence.\n   */\n  findTargets(): ArrayLike<INode> | ReadonlyArray<INode>;\n\n  /**\n   * Insert this sequence as a sibling before refNode\n   */\n  insertBefore(refNode: INode): void;\n\n  /**\n   * Append this sequence as a child to parent\n   */\n  appendTo(parent: INode): void;\n\n  /**\n   * Remove this sequence from its parent.\n   */\n  remove(): void;\n}\n\nexport interface INodeObserver {\n  disconnect(): void;\n}\n\n// tslint:disable:no-any\nexport const DOM = {\n  createDocumentFragment(markupOrNode?: string | IElement): IDocumentFragment {\n    if (markupOrNode === undefined || markupOrNode === null) {\n      return <IDocumentFragment>document.createDocumentFragment();\n    }\n    if ((<IElement>markupOrNode).nodeType > 0) {\n      if ((<IElement>markupOrNode).content !== undefined) {\n        return (<IElement>markupOrNode).content;\n      }\n      const fragment = document.createDocumentFragment();\n      fragment.appendChild(<any>markupOrNode);\n      return <IDocumentFragment>fragment;\n    }\n    return DOM.createTemplate(<string>markupOrNode).content;\n  },\n  createTemplate(markup?: string): IElement {\n    if (markup === undefined) {\n      return <IElement>document.createElement('template');\n    }\n    const template = document.createElement('template');\n    template.innerHTML = markup;\n    return <IElement>template;\n  },\n  addClass(node: INode, className: string): void {\n    (<any>node).classList.add(className);\n  },\n  addEventListener(eventName: string, subscriber: any, publisher?: INode, options?: any): void {\n    ((<any>publisher) || document).addEventListener(eventName, subscriber, options);\n  },\n  appendChild(parent: INode, child: INode): void {\n    (<any>parent).appendChild(child);\n  },\n  attachShadow(host: IElement, options: ShadowRootInit): IDocumentFragment {\n    return (<any>host).attachShadow(options);\n  },\n  cloneNode<T extends INode = INode>(node: T, deep?: boolean): T {\n    return (<any>node).cloneNode(deep !== false); // use true unless the caller explicitly passes in false\n  },\n  convertToRenderLocation(node: INode): IRenderLocation {\n    if (isRenderLocation(node)) {\n      return node; // it's already a RenderLocation (converted by FragmentNodeSequence)\n    }\n    if ((<any>node).parentNode === null) {\n      throw Reporter.error(52);\n    }\n    const locationEnd = <IRenderLocation>document.createComment('au-end');\n    const locationStart = <IRenderLocation>document.createComment('au-start');\n    DOM.replaceNode(locationEnd, node);\n    DOM.insertBefore(locationStart, locationEnd);\n    locationEnd.$start = locationStart;\n    locationStart.$nodes = null;\n    return locationEnd;\n  },\n  createComment(text: string): IComment {\n    return <IComment>document.createComment(text);\n  },\n  createElement(name: string): IElement {\n    return document.createElement(name);\n  },\n  createNodeObserver(target: INode, callback: MutationCallback, options: MutationObserverInit): MutationObserver {\n    const observer = new MutationObserver(callback);\n    observer.observe(<any>target, options);\n    return observer;\n  },\n  createTextNode(text: string): IText {\n    return <IText>document.createTextNode(text);\n  },\n  getAttribute(node: INode, name: string): any {\n    return (<any>node).getAttribute(name);\n  },\n  hasClass(node: INode, className: string): boolean {\n    return (<any>node).classList.contains(className);\n  },\n  insertBefore(nodeToInsert: INode, referenceNode: INode): void {\n    (<any>referenceNode).parentNode.insertBefore(nodeToInsert, referenceNode);\n  },\n  isAllWhitespace(node: INode): boolean {\n    if ((<any>node).auInterpolationTarget === true) {\n      return false;\n    }\n    const text = node.textContent;\n    const len = text.length;\n    let i = 0;\n    // for perf benchmark of this compared to the regex method: http://jsben.ch/p70q2 (also a general case against using regex)\n    while (i < len) {\n      // charCodes 0-0x20(32) can all be considered whitespace (non-whitespace chars in this range don't have a visual representation anyway)\n      if (text.charCodeAt(i) > 0x20) {\n        return false;\n      }\n      i++;\n    }\n    return true;\n  },\n  isCommentNodeType(node: INode): node is IComment {\n    return node.nodeType === COMMENT_NODE;\n  },\n  isDocumentFragmentType(node: INode): node is IDocumentFragment {\n    return node.nodeType === DOCUMENT_FRAGMENT_NODE;\n  },\n  isElementNodeType(node: INode): node is IElement {\n    return node.nodeType === ELEMENT_NODE;\n  },\n  isNodeInstance(potentialNode: any): potentialNode is INode {\n    return potentialNode.nodeType > 0;\n  },\n  isTextNodeType(node: INode): node is IText {\n    return node.nodeType === TEXT_NODE;\n  },\n  migrateChildNodes(currentParent: INode, newParent: INode): void {\n    while (currentParent.firstChild) {\n      DOM.appendChild(newParent, currentParent.firstChild);\n    }\n  },\n  registerElementResolver(container: IContainer, resolver: IResolver): void {\n    container.registerResolver(INode, resolver);\n    container.registerResolver(Element, resolver);\n    container.registerResolver(HTMLElement, resolver);\n    container.registerResolver(SVGElement, resolver);\n  },\n  remove(node: INodeLike): void {\n    if ((<any>node).remove) {\n      (<any>node).remove();\n    } else {\n      (<any>node).parentNode.removeChild(node);\n    }\n  },\n  removeAttribute(node: INode, name: string): void {\n    (<any>node).removeAttribute(name);\n  },\n  removeClass(node: INode, className: string): void {\n    (<any>node).classList.remove(className);\n  },\n  removeEventListener(eventName: string, subscriber: any, publisher?: INode, options?: any): void {\n    ((<any>publisher) || document).removeEventListener(eventName, subscriber, options);\n  },\n  replaceNode(newChild: INode, oldChild: INode): void {\n    if (oldChild.parentNode) {\n      (<any>oldChild).parentNode.replaceChild(newChild, oldChild);\n    }\n  },\n  setAttribute(node: INode, name: string, value: any): void {\n    (<any>node).setAttribute(name, value);\n  },\n  treatAsNonWhitespace(node: INode): void {\n    // see isAllWhitespace above\n    (<any>node).auInterpolationTarget = true;\n  }\n};\n\n// This is an implementation of INodeSequence that represents \"no DOM\" to render.\n// It's used in various places to avoid null and to encode\n// the explicit idea of \"no view\".\nconst emptySequence: INodeSequence = {\n  firstChild: null,\n  lastChild: null,\n  childNodes: PLATFORM.emptyArray,\n  findTargets(): ReturnType<INodeSequence['findTargets']> { return PLATFORM.emptyArray; },\n  insertBefore(refNode: INode): ReturnType<INodeSequence['insertBefore']> { /*do nothing*/ },\n  appendTo(parent: INode): ReturnType<INodeSequence['appendTo']> { /*do nothing*/ },\n  remove(): ReturnType<INodeSequence['remove']> { /*do nothing*/ }\n};\n\nexport const NodeSequence = {\n  empty: emptySequence\n};\n\n/**\n * An specialized INodeSequence with optimizations for text (interpolation) bindings\n * The contract of this INodeSequence is:\n * - the previous element is an `au-marker` node\n * - text is the actual text node\n */\nexport class TextNodeSequence implements INodeSequence {\n  public firstChild: IText;\n  public lastChild: IText;\n  public childNodes: IText[];\n\n  private targets: [INode];\n\n  constructor(text: IText) {\n    this.firstChild = text;\n    this.lastChild = text;\n    this.childNodes = [text];\n    this.targets = [new AuMarker(text)];\n  }\n\n  public findTargets(): ArrayLike<INode> {\n    return this.targets;\n  }\n\n  public insertBefore(refNode: INode): void {\n    (<any>refNode).parentNode.insertBefore(this.firstChild, refNode);\n  }\n\n  public appendTo(parent: INode): void {\n    (<any>parent).appendChild(this.firstChild);\n  }\n\n  public remove(): void {\n    (<any>this.firstChild).remove();\n  }\n}\n// tslint:enable:no-any\n\n// This is the most common form of INodeSequence.\n// Every custom element or template controller whose node sequence is based on an HTML template\n// has an instance of this under the hood. Anyone who wants to create a node sequence from\n// a string of markup would also receive an instance of this.\n// CompiledTemplates create instances of FragmentNodeSequence.\n/*@internal*/\nexport class FragmentNodeSequence implements INodeSequence {\n  public firstChild: INode;\n  public lastChild: INode;\n  public childNodes: INode[];\n\n  private fragment: IDocumentFragment;\n  private targets: ArrayLike<INode>;\n\n  private start: IRenderLocation;\n  private end: IRenderLocation;\n\n  constructor(fragment: IDocumentFragment) {\n    this.fragment = fragment;\n    // tslint:disable-next-line:no-any\n    const targetNodeList = (<any>fragment).querySelectorAll('.au');\n    let i = 0;\n    let ii = targetNodeList.length;\n    const targets = this.targets = Array(ii);\n    while (i < ii) {\n      // eagerly convert all markers to IRenderLocations (otherwise the renderer\n      // will do it anyway) and store them in the target list (since the comments\n      // can't be queried)\n      const target = targetNodeList[i];\n      if (target.nodeName === 'AU-MARKER') {\n        // note the renderer will still call this method, but it will just return the\n        // location if it sees it's already a location\n        targets[i] = DOM.convertToRenderLocation(target);\n      } else {\n        // also store non-markers for consistent ordering\n        targets[i] = target;\n      }\n      ++i;\n    }\n    const childNodeList = fragment.childNodes;\n    i = 0;\n    ii = childNodeList.length;\n    const childNodes = this.childNodes = Array(ii);\n    while (i < ii) {\n      childNodes[i] = childNodeList[i] as Writable<INode>;\n      ++i;\n    }\n\n    this.firstChild = fragment.firstChild;\n    this.lastChild = fragment.lastChild;\n\n    this.start = this.end = null;\n  }\n\n  public findTargets(): ArrayLike<INode> {\n    // tslint:disable-next-line:no-any\n    return this.targets;\n  }\n\n  public insertBefore(refNode: IRenderLocation): void {\n    // tslint:disable-next-line:no-any\n    (<any>refNode).parentNode.insertBefore(this.fragment, refNode);\n    // internally we could generally assume that this is an IRenderLocation,\n    // but since this is also public API we still need to double check\n    // (or horrible things might happen)\n    if (isRenderLocation(refNode)) {\n      this.end = refNode;\n      const start = this.start = refNode.$start;\n      if (start.$nodes === null) {\n        start.$nodes = this;\n      } else {\n        // if more than one NodeSequence uses the same RenderLocation, it's an child\n        // of a repeater (or something similar) and we shouldn't remove all nodes between\n        // start - end since that would always remove all items from a repeater, even\n        // when only one is removed\n        // so we set $nodes to PLATFORM.emptyObject to 1) tell other sequences that it's\n        // occupied and 2) prevent start.$nodes === this from ever evaluating to true\n        // during remove()\n        start.$nodes = PLATFORM.emptyObject;\n      }\n    }\n  }\n\n  public appendTo(parent: INode): void {\n    // tslint:disable-next-line:no-any\n    (<any>parent).appendChild(this.fragment);\n    // this can never be a RenderLocation, and if for whatever reason we moved\n    // from a RenderLocation to a host, make sure \"start\" and \"end\" are null\n    this.start = this.end = null;\n  }\n\n  public remove(): void {\n    const fragment = this.fragment;\n    if (this.start !== null && this.start.$nodes === this) {\n      // if we're between a valid \"start\" and \"end\" (e.g. if/else, containerless, or a\n      // repeater with a single item) then simply remove everything in-between (but not\n      // the comments themselves as they belong to the parent)\n      const end = this.end;\n      let next: INode;\n      let current = this.start.nextSibling;\n      while (current !== end) {\n        next = current.nextSibling;\n        // tslint:disable-next-line:no-any\n        (<any>fragment).appendChild(current);\n        current = next;\n      }\n      this.start.$nodes = null;\n      this.start = this.end = null;\n    } else {\n      // otherwise just remove from first to last child in the regular way\n      let current = this.firstChild;\n\n      if (current.parentNode !== fragment) {\n        const end = this.lastChild;\n        let next: INode;\n\n        while (current !== null) {\n          next = current.nextSibling;\n          // tslint:disable-next-line:no-any\n          (<any>fragment).appendChild(current);\n\n          if (current === end) {\n            break;\n          }\n\n          current = next;\n        }\n      }\n    }\n  }\n}\n\ninterface ICloneableNode extends INode {\n  cloneNode(deep?: boolean): ICloneableNode;\n}\n\nexport interface INodeSequenceFactory {\n  createNodeSequence(): INodeSequence;\n}\n\nexport class NodeSequenceFactory {\n  private readonly deepClone: boolean;\n  private readonly node: ICloneableNode;\n  private readonly Type: Constructable<INodeSequence>;\n  constructor(fragment: IDocumentFragment) {\n    const childNodes = fragment.childNodes;\n    switch (childNodes.length) {\n      case 0:\n        this.createNodeSequence = () => NodeSequence.empty;\n        return;\n      case 2:\n        const target = childNodes[0];\n        if (target.nodeName === 'AU-MARKER' || target.nodeName === '#comment') {\n          const text = childNodes[1];\n          if (text.nodeType === TEXT_NODE && text.textContent === ' ') {\n            text.textContent = '';\n            this.deepClone = false;\n            this.node = <ICloneableNode>text;\n            this.Type = TextNodeSequence;\n            return;\n          }\n        }\n      // falls through if not returned\n      default:\n        this.deepClone = true;\n        this.node = <ICloneableNode>fragment;\n        this.Type = FragmentNodeSequence;\n    }\n  }\n\n  public static createFor(markupOrNode: string | INode): NodeSequenceFactory {\n    const fragment = DOM.createDocumentFragment(markupOrNode);\n    return new NodeSequenceFactory(fragment);\n  }\n\n  public createNodeSequence(): INodeSequence {\n    return new this.Type(this.node.cloneNode(this.deepClone));\n  }\n}\n\n/*@internal*/\nexport class AuMarker implements INode {\n  public get parentNode(): INode {\n    return this.nextSibling.parentNode;\n  }\n  public readonly nextSibling: INode;\n  public readonly previousSibling: INode;\n  public readonly content?: INode;\n  public readonly firstChild: INode;\n  public readonly lastChild: INode;\n  public readonly childNodes: ArrayLike<INode>;\n  public readonly nodeName: 'AU-MARKER';\n  public readonly nodeType: typeof ELEMENT_NODE;\n  public textContent: string = '';\n\n  constructor(next: INode) {\n    this.nextSibling = next;\n  }\n  public remove(): void { /* do nothing */ }\n}\n(proto => {\n  proto.previousSibling = null;\n  proto.firstChild = null;\n  proto.lastChild = null;\n  proto.childNodes = PLATFORM.emptyArray;\n  proto.nodeName = 'AU-MARKER';\n  proto.nodeType = ELEMENT_NODE;\n})(<Writable<AuMarker>>AuMarker.prototype);\n","import { IIndexable, Primitive } from '@aurelia/kernel';\nimport {\n  IBatchedCollectionSubscriber, IBatchedSubscriberCollection, IndexMap, IPropertySubscriber,\n  ISubscriberCollection, LifecycleFlags, MutationKind, MutationKindToBatchedSubscriber,\n  MutationKindToSubscriber, SubscriberFlags\n} from '../observation';\n\nexport function subscriberCollection<T extends MutationKind>(mutationKind: T): ClassDecorator {\n  return function(target: Function): void {\n    const proto = <ISubscriberCollection<MutationKind.instance | MutationKind.collection>>target.prototype;\n\n    proto._subscriberFlags = SubscriberFlags.None;\n    proto._subscriber0 = null;\n    proto._subscriber1 = null;\n    proto._subscriber2 = null;\n    proto._subscribersRest = null;\n\n    proto.addSubscriber = addSubscriber;\n    proto.removeSubscriber = removeSubscriber;\n    proto.hasSubscriber = hasSubscriber;\n    proto.hasSubscribers = hasSubscribers;\n    proto.callSubscribers = (mutationKind === MutationKind.instance ? callPropertySubscribers : callCollectionSubscribers);\n  };\n}\n\nfunction addSubscriber<T extends MutationKind>(this: ISubscriberCollection<T>, subscriber: MutationKindToSubscriber<T>): boolean {\n  if (this.hasSubscriber(subscriber)) {\n    return false;\n  }\n  const subscriberFlags = this._subscriberFlags;\n  if (!(subscriberFlags & SubscriberFlags.Subscriber0)) {\n    this._subscriber0 = subscriber;\n    this._subscriberFlags |= SubscriberFlags.Subscriber0;\n    return true;\n  }\n  if (!(subscriberFlags & SubscriberFlags.Subscriber1)) {\n    this._subscriber1 = subscriber;\n    this._subscriberFlags |= SubscriberFlags.Subscriber1;\n    return true;\n  }\n  if (!(subscriberFlags & SubscriberFlags.Subscriber2)) {\n    this._subscriber2 = subscriber;\n    this._subscriberFlags |= SubscriberFlags.Subscriber2;\n    return true;\n  }\n  if (!(subscriberFlags & SubscriberFlags.SubscribersRest)) {\n    this._subscribersRest = [subscriber];\n    this._subscriberFlags |= SubscriberFlags.SubscribersRest;\n    return true;\n  }\n  this._subscribersRest.push(subscriber);\n  return true;\n}\n\nfunction removeSubscriber<T extends MutationKind>(this: ISubscriberCollection<T>, subscriber: IPropertySubscriber): boolean {\n  const subscriberFlags = this._subscriberFlags;\n  if ((subscriberFlags & SubscriberFlags.Subscriber0) && this._subscriber0 === subscriber) {\n    this._subscriber0 = null;\n    this._subscriberFlags &= ~SubscriberFlags.Subscriber0;\n    return true;\n  }\n  if ((subscriberFlags & SubscriberFlags.Subscriber1) && this._subscriber1 === subscriber) {\n    this._subscriber1 = null;\n    this._subscriberFlags &= ~SubscriberFlags.Subscriber1;\n    return true;\n  }\n  if ((subscriberFlags & SubscriberFlags.Subscriber2) && this._subscriber2 === subscriber) {\n    this._subscriber2 = null;\n    this._subscriberFlags &= ~SubscriberFlags.Subscriber2;\n    return true;\n  }\n  if (subscriberFlags & SubscriberFlags.SubscribersRest) {\n    const subscribers = this._subscribersRest;\n    for (let i = 0, ii = subscribers.length; i < ii; ++i) {\n      if (subscribers[i] === subscriber) {\n        subscribers.splice(i, 1);\n        if (ii === 1) {\n          this._subscriberFlags &= ~SubscriberFlags.SubscribersRest;\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction callPropertySubscribers(\n  this: ISubscriberCollection<MutationKind.instance>,\n  newValue: IIndexable | Primitive,\n  previousValue: IIndexable | Primitive,\n  flags: LifecycleFlags): void {\n  /**\n   * Note: change handlers may have the side-effect of adding/removing subscribers to this collection during this\n   * callSubscribers invocation, so we're caching them all before invoking any.\n   * Subscribers added during this invocation are not invoked (and they shouldn't be).\n   * Subscribers removed during this invocation will still be invoked (and they also shouldn't be,\n   * however this is accounted for via $isBound and similar flags on the subscriber objects)\n   */\n  const subscriber0 = this._subscriber0;\n  const subscriber1 = this._subscriber1;\n  const subscriber2 = this._subscriber2;\n  let subscribers = this._subscribersRest;\n  if (subscribers !== null) {\n    subscribers = subscribers.slice();\n  }\n  if (subscriber0 !== null) {\n    subscriber0.handleChange(newValue, previousValue, flags);\n  }\n  if (subscriber1 !== null) {\n    subscriber1.handleChange(newValue, previousValue, flags);\n  }\n  if (subscriber2 !== null) {\n    subscriber2.handleChange(newValue, previousValue, flags);\n  }\n  const length = subscribers && subscribers.length;\n  if (length !== undefined && length > 0) {\n    for (let i = 0; i < length; ++i) {\n      const subscriber = subscribers[i];\n      if (subscriber !== null) {\n        subscriber.handleChange(newValue, previousValue, flags);\n      }\n    }\n  }\n}\n\nfunction callCollectionSubscribers(this: ISubscriberCollection<MutationKind.collection> & Required<IBatchedSubscriberCollection<MutationKind.collection>>, origin: string, args: IArguments | null, flags: LifecycleFlags): void {\n  const subscriber0 = this._subscriber0;\n  const subscriber1 = this._subscriber1;\n  const subscriber2 = this._subscriber2;\n  let subscribers = this._subscribersRest;\n  if (subscribers !== null) {\n    subscribers = subscribers.slice();\n  }\n  if (subscriber0 !== null) {\n    subscriber0.handleChange(origin, args, flags);\n  }\n  if (subscriber1 !== null) {\n    subscriber1.handleChange(origin, args, flags);\n  }\n  if (subscriber2 !== null) {\n    subscriber2.handleChange(origin, args, flags);\n  }\n  const length = subscribers && subscribers.length;\n  if (length !== undefined && length > 0) {\n    for (let i = 0; i < length; ++i) {\n      const subscriber = subscribers[i];\n      if (subscriber !== null) {\n        subscriber.handleChange(origin, args, flags);\n      }\n    }\n  }\n  this.lifecycle.enqueueFlush(this);\n}\n\nfunction hasSubscribers<T extends MutationKind>(this: ISubscriberCollection<T>): boolean {\n  return this._subscriberFlags !== SubscriberFlags.None;\n}\n\nfunction hasSubscriber<T extends MutationKind>(this: ISubscriberCollection<T>, subscriber: IPropertySubscriber): boolean {\n  // Flags here is just a perf tweak\n  // Compared to not using flags, it's a moderate speed-up when this collection does not have the subscriber;\n  // and minor slow-down when it does, and the former is more common than the latter.\n  const subscriberFlags = this._subscriberFlags;\n  if ((subscriberFlags & SubscriberFlags.Subscriber0) && this._subscriber0 === subscriber) {\n    return true;\n  }\n  if ((subscriberFlags & SubscriberFlags.Subscriber1) && this._subscriber1 === subscriber) {\n    return true;\n  }\n  if ((subscriberFlags & SubscriberFlags.Subscriber2) && this._subscriber2 === subscriber) {\n    return true;\n  }\n  if (subscriberFlags & SubscriberFlags.SubscribersRest) {\n    // no need to check length; if the flag is set, there's always at least one\n    const subscribers = this._subscribersRest;\n    for (let i = 0, ii = subscribers.length; i < ii; ++i) {\n      if (subscribers[i] === subscriber) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nexport function batchedSubscriberCollection(): ClassDecorator {\n  return function(target: Function): void {\n    const proto = <IBatchedSubscriberCollection<MutationKind.collection>>target.prototype;\n\n    proto._batchedSubscriberFlags = SubscriberFlags.None;\n    proto._batchedSubscriber0 = null;\n    proto._batchedSubscriber1 = null;\n    proto._batchedSubscriber2 = null;\n    proto._batchedSubscribersRest = null;\n\n    proto.addBatchedSubscriber = addBatchedSubscriber;\n    proto.removeBatchedSubscriber = removeBatchedSubscriber;\n    proto.hasBatchedSubscriber = hasBatchedSubscriber;\n    proto.hasBatchedSubscribers = hasBatchedSubscribers;\n    proto.callBatchedSubscribers = callBatchedCollectionSubscribers;\n  };\n}\n\nfunction addBatchedSubscriber(this: IBatchedSubscriberCollection<MutationKind.collection>, subscriber: MutationKindToBatchedSubscriber<MutationKind.collection>): boolean {\n  if (this.hasBatchedSubscriber(subscriber)) {\n    return false;\n  }\n  const subscriberFlags = this._batchedSubscriberFlags;\n  if (!(subscriberFlags & SubscriberFlags.Subscriber0)) {\n    this._batchedSubscriber0 = subscriber;\n    this._batchedSubscriberFlags |= SubscriberFlags.Subscriber0;\n    return true;\n  }\n  if (!(subscriberFlags & SubscriberFlags.Subscriber1)) {\n    this._batchedSubscriber1 = subscriber;\n    this._batchedSubscriberFlags |= SubscriberFlags.Subscriber1;\n    return true;\n  }\n  if (!(subscriberFlags & SubscriberFlags.Subscriber2)) {\n    this._batchedSubscriber2 = subscriber;\n    this._batchedSubscriberFlags |= SubscriberFlags.Subscriber2;\n    return true;\n  }\n  if (!(subscriberFlags & SubscriberFlags.SubscribersRest)) {\n    this._batchedSubscribersRest = [subscriber];\n    this._batchedSubscriberFlags |= SubscriberFlags.SubscribersRest;\n    return true;\n  }\n  this._batchedSubscribersRest.push(subscriber);\n  return true;\n}\n\nfunction removeBatchedSubscriber(this: IBatchedSubscriberCollection<MutationKind.collection>, subscriber: IBatchedCollectionSubscriber): boolean {\n  const subscriberFlags = this._batchedSubscriberFlags;\n  if ((subscriberFlags & SubscriberFlags.Subscriber0) && this._batchedSubscriber0 === subscriber) {\n    this._batchedSubscriber0 = null;\n    this._batchedSubscriberFlags &= ~SubscriberFlags.Subscriber0;\n    return true;\n  }\n  if ((subscriberFlags & SubscriberFlags.Subscriber1) && this._batchedSubscriber1 === subscriber) {\n    this._batchedSubscriber1 = null;\n    this._batchedSubscriberFlags &= ~SubscriberFlags.Subscriber1;\n    return true;\n  }\n  if ((subscriberFlags & SubscriberFlags.Subscriber2) && this._batchedSubscriber2 === subscriber) {\n    this._batchedSubscriber2 = null;\n    this._batchedSubscriberFlags &= ~SubscriberFlags.Subscriber2;\n    return true;\n  }\n  if (subscriberFlags & SubscriberFlags.SubscribersRest) {\n    const subscribers = this._batchedSubscribersRest;\n    for (let i = 0, ii = subscribers.length; i < ii; ++i) {\n      if (subscribers[i] === subscriber) {\n        subscribers.splice(i, 1);\n        if (ii === 1) {\n          this._batchedSubscriberFlags &= ~SubscriberFlags.SubscribersRest;\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction callBatchedCollectionSubscribers(this: IBatchedSubscriberCollection<MutationKind.collection>, indexMap: IndexMap): void {\n  const subscriber0 = this._batchedSubscriber0;\n  const subscriber1 = this._batchedSubscriber1;\n  const subscriber2 = this._batchedSubscriber2;\n  let subscribers = this._batchedSubscribersRest;\n  if (subscribers !== null) {\n    subscribers = subscribers.slice();\n  }\n  if (subscriber0 !== null) {\n    subscriber0.handleBatchedChange(indexMap);\n  }\n  if (subscriber1 !== null) {\n    subscriber1.handleBatchedChange(indexMap);\n  }\n  if (subscriber2 !== null) {\n    subscriber2.handleBatchedChange(indexMap);\n  }\n  const length = subscribers && subscribers.length;\n  if (length !== undefined && length > 0) {\n    for (let i = 0; i < length; ++i) {\n      const subscriber = subscribers[i];\n      if (subscriber !== null) {\n        subscriber.handleBatchedChange(indexMap);\n      }\n    }\n  }\n}\n\nfunction hasBatchedSubscribers(this: IBatchedSubscriberCollection<MutationKind.collection>): boolean {\n  return this._batchedSubscriberFlags !== SubscriberFlags.None;\n}\n\nfunction hasBatchedSubscriber(this: IBatchedSubscriberCollection<MutationKind.collection>, subscriber: IBatchedCollectionSubscriber): boolean {\n  // Flags here is just a perf tweak\n  // Compared to not using flags, it's a moderate speed-up when this collection does not have the subscriber;\n  // and minor slow-down when it does, and the former is more common than the latter.\n  const subscriberFlags = this._batchedSubscriberFlags;\n  if ((subscriberFlags & SubscriberFlags.Subscriber0) && this._batchedSubscriber0 === subscriber) {\n    return true;\n  }\n  if ((subscriberFlags & SubscriberFlags.Subscriber1) && this._batchedSubscriber1 === subscriber) {\n    return true;\n  }\n  if ((subscriberFlags & SubscriberFlags.Subscriber2) && this._batchedSubscriber2 === subscriber) {\n    return true;\n  }\n  if (subscriberFlags & SubscriberFlags.SubscribersRest) {\n    // no need to check length; if the flag is set, there's always at least one\n    const subscribers = this._batchedSubscribersRest;\n    for (let i = 0, ii = subscribers.length; i < ii; ++i) {\n      if (subscribers[i] === subscriber) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n","import { IIndexable, Primitive } from '@aurelia/kernel';\nimport { DOM } from '../dom';\nimport { ILifecycle } from '../lifecycle';\nimport { IBindingTargetAccessor, LifecycleFlags, MutationKind } from '../observation';\nimport { subscriberCollection } from './subscriber-collection';\n\ntype BindingTargetAccessor = IBindingTargetAccessor & {\n  lifecycle: ILifecycle;\n  currentFlags: LifecycleFlags;\n  oldValue?: IIndexable | Primitive;\n  defaultValue: Primitive | IIndexable;\n  $nextFlush?: BindingTargetAccessor;\n  flush(flags: LifecycleFlags): void;\n  setValueCore(value: Primitive | IIndexable, flags: LifecycleFlags): void;\n};\n\nfunction setValue(this: BindingTargetAccessor, newValue: Primitive | IIndexable, flags: LifecycleFlags): Promise<void> {\n  const currentValue = this.currentValue;\n  newValue = newValue === null || newValue === undefined ? this.defaultValue : newValue;\n  if (currentValue !== newValue) {\n    this.currentValue = newValue;\n    if ((flags & (LifecycleFlags.fromFlush | LifecycleFlags.fromBind)) &&\n      !((flags & LifecycleFlags.doNotUpdateDOM) && DOM.isNodeInstance(this.obj))) {\n      this.setValueCore(newValue, flags);\n    } else {\n      this.currentFlags = flags;\n      return this.lifecycle.enqueueFlush(this);\n    }\n  }\n  return Promise.resolve();\n}\n\nfunction flush(this: BindingTargetAccessor, flags: LifecycleFlags): void {\n  if (flags & LifecycleFlags.doNotUpdateDOM) {\n    if (DOM.isNodeInstance(this.obj)) {\n      // re-queue the change so it will still propagate on flush when it's attached again\n      this.lifecycle.enqueueFlush(this);\n      return;\n    }\n  }\n  const currentValue = this.currentValue;\n  // we're doing this check because a value could be set multiple times before a flush, and the final value could be the same as the original value\n  // in which case the target doesn't need to be updated\n  if (this.oldValue !== currentValue) {\n    this.setValueCore(currentValue, this.currentFlags | flags | LifecycleFlags.updateTargetInstance);\n    this.oldValue = this.currentValue;\n  }\n}\n\nfunction dispose(this: BindingTargetAccessor): void {\n  this.currentValue = null;\n  this.oldValue = null;\n  this.defaultValue = null;\n\n  this.obj = null;\n  this.propertyKey = '';\n}\n\nexport function targetObserver(defaultValue: Primitive | IIndexable = null): ClassDecorator {\n  return function(target: Function): void {\n    subscriberCollection(MutationKind.instance)(target);\n    const proto = <BindingTargetAccessor>target.prototype;\n\n    proto.$nextFlush = null;\n\n    proto.currentValue = defaultValue;\n    proto.oldValue = defaultValue;\n    proto.defaultValue = defaultValue;\n\n    proto.obj = null;\n    proto.propertyKey = '';\n\n    proto.setValue = proto.setValue || setValue;\n    proto.flush = proto.flush || flush;\n    proto.dispose = proto.dispose || dispose;\n  };\n}\n","import { IIndexable, Primitive } from '@aurelia/kernel';\nimport { DOM, IHTMLElement, INode } from '../dom';\nimport { ILifecycle } from '../lifecycle';\nimport { IBindingTargetAccessor } from '../observation';\nimport { targetObserver } from './target-observer';\n\n// tslint:disable-next-line:no-http-string\nconst xlinkAttributeNS = 'http://www.w3.org/1999/xlink';\n\nexport interface XLinkAttributeAccessor extends IBindingTargetAccessor<IHTMLElement, string, string> {}\n\n@targetObserver('')\nexport class XLinkAttributeAccessor implements XLinkAttributeAccessor {\n  public currentValue: string;\n  public oldValue: string;\n  public defaultValue: string;\n\n  // xlink namespaced attributes require getAttributeNS/setAttributeNS\n  // (even though the NS version doesn't work for other namespaces\n  // in html5 documents)\n\n  // Using very HTML-specific code here since this isn't likely to get\n  // called unless operating against a real HTML element.\n\n  constructor(\n    public lifecycle: ILifecycle,\n    public obj: IHTMLElement,\n    public propertyKey: string,\n    public attributeName: string) {\n\n    this.oldValue = this.currentValue = this.getValue();\n  }\n\n  public getValue(): string {\n    return this.obj.getAttributeNS(xlinkAttributeNS, this.attributeName);\n  }\n\n  public setValueCore(newValue: string): void {\n    this.obj.setAttributeNS(xlinkAttributeNS, this.attributeName, newValue);\n  }\n}\n\nXLinkAttributeAccessor.prototype.attributeName = '';\n\nexport interface DataAttributeAccessor extends IBindingTargetAccessor<INode, string, string> {}\n\n@targetObserver()\nexport class DataAttributeAccessor implements DataAttributeAccessor {\n  public currentValue: string;\n  public oldValue: string;\n  public defaultValue: string;\n\n  constructor(\n    public lifecycle: ILifecycle,\n    public obj: INode,\n    public propertyKey: string) {\n\n    this.oldValue = this.currentValue = this.getValue();\n  }\n\n  public getValue(): string {\n    return DOM.getAttribute(this.obj, this.propertyKey);\n  }\n\n  public setValueCore(newValue: string): void {\n    if (newValue === null) {\n      DOM.removeAttribute(this.obj, this.propertyKey);\n    } else {\n      DOM.setAttribute(this.obj, this.propertyKey, newValue);\n    }\n  }\n}\n\nexport interface StyleAttributeAccessor extends IBindingTargetAccessor<IHTMLElement, 'style', string | IIndexable> {}\n\n@targetObserver()\nexport class StyleAttributeAccessor implements StyleAttributeAccessor {\n  public currentValue: string | IIndexable;\n  public oldValue: string | IIndexable;\n  public defaultValue: string | IIndexable;\n\n  public propertyKey: 'style';\n\n  public styles: IIndexable;\n  public version: number;\n\n  constructor(\n    public lifecycle: ILifecycle,\n    public obj: IHTMLElement) {\n\n    this.oldValue = this.currentValue = obj.style.cssText;\n  }\n\n  public getValue(): string {\n    return this.obj.style.cssText;\n  }\n\n  // tslint:disable-next-line:function-name\n  public _setProperty(style: string, value: string): void {\n    let priority = '';\n\n    if (value !== null && value !== undefined && typeof value.indexOf === 'function' && value.indexOf('!important') !== -1) {\n      priority = 'important';\n      value = value.replace('!important', '');\n    }\n\n    this.obj.style.setProperty(style, value, priority);\n  }\n\n  public setValueCore(newValue: string | IIndexable): void {\n    const styles = this.styles || {};\n    let style;\n    let version = this.version;\n\n    if (newValue !== null) {\n      if (newValue instanceof Object) {\n        let value;\n        for (style in (<Object>newValue)) {\n          if (newValue.hasOwnProperty(style)) {\n            value = newValue[style];\n            style = style.replace(/([A-Z])/g, m => `-${m.toLowerCase()}`);\n            styles[style] = version;\n            this._setProperty(style, value);\n          }\n        }\n      } else if ((<string>newValue).length) {\n        const rx = /\\s*([\\w\\-]+)\\s*:\\s*((?:(?:[\\w\\-]+\\(\\s*(?:\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'|[\\w\\-]+\\(\\s*(?:^\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'|[^\\)]*)\\),?|[^\\)]*)\\),?|\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'|[^;]*),?\\s*)+);?/g;\n        let pair;\n        while ((pair = rx.exec(newValue)) !== null) {\n          style = pair[1];\n          if (!style) { continue; }\n\n          styles[style] = version;\n          this._setProperty(style, pair[2]);\n        }\n      }\n    }\n\n    this.styles = styles;\n    this.version += 1;\n    if (version === 0) {\n      return;\n    }\n\n    version -= 1;\n    for (style in styles) {\n      if (!styles.hasOwnProperty(style) || styles[style] !== version) {\n        continue;\n      }\n      this.obj.style.removeProperty(style);\n    }\n  }\n}\n\nStyleAttributeAccessor.prototype.styles = null;\nStyleAttributeAccessor.prototype.version = 0;\nStyleAttributeAccessor.prototype.propertyKey = 'style';\n\nexport interface ClassAttributeAccessor extends IBindingTargetAccessor<INode, string, string> {}\n\n@targetObserver('')\nexport class ClassAttributeAccessor implements ClassAttributeAccessor {\n  public currentValue: string;\n  public oldValue: string;\n  public defaultValue: string;\n\n  public doNotCache: true;\n  public version: number;\n  public nameIndex: IIndexable;\n\n  constructor(\n    public lifecycle: ILifecycle,\n    public obj: INode) { }\n\n  public getValue(): string {\n    return this.currentValue;\n  }\n\n  public setValueCore(newValue: string): void {\n    const nameIndex = this.nameIndex || {};\n    let version = this.version;\n    let names;\n    let name;\n\n    // Add the classes, tracking the version at which they were added.\n    if (newValue.length) {\n      const node = this.obj;\n      names = newValue.split(/\\s+/);\n      for (let i = 0, length = names.length; i < length; i++) {\n        name = names[i];\n        if (!name.length) {\n          continue;\n        }\n        nameIndex[name] = version;\n        DOM.addClass(node, name);\n      }\n    }\n\n    // Update state variables.\n    this.nameIndex = nameIndex;\n    this.version += 1;\n\n    // First call to setValue?  We're done.\n    if (version === 0) {\n      return;\n    }\n\n    // Remove classes from previous version.\n    version -= 1;\n    for (name in nameIndex) {\n      if (!nameIndex.hasOwnProperty(name) || nameIndex[name] !== version) {\n        continue;\n      }\n\n      // TODO: this has the side-effect that classes already present which are added again,\n      // will be removed if they're not present in the next update.\n      // Better would be do have some configurability for this behavior, allowing the user to\n      // decide whether initial classes always need to be kept, always removed, or something in between\n      DOM.removeClass(this.obj, name);\n    }\n  }\n}\n\nClassAttributeAccessor.prototype.doNotCache = true;\nClassAttributeAccessor.prototype.version = 0;\nClassAttributeAccessor.prototype.nameIndex = null;\n\nexport interface ElementPropertyAccessor extends IBindingTargetAccessor<IIndexable, string, Primitive | IIndexable> {}\n\n@targetObserver('')\nexport class ElementPropertyAccessor implements ElementPropertyAccessor {\n  constructor(\n    public lifecycle: ILifecycle,\n    public obj: IIndexable,\n    public propertyKey: string) { }\n\n  public getValue(): Primitive | IIndexable {\n    return this.obj[this.propertyKey];\n  }\n\n  public setValueCore(value: Primitive | IIndexable): void {\n    this.obj[this.propertyKey] = value;\n  }\n}\n\nexport interface PropertyAccessor extends IBindingTargetAccessor<IIndexable, string, Primitive | IIndexable> {}\n\nexport class PropertyAccessor implements PropertyAccessor {\n  constructor(public obj: IIndexable, public propertyKey: string) { }\n\n  public getValue(): Primitive | IIndexable {\n    return this.obj[this.propertyKey];\n  }\n\n  public setValue(value: Primitive | IIndexable): void {\n    this.obj[this.propertyKey] = value;\n  }\n}\n","import { ILifecycle } from '../../lifecycle';\nimport { IScope, LifecycleFlags } from '../../observation';\nimport { Binding } from '../binding';\nimport { bindingBehavior } from '../binding-behavior';\nimport { DataAttributeAccessor } from '../target-accessors';\n\n@bindingBehavior('attr')\nexport class AttrBindingBehavior {\n  public bind(flags: LifecycleFlags, scope: IScope, binding: Binding): void {\n    binding.targetObserver = new DataAttributeAccessor(binding.locator.get(ILifecycle), binding.target, binding.targetProperty);\n  }\n\n  // tslint:disable-next-line:no-empty\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: Binding): void { }\n}\n","/*\n* Note: the oneTime binding now has a non-zero value for 2 reasons:\n*  - plays nicer with bitwise operations (more consistent code, more explicit settings)\n*  - allows for potentially having something like BindingMode.oneTime | BindingMode.fromView, where an initial value is set once to the view but updates from the view also propagate back to the view model\n*\n* Furthermore, the \"default\" mode would be for simple \".bind\" expressions to make it explicit for our logic that the default is being used.\n* This essentially adds extra information which binding could use to do smarter things and allows bindingBehaviors that add a mode instead of simply overwriting it\n*/\nexport enum BindingMode {\n  oneTime  = 0b0001,\n  toView   = 0b0010,\n  fromView = 0b0100,\n  twoWay   = 0b0110,\n  default  = 0b1000\n}\n","import { IScope, LifecycleFlags } from '../../observation';\nimport { Binding } from '../binding';\nimport { bindingBehavior } from '../binding-behavior';\nimport { BindingMode } from '../binding-mode';\n\nconst { oneTime, toView, fromView, twoWay } = BindingMode;\n\nexport type WithMode = { mode: BindingMode; originalMode?: BindingMode };\n\nexport abstract class BindingModeBehavior {\n  constructor(private mode: BindingMode) {}\n\n  public bind(flags: LifecycleFlags, scope: IScope, binding: Binding & WithMode): void {\n    binding.originalMode = binding.mode;\n    binding.mode = this.mode;\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: Binding & WithMode): void {\n    binding.mode = binding.originalMode;\n    binding.originalMode = null;\n  }\n}\n\n@bindingBehavior('oneTime')\nexport class OneTimeBindingBehavior extends BindingModeBehavior {\n  constructor() {\n    super(oneTime);\n  }\n}\n\n@bindingBehavior('toView')\nexport class ToViewBindingBehavior extends BindingModeBehavior {\n  constructor() {\n    super(toView);\n  }\n}\n\n@bindingBehavior('fromView')\nexport class FromViewBindingBehavior extends BindingModeBehavior {\n  constructor() {\n    super(fromView);\n  }\n}\n\n@bindingBehavior('twoWay')\nexport class TwoWayBindingBehavior extends BindingModeBehavior {\n  constructor() {\n    super(twoWay);\n  }\n}\n","import { Reporter } from '@aurelia/kernel';\nimport { IPropertySubscriber, LifecycleFlags, MutationKind, PropertyObserver } from '../observation';\nimport { subscriberCollection } from './subscriber-collection';\n\nconst defineProperty = Reflect.defineProperty;\n// note: we're reusing the same object for setting all descriptors, just changing some properties as needed\n//   this works, because the properties are copied by defineProperty (so changing them afterwards doesn't affect existing descriptors)\n// see also: https://tc39.github.io/ecma262/#sec-topropertydescriptor\nconst observedPropertyDescriptor: PropertyDescriptor = {\n  get: undefined,\n  set: undefined,\n  enumerable: true,\n  configurable: true\n};\n\nfunction subscribe(this: PropertyObserver, subscriber: IPropertySubscriber): void {\n  if (this.observing === false) {\n    this.observing = true;\n    const { obj, propertyKey } = this;\n    this.currentValue = obj[propertyKey];\n    observedPropertyDescriptor.get = () => this.getValue();\n    observedPropertyDescriptor.set = value => { this.setValue(value, LifecycleFlags.updateTargetInstance); };\n    if (!defineProperty(obj, propertyKey, observedPropertyDescriptor)) {\n      Reporter.write(1, propertyKey, obj);\n    }\n  }\n  this.addSubscriber(subscriber);\n}\n\nfunction dispose(this: PropertyObserver): void {\n  delete this.obj[this.propertyKey];\n  this.obj = null;\n  this.propertyKey = null;\n  this.currentValue = null;\n}\n\nexport function propertyObserver(): ClassDecorator {\n  return function(target: Function): void {\n    subscriberCollection(MutationKind.instance)(target);\n    const proto = <PropertyObserver>target.prototype;\n\n    proto.observing = false;\n    proto.obj = null;\n    proto.propertyKey = null;\n    // Note: this will generate some \"false positive\" changes when setting a target undefined from a source undefined,\n    // but those aren't harmful because the changes won't be propagated through to subscribers during $bind anyway.\n    // It will, however, solve some \"false negative\" changes when the source value is undefined but the target value is not;\n    // in such cases, this.currentValue in the observer being undefined will block the change from propagating to the target.\n    // This is likely not working correctly in vCurrent either.\n    proto.currentValue = Symbol();\n\n    proto.subscribe = proto.subscribe || subscribe;\n    proto.unsubscribe = proto.unsubscribe || proto.removeSubscriber;\n\n    proto.dispose = proto.dispose || dispose;\n  };\n}\n","import { IIndexable, PLATFORM, Primitive } from '@aurelia/kernel';\nimport { IAccessor, IPropertyObserver, IPropertySubscriber, ISubscribable, LifecycleFlags, MutationKind } from '../observation';\nimport { propertyObserver } from './property-observer';\n\nconst noop = PLATFORM.noop;\n\n// note: string.length is the only property of any primitive that is not a function,\n// so we can hardwire it to that and simply return undefined for anything else\n// note#2: a modified primitive constructor prototype would not work (and really, it shouldn't..)\nexport class PrimitiveObserver implements IAccessor, ISubscribable<MutationKind.instance> {\n  public getValue: () => undefined | number;\n  // removed the error reporter here because technically any primitive property that can get, can also set,\n  // but since that never serves any purpose (e.g. setting string.length doesn't throw but doesn't change the length either),\n  // we could best just leave this as a no-op and so don't need to store the propertyName\n  public setValue: () => void;\n  public subscribe: () => void;\n  public unsubscribe: () => void;\n  public dispose: () => void;\n\n  public doNotCache: boolean = true;\n  public obj: Primitive;\n\n  constructor(obj: Primitive, propertyKey: PropertyKey) {\n    // we don't need to store propertyName because only 'length' can return a useful value\n    if (propertyKey === 'length') {\n      // deliberately not checking for typeof string as users probably still want to know via an error that their string is undefined\n      this.obj = obj;\n      this.getValue = this.getStringLength;\n    } else {\n      this.getValue = this.returnUndefined;\n    }\n  }\n\n  private getStringLength(): number {\n    return (<string>this.obj).length;\n  }\n  private returnUndefined(): undefined {\n    return undefined;\n  }\n}\nPrimitiveObserver.prototype.setValue = noop;\nPrimitiveObserver.prototype.subscribe = noop;\nPrimitiveObserver.prototype.unsubscribe = noop;\nPrimitiveObserver.prototype.dispose = noop;\n\nexport interface SetterObserver extends IPropertyObserver<IIndexable, string> {}\n\n@propertyObserver()\nexport class SetterObserver implements SetterObserver {\n  public subscribe: (subscriber: IPropertySubscriber) => void;\n  public unsubscribe: (subscriber: IPropertySubscriber) => void;\n  public obj: IIndexable;\n  public propertyKey: string;\n\n  constructor(obj: IIndexable, propertyKey: string) {\n    this.obj = obj;\n    this.propertyKey = propertyKey;\n  }\n\n  public getValue(): IIndexable | Primitive {\n    return this.currentValue;\n  }\n  public setValue(newValue: IIndexable | Primitive, flags: LifecycleFlags): void {\n    const currentValue = this.currentValue;\n    if (currentValue !== newValue) {\n      this.currentValue = newValue;\n      if (!(flags & LifecycleFlags.fromBind)) {\n        this.callSubscribers(newValue, currentValue, flags);\n      }\n      // If subscribe() has been called, the target property descriptor is replaced by these getter/setter methods,\n      // so calling obj[propertyKey] will actually return this.currentValue.\n      // However, if subscribe() was not yet called (indicated by !this.observing), the target descriptor\n      // is unmodified and we need to explicitly set the property value.\n      // This will happen in one-time, to-view and two-way bindings during $bind, meaning that the $bind will not actually update the target value.\n      // This wasn't visible in vCurrent due to connect-queue always doing a delayed update, so in many cases it didn't matter whether $bind updated the target or not.\n      if (!this.observing) {\n        this.obj[this.propertyKey] = newValue;\n      }\n    }\n  }\n}\n\nexport interface Observer extends IPropertyObserver<IIndexable, string> {}\n\n@propertyObserver()\nexport class Observer implements Observer {\n  public obj: IIndexable;\n  public propertyKey: string;\n  public currentValue: IIndexable | Primitive;\n\n  private callback: (newValue: IIndexable | Primitive, oldValue: IIndexable | Primitive) => IIndexable | Primitive;\n\n  constructor(\n    instance: object,\n    propertyName: string,\n    callbackName: string\n  ) {\n      this.obj = instance;\n      this.propertyKey = propertyName;\n      this.currentValue = instance[propertyName];\n      this.callback = callbackName in instance\n        ? instance[callbackName].bind(instance)\n        : noop;\n  }\n\n  public getValue(): IIndexable | Primitive {\n    return this.currentValue;\n  }\n\n  public setValue(newValue: IIndexable | Primitive, flags: LifecycleFlags): void {\n    const currentValue = this.currentValue;\n\n    if (currentValue !== newValue) {\n      this.currentValue = newValue;\n\n      if (!(flags & LifecycleFlags.fromBind)) {\n        const coercedValue = this.callback(newValue, currentValue);\n\n        if (coercedValue !== undefined) {\n          this.currentValue = newValue = coercedValue;\n        }\n\n        this.callSubscribers(newValue, currentValue, flags);\n      }\n    }\n  }\n}\n","import { IIndexable, Reporter, StrictPrimitive } from '@aurelia/kernel';\nimport { IBindScope } from '../lifecycle';\nimport { IBindingContext, IOverrideContext, IScope, ObservedCollection, ObserversLookup, PropertyObserver } from '../observation';\nimport { SetterObserver } from './property-observation';\n\nconst enum RuntimeError {\n  UndefinedScope = 250, // trying to evaluate on something that's not a valid binding\n  NullScope = 251, // trying to evaluate on an unbound binding\n  NilOverrideContext = 252,\n  NilParentScope = 253\n}\n\n/*@internal*/\nexport class InternalObserversLookup {\n  public getOrCreate(obj: IBindingContext | IOverrideContext, key: string): PropertyObserver {\n    let observer = this[key];\n    if (observer === undefined) {\n      observer = this[key] = new SetterObserver(obj, key);\n    }\n    return observer;\n  }\n}\n\nexport class BindingContext implements IBindingContext {\n  [key: string]: ObservedCollection | StrictPrimitive | IIndexable;\n\n  public readonly $synthetic: true = true;\n\n  public $observers: ObserversLookup<IOverrideContext>;\n\n  private constructor(keyOrObj?: string | IIndexable, value?: ObservedCollection | StrictPrimitive | IIndexable) {\n    if (keyOrObj !== undefined) {\n      if (value !== undefined) {\n        // if value is defined then it's just a property and a value to initialize with\n        // tslint:disable-next-line:no-any\n        this[<any>keyOrObj] = value;\n      } else {\n        // can either be some random object or another bindingContext to clone from\n        for (const prop in <IIndexable>keyOrObj) {\n          if (keyOrObj.hasOwnProperty(prop)) {\n            this[prop] = keyOrObj[prop];\n          }\n        }\n      }\n    }\n  }\n\n  public static create(obj?: IIndexable): BindingContext;\n  public static create(key: string, value: ObservedCollection | StrictPrimitive | IIndexable): BindingContext;\n  public static create(keyOrObj?: string | IIndexable, value?: ObservedCollection | StrictPrimitive | IIndexable): BindingContext {\n    return new BindingContext(keyOrObj, value);\n  }\n\n  // tslint:disable-next-line:no-reserved-keywords\n  public static get(scope: IScope, name: string, ancestor: number): IBindingContext | IOverrideContext | IBindScope {\n    if (scope === undefined) {\n      throw Reporter.error(RuntimeError.UndefinedScope);\n    }\n    if (scope === null) {\n      throw Reporter.error(RuntimeError.NullScope);\n    }\n    let overrideContext = scope.overrideContext;\n\n    if (ancestor > 0) {\n      // jump up the required number of ancestor contexts (eg $parent.$parent requires two jumps)\n      while (ancestor > 0) {\n        if (overrideContext.parentOverrideContext === null) {\n          return undefined;\n        }\n        ancestor--;\n        overrideContext = overrideContext.parentOverrideContext;\n      }\n\n      return name in overrideContext ? overrideContext : overrideContext.bindingContext;\n    }\n\n    // traverse the context and it's ancestors, searching for a context that has the name.\n    while (overrideContext && !(name in overrideContext) && !(overrideContext.bindingContext && name in overrideContext.bindingContext)) {\n      overrideContext = overrideContext.parentOverrideContext;\n    }\n\n    if (overrideContext) {\n      // we located a context with the property.  return it.\n      return name in overrideContext ? overrideContext : overrideContext.bindingContext;\n    }\n\n    // the name wasn't found.  return the root binding context.\n    return scope.bindingContext || scope.overrideContext;\n  }\n\n  public getObservers(): ObserversLookup<IOverrideContext> {\n    let observers = this.$observers;\n    if (observers === undefined) {\n      this.$observers = observers = new InternalObserversLookup() as ObserversLookup<this>;\n    }\n    return observers;\n  }\n}\n\nexport class Scope implements IScope {\n  private constructor(\n    public readonly bindingContext: IBindingContext | IBindScope,\n    public readonly overrideContext: IOverrideContext\n  ) { }\n\n  public static create(bc: IBindingContext | IBindScope, oc: IOverrideContext | null): Scope {\n    return new Scope(bc, oc === null || oc === undefined ? OverrideContext.create(bc, oc) : oc);\n  }\n\n  public static fromOverride(oc: IOverrideContext): Scope {\n    if (oc === null || oc === undefined) {\n      throw Reporter.error(RuntimeError.NilOverrideContext);\n    }\n    return new Scope(oc.bindingContext, oc);\n  }\n\n  public static fromParent(ps: IScope, bc: IBindingContext | IBindScope): Scope {\n    if (ps === null || ps === undefined) {\n      throw Reporter.error(RuntimeError.NilParentScope);\n    }\n    return new Scope(bc, OverrideContext.create(bc, ps.overrideContext));\n  }\n}\n\nexport class OverrideContext implements IOverrideContext {\n  [key: string]: ObservedCollection | StrictPrimitive | IIndexable;\n\n  public readonly $synthetic: true = true;\n\n  private constructor(\n    public readonly bindingContext: IBindingContext | IBindScope,\n    public readonly parentOverrideContext: IOverrideContext | null\n  ) { }\n\n  public static create(bc: IBindingContext | IBindScope, poc: IOverrideContext | null): OverrideContext {\n    return new OverrideContext(bc, poc === undefined ? null : poc);\n  }\n\n  public getObservers(): ObserversLookup<IOverrideContext> {\n    let observers = this.$observers;\n    if (observers === undefined) {\n      this.$observers = observers = new InternalObserversLookup();\n    }\n    return observers as ObserversLookup<IOverrideContext>;\n  }\n}\n","import { DI, Immutable } from '@aurelia/kernel';\nimport { IPropertySubscriber, LifecycleFlags } from '../observation';\n\ntype Signal = string;\n\nexport interface ISignaler {\n  signals: Immutable<Record<string, Set<IPropertySubscriber>>>;\n  dispatchSignal(name: Signal, flags?: LifecycleFlags): void;\n  addSignalListener(name: Signal, listener: IPropertySubscriber): void;\n  removeSignalListener(name: Signal, listener: IPropertySubscriber): void;\n}\n\nexport const ISignaler = DI.createInterface<ISignaler>().withDefault(x => x.singleton(Signaler));\n\n/*@internal*/\nexport class Signaler implements ISignaler {\n  public signals: Record<string, Set<IPropertySubscriber>>;\n\n  constructor() {\n    this.signals = Object.create(null);\n  }\n\n  public dispatchSignal(name: Signal, flags?: LifecycleFlags): void {\n    const listeners = this.signals[name];\n    if (listeners === undefined) {\n      return;\n    }\n    for (const listener of listeners.keys()) {\n      listener.handleChange(undefined, undefined, flags | LifecycleFlags.updateTargetInstance);\n    }\n  }\n\n  public addSignalListener(name: Signal, listener: IPropertySubscriber): void {\n    const signals = this.signals;\n    const listeners = signals[name];\n    if (listeners === undefined) {\n      signals[name] = new Set([listener]);\n    } else {\n      listeners.add(listener);\n    }\n  }\n\n  public removeSignalListener(name: Signal, listener: IPropertySubscriber): void {\n    const listeners = this.signals[name];\n    if (listeners) {\n      listeners.delete(listener);\n    }\n  }\n}\n","import { Constructable, IContainer, Registration, Writable } from '@aurelia/kernel';\nimport { IResourceKind, IResourceType } from '../resource';\n\nexport interface IValueConverterSource {\n  name: string;\n}\n\nexport type IValueConverterType = IResourceType<IValueConverterSource>;\n\nexport function valueConverter(nameOrSource: string | IValueConverterSource): <T extends Constructable>(target: T) => T & IResourceType<IValueConverterSource> {\n  return function<T extends Constructable>(target: T): T & IResourceType<IValueConverterSource> {\n    return ValueConverterResource.define(nameOrSource, target);\n  };\n}\n\nexport const ValueConverterResource: IResourceKind<IValueConverterSource, IValueConverterType> = {\n  name: 'value-converter',\n\n  keyFrom(name: string): string {\n    return `${this.name}:${name}`;\n  },\n\n  isType<T extends Constructable>(Type: T): Type is T & IValueConverterType {\n    return (Type as T & IValueConverterType).kind === this;\n  },\n\n  define<T extends Constructable>(nameOrSource: string | IValueConverterSource, ctor: T): T & IValueConverterType {\n    const Type = ctor as T & IValueConverterType;\n    const description = typeof nameOrSource === 'string'\n      ? { name: nameOrSource }\n      : nameOrSource;\n\n    (Type as Writable<IValueConverterType>).kind = ValueConverterResource;\n    (Type as Writable<IValueConverterType>).description = description;\n    Type.register = register;\n\n    return Type;\n  }\n};\n\nfunction register(this: IValueConverterType, container: IContainer): void {\n  container.register(\n    Registration.singleton(\n      ValueConverterResource.keyFrom(this.description.name),\n      this\n    )\n  );\n}\n","import { IIndexable, IServiceLocator, PLATFORM, Reporter, StrictPrimitive } from '@aurelia/kernel';\nimport { Collection, IScope, LifecycleFlags, ObservedCollection } from '../observation';\nimport { IBinding } from './binding';\nimport { BindingBehaviorResource } from './binding-behavior';\nimport { BindingContext } from './binding-context';\nimport { IConnectableBinding } from './connectable';\nimport { ISignaler } from './signaler';\nimport { ValueConverterResource } from './value-converter';\n\n/**\n * StrictAny is a somewhat strongly typed alternative to 'any', in an effort to try to get rid of all 'any''s\n * It's not even remotely foolproof however, and this can largely be attributed to the fact that TypeScript imposes\n * far more constraints on what arithmic is allowed than vanilla JS does.\n * We don't necessarily want to impose the same constraints on users (e.g. by performing auto conversions or throwing),\n * because even though that behavior would technically be \"better\", it could also be experienced as unpredictable.\n * We'd generally not want to ask more of users than to simply understand how vanilla JS works, and let them account for its quirks themselves.\n * This gives end users less framework-specific things to learn.\n * Consequently, it's impossible to achieve any kind of strict type checking in the AST and generally in the observers.\n * We're trying to achieve some middle ground by applying some explicit type casts where TypeScript would otherwise not allow compilation.\n */\nexport type StrictAny = StrictPrimitive | IIndexable | Function;\nexport type IsPrimary = AccessThis | AccessScope | ArrayLiteral | ObjectLiteral | PrimitiveLiteral | Template;\nexport type IsLiteral = ArrayLiteral | ObjectLiteral | PrimitiveLiteral | Template;\nexport type IsLeftHandSide = IsPrimary | CallFunction | CallMember | CallScope | AccessMember | AccessKeyed | TaggedTemplate;\nexport type IsUnary = IsLeftHandSide | Unary;\nexport type IsBinary = IsUnary | Binary;\nexport type IsConditional = IsBinary | Conditional;\nexport type IsAssign = IsConditional | Assign;\nexport type IsValueConverter = IsAssign | ValueConverter;\nexport type IsBindingBehavior = IsValueConverter | BindingBehavior;\nexport type IsAssignable = AccessScope | AccessKeyed | AccessMember | Assign;\nexport type IsExpression = IsBindingBehavior | Interpolation;\nexport type IsExpressionOrStatement = IsExpression | ForOfStatement | BindingIdentifierOrPattern | HtmlLiteral;\nexport type Connects = AccessScope | ArrayLiteral | ObjectLiteral | Template | Unary | CallScope | AccessMember | AccessKeyed | TaggedTemplate | Binary | Conditional | ValueConverter | BindingBehavior | ForOfStatement;\nexport type Observes = AccessScope | AccessKeyed | AccessMember;\nexport type CallsFunction = CallFunction | CallScope | CallMember | TaggedTemplate;\nexport type IsResource = ValueConverter | BindingBehavior;\nexport type HasBind = BindingBehavior;\nexport type HasUnbind = ValueConverter | BindingBehavior;\nexport type HasAncestor = AccessThis | AccessScope | CallScope;\n\n// tslint:disable-next-line:no-any\nexport interface IVisitor<T = any> {\n  visitAccessKeyed(expr: AccessKeyed): T;\n  visitAccessMember(expr: AccessMember): T;\n  visitAccessScope(expr: AccessScope): T;\n  visitAccessThis(expr: AccessThis): T;\n  visitArrayBindingPattern(expr: ArrayBindingPattern): T;\n  visitArrayLiteral(expr: ArrayLiteral): T;\n  visitAssign(expr: Assign): T;\n  visitBinary(expr: Binary): T;\n  visitBindingBehavior(expr: BindingBehavior): T;\n  visitBindingIdentifier(expr: BindingIdentifier): T;\n  visitCallFunction(expr: CallFunction): T;\n  visitCallMember(expr: CallMember): T;\n  visitCallScope(expr: CallScope): T;\n  visitConditional(expr: Conditional): T;\n  visitForOfStatement(expr: ForOfStatement): T;\n  visitHtmlLiteral(expr: HtmlLiteral): T;\n  visitInterpolation(expr: Interpolation): T;\n  visitObjectBindingPattern(expr: ObjectBindingPattern): T;\n  visitObjectLiteral(expr: ObjectLiteral): T;\n  visitPrimitiveLiteral(expr: PrimitiveLiteral): T;\n  visitTaggedTemplate(expr: TaggedTemplate): T;\n  visitTemplate(expr: Template): T;\n  visitUnary(expr: Unary): T;\n  visitValueConverter(expr: ValueConverter): T;\n}\n\nexport interface IExpression {\n  readonly $kind: ExpressionKind;\n  evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator | null): StrictAny;\n  connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void;\n  accept<T>(visitor: IVisitor<T>): T;\n  assign?(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator | null, value: StrictAny): StrictAny;\n  bind?(flags: LifecycleFlags, scope: IScope, binding: IBinding): void;\n  unbind?(flags: LifecycleFlags, scope: IScope, binding: IBinding): void;\n}\n\nexport const enum ExpressionKind {\n  Connects             = 0b000000000001_00000, // The expression's connect() function calls observeProperty and/or calls connect() on another expression that it wraps (all expressions except for AccessThis, PrimitiveLiteral, CallMember/Function and Assign)\n  Observes             = 0b000000000010_00000, // The expression's connect() function calls observeProperty (only AccessScope, AccessMember and AccessKeyed do this)\n  CallsFunction        = 0b000000000100_00000, // Calls a function (CallFunction, CallScope, CallMember, TaggedTemplate) -> needs a valid function object returning from its lefthandside's evaluate()\n  HasAncestor          = 0b000000001000_00000, // Has an \"ancestor\" property, meaning the expression could climb up the context (only AccessThis, AccessScope and CallScope)\n  IsPrimary            = 0b000000010000_00000, // Is a primary expression according to ES parsing rules\n  IsLeftHandSide       = 0b000000100000_00000, // Is a left-hand side expression according to ES parsing rules, includes IsPrimary\n  HasBind              = 0b000001000000_00000, // Has a bind() method (currently only BindingBehavior)\n  HasUnbind            = 0b000010000000_00000, // Has an unbind() method (currentl only BindingBehavior and ValueConverter)\n  IsAssignable         = 0b000100000000_00000, // Is an assignable expression according to ES parsing rules (only AccessScope, AccessMember, AccessKeyed ans Assign)\n  IsLiteral            = 0b001000000000_00000, // Is an Aurelia resource (ValueConverter or BindingBehavior)\n  IsResource           = 0b010000000000_00000, // Is literal expression (Primitive, Array, Object or Template)\n  IsForDeclaration     = 0b100000000000_00000, // Is a For declaration (for..of, for..in -> currently only ForOfStatement)\n  Type                 = 0b000000000000_11111, // Type mask to uniquely identify each AST class (concrete types start below)\n  // ---------------------------------------------------------------------------------------------------------------------------\n  AccessThis           = 0b000000111000_00001, //               HasAncestor\n  AccessScope          = 0b000100111011_00010, // IsAssignable  HasAncestor       Observes  Connects\n  ArrayLiteral         = 0b001000110001_00011, //                                           Connects\n  ObjectLiteral        = 0b001000110001_00100, //                                           Connects\n  PrimitiveLiteral     = 0b001000110000_00101, //\n  Template             = 0b001000110001_00110, //                                           Connects\n  Unary                = 0b000000000001_00111, //                                           Connects\n  CallScope            = 0b000000101101_01000, //               HasAncestor  CallsFunction  Connects\n  CallMember           = 0b000000100100_01001, //                            CallsFunction\n  CallFunction         = 0b000000100100_01010, //                            CallsFunction\n  AccessMember         = 0b000100100011_01011, // IsAssignable                    Observes  Connects\n  AccessKeyed          = 0b000100100011_01100, // IsAssignable                    Observes  Connects\n  TaggedTemplate       = 0b000000100101_01101, //                            CallsFunction  Connects\n  Binary               = 0b000000000001_01110, //                                           Connects\n  Conditional          = 0b000000000001_11111, //                                           Connects\n  Assign               = 0b000100000000_10000, // IsAssignable\n  ValueConverter       = 0b010010000001_10001, //                                           Connects\n  BindingBehavior      = 0b010011000001_10010, //                                           Connects\n  HtmlLiteral          = 0b000000000001_10011, //                                           Connects\n  ArrayBindingPattern  = 0b100000000000_10100, //\n  ObjectBindingPattern = 0b100000000000_10101, //\n  BindingIdentifier    = 0b100000000000_10110, //\n  ForOfStatement       = 0b000000000001_10111, //                                           Connects\n  Interpolation        = 0b000000000000_11000  //\n}\n\nexport function connects(expr: IsExpressionOrStatement): expr is Connects {\n  return (expr.$kind & ExpressionKind.Connects) === ExpressionKind.Connects;\n}\nexport function observes(expr: IsExpressionOrStatement): expr is Observes {\n  return (expr.$kind & ExpressionKind.Observes) === ExpressionKind.Observes;\n}\nexport function callsFunction(expr: IsExpressionOrStatement): expr is CallsFunction {\n  return (expr.$kind & ExpressionKind.CallsFunction) === ExpressionKind.CallsFunction;\n}\nexport function hasAncestor(expr: IsExpressionOrStatement): expr is HasAncestor {\n  return (expr.$kind & ExpressionKind.HasAncestor) === ExpressionKind.HasAncestor;\n}\nexport function isAssignable(expr: IsExpressionOrStatement): expr is IsAssignable {\n  return (expr.$kind & ExpressionKind.IsAssignable) === ExpressionKind.IsAssignable;\n}\nexport function isLeftHandSide(expr: IsExpressionOrStatement): expr is IsLeftHandSide {\n  return (expr.$kind & ExpressionKind.IsLeftHandSide) === ExpressionKind.IsLeftHandSide;\n}\nexport function isPrimary(expr: IsExpressionOrStatement): expr is IsPrimary {\n  return (expr.$kind & ExpressionKind.IsPrimary) === ExpressionKind.IsPrimary;\n}\nexport function isResource(expr: IsExpressionOrStatement): expr is IsResource {\n  return (expr.$kind & ExpressionKind.IsResource) === ExpressionKind.IsResource;\n}\nexport function hasBind(expr: IsExpressionOrStatement): expr is HasBind {\n  return (expr.$kind & ExpressionKind.HasBind) === ExpressionKind.HasBind;\n}\nexport function hasUnbind(expr: IsExpressionOrStatement): expr is HasUnbind {\n  return (expr.$kind & ExpressionKind.HasUnbind) === ExpressionKind.HasUnbind;\n}\nexport function isLiteral(expr: IsExpressionOrStatement): expr is IsLiteral {\n  return (expr.$kind & ExpressionKind.IsLiteral) === ExpressionKind.IsLiteral;\n}\nexport function arePureLiterals(expressions: ReadonlyArray<IsExpressionOrStatement>): expressions is IsLiteral[] {\n  if (expressions === undefined || expressions.length === 0) {\n    return true;\n  }\n  for (let i = 0; i < expressions.length; ++i) {\n    if (!isPureLiteral(expressions[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nexport function isPureLiteral(expr: IsExpressionOrStatement): expr is IsLiteral {\n  if (isLiteral(expr)) {\n    switch (expr.$kind) {\n      case ExpressionKind.ArrayLiteral:\n        return arePureLiterals(expr.elements);\n      case ExpressionKind.ObjectLiteral:\n        return arePureLiterals(expr.values);\n      case ExpressionKind.Template:\n        return arePureLiterals(expr.expressions);\n      case ExpressionKind.PrimitiveLiteral:\n        return true;\n    }\n  }\n  return false;\n}\n\nconst enum RuntimeError {\n  NoLocator = 202,\n  NoBehaviorFound = 203,\n  BehaviorAlreadyApplied = 204,\n  NoConverterFound = 205,\n  NoBinding = 206,\n  NotAFunction = 207,\n  UnknownOperator = 208,\n  UndefinedScope = 250, // trying to evaluate on something that's not a valid binding\n  NullScope = 251, // trying to evaluate on an unbound binding\n}\n\nexport class BindingBehavior implements IExpression {\n  public $kind: ExpressionKind.BindingBehavior;\n  public readonly behaviorKey: string;\n  private readonly expressionHasBind: boolean;\n  private readonly expressionHasUnbind: boolean;\n  constructor(\n    public readonly expression: IsBindingBehavior,\n    public readonly name: string,\n    public readonly args: ReadonlyArray<IsAssign>) {\n    this.behaviorKey = BindingBehaviorResource.keyFrom(this.name);\n    this.expressionHasBind = hasBind(expression);\n    this.expressionHasUnbind = hasUnbind(expression);\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): StrictAny {\n    return this.expression.evaluate(flags, scope, locator);\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, value: StrictAny): StrictAny {\n    return this.expression.assign(flags, scope, locator, value);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    this.expression.connect(flags, scope, binding);\n  }\n\n  public bind(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    if (scope === undefined) {\n      throw Reporter.error(RuntimeError.UndefinedScope, this);\n    }\n    if (scope === null) {\n      throw Reporter.error(RuntimeError.NullScope, this);\n    }\n    if (!binding) {\n      throw Reporter.error(RuntimeError.NoBinding, this);\n    }\n    const locator = binding.locator;\n    if (!locator) {\n      throw Reporter.error(RuntimeError.NoLocator, this);\n    }\n    if (this.expressionHasBind) {\n      (this.expression as BindingBehavior).bind(flags, scope, binding);\n    }\n    const behaviorKey = this.behaviorKey;\n    const behavior = locator.get<BindingBehavior>(behaviorKey);\n    if (!behavior) {\n      throw Reporter.error(RuntimeError.NoBehaviorFound, this);\n    }\n    if (binding[behaviorKey] !== undefined && binding[behaviorKey] !== null) {\n      throw Reporter.error(RuntimeError.BehaviorAlreadyApplied, this);\n    }\n    binding[behaviorKey] = behavior;\n    behavior.bind.apply(behavior, (<StrictAny[]>[flags, scope, binding]).concat(evalList(flags, scope, locator, this.args)));\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const behaviorKey = this.behaviorKey;\n    binding[behaviorKey].unbind(flags, scope, binding);\n    binding[behaviorKey] = null;\n    if (this.expressionHasUnbind) {\n      (this.expression as BindingBehavior | ValueConverter).unbind(flags, scope, binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitBindingBehavior(this);\n  }\n}\n\nexport class ValueConverter implements IExpression {\n  public $kind: ExpressionKind.ValueConverter;\n  public readonly converterKey: string;\n  constructor(\n    public readonly expression: IsValueConverter,\n    public readonly name: string,\n    public readonly args: ReadonlyArray<IsAssign>) {\n    this.converterKey = ValueConverterResource.keyFrom(this.name);\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): StrictAny {\n    if (!locator) {\n      throw Reporter.error(RuntimeError.NoLocator, this);\n    }\n    const converter = locator.get<ValueConverter & { toView(...args: (StrictAny)[]): StrictAny }>(this.converterKey);\n    if (!converter) {\n      throw Reporter.error(RuntimeError.NoConverterFound, this);\n    }\n    if ('toView' in converter) {\n      const args = this.args;\n      const len = args.length;\n      const result = Array(len + 1);\n      result[0] = this.expression.evaluate(flags, scope, locator);\n      for (let i = 0; i < len; ++i) {\n        result[i + 1] = args[i].evaluate(flags, scope, locator);\n      }\n      return converter.toView.apply(converter, result);\n    }\n    return this.expression.evaluate(flags, scope, locator);\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, value: StrictAny): StrictAny {\n    if (!locator) {\n      throw Reporter.error(RuntimeError.NoLocator, this);\n    }\n    const converter = locator.get<ValueConverter & { fromView(...args: (StrictAny)[]): StrictAny }>(this.converterKey);\n    if (!converter) {\n      throw Reporter.error(RuntimeError.NoConverterFound, this);\n    }\n    if ('fromView' in converter) {\n      value = converter.fromView.apply(converter, [value].concat(evalList(flags, scope, locator, this.args)));\n    }\n    return this.expression.assign(flags, scope, locator, value);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    if (scope === undefined) {\n      throw Reporter.error(RuntimeError.UndefinedScope, this);\n    }\n    if (scope === null) {\n      throw Reporter.error(RuntimeError.NullScope, this);\n    }\n    if (!binding) {\n      throw Reporter.error(RuntimeError.NoBinding, this);\n    }\n    const locator = binding.locator;\n    if (!locator) {\n      throw Reporter.error(RuntimeError.NoLocator, this);\n    }\n    this.expression.connect(flags, scope, binding);\n    const args = this.args;\n    for (let i = 0, ii = args.length; i < ii; ++i) {\n      args[i].connect(flags, scope, binding);\n    }\n    const converter = locator.get(this.converterKey) as { signals?: string[] };\n    if (!converter) {\n      throw Reporter.error(RuntimeError.NoConverterFound, this);\n    }\n    const signals = converter.signals;\n    if (signals === undefined) {\n      return;\n    }\n    const signaler = locator.get(ISignaler);\n    for (let i = 0, ii = signals.length; i < ii; ++i) {\n      signaler.addSignalListener(signals[i], binding);\n    }\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const locator = binding.locator;\n    const converter = locator.get(this.converterKey) as { signals?: string[] };\n    const signals = converter.signals;\n    if (signals === undefined) {\n      return;\n    }\n    const signaler = locator.get(ISignaler);\n    for (let i = 0, ii = signals.length; i < ii; ++i) {\n      signaler.removeSignalListener(signals[i], binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitValueConverter(this);\n  }\n}\n\nexport class Assign implements IExpression {\n  public $kind: ExpressionKind.Assign;\n  constructor(\n    public readonly target: IsAssignable,\n    public readonly value: IsAssign) { }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): StrictAny {\n    return this.target.assign(flags, scope, locator, this.value.evaluate(flags, scope, locator));\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    return;\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, value: StrictAny): StrictAny {\n    this.value.assign(flags, scope, locator, value);\n    return this.target.assign(flags, scope, locator, value);\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitAssign(this);\n  }\n}\n\nexport class Conditional implements IExpression {\n  public $kind: ExpressionKind.Conditional;\n  public assign: IExpression['assign'];\n  constructor(\n    public readonly condition: IsBinary,\n    public readonly yes: IsAssign,\n    public readonly no: IsAssign) { }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): StrictAny {\n    return (!!this.condition.evaluate(flags, scope, locator))\n      ? this.yes.evaluate(flags, scope, locator)\n      : this.no.evaluate(flags, scope, locator);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const condition = this.condition;\n    if (condition.evaluate(flags, scope, null)) {\n      this.condition.connect(flags, scope, binding);\n      this.yes.connect(flags, scope, binding);\n    } else {\n      this.condition.connect(flags, scope, binding);\n      this.no.connect(flags, scope, binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitConditional(this);\n  }\n}\n\nexport class AccessThis implements IExpression {\n  public static readonly $this: AccessThis = new AccessThis(0);\n  public static readonly $parent: AccessThis = new AccessThis(1);\n  public $kind: ExpressionKind.AccessThis;\n  public assign: IExpression['assign'];\n  public connect: IExpression['connect'];\n  constructor(\n    public readonly ancestor: number = 0) { }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): StrictAny {\n    if (scope === undefined) {\n      throw Reporter.error(RuntimeError.UndefinedScope, this);\n    }\n    if (scope === null) {\n      throw Reporter.error(RuntimeError.NullScope, this);\n    }\n    let oc = scope.overrideContext;\n    let i = this.ancestor;\n    while (i-- && oc) {\n      oc = oc.parentOverrideContext;\n    }\n    return i < 1 && oc ? oc.bindingContext : undefined;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitAccessThis(this);\n  }\n}\n\nexport class AccessScope implements IExpression {\n  public $kind: ExpressionKind.AccessScope;\n  constructor(\n    public readonly name: string,\n    public readonly ancestor: number = 0) { }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): StrictAny {\n    const name = this.name;\n    return BindingContext.get(scope, name, this.ancestor)[name];\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, value: StrictAny): StrictAny {\n    const name = this.name;\n    const context = BindingContext.get(scope, name, this.ancestor);\n    return context ? (context[name] = value) : undefined;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const name = this.name;\n    const context = BindingContext.get(scope, name, this.ancestor);\n    binding.observeProperty(context, name);\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitAccessScope(this);\n  }\n}\n\nexport class AccessMember implements IExpression {\n  public $kind: ExpressionKind.AccessMember;\n  constructor(\n    public readonly object: IsLeftHandSide,\n    public readonly name: string) { }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): StrictAny {\n    const instance = this.object.evaluate(flags, scope, locator);\n    return instance === null || instance === undefined ? instance : instance[this.name];\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, value: StrictAny): StrictAny {\n    let instance = this.object.evaluate(flags, scope, locator);\n    if (instance === null || typeof instance !== 'object') {\n      instance = {};\n      this.object.assign(flags, scope, locator, instance);\n    }\n    instance[this.name] = value;\n    return value;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const obj = this.object.evaluate(flags, scope, null);\n    this.object.connect(flags, scope, binding);\n    if (obj) {\n      binding.observeProperty(obj, this.name);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitAccessMember(this);\n  }\n}\n\nexport class AccessKeyed implements IExpression {\n  public $kind: ExpressionKind.AccessKeyed;\n  constructor(\n    public readonly object: IsLeftHandSide,\n    public readonly key: IsAssign) { }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): StrictAny {\n    const instance = this.object.evaluate(flags, scope, locator);\n    if (instance === null || instance === undefined) {\n      return undefined;\n    }\n    const key = this.key.evaluate(flags, scope, locator);\n    // note: getKeyed and setKeyed are removed because they are identical to the default spec behavior\n    // and the runtime does this this faster\n    // tslint:disable-next-line:no-any\n    return instance[<any>key];\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, value: StrictAny): StrictAny {\n    const instance = this.object.evaluate(flags, scope, locator);\n    const key = this.key.evaluate(flags, scope, locator);\n    // tslint:disable-next-line:no-any\n    return instance[<any>key] = value;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const obj = this.object.evaluate(flags, scope, null);\n    this.object.connect(flags, scope, binding);\n    if (typeof obj === 'object' && obj !== null) {\n      this.key.connect(flags, scope, binding);\n      const key = this.key.evaluate(flags, scope, null);\n      // observe the property represented by the key as long as it's not an array indexer\n      // (note: string indexers behave the same way as numeric indexers as long as they represent numbers)\n      if (!(Array.isArray(obj) && isNumeric(key))) {\n        binding.observeProperty(obj, key);\n      }\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitAccessKeyed(this);\n  }\n}\n\nexport class CallScope implements IExpression {\n  public $kind: ExpressionKind.CallScope;\n  public assign: IExpression['assign'];\n  constructor(\n    public readonly name: string,\n    public readonly args: ReadonlyArray<IsAssign>,\n    public readonly ancestor: number = 0) { }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator | null): StrictAny {\n    const args = evalList(flags, scope, locator, this.args);\n    const context = BindingContext.get(scope, this.name, this.ancestor);\n    const func = getFunction(flags, context, this.name);\n    if (func) {\n      return func.apply(context, args);\n    }\n    return undefined;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const args = this.args;\n    for (let i = 0, ii = args.length; i < ii; ++i) {\n      args[i].connect(flags, scope, binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitCallScope(this);\n  }\n}\n\nexport class CallMember implements IExpression {\n  public $kind: ExpressionKind.CallMember;\n  public assign: IExpression['assign'];\n  constructor(\n    public readonly object: IsLeftHandSide,\n    public readonly name: string,\n    public readonly args: ReadonlyArray<IsAssign>) { }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): StrictAny {\n    const instance = this.object.evaluate(flags, scope, locator);\n    const args = evalList(flags, scope, locator, this.args);\n    const func = getFunction(flags, instance, this.name);\n    if (func) {\n      return func.apply(instance, args);\n    }\n    return undefined;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const obj = this.object.evaluate(flags, scope, null);\n    this.object.connect(flags, scope, binding);\n    if (getFunction(flags & ~LifecycleFlags.mustEvaluate, obj, this.name)) {\n      const args = this.args;\n      for (let i = 0, ii = args.length; i < ii; ++i) {\n        args[i].connect(flags, scope, binding);\n      }\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitCallMember(this);\n  }\n}\n\nexport class CallFunction implements IExpression {\n  public $kind: ExpressionKind.CallFunction;\n  public assign: IExpression['assign'];\n  constructor(\n    public readonly func: IsLeftHandSide,\n    public readonly args: ReadonlyArray<IsAssign>) { }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): StrictAny {\n    const func = this.func.evaluate(flags, scope, locator) as StrictAny; // not sure why this cast is needed..\n    if (typeof func === 'function') {\n      return func.apply(null, evalList(flags, scope, locator, this.args));\n    }\n    if (!(flags & LifecycleFlags.mustEvaluate) && (func === null || func === undefined)) {\n      return undefined;\n    }\n    throw Reporter.error(RuntimeError.NotAFunction, this);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const func = this.func.evaluate(flags, scope, null);\n    this.func.connect(flags, scope, binding);\n    if (typeof func === 'function') {\n      const args = this.args;\n      for (let i = 0, ii = args.length; i < ii; ++i) {\n        args[i].connect(flags, scope, binding);\n      }\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitCallFunction(this);\n  }\n}\n\nexport type BinaryOperator = '&&' | '||' |  '==' |  '===' |  '!=' |  '!==' |  'instanceof' |  'in' |  '+' |  '-' |  '*' |  '/' |  '%' |  '<' |  '>' |  '<=' |  '>=';\n\nexport class Binary implements IExpression {\n  public $kind: ExpressionKind.Binary;\n  public assign: IExpression['assign'];\n  constructor(\n    public readonly operation: BinaryOperator,\n    public readonly left: IsBinary,\n    public readonly right: IsBinary) {\n    // what we're doing here is effectively moving the large switch statement from evaluate to the constructor\n    // so that the check only needs to be done once, and evaluate (which is called many times) will have a lot less\n    // work to do; we can do this because the operation can't change after it's parsed\n    this.evaluate = this[operation];\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): StrictAny {\n    throw Reporter.error(RuntimeError.UnknownOperator, this);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const left = this.left.evaluate(flags, scope, null);\n    this.left.connect(flags, scope, binding);\n    if (this.operation === '&&' && !left || this.operation === '||' && left) {\n      return;\n    }\n    this.right.connect(flags, scope, binding);\n  }\n\n  private ['&&'](f: LifecycleFlags, s: IScope, l: IServiceLocator): StrictAny {\n    return this.left.evaluate(f, s, l) && this.right.evaluate(f, s, l);\n  }\n  private ['||'](f: LifecycleFlags, s: IScope, l: IServiceLocator): StrictAny {\n    return this.left.evaluate(f, s, l) || this.right.evaluate(f, s, l);\n  }\n  private ['=='](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    // tslint:disable-next-line:triple-equals\n    return this.left.evaluate(f, s, l) == this.right.evaluate(f, s, l);\n  }\n  private ['==='](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return this.left.evaluate(f, s, l) === this.right.evaluate(f, s, l);\n  }\n  private ['!='](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    // tslint:disable-next-line:triple-equals\n    return this.left.evaluate(f, s, l) != this.right.evaluate(f, s, l);\n  }\n  private ['!=='](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return this.left.evaluate(f, s, l) !== this.right.evaluate(f, s, l);\n  }\n  private ['instanceof'](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    const right = this.right.evaluate(f, s, l);\n    if (typeof right === 'function') {\n      return this.left.evaluate(f, s, l) instanceof right;\n    }\n    return false;\n  }\n  private ['in'](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    const right = this.right.evaluate(f, s, l);\n    if (right !== null && typeof right === 'object') {\n      return this.left.evaluate(f, s, l) in right;\n    }\n    return false;\n  }\n  // note: autoConvertAdd (and the null check) is removed because the default spec behavior is already largely similar\n  // and where it isn't, you kind of want it to behave like the spec anyway (e.g. return NaN when adding a number to undefined)\n  // this makes bugs in user code easier to track down for end users\n  // also, skipping these checks and leaving it to the runtime is a nice little perf boost and simplifies our code\n  private ['+'](f: LifecycleFlags, s: IScope, l: IServiceLocator): StrictAny {\n    // tslint:disable-next-line:no-any\n    return (<any>this.left.evaluate(f, s, l)) + (<any>this.right.evaluate(f, s, l));\n  }\n  private ['-'](f: LifecycleFlags, s: IScope, l: IServiceLocator): StrictAny {\n    // tslint:disable-next-line:no-any\n    return (<any>this.left.evaluate(f, s, l)) - (<any>this.right.evaluate(f, s, l));\n  }\n  private ['*'](f: LifecycleFlags, s: IScope, l: IServiceLocator): StrictAny {\n    // tslint:disable-next-line:no-any\n    return (<any>this.left.evaluate(f, s, l)) * (<any>this.right.evaluate(f, s, l));\n  }\n  private ['/'](f: LifecycleFlags, s: IScope, l: IServiceLocator): StrictAny {\n    // tslint:disable-next-line:no-any\n    return (<any>this.left.evaluate(f, s, l)) / (<any>this.right.evaluate(f, s, l));\n  }\n  private ['%'](f: LifecycleFlags, s: IScope, l: IServiceLocator): StrictAny {\n    // tslint:disable-next-line:no-any\n    return (<any>this.left.evaluate(f, s, l)) % (<any>this.right.evaluate(f, s, l));\n  }\n  private ['<'](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return this.left.evaluate(f, s, l) < this.right.evaluate(f, s, l);\n  }\n  private ['>'](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return this.left.evaluate(f, s, l) > this.right.evaluate(f, s, l);\n  }\n  private ['<='](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return this.left.evaluate(f, s, l) <= this.right.evaluate(f, s, l);\n  }\n  private ['>='](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return this.left.evaluate(f, s, l) >= this.right.evaluate(f, s, l);\n  }\n\n  // tslint:disable-next-line:member-ordering\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitBinary(this);\n  }\n}\n\nexport type UnaryOperator = 'void' | 'typeof' | '!' | '-' | '+';\n\nexport class Unary implements IExpression {\n  public $kind: ExpressionKind.Unary;\n  public assign: IExpression['assign'];\n  constructor(\n    public readonly operation: UnaryOperator,\n    public readonly expression: IsLeftHandSide) {\n    // see Binary (we're doing the same thing here)\n    // tslint:disable-next-line:no-any\n    this.evaluate = this[operation];\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): StrictAny {\n    throw Reporter.error(RuntimeError.UnknownOperator, this);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    this.expression.connect(flags, scope, binding);\n  }\n\n  public ['void'](f: LifecycleFlags, s: IScope, l: IServiceLocator): undefined {\n    return void this.expression.evaluate(f, s, l);\n  }\n  public ['typeof'](f: LifecycleFlags, s: IScope, l: IServiceLocator): string {\n    return typeof this.expression.evaluate(f, s, l);\n  }\n  public ['!'](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return !this.expression.evaluate(f, s, l);\n  }\n  public ['-'](f: LifecycleFlags, s: IScope, l: IServiceLocator): number {\n    return -this.expression.evaluate(f, s, l);\n  }\n  public ['+'](f: LifecycleFlags, s: IScope, l: IServiceLocator): number {\n    return +this.expression.evaluate(f, s, l);\n  }\n\n  // tslint:disable-next-line:member-ordering\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitUnary(this);\n  }\n}\nexport class PrimitiveLiteral<TValue extends StrictPrimitive = StrictPrimitive> implements IExpression {\n  public static readonly $undefined: PrimitiveLiteral<undefined> = new PrimitiveLiteral<undefined>(undefined);\n  public static readonly $null: PrimitiveLiteral<null> = new PrimitiveLiteral<null>(null);\n  public static readonly $true: PrimitiveLiteral<true> = new PrimitiveLiteral<true>(true);\n  public static readonly $false: PrimitiveLiteral<false> = new PrimitiveLiteral<false>(false);\n  public static readonly $empty: PrimitiveLiteral<string> = new PrimitiveLiteral<''>('');\n  public $kind: ExpressionKind.PrimitiveLiteral;\n  public connect: IExpression['connect'];\n  public assign: IExpression['assign'];\n  constructor(public readonly value: TValue) { }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): TValue {\n    return this.value;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitPrimitiveLiteral(this);\n  }\n}\n\nexport class HtmlLiteral implements IExpression {\n  public $kind: ExpressionKind.HtmlLiteral;\n  public assign: IExpression['assign'];\n  constructor(public readonly parts: ReadonlyArray<HtmlLiteral>) { }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): string {\n    const elements = this.parts;\n    let result = '';\n    for (let i = 0, ii = elements.length; i < ii; ++i) {\n      const value = elements[i].evaluate(flags, scope, locator);\n      if (value === undefined || value === null) {\n        continue;\n      }\n      result += value;\n    }\n    return result;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    for (let i = 0, ii = this.parts.length; i < ii; ++i) {\n      this.parts[i].connect(flags, scope, binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitHtmlLiteral(this);\n  }\n}\n\nexport class ArrayLiteral implements IExpression {\n  public static readonly $empty: ArrayLiteral = new ArrayLiteral(PLATFORM.emptyArray);\n  public $kind: ExpressionKind.ArrayLiteral;\n  public assign: IExpression['assign'];\n  constructor(public readonly elements: ReadonlyArray<IsAssign>) { }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): ReadonlyArray<StrictAny> {\n    const elements = this.elements;\n    const length = elements.length;\n    const result = Array(length);\n    for (let i = 0; i < length; ++i) {\n      result[i] = elements[i].evaluate(flags, scope, locator);\n    }\n    return result;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const elements = this.elements;\n    for (let i = 0, ii = elements.length; i < ii; ++i) {\n      elements[i].connect(flags, scope, binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitArrayLiteral(this);\n  }\n}\n\nexport class ObjectLiteral implements IExpression {\n  public static readonly $empty: ObjectLiteral = new ObjectLiteral(PLATFORM.emptyArray, PLATFORM.emptyArray);\n  public $kind: ExpressionKind.ObjectLiteral;\n  public assign: IExpression['assign'];\n  constructor(\n    public readonly keys: ReadonlyArray<number | string>,\n    public readonly values: ReadonlyArray<IsAssign>) { }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): Record<string, StrictAny> {\n    const instance: Record<string, StrictAny> = {};\n    const keys = this.keys;\n    const values = this.values;\n    for (let i = 0, ii = keys.length; i < ii; ++i) {\n      instance[keys[i]] = values[i].evaluate(flags, scope, locator);\n    }\n    return instance;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const keys = this.keys;\n    const values = this.values;\n    for (let i = 0, ii = keys.length; i < ii; ++i) {\n      values[i].connect(flags, scope, binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitObjectLiteral(this);\n  }\n}\n\nexport class Template implements IExpression {\n  public static readonly $empty: Template = new Template(['']);\n  public $kind: ExpressionKind.Template;\n  public assign: IExpression['assign'];\n  constructor(\n    public readonly cooked: ReadonlyArray<string>,\n    public readonly expressions?: ReadonlyArray<IsAssign>) {\n    this.expressions = expressions || PLATFORM.emptyArray;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): string {\n    const expressions = this.expressions;\n    const cooked = this.cooked;\n    let result = cooked[0];\n    for (let i = 0, ii = expressions.length; i < ii; ++i) {\n      result += expressions[i].evaluate(flags, scope, locator);\n      result += cooked[i + 1];\n    }\n    return result;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const expressions = this.expressions;\n    for (let i = 0, ii = expressions.length; i < ii; ++i) {\n      expressions[i].connect(flags, scope, binding);\n      i++;\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitTemplate(this);\n  }\n}\n\nexport class TaggedTemplate implements IExpression {\n  public $kind: ExpressionKind.TaggedTemplate;\n  public assign: IExpression['assign'];\n  constructor(\n    public readonly cooked: ReadonlyArray<string> & { raw?: ReadonlyArray<string> },\n    raw: ReadonlyArray<string>,\n    public readonly func: IsLeftHandSide,\n    public readonly expressions?: ReadonlyArray<IsAssign>) {\n    cooked.raw = raw;\n    this.expressions = expressions || PLATFORM.emptyArray;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): string {\n    const expressions = this.expressions;\n    const len = expressions.length;\n    const results = Array(len);\n    for (let i = 0, ii = len; i < ii; ++i) {\n      results[i] = expressions[i].evaluate(flags, scope, locator);\n    }\n    const func = this.func.evaluate(flags, scope, locator) as StrictAny; // not sure why this cast is needed..\n    if (typeof func !== 'function') {\n      throw Reporter.error(RuntimeError.NotAFunction, this);\n    }\n    return func.apply(null, [this.cooked].concat(results));\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const expressions = this.expressions;\n    for (let i = 0, ii = expressions.length; i < ii; ++i) {\n      expressions[i].connect(flags, scope, binding);\n    }\n    this.func.connect(flags, scope, binding);\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitTaggedTemplate(this);\n  }\n}\n\nexport class ArrayBindingPattern implements IExpression {\n  public $kind: ExpressionKind.ArrayBindingPattern;\n  // We'll either have elements, or keys+values, but never all 3\n  constructor(\n    public readonly elements: ReadonlyArray<IsAssign>\n  ) { }\n\n  // tslint:disable-next-line:no-any\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): any {\n    // TODO\n  }\n\n  // tslint:disable-next-line:no-any\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, obj: IIndexable): any {\n    // TODO\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    return;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitArrayBindingPattern(this);\n  }\n}\n\nexport class ObjectBindingPattern implements IExpression {\n  public $kind: ExpressionKind.ObjectBindingPattern;\n  // We'll either have elements, or keys+values, but never all 3\n  constructor(\n    public readonly keys: ReadonlyArray<string | number>,\n    public readonly values: ReadonlyArray<IsAssign>\n  ) { }\n\n  // tslint:disable-next-line:no-any\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): any {\n    // TODO\n  }\n\n  // tslint:disable-next-line:no-any\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, obj: IIndexable): any {\n    // TODO\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    return;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitObjectBindingPattern(this);\n  }\n}\n\nexport class BindingIdentifier implements IExpression {\n  public $kind: ExpressionKind.BindingIdentifier;\n  constructor(public readonly name: string) { }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): StrictAny {\n    return this.name;\n  }\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    return;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitBindingIdentifier(this);\n  }\n}\n\nexport type BindingIdentifierOrPattern = BindingIdentifier | ArrayBindingPattern | ObjectBindingPattern;\n\nconst toStringTag = Object.prototype.toString;\n\n// https://tc39.github.io/ecma262/#sec-iteration-statements\n// https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements\nexport class ForOfStatement implements IExpression {\n  public $kind: ExpressionKind.ForOfStatement;\n  public assign: IExpression['assign'];\n  constructor(\n    public readonly declaration: BindingIdentifierOrPattern,\n    public readonly iterable: IsBindingBehavior) { }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): StrictAny {\n    return this.iterable.evaluate(flags, scope, locator);\n  }\n\n  public count(result: ObservedCollection | number | null | undefined): number {\n    return CountForOfStatement[toStringTag.call(result)](result);\n  }\n\n  // tslint:disable-next-line:no-any\n  public iterate(result: ObservedCollection | number | null | undefined, func: (arr: Collection, index: number, item: any) => void): void {\n    IterateForOfStatement[toStringTag.call(result)](result, func);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    this.declaration.connect(flags, scope, binding);\n    this.iterable.connect(flags, scope, binding);\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitForOfStatement(this);\n  }\n}\n\n/*\n* Note: this implementation is far simpler than the one in vCurrent and might be missing important stuff (not sure yet)\n* so while this implementation is identical to Template and we could reuse that one, we don't want to lock outselves in to potentially the wrong abstraction\n* but this class might be a candidate for removal if it turns out it does provide all we need\n*/\nexport class Interpolation implements IExpression {\n  public $kind: ExpressionKind.Interpolation;\n  public assign: IExpression['assign'];\n  public readonly isMulti: boolean;\n  public readonly firstExpression: IsBindingBehavior;\n  constructor(\n    public readonly parts: ReadonlyArray<string>,\n    public readonly expressions: ReadonlyArray<IsBindingBehavior>) {\n      this.isMulti = expressions.length > 1;\n      this.firstExpression = expressions[0];\n    }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): string {\n    if (this.isMulti) {\n      const expressions = this.expressions;\n      const parts = this.parts;\n      let result = parts[0];\n      for (let i = 0, ii = expressions.length; i < ii; ++i) {\n        result += expressions[i].evaluate(flags, scope, locator);\n        result += parts[i + 1];\n      }\n      return result;\n    } else {\n      const parts = this.parts;\n      return parts[0] + this.firstExpression.evaluate(flags, scope, locator) + parts[1];\n    }\n  }\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    return;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitInterpolation(this);\n  }\n}\n\n/*\n* Note: for a property that is always the same, directly assigning it to the prototype is more efficient CPU wise\n* (gets assigned once, instead of per constructor call) as well as memory wise (stored once, instead of per instance)\n*\n* This gives us a cheap way to add some extra information to the AST for the runtime to do things more efficiently.\n*/\nBindingBehavior.prototype.$kind = ExpressionKind.BindingBehavior;\nValueConverter.prototype.$kind = ExpressionKind.ValueConverter;\nAssign.prototype.$kind = ExpressionKind.Assign;\nConditional.prototype.$kind = ExpressionKind.Conditional;\nAccessThis.prototype.$kind = ExpressionKind.AccessThis;\nAccessScope.prototype.$kind = ExpressionKind.AccessScope;\nAccessMember.prototype.$kind = ExpressionKind.AccessMember;\nAccessKeyed.prototype.$kind = ExpressionKind.AccessKeyed;\nCallScope.prototype.$kind = ExpressionKind.CallScope;\nCallMember.prototype.$kind = ExpressionKind.CallMember;\nCallFunction.prototype.$kind = ExpressionKind.CallFunction;\nBinary.prototype.$kind = ExpressionKind.Binary;\nUnary.prototype.$kind = ExpressionKind.Unary;\nPrimitiveLiteral.prototype.$kind = ExpressionKind.PrimitiveLiteral;\nHtmlLiteral.prototype.$kind = ExpressionKind.HtmlLiteral;\nArrayLiteral.prototype.$kind = ExpressionKind.ArrayLiteral;\nObjectLiteral.prototype.$kind = ExpressionKind.ObjectLiteral;\nTemplate.prototype.$kind = ExpressionKind.Template;\nTaggedTemplate.prototype.$kind = ExpressionKind.TaggedTemplate;\nArrayBindingPattern.prototype.$kind = ExpressionKind.ArrayBindingPattern;\nObjectBindingPattern.prototype.$kind = ExpressionKind.ObjectBindingPattern;\nBindingIdentifier.prototype.$kind = ExpressionKind.BindingIdentifier;\nForOfStatement.prototype.$kind = ExpressionKind.ForOfStatement;\nInterpolation.prototype.$kind = ExpressionKind.Interpolation;\n\n/// Evaluate the [list] in context of the [scope].\nfunction evalList(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, list: ReadonlyArray<IExpression>): StrictAny[] {\n  const len = list.length;\n  const result = Array(len);\n  for (let i = 0; i < len; ++i) {\n    result[i] = list[i].evaluate(flags, scope, locator);\n  }\n  return result;\n}\n\nfunction getFunction(flags: LifecycleFlags, obj: StrictAny, name: string): Function | null {\n  const func = obj === null || obj === undefined ? null : obj[name];\n  if (typeof func === 'function') {\n    return func;\n  }\n  if (!(flags & LifecycleFlags.mustEvaluate) && (func === null || func === undefined)) {\n    return null;\n  }\n  throw Reporter.error(RuntimeError.NotAFunction, obj, name, func);\n}\n\nfunction isNumeric(value: StrictAny): value is number {\n  const valueType = typeof value;\n  if (valueType === 'number') return true;\n  if (valueType !== 'string') return false;\n  const len = (<string>value).length;\n  if (len === 0) return false;\n  for (let i = 0; i < len; ++i) {\n    const char = (<string>value).charCodeAt(i);\n    if (char < 0x30 /*0*/ || char > 0x39/*9*/) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*@internal*/\nexport const IterateForOfStatement = {\n  ['[object Array]'](result: StrictAny[], func: (arr: Collection, index: number, item: StrictAny) => void): void {\n    for (let i = 0, ii = result.length; i < ii; ++i) {\n      func(result, i, result[i]);\n    }\n  },\n  ['[object Map]'](result: Map<StrictAny, StrictAny>, func: (arr: Collection, index: number, item: StrictAny) => void): void {\n    const arr = Array(result.size);\n    let i = -1;\n    for (const entry of result.entries()) {\n      arr[++i] = entry;\n    }\n    IterateForOfStatement['[object Array]'](arr, func);\n  },\n  ['[object Set]'](result: Set<StrictAny>, func: (arr: Collection, index: number, item: StrictAny) => void): void {\n    const arr = Array(result.size);\n    let i = -1;\n    for (const key of result.keys()) {\n      arr[++i] = key;\n    }\n    IterateForOfStatement['[object Array]'](arr, func);\n  },\n  ['[object Number]'](result: number, func: (arr: Collection, index: number, item: StrictAny) => void): void {\n    const arr = Array(result);\n    for (let i = 0; i < result; ++i) {\n      arr[i] = i;\n    }\n    IterateForOfStatement['[object Array]'](arr, func);\n  },\n  ['[object Null]'](result: null, func: (arr: Collection, index: number, item: StrictAny) => void): void {\n    return;\n  },\n  ['[object Undefined]'](result: null, func: (arr: Collection, index: number, item: StrictAny) => void): void {\n    return;\n  }\n};\n\n/*@internal*/\nexport const CountForOfStatement = {\n  ['[object Array]'](result: StrictAny[]): number { return result.length; },\n  ['[object Map]'](result: Map<StrictAny, StrictAny>): number { return result.size; },\n  ['[object Set]'](result: Set<StrictAny>): number { return result.size; },\n  ['[object Number]'](result: number): number { return result; },\n  ['[object Null]'](result: null): number { return 0; },\n  ['[object Undefined]'](result: null): number { return 0; }\n};\n\n// Give each AST class a noop for each interface method if and only if it's not already defined\n// This accomplishes the following:\n//   1) no runtime error due to bad AST structure (it's the parser's job to guard against that)\n//   2) no runtime error due to a bad binding such as two-way on a literal (no need, since it doesn't threaten the integrity of the app's state)\n//   3) should we decide something else, we can easily change the global behavior of 1) and 2) by simply assigning a different method here (either in the source or via AOT)\nconst ast = [AccessThis, AccessScope, ArrayLiteral, ObjectLiteral, PrimitiveLiteral, Template, Unary, CallFunction, CallMember, CallScope, AccessMember, AccessKeyed, TaggedTemplate, Binary, Conditional, Assign, ForOfStatement];\nfor (let i = 0, ii = ast.length; i < ii; ++i) {\n  const proto = ast[i].prototype;\n  // tslint:disable-next-line:no-any\n  proto.assign = proto.assign || <any>PLATFORM.noop;\n  proto.connect = proto.connect || PLATFORM.noop;\n}\n","import { Decoratable, Decorated, IIndexable } from '@aurelia/kernel';\nimport { IBindingTargetObserver, IPropertySubscriber, LifecycleFlags } from '../observation';\nimport { StrictAny } from './ast';\nimport { IBinding } from './binding';\nimport { IObserverLocator } from './observer-locator';\n\n// TODO: add connect-queue (or something similar) back in when everything else is working, to improve startup time\n\nconst slotNames: string[] = [];\nconst versionSlotNames: string[] = [];\nlet lastSlot = -1;\nfunction ensureEnoughSlotNames(currentSlot: number): void {\n  if (currentSlot === lastSlot) {\n    lastSlot += 5;\n    const ii = slotNames.length = versionSlotNames.length = lastSlot + 1;\n    for (let i = currentSlot + 1; i < ii; ++i) {\n      slotNames[i] = `_observer${i}`;\n      versionSlotNames[i] = `_observerVersion${i}`;\n    }\n  }\n}\nensureEnoughSlotNames(-1);\n\nexport interface IPartialConnectableBinding extends IBinding, IPropertySubscriber {\n  observerLocator: IObserverLocator;\n}\n\nexport interface IConnectableBinding extends IPartialConnectableBinding {\n  $nextConnect?: IConnectableBinding;\n  $nextPatch?: IConnectableBinding;\n  observerSlots: number;\n  version: number;\n  observeProperty(obj: StrictAny, propertyName: StrictAny): void;\n  addObserver(observer: IBindingTargetObserver): void;\n  unobserve(all?: boolean): void;\n  connect(flags: LifecycleFlags): void;\n  patch(flags: LifecycleFlags): void;\n}\n\n/*@internal*/\nexport function addObserver(this: IConnectableBinding, observer: IBindingTargetObserver): void {\n  // find the observer.\n  const observerSlots = this.observerSlots === undefined ? 0 : this.observerSlots;\n  let i = observerSlots;\n\n  while (i-- && this[slotNames[i]] !== observer);\n\n  // if we are not already observing, put the observer in an open slot and subscribe.\n  if (i === -1) {\n    i = 0;\n    while (this[slotNames[i]]) {\n      i++;\n    }\n    this[slotNames[i]] = observer;\n    observer.subscribe(this);\n    // increment the slot count.\n    if (i === observerSlots) {\n      this.observerSlots = i + 1;\n    }\n  }\n  // set the \"version\" when the observer was used.\n  if (this.version === undefined) {\n    this.version = 0;\n  }\n  this[versionSlotNames[i]] = this.version;\n  ensureEnoughSlotNames(i);\n}\n\n/*@internal*/\nexport function observeProperty(this: IConnectableBinding, obj: IIndexable, propertyName: string): void {\n  const observer = this.observerLocator.getObserver(obj, propertyName) as IBindingTargetObserver;\n  /* Note: we need to cast here because we can indeed get an accessor instead of an observer,\n   *  in which case the call to observer.subscribe will throw. It's not very clean and we can solve this in 2 ways:\n   *  1. Fail earlier: only let the locator resolve observers from .getObserver, and throw if no branches are left (e.g. it would otherwise return an accessor)\n   *  2. Fail silently (without throwing): give all accessors a no-op subscribe method\n   *\n   * We'll probably want to implement some global configuration (like a \"strict\" toggle) so users can pick between enforced correctness vs. ease-of-use\n   */\n  this.addObserver(observer);\n}\n\n/*@internal*/\nexport function unobserve(this: IConnectableBinding, all?: boolean): void {\n  const slots = this.observerSlots;\n  let slotName: string;\n  let observer: IBindingTargetObserver;\n  if (all === true) {\n    for (let i = 0; i < slots; ++i) {\n      slotName = slotNames[i];\n      observer = this[slotName];\n      if (observer !== null && observer !== undefined) {\n        this[slotName] = null;\n        observer.unsubscribe(this);\n      }\n    }\n  } else {\n    const version = this.version;\n    for (let i = 0; i < slots; ++i) {\n      if (this[versionSlotNames[i]] !== version) {\n        slotName = slotNames[i];\n        observer = this[slotName];\n        if (observer !== null && observer !== undefined) {\n          this[slotName] = null;\n          observer.unsubscribe(this);\n        }\n      }\n    }\n  }\n}\n\ntype DecoratableConnectable = Decoratable<IConnectableBinding, IPartialConnectableBinding>;\ntype DecoratedConnectable = Decorated<IConnectableBinding, IPartialConnectableBinding>;\n\nfunction connectableDecorator(target: DecoratableConnectable): DecoratedConnectable {\n  const proto = target.prototype;\n  if (!proto.hasOwnProperty('observeProperty')) proto.observeProperty = observeProperty;\n  if (!proto.hasOwnProperty('unobserve')) proto.unobserve = unobserve;\n  if (!proto.hasOwnProperty('addObserver')) proto.addObserver = addObserver;\n  return target as DecoratedConnectable;\n}\n\nexport function connectable(): typeof connectableDecorator;\nexport function connectable(target: DecoratableConnectable): DecoratedConnectable;\nexport function connectable(target?: DecoratableConnectable): DecoratedConnectable | typeof connectableDecorator {\n  return target === undefined ? connectableDecorator : connectableDecorator(target);\n}\n","import { IServiceLocator, Reporter } from '@aurelia/kernel';\nimport { IBindScope, ILifecycle, State } from '../lifecycle';\nimport { AccessorOrObserver, IBindingTargetObserver, IScope, LifecycleFlags } from '../observation';\nimport { ExpressionKind, ForOfStatement, hasBind, hasUnbind, IsBindingBehavior } from './ast';\nimport { BindingMode } from './binding-mode';\nimport { connectable, IConnectableBinding, IPartialConnectableBinding } from './connectable';\nimport { IObserverLocator } from './observer-locator';\n\n// tslint:disable:no-any\n\nexport interface IBinding extends IBindScope {\n  readonly locator: IServiceLocator;\n  readonly $scope: IScope;\n}\n\nexport type IBindingTarget = any; // Node | CSSStyleDeclaration | IObservable;\n\n// BindingMode is not a const enum (and therefore not inlined), so assigning them to a variable to save a member accessor is a minor perf tweak\nconst { oneTime, toView, fromView } = BindingMode;\n\n// pre-combining flags for bitwise checks is a minor perf tweak\nconst toViewOrOneTime = toView | oneTime;\n\nexport interface Binding extends IConnectableBinding {}\n\n@connectable()\nexport class Binding implements IPartialConnectableBinding {\n  public $nextConnect: IConnectableBinding = null;\n  public $nextPatch: IConnectableBinding = null;\n  public $nextBind: IBindScope = null;\n  public $prevBind: IBindScope = null;\n\n  public $state: State = State.none;\n  public $scope: IScope = null;\n  public $lifecycle: ILifecycle;\n\n  public targetObserver: AccessorOrObserver;\n\n  constructor(\n    public sourceExpression: IsBindingBehavior | ForOfStatement,\n    public target: IBindingTarget,\n    public targetProperty: string,\n    public mode: BindingMode,\n    public observerLocator: IObserverLocator,\n    public locator: IServiceLocator) {\n    this.$lifecycle = locator.get(ILifecycle);\n  }\n\n  public updateTarget(value: any, flags: LifecycleFlags): void {\n    this.targetObserver.setValue(value, flags | LifecycleFlags.updateTargetInstance);\n  }\n\n  public updateSource(value: any, flags: LifecycleFlags): void {\n    this.sourceExpression.assign(flags | LifecycleFlags.updateSourceExpression, this.$scope, this.locator, value);\n  }\n\n  public handleChange(newValue: any, previousValue: any, flags: LifecycleFlags): void {\n    if (!(this.$state & State.isBound)) {\n      return;\n    }\n\n    const sourceExpression = this.sourceExpression;\n    const $scope = this.$scope;\n    const locator = this.locator;\n\n    if (flags & LifecycleFlags.updateTargetInstance) {\n      const targetObserver = this.targetObserver;\n      const mode = this.mode;\n\n      previousValue = targetObserver.getValue();\n      // if the only observable is an AccessScope then we can assume the passed-in newValue is the correct and latest value\n      if (sourceExpression.$kind !== ExpressionKind.AccessScope || this.observerSlots > 1) {\n        newValue = sourceExpression.evaluate(flags, $scope, locator);\n      }\n      if (newValue !== previousValue) {\n        this.updateTarget(newValue, flags);\n      }\n      if ((mode & oneTime) === 0) {\n        this.version++;\n        sourceExpression.connect(flags, $scope, this);\n        this.unobserve(false);\n      }\n      return;\n    }\n\n    if (flags & LifecycleFlags.updateSourceExpression) {\n      if (newValue !== sourceExpression.evaluate(flags, $scope, locator)) {\n        this.updateSource(newValue, flags);\n      }\n      return;\n    }\n\n    throw Reporter.error(15, LifecycleFlags[flags]);\n  }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        return;\n      }\n      this.$unbind(flags | LifecycleFlags.fromBind);\n    }\n    // add isBinding flag\n    this.$state |= State.isBinding;\n\n    this.$scope = scope;\n\n    let sourceExpression = this.sourceExpression;\n    if (hasBind(sourceExpression)) {\n      sourceExpression.bind(flags, scope, this);\n    }\n\n    const mode = this.mode;\n    let targetObserver = this.targetObserver as IBindingTargetObserver;\n    if (!targetObserver) {\n      if (mode & fromView) {\n        targetObserver = this.targetObserver = this.observerLocator.getObserver(this.target, this.targetProperty) as IBindingTargetObserver;\n      } else {\n        targetObserver = this.targetObserver = this.observerLocator.getAccessor(this.target, this.targetProperty) as IBindingTargetObserver;\n      }\n    }\n    if (targetObserver.bind) {\n      targetObserver.bind(flags);\n    }\n\n    // during bind, binding behavior might have changed sourceExpression\n    sourceExpression = this.sourceExpression;\n    if (mode & toViewOrOneTime) {\n      this.updateTarget(sourceExpression.evaluate(flags, scope, this.locator), flags);\n    }\n    if (mode & toView) {\n      this.$lifecycle.enqueueConnect(this);\n    }\n    if (mode & fromView) {\n      targetObserver.subscribe(this);\n    }\n\n    // add isBound flag and remove isBinding flag\n    this.$state |= State.isBound;\n    this.$state &= ~State.isBinding;\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (!(this.$state & State.isBound)) {\n      return;\n    }\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    const sourceExpression = this.sourceExpression;\n    if (hasUnbind(sourceExpression)) {\n      sourceExpression.unbind(flags, this.$scope, this);\n    }\n    this.$scope = null;\n\n    const targetObserver = this.targetObserver as IBindingTargetObserver;\n    if (targetObserver.unbind) {\n      targetObserver.unbind(flags);\n    }\n    if (targetObserver.unsubscribe) {\n      targetObserver.unsubscribe(this);\n    }\n    this.unobserve(true);\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n  }\n\n  public connect(flags: LifecycleFlags): void {\n    if (this.$state & State.isBound) {\n      this.sourceExpression.connect(flags | LifecycleFlags.mustEvaluate, this.$scope, this);\n    }\n  }\n\n  public patch(flags: LifecycleFlags): void {\n    if (this.$state & State.isBound) {\n      this.updateTarget(this.sourceExpression.evaluate(flags | LifecycleFlags.mustEvaluate, this.$scope, this.locator), flags);\n    }\n  }\n}\n","import { IScope, LifecycleFlags } from '../../observation';\nimport { Binding } from '../binding';\nimport { bindingBehavior } from '../binding-behavior';\nimport { BindingMode } from '../binding-mode';\nimport { Call } from '../call';\nimport { Listener } from '../listener';\n\nexport type DebounceableBinding = (Binding | Call | Listener) & {\n  debouncedMethod: ((newValue: any, oldValue: any, flags: LifecycleFlags) => void) & { originalName: string };\n  debounceState: {\n    callContextToDebounce: LifecycleFlags;\n    delay: number;\n    timeoutId: any;\n    oldValue: any;\n  };\n};\n\nconst unset = {};\n\n/*@internal*/\nexport function debounceCallSource(event: Event): void {\n  const state = this.debounceState;\n  clearTimeout(state.timeoutId);\n  state.timeoutId = setTimeout(() => this.debouncedMethod(event), state.delay);\n}\n\n/*@internal*/\nexport function debounceCall(this: DebounceableBinding, newValue: any, oldValue: any, flags: LifecycleFlags): void {\n  const state = this.debounceState;\n  clearTimeout(state.timeoutId);\n  if (!(flags & state.callContextToDebounce)) {\n    state.oldValue = unset;\n    this.debouncedMethod(newValue, oldValue, flags);\n    return;\n  }\n  if (state.oldValue === unset) {\n    state.oldValue = oldValue;\n  }\n  state.timeoutId = setTimeout(\n    () => {\n      const ov = state.oldValue;\n      state.oldValue = unset;\n      this.debouncedMethod(newValue, ov, flags);\n    },\n    state.delay\n  );\n}\n\nconst fromView = BindingMode.fromView;\n\n@bindingBehavior('debounce')\nexport class DebounceBindingBehavior {\n  public bind(flags: LifecycleFlags, scope: IScope, binding: DebounceableBinding, delay: number = 200): void {\n    let methodToDebounce;\n    let callContextToDebounce;\n    let debouncer;\n\n    if (binding instanceof Binding) {\n      methodToDebounce = 'handleChange';\n      debouncer = debounceCall;\n      callContextToDebounce = binding.mode & fromView ? LifecycleFlags.updateSourceExpression : LifecycleFlags.updateTargetInstance;\n    } else {\n      methodToDebounce = 'callSource';\n      debouncer = debounceCallSource;\n      callContextToDebounce = LifecycleFlags.updateTargetInstance;\n    }\n\n    // stash the original method and it's name.\n    // note: a generic name like \"originalMethod\" is not used to avoid collisions\n    // with other binding behavior types.\n    binding.debouncedMethod = binding[methodToDebounce];\n    binding.debouncedMethod.originalName = methodToDebounce;\n\n    // replace the original method with the debouncing version.\n    binding[methodToDebounce] = debouncer;\n\n    // create the debounce state.\n    binding.debounceState = {\n      callContextToDebounce,\n      delay,\n      timeoutId: 0,\n      oldValue: unset\n    };\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: DebounceableBinding): void {\n    // restore the state of the binding.\n    const methodToRestore = binding.debouncedMethod.originalName;\n    binding[methodToRestore] = binding.debouncedMethod;\n    binding.debouncedMethod = null;\n    clearTimeout(binding.debounceState.timeoutId);\n    binding.debounceState = null;\n  }\n}\n","import { DI, inject } from '@aurelia/kernel';\nimport { valueConverter } from '../value-converter';\n\nconst SCRIPT_REGEX = /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi;\n\nexport interface ISanitizer {\n /**\n  * Sanitizes the provided input.\n  * @param input The input to be sanitized.\n  */\n  sanitize(input: string): string;\n}\n\nexport const ISanitizer = DI.createInterface<ISanitizer>()\n  .withDefault(x => x.singleton(class {\n    public sanitize(input: string): string {\n      return input.replace(SCRIPT_REGEX, '');\n    }\n  })\n);\n\n/**\n * Simple html sanitization converter to preserve whitelisted elements and attributes on a bound property containing html.\n */\n@valueConverter('sanitize')\n@inject(ISanitizer)\nexport class SanitizeValueConverter {\n  constructor(private sanitizer: ISanitizer) {\n    this.sanitizer = sanitizer;\n  }\n\n /**\n  * Process the provided markup that flows to the view.\n  * @param untrustedMarkup The untrusted markup to be sanitized.\n  */\n  public toView(untrustedMarkup: string): string|null {\n    if (untrustedMarkup === null || untrustedMarkup === undefined) {\n      return null;\n    }\n\n    return this.sanitizer.sanitize(untrustedMarkup);\n  }\n}\n","import { DI, IDisposable } from '@aurelia/kernel';\nimport { DOM, INode } from '../dom';\n\nexport interface IEventWithStandardPropagation extends Event {\n  propagationStopped?: boolean;\n  standardStopPropagation?: Event['stopPropagation'];\n}\n\n/*@internal*/\nexport type CompatibleEvent = {\n  target?: EventTarget;\n\n  // legacy\n  path?: EventTarget[];\n\n  // old composedPath\n  deepPath?(): EventTarget[];\n\n  // current spec\n  composedPath?(): EventTarget[];\n};\n\n//Note: path and deepPath are designed to handle v0 and v1 shadow dom specs respectively\n/*@internal*/\nexport function findOriginalEventTarget(event: Event & CompatibleEvent): EventTarget {\n  return (event.composedPath && event.composedPath()[0]) || (event.deepPath && event.deepPath()[0]) || (event.path && event.path[0]) || event.target;\n}\n\nfunction stopPropagation(this: IEventWithStandardPropagation): void {\n  this.standardStopPropagation();\n  this.propagationStopped = true;\n}\n\nfunction handleCapturedEvent(event: IEventWithStandardPropagation): void {\n  event.propagationStopped = false;\n  let target: IEventTargetWithLookups = findOriginalEventTarget(event) as EventTarget & IEventTargetWithLookups;\n  const orderedCallbacks = [];\n  /**\n   * During capturing phase, event 'bubbles' down from parent. Needs to reorder callback from root down to target\n   */\n  while (target) {\n    if (target.capturedCallbacks) {\n      const callback = target.capturedCallbacks[event.type];\n      if (callback) {\n        if (event.stopPropagation !== stopPropagation) {\n          event.standardStopPropagation = event.stopPropagation;\n          event.stopPropagation = stopPropagation;\n        }\n        orderedCallbacks.push(callback);\n      }\n    }\n    target = target.parentNode;\n  }\n\n  for (let i = orderedCallbacks.length - 1; i >= 0 && !event.propagationStopped; i--) {\n    const orderedCallback = orderedCallbacks[i];\n    if ('handleEvent' in orderedCallback) {\n      orderedCallback.handleEvent(event);\n    } else {\n      orderedCallback(event);\n    }\n  }\n}\n\nfunction handleDelegatedEvent(event: IEventWithStandardPropagation): void {\n  event.propagationStopped = false;\n  let target: IEventTargetWithLookups = findOriginalEventTarget(event) as EventTarget & IEventTargetWithLookups;\n  while (target && !event.propagationStopped) {\n    if (target.delegatedCallbacks) {\n      const callback = target.delegatedCallbacks[event.type];\n      if (callback) {\n        if (event.stopPropagation !== stopPropagation) {\n          event.standardStopPropagation = event.stopPropagation;\n          event.stopPropagation = stopPropagation;\n        }\n        if ('handleEvent' in callback) {\n          callback.handleEvent(event);\n        } else {\n          callback(event);\n        }\n      }\n    }\n    target = target.parentNode;\n  }\n}\n\nexport class ListenerTracker {\n  private count: number = 0;\n\n  constructor(\n    private eventName: string,\n    private listener: EventListenerOrEventListenerObject,\n    private capture: boolean\n  ) { }\n\n  public increment(): void {\n    this.count++;\n    if (this.count === 1) {\n      DOM.addEventListener(this.eventName, this.listener, null, this.capture);\n    }\n  }\n\n  public decrement(): void {\n    this.count--;\n    if (this.count === 0) {\n      DOM.removeEventListener(this.eventName, this.listener, null, this.capture);\n    }\n  }\n}\n\n/**\n * Enable dispose() pattern for `delegate` & `capture` commands\n */\nexport class DelegateOrCaptureSubscription {\n  constructor(\n    public entry: ListenerTracker,\n    public lookup: Record<string, EventListenerOrEventListenerObject>,\n    public targetEvent: string,\n    callback: EventListenerOrEventListenerObject\n  ) {\n    lookup[targetEvent] = callback;\n  }\n\n  public dispose(): void {\n    this.entry.decrement();\n    this.lookup[this.targetEvent] = null;\n  }\n}\n\n/**\n * Enable dispose() pattern for addEventListener for `trigger`\n */\nexport class TriggerSubscription {\n  constructor(\n    public target: INode,\n    public targetEvent: string,\n    public callback: EventListenerOrEventListenerObject\n  ) {\n    DOM.addEventListener(targetEvent, callback, target);\n  }\n\n  public dispose(): void {\n    DOM.removeEventListener(this.targetEvent, this.callback, this.target);\n  }\n}\n\nexport interface  IEventTargetWithLookups extends INode {\n  delegatedCallbacks?: Record<string, EventListenerOrEventListenerObject>;\n  capturedCallbacks?: Record<string, EventListenerOrEventListenerObject>;\n}\n\nexport enum DelegationStrategy {\n  none = 0,\n  capturing = 1,\n  bubbling = 2\n}\n\nexport interface IElementConfiguration {\n  tagName: string;\n  properties: Record<string, string[]>;\n}\n\nexport interface IEventSubscriber extends IDisposable {\n  subscribe(node: INode, callbackOrListener: EventListenerOrEventListenerObject): void;\n}\n\nexport class EventSubscriber implements IEventSubscriber {\n  private target: INode;\n  private handler: EventListenerOrEventListenerObject;\n\n  constructor(private readonly events: string[]) {\n    this.events = events;\n    this.target = null;\n    this.handler = null;\n  }\n\n  public subscribe(node: INode, callbackOrListener: EventListenerOrEventListenerObject): void {\n    this.target = node;\n    this.handler = callbackOrListener;\n\n    const add = DOM.addEventListener;\n    const events = this.events;\n\n    for (let i = 0, ii = events.length; ii > i; ++i) {\n      add(events[i], callbackOrListener, node);\n    }\n  }\n\n  public dispose(): void {\n    const node = this.target;\n    const callbackOrListener = this.handler;\n    const events = this.events;\n    const remove = DOM.removeEventListener;\n\n    for (let i = 0, ii = events.length; ii > i; ++i) {\n      remove(events[i], callbackOrListener, node);\n    }\n\n    this.target = this.handler = null;\n  }\n}\n\nexport type EventSubscription = DelegateOrCaptureSubscription | TriggerSubscription;\n\nexport interface IEventManager {\n  registerElementConfiguration(config: IElementConfiguration): void;\n  getElementHandler(target: INode, propertyName: string): IEventSubscriber | null;\n  addEventListener(target: INode, targetEvent: string, callbackOrListener: EventListenerOrEventListenerObject, delegate: DelegationStrategy): IDisposable;\n}\n\nexport const IEventManager = DI.createInterface<IEventManager>()\n  .withDefault(x => x.singleton(EventManager));\n\n/*@internal*/\nexport class EventManager implements IEventManager {\n  public elementHandlerLookup: Record<string, Record<string, string[]>> = {};\n  public delegatedHandlers: Record<string, ListenerTracker> = {};\n  public capturedHandlers: Record<string, ListenerTracker> = {};\n\n  constructor() {\n    this.registerElementConfiguration({\n      tagName: 'INPUT',\n      properties: {\n        value: ['change', 'input'],\n        checked: ['change', 'input'],\n        files: ['change', 'input']\n      }\n    });\n    this.registerElementConfiguration({\n      tagName: 'TEXTAREA',\n      properties: {\n        value: ['change', 'input']\n      }\n    });\n    this.registerElementConfiguration({\n      tagName: 'SELECT',\n      properties: {\n        value: ['change']\n      }\n    });\n    this.registerElementConfiguration({\n      tagName: 'content editable',\n      properties: {\n        value: ['change', 'input', 'blur', 'keyup', 'paste']\n      }\n    });\n    this.registerElementConfiguration({\n      tagName: 'scrollable element',\n      properties: {\n        scrollTop: ['scroll'],\n        scrollLeft: ['scroll']\n      }\n    });\n  }\n\n  public registerElementConfiguration(config: IElementConfiguration): void {\n    const properties = config.properties;\n    const lookup: Record<string, string[]> = this.elementHandlerLookup[config.tagName] = {};\n\n    for (const propertyName in properties) {\n      if (properties.hasOwnProperty(propertyName)) {\n        lookup[propertyName] = properties[propertyName];\n      }\n    }\n  }\n\n  public getElementHandler(target: INode, propertyName: string): IEventSubscriber | null {\n    const tagName = target['tagName'];\n    const lookup = this.elementHandlerLookup;\n\n    if (tagName) {\n      if (lookup[tagName] && lookup[tagName][propertyName]) {\n        return new EventSubscriber(lookup[tagName][propertyName]);\n      }\n      if (propertyName === 'textContent' || propertyName === 'innerHTML') {\n        return new EventSubscriber(lookup['content editable'].value);\n      }\n      if (propertyName === 'scrollTop' || propertyName === 'scrollLeft') {\n        return new EventSubscriber(lookup['scrollable element'][propertyName]);\n      }\n    }\n    return null;\n  }\n\n  public addEventListener(\n    target: IEventTargetWithLookups,\n    targetEvent: string,\n    callbackOrListener: EventListenerOrEventListenerObject,\n    strategy: DelegationStrategy\n  ): EventSubscription {\n    let delegatedHandlers: Record<string, ListenerTracker> | undefined;\n    let capturedHandlers: Record<string, ListenerTracker> | undefined;\n    let handlerEntry: ListenerTracker | ListenerTracker | undefined;\n\n    if (strategy === DelegationStrategy.bubbling) {\n      delegatedHandlers = this.delegatedHandlers;\n      handlerEntry = delegatedHandlers[targetEvent] || (delegatedHandlers[targetEvent] = new ListenerTracker(targetEvent, handleDelegatedEvent, false));\n      handlerEntry.increment();\n      const delegatedCallbacks = target.delegatedCallbacks || (target.delegatedCallbacks = {});\n      return new DelegateOrCaptureSubscription(handlerEntry, delegatedCallbacks, targetEvent, callbackOrListener);\n    }\n    if (strategy === DelegationStrategy.capturing) {\n      capturedHandlers = this.capturedHandlers;\n      handlerEntry = capturedHandlers[targetEvent] || (capturedHandlers[targetEvent] = new ListenerTracker(targetEvent, handleCapturedEvent, true));\n      handlerEntry.increment();\n      const capturedCallbacks = target.capturedCallbacks || (target.capturedCallbacks = {});\n      return new DelegateOrCaptureSubscription(handlerEntry, capturedCallbacks, targetEvent, callbackOrListener);\n    }\n    return new TriggerSubscription(target, targetEvent, callbackOrListener);\n  }\n}\n","import { Reporter } from '@aurelia/kernel';\nimport { IScope, LifecycleFlags } from '../../observation';\nimport { bindingBehavior } from '../binding-behavior';\nimport { findOriginalEventTarget } from '../event-manager';\nimport { Listener } from '../listener';\n\n/*@internal*/\nexport function handleSelfEvent(event: Event): ReturnType<Listener['callSource']> {\n  const target = findOriginalEventTarget(event);\n\n  if (this.target !== target) {\n    return;\n  }\n\n  return this.selfEventCallSource(event);\n}\n\nexport type SelfableBinding = Listener & {\n  selfEventCallSource: Listener['callSource'];\n};\n\n@bindingBehavior('self')\nexport class SelfBindingBehavior {\n  public bind(flags: LifecycleFlags, scope: IScope, binding: SelfableBinding): void {\n    if (!binding.callSource || !binding.targetEvent) {\n      throw Reporter.error(8);\n    }\n\n    binding.selfEventCallSource = binding.callSource;\n    binding.callSource = handleSelfEvent;\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: SelfableBinding): void {\n    binding.callSource = binding.selfEventCallSource;\n    binding.selfEventCallSource = null;\n  }\n}\n","import { inject, Reporter } from '@aurelia/kernel';\nimport { IScope, LifecycleFlags } from '../../observation';\nimport { Binding } from '../binding';\nimport { bindingBehavior } from '../binding-behavior';\nimport { ISignaler } from '../signaler';\n\nexport type SignalableBinding = Binding & {\n  signal: string | string[];\n};\n\n@bindingBehavior('signal')\n@inject(ISignaler)\nexport class SignalBindingBehavior {\n  constructor(private signaler: ISignaler) {}\n\n  public bind(flags: LifecycleFlags, scope: IScope, binding: SignalableBinding): void {\n    if (!binding.updateTarget) {\n      throw Reporter.error(11);\n    }\n\n    if (arguments.length === 4) {\n      const name = arguments[3];\n      this.signaler.addSignalListener(name, binding);\n      binding.signal = name;\n    } else if (arguments.length > 4) {\n      const names = Array.prototype.slice.call(arguments, 3);\n      let i = names.length;\n\n      while (i--) {\n        const name = names[i];\n        this.signaler.addSignalListener(name, binding);\n      }\n\n      binding.signal = names;\n    } else {\n      throw Reporter.error(12);\n    }\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: SignalableBinding): void {\n    const name = binding.signal;\n    binding.signal = null;\n\n    if (Array.isArray(name)) {\n      const names = name;\n      let i = names.length;\n\n      while (i--) {\n        this.signaler.removeSignalListener(names[i], binding);\n      }\n    } else {\n      this.signaler.removeSignalListener(name, binding);\n    }\n  }\n}\n","import { IScope, LifecycleFlags } from '../../observation';\nimport { Binding } from '../binding';\nimport { bindingBehavior } from '../binding-behavior';\nimport { BindingMode } from '../binding-mode';\nimport { Call } from '../call';\nimport { Listener } from '../listener';\n\nexport type ThrottleableBinding = (Binding | Call | Listener) & {\n  throttledMethod: ((value: any) => any) & { originalName: string };\n  throttleState: {\n    delay: number;\n    timeoutId: any;\n    last: any;\n    newValue?: any;\n  };\n};\n\n/*@internal*/\nexport function throttle(this: ThrottleableBinding, newValue: any): void {\n  const state = this.throttleState;\n  const elapsed = +new Date() - state.last;\n\n  if (elapsed >= state.delay) {\n    clearTimeout(state.timeoutId);\n    state.timeoutId = null;\n    state.last = +new Date();\n    this.throttledMethod(newValue);\n    return;\n  }\n\n  state.newValue = newValue;\n\n  if (state.timeoutId === null) {\n    state.timeoutId = setTimeout(\n      () => {\n        state.timeoutId = null;\n        state.last = +new Date();\n        this.throttledMethod(state.newValue);\n      },\n      state.delay - elapsed\n    );\n  }\n}\n\n@bindingBehavior('throttle')\nexport class ThrottleBindingBehavior {\n  public bind(flags: LifecycleFlags, scope: IScope, binding: ThrottleableBinding, delay: number = 200): void {\n    let methodToThrottle: string;\n\n    if (binding instanceof Binding) {\n      if (binding.mode === BindingMode.twoWay) {\n        methodToThrottle = 'updateSource';\n      } else {\n        methodToThrottle = 'updateTarget';\n      }\n    } else {\n      methodToThrottle = 'callSource';\n    }\n\n    // stash the original method and it's name.\n    // note: a generic name like \"originalMethod\" is not used to avoid collisions\n    // with other binding behavior types.\n    binding.throttledMethod = binding[methodToThrottle];\n    binding.throttledMethod.originalName = methodToThrottle;\n\n    // replace the original method with the throttling version.\n    binding[methodToThrottle] = throttle;\n\n    // create the throttle state.\n    binding.throttleState = {\n      delay: delay,\n      last: 0,\n      timeoutId: null\n    };\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: ThrottleableBinding): void {\n    // restore the state of the binding.\n    const methodToRestore = binding.throttledMethod.originalName;\n    binding[methodToRestore] = binding.throttledMethod;\n    binding.throttledMethod = null;\n    clearTimeout(binding.throttleState.timeoutId);\n    binding.throttleState = null;\n  }\n}\n","import {\n  Collection, CollectionKind, CollectionObserver, IBindingTargetObserver,\n  ICollectionObserver, IndexMap, IPropertySubscriber, LifecycleFlags, MutationKind\n} from '../observation';\nimport { batchedSubscriberCollection, subscriberCollection } from './subscriber-collection';\nimport { targetObserver } from './target-observer';\n\nfunction flush(this: CollectionObserver): void {\n  this.callBatchedSubscribers(this.indexMap);\n  this.resetIndexMap();\n}\n\nfunction dispose(this: CollectionObserver): void {\n  this.collection.$observer = undefined;\n  this.collection = null;\n  this.indexMap = null;\n}\n\nfunction resetIndexMapIndexed(this: ICollectionObserver<CollectionKind.indexed>): void {\n  const len = this.collection.length;\n  const indexMap: IndexMap = (this.indexMap = Array(len));\n  let i = 0;\n  while (i < len) {\n    indexMap[i] = i++;\n  }\n  indexMap.deletedItems = [];\n}\n\nfunction resetIndexMapKeyed(this: ICollectionObserver<CollectionKind.keyed>): void {\n  const len = this.collection.size;\n  const indexMap: IndexMap = (this.indexMap = Array(len));\n  let i = 0;\n  while (i < len) {\n    indexMap[i] = i++;\n  }\n  indexMap.deletedItems = [];\n}\n\nfunction getLengthObserver(this: CollectionObserver): CollectionLengthObserver {\n  return this.lengthObserver || <any>(this.lengthObserver = new CollectionLengthObserver(<any>this, this.lengthPropertyName));\n}\n\nexport function collectionObserver(kind: CollectionKind.array | CollectionKind.set | CollectionKind.map): ClassDecorator {\n  return function(target: Function): void {\n    subscriberCollection(MutationKind.collection)(target);\n    batchedSubscriberCollection()(target);\n    const proto = <CollectionObserver>target.prototype;\n\n    proto.$nextFlush = null;\n\n    proto.collection = null;\n    proto.indexMap = null;\n    proto.hasChanges = false;\n    proto.lengthPropertyName = kind & CollectionKind.indexed ? 'length' : 'size';\n    proto.collectionKind = kind;\n    proto.resetIndexMap = kind & CollectionKind.indexed ? resetIndexMapIndexed : resetIndexMapKeyed;\n    proto.flush = flush;\n    proto.dispose = dispose;\n    proto.getLengthObserver = getLengthObserver;\n\n    proto.subscribe = proto.subscribe || proto.addSubscriber;\n    proto.unsubscribe = proto.unsubscribe || proto.removeSubscriber;\n\n    proto.subscribeBatched = proto.subscribeBatched || proto.addBatchedSubscriber;\n    proto.unsubscribeBatched = proto.unsubscribeBatched || proto.removeBatchedSubscriber;\n  };\n}\n\nexport interface CollectionLengthObserver extends IBindingTargetObserver<any, string> {}\n\n@targetObserver()\nexport class CollectionLengthObserver implements CollectionLengthObserver {\n  public currentValue: number;\n  public currentFlags: LifecycleFlags;\n\n  constructor(public obj: Collection, public propertyKey: 'length' | 'size') {\n    this.currentValue = obj[propertyKey];\n  }\n\n  public getValue(): number {\n    return this.obj[this.propertyKey];\n  }\n\n  public setValueCore(newValue: number): void {\n    this.obj[this.propertyKey] = newValue;\n  }\n\n  public subscribe(subscriber: IPropertySubscriber): void {\n    this.addSubscriber(subscriber);\n  }\n\n  public unsubscribe(subscriber: IPropertySubscriber): void {\n    this.removeSubscriber(subscriber);\n  }\n}\n","import { IIndexable, Primitive } from '@aurelia/kernel';\nimport { ILifecycle } from '../lifecycle';\nimport { CollectionKind, ICollectionObserver, IndexMap, IObservedArray, LifecycleFlags } from '../observation';\nimport { collectionObserver } from './collection-observer';\nconst proto = Array.prototype;\nexport const nativePush = proto.push; // TODO: probably want to make these internal again\nexport const nativeUnshift = proto.unshift;\nexport const nativePop = proto.pop;\nexport const nativeShift = proto.shift;\nexport const nativeSplice = proto.splice;\nexport const nativeReverse = proto.reverse;\nexport const nativeSort = proto.sort;\n\n// https://tc39.github.io/ecma262/#sec-array.prototype.push\nfunction observePush(this: IObservedArray): ReturnType<typeof nativePush> {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativePush.apply(this, arguments);\n  }\n  const len = this.length;\n  const argCount = arguments.length;\n  if (argCount === 0) {\n    return len;\n  }\n  this.length = o.indexMap.length = len + argCount;\n  let i = len;\n  while (i < this.length) {\n    this[i] = arguments[i - len]; o.indexMap[i] = - 2;\n    i++;\n  }\n  o.callSubscribers('push', arguments, LifecycleFlags.isCollectionMutation);\n  return this.length;\n}\n\n// https://tc39.github.io/ecma262/#sec-array.prototype.unshift\nfunction observeUnshift(this: IObservedArray): ReturnType<typeof nativeUnshift>  {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativeUnshift.apply(this, arguments);\n  }\n  const argCount = arguments.length;\n  const inserts = new Array(argCount);\n  let i = 0;\n  while (i < argCount) {\n    inserts[i++] = - 2;\n  }\n  nativeUnshift.apply(o.indexMap, inserts);\n  const len = nativeUnshift.apply(this, arguments);\n  o.callSubscribers('unshift', arguments, LifecycleFlags.isCollectionMutation);\n  return len;\n}\n\n// https://tc39.github.io/ecma262/#sec-array.prototype.pop\nfunction observePop(this: IObservedArray): ReturnType<typeof nativePop> {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativePop.call(this);\n  }\n  const indexMap = o.indexMap;\n  const element = nativePop.call(this);\n  // only mark indices as deleted if they actually existed in the original array\n  const index = indexMap.length - 1;\n  if (indexMap[index] > -1) {\n    nativePush.call(indexMap.deletedItems, element);\n  }\n  nativePop.call(indexMap);\n  o.callSubscribers('pop', arguments, LifecycleFlags.isCollectionMutation);\n  return element;\n}\n\n// https://tc39.github.io/ecma262/#sec-array.prototype.shift\nfunction observeShift(this: IObservedArray): ReturnType<typeof nativeShift> {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativeShift.call(this);\n  }\n  const indexMap = o.indexMap;\n  const element = nativeShift.call(this);\n  // only mark indices as deleted if they actually existed in the original array\n  if (indexMap[0] > -1) {\n    nativePush.call(indexMap.deletedItems, element);\n  }\n  nativeShift.call(indexMap);\n  o.callSubscribers('shift', arguments, LifecycleFlags.isCollectionMutation);\n  return element;\n}\n\n// https://tc39.github.io/ecma262/#sec-array.prototype.splice\nfunction observeSplice(this: IObservedArray, start: number, deleteCount?: number): ReturnType<typeof nativeSplice> {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativeSplice.apply(this, arguments);\n  }\n  const indexMap = o.indexMap;\n  if (deleteCount > 0) {\n    let i = isNaN(start) ? 0 : start;\n    const to = i + deleteCount;\n    while (i < to) {\n      if (indexMap[i] > -1) {\n        nativePush.call(indexMap.deletedItems, this[i]);\n      }\n      i++;\n    }\n  }\n  const argCount = arguments.length;\n  if (argCount > 2) {\n    const itemCount = argCount - 2;\n    const inserts = new Array(itemCount);\n    let i = 0;\n    while (i < itemCount) {\n      inserts[i++] = - 2;\n    }\n    nativeSplice.call(indexMap, start, deleteCount, ...inserts);\n  } else if (argCount === 2) {\n    nativeSplice.call(indexMap, start, deleteCount);\n  }\n  const deleted = nativeSplice.apply(this, arguments);\n  o.callSubscribers('splice', arguments, LifecycleFlags.isCollectionMutation);\n  return deleted;\n}\n\n// https://tc39.github.io/ecma262/#sec-array.prototype.reverse\nfunction observeReverse(this: IObservedArray): ReturnType<typeof nativeReverse> {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativeReverse.call(this);\n  }\n  const len = this.length;\n  const middle = (len / 2) | 0;\n  let lower = 0;\n  while (lower !== middle) {\n    const upper = len - lower - 1;\n    const lowerValue = this[lower]; const lowerIndex = o.indexMap[lower];\n    const upperValue = this[upper]; const upperIndex = o.indexMap[upper];\n    this[lower] = upperValue; o.indexMap[lower] = upperIndex;\n    this[upper] = lowerValue; o.indexMap[upper] = lowerIndex;\n    lower++;\n  }\n  o.callSubscribers('reverse', arguments, LifecycleFlags.isCollectionMutation);\n  return this;\n}\n\n// https://tc39.github.io/ecma262/#sec-array.prototype.sort\n// https://github.com/v8/v8/blob/master/src/js/array.js\nfunction observeSort(this: IObservedArray, compareFn?: (a: IIndexable | Primitive, b: IIndexable | Primitive) => number): IObservedArray {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativeSort.call(this, compareFn);\n  }\n  const len = this.length;\n  if (len < 2) {\n    return this;\n  }\n  quickSort(this, o.indexMap, 0, len, preSortCompare);\n  let i = 0;\n  while (i < len) {\n    if (this[i] === undefined) {\n      break;\n    }\n    i++;\n  }\n  if (compareFn === undefined || typeof compareFn !== 'function'/*spec says throw a TypeError, should we do that too?*/) {\n    compareFn = sortCompare;\n  }\n  quickSort(this, o.indexMap, 0, i, compareFn);\n  o.callSubscribers('sort', arguments, LifecycleFlags.isCollectionMutation);\n  return this;\n}\n\n// https://tc39.github.io/ecma262/#sec-sortcompare\nfunction sortCompare(x: IIndexable | Primitive, y: IIndexable | Primitive): number {\n  if (x === y) {\n    return 0;\n  }\n  x = x === null ? 'null' : x.toString();\n  y = y === null ? 'null' : y.toString();\n  return x < y ? -1 : 1;\n}\n\nfunction preSortCompare(x: IIndexable | Primitive, y: IIndexable | Primitive): number {\n  if (x === undefined) {\n    if (y === undefined) {\n      return 0;\n    } else {\n      return 1;\n    }\n  }\n  if (y === undefined) {\n    return -1;\n  }\n  return 0;\n}\n\nfunction insertionSort(arr: IObservedArray, indexMap: IndexMap, fromIndex: number, toIndex: number, compareFn: (a: IIndexable | Primitive, b: IIndexable | Primitive) => number): void {\n  let velement, ielement, vtmp, itmp, order;\n  let i, j;\n  for (i = fromIndex + 1; i < toIndex; i++) {\n    velement = arr[i]; ielement = indexMap[i];\n    for (j = i - 1; j >= fromIndex; j--) {\n      vtmp = arr[j]; itmp = indexMap[j];\n      order = compareFn(vtmp, velement);\n      if (order > 0) {\n        arr[j + 1] = vtmp; indexMap[j + 1] = itmp;\n      } else {\n        break;\n      }\n    }\n    arr[j + 1] = velement; indexMap[j + 1] = ielement;\n  }\n}\n\nfunction quickSort(arr: IObservedArray, indexMap: IndexMap, fromIndex: number, toIndex: number, compareFn: (a: IIndexable | Primitive, b: IIndexable | Primitive) => number): void {\n  let thirdIndex = 0, i = 0;\n  let v0, v1, v2;\n  let i0, i1, i2;\n  let c01, c02, c12;\n  let vtmp, itmp;\n  let vpivot, ipivot, lowEnd, highStart;\n  let velement, ielement, order, vtopElement;\n\n  // tslint:disable-next-line:no-constant-condition\n  while (true) {\n    if (toIndex - fromIndex <= 10) {\n      insertionSort(arr, indexMap, fromIndex, toIndex, compareFn);\n      return;\n    }\n\n    thirdIndex = fromIndex + ((toIndex - fromIndex) >> 1);\n    v0 = arr[fromIndex];       i0 = indexMap[fromIndex];\n    v1 = arr[toIndex - 1];     i1 = indexMap[toIndex - 1];\n    v2 = arr[thirdIndex]; i2 = indexMap[thirdIndex];\n    c01 = compareFn(v0, v1);\n    if (c01 > 0) {\n      vtmp = v0; itmp = i0;\n      v0 = v1;   i0 = i1;\n      v1 = vtmp; i1 = itmp;\n    }\n    c02 = compareFn(v0, v2);\n    if (c02 >= 0) {\n      vtmp = v0; itmp = i0;\n      v0 = v2;   i0 = i2;\n      v2 = v1;   i2 = i1;\n      v1 = vtmp; i1 = itmp;\n    } else {\n      c12 = compareFn(v1, v2);\n      if (c12 > 0) {\n        vtmp = v1; itmp = i1;\n        v1 = v2;   i1 = i2;\n        v2 = vtmp; i2 = itmp;\n      }\n    }\n    arr[fromIndex] = v0;   indexMap[fromIndex] = i0;\n    arr[toIndex - 1] = v2; indexMap[toIndex - 1] = i2;\n    vpivot = v1;      ipivot = i1;\n    lowEnd = fromIndex + 1;\n    highStart = toIndex - 1;\n    arr[thirdIndex] = arr[lowEnd]; indexMap[thirdIndex] = indexMap[lowEnd];\n    arr[lowEnd] = vpivot;          indexMap[lowEnd] = ipivot;\n\n    partition: for (i = lowEnd + 1; i < highStart; i++) {\n      velement = arr[i]; ielement = indexMap[i];\n      order = compareFn(velement, vpivot);\n      if (order < 0) {\n        arr[i] = arr[lowEnd];   indexMap[i] = indexMap[lowEnd];\n        arr[lowEnd] = velement; indexMap[lowEnd] = ielement;\n        lowEnd++;\n      } else if (order > 0) {\n        do {\n          highStart--;\n          // tslint:disable-next-line:triple-equals\n          if (highStart == i) {\n            break partition;\n          }\n          vtopElement = arr[highStart];          order = compareFn(vtopElement, vpivot);\n        } while (order > 0);\n        arr[i] = arr[highStart];   indexMap[i] = indexMap[highStart];\n        arr[highStart] = velement; indexMap[highStart] = ielement;\n        if (order < 0) {\n          velement = arr[i];      ielement = indexMap[i];\n          arr[i] = arr[lowEnd];   indexMap[i] = indexMap[lowEnd];\n          arr[lowEnd] = velement; indexMap[lowEnd] = ielement;\n          lowEnd++;\n        }\n      }\n    }\n    if (toIndex - highStart < lowEnd - fromIndex) {\n      quickSort(arr, indexMap, highStart, toIndex, compareFn);\n      toIndex = lowEnd;\n    } else {\n      quickSort(arr, indexMap, fromIndex, lowEnd, compareFn);\n      fromIndex = highStart;\n    }\n  }\n}\n\nfor (const observe of [observePush, observeUnshift, observePop, observeShift, observeSplice, observeReverse, observeSort]) {\n  Object.defineProperty(observe, 'observing', { value: true, writable: false, configurable: false, enumerable: false });\n}\n\nexport function enableArrayObservation(): void {\n  if (proto.push['observing'] !== true) proto.push = observePush;\n  if (proto.unshift['observing'] !== true) proto.unshift = observeUnshift;\n  if (proto.pop['observing'] !== true) proto.pop = observePop;\n  if (proto.shift['observing'] !== true) proto.shift = observeShift;\n  if (proto.splice['observing'] !== true) proto.splice = observeSplice;\n  if (proto.reverse['observing'] !== true) proto.reverse = observeReverse;\n  if (proto.sort['observing'] !== true) proto.sort = observeSort;\n}\n\nenableArrayObservation();\n\nexport function disableArrayObservation(): void {\n  if (proto.push['observing'] === true) proto.push = nativePush;\n  if (proto.unshift['observing'] === true) proto.unshift = nativeUnshift;\n  if (proto.pop['observing'] === true) proto.pop = nativePop;\n  if (proto.shift['observing'] === true) proto.shift = nativeShift;\n  if (proto.splice['observing'] === true) proto.splice = nativeSplice;\n  if (proto.reverse['observing'] === true) proto.reverse = nativeReverse;\n  if (proto.sort['observing'] === true) proto.sort = nativeSort;\n}\n\nexport interface ArrayObserver extends ICollectionObserver<CollectionKind.array> {}\n\n@collectionObserver(CollectionKind.array)\nexport class ArrayObserver implements ArrayObserver {\n  public resetIndexMap: () => void;\n\n  public collection: IObservedArray;\n\n  constructor(lifecycle: ILifecycle, array: IObservedArray) {\n    this.lifecycle = lifecycle;\n    array.$observer = this;\n    this.collection = array;\n    this.resetIndexMap();\n  }\n}\n\nexport function getArrayObserver(lifecycle: ILifecycle, array: IObservedArray): ArrayObserver {\n  return (array.$observer as ArrayObserver) || new ArrayObserver(lifecycle, array);\n}\n","import { IIndexable, PLATFORM, Primitive, Reporter } from '@aurelia/kernel';\nimport { ILifecycle } from '../lifecycle';\nimport { IBindingTargetAccessor, IBindingTargetObserver, IObservable, IPropertySubscriber, ISubscribable, LifecycleFlags, MutationKind } from '../observation';\nimport { IDirtyChecker } from './dirty-checker';\nimport { IObserverLocator } from './observer-locator';\nimport { subscriberCollection } from './subscriber-collection';\n\nexport interface ComputedOverrides {\n  // Indicates that a getter doesn't need to re-calculate its dependencies after the first observation.\n  // tslint:disable-next-line:no-reserved-keywords\n  static?: boolean;\n\n  // Indicates that the getter of a getter/setter pair can change its value based on side-effects outside the setter.\n  volatile?: boolean;\n}\n\nexport type ComputedLookup = { computed?: Record<string, ComputedOverrides> };\n\nexport function computed(config: ComputedOverrides): PropertyDecorator {\n  return function(target: Object & ComputedLookup, key: string): void {\n    (target.computed || (target.computed = {}))[key] = config;\n  };\n}\n\nconst noProxy = !(typeof Proxy !== undefined);\nconst computedOverrideDefaults: ComputedOverrides = { static: false, volatile: false };\n\n/* @internal */\nexport function createComputedObserver(\n  observerLocator: IObserverLocator,\n  dirtyChecker: IDirtyChecker,\n  lifecycle: ILifecycle,\n  // tslint:disable-next-line:no-reserved-keywords\n  instance: IObservable & { constructor: Function & ComputedLookup },\n  propertyName: string,\n  descriptor: PropertyDescriptor): IBindingTargetAccessor {\n\n  if (descriptor.configurable === false) {\n    return dirtyChecker.createProperty(instance, propertyName);\n  }\n\n  if (descriptor.get) {\n    const overrides: ComputedOverrides = instance.constructor.computed\n      ? instance.constructor.computed[propertyName] || computedOverrideDefaults\n      : computedOverrideDefaults;\n\n    if (descriptor.set) {\n      if (overrides.volatile) {\n        return noProxy\n          ? dirtyChecker.createProperty(instance, propertyName)\n          : new GetterObserver(overrides, instance, propertyName, descriptor, observerLocator, lifecycle);\n      }\n\n      return new CustomSetterObserver(instance, propertyName, descriptor, lifecycle);\n    }\n\n    return noProxy\n      ? dirtyChecker.createProperty(instance, propertyName)\n      : new GetterObserver(overrides, instance, propertyName, descriptor, observerLocator, lifecycle);\n  }\n\n  throw Reporter.error(18, propertyName);\n}\n\nexport interface CustomSetterObserver extends IBindingTargetObserver { }\n\n// Used when the getter is dependent solely on changes that happen within the setter.\n@subscriberCollection(MutationKind.instance)\nexport class CustomSetterObserver implements CustomSetterObserver {\n  public $nextFlush: this = null;\n  public dispose: () => void;\n  public observing: boolean = false;\n  public currentValue: IIndexable | Primitive;\n  public oldValue: IIndexable | Primitive;\n\n  constructor(\n    public obj: IObservable,\n    public propertyKey: string,\n    private descriptor: PropertyDescriptor,\n    private lifecycle: ILifecycle\n  ) { }\n\n  public getValue(): IIndexable | Primitive {\n    return this.obj[this.propertyKey];\n  }\n\n  public setValue(newValue: IIndexable | Primitive): void {\n    this.obj[this.propertyKey] = newValue;\n  }\n\n  public flush(flags: LifecycleFlags): void {\n    const oldValue = this.oldValue;\n    const newValue = this.currentValue;\n\n    this.callSubscribers(newValue, oldValue, flags | LifecycleFlags.updateTargetInstance);\n  }\n\n  public subscribe(subscriber: IPropertySubscriber): void {\n    if (!this.observing) {\n      this.convertProperty();\n    }\n    this.addSubscriber(subscriber);\n  }\n\n  public unsubscribe(subscriber: IPropertySubscriber): void {\n    this.removeSubscriber(subscriber);\n  }\n\n  public convertProperty(): void {\n    const setter = this.descriptor.set;\n    const that = this;\n\n    this.observing = true;\n    this.currentValue = this.obj[this.propertyKey];\n\n    Reflect.defineProperty(this.obj, this.propertyKey, {\n      set: function(newValue: IIndexable | Primitive): void {\n        setter.call(that.obj, newValue);\n\n        const oldValue = this.currentValue;\n\n        if (oldValue !== newValue) {\n          that.oldValue = oldValue;\n          this.lifecycle.queueFlush(that);\n\n          that.currentValue = newValue;\n        }\n      }\n    });\n  }\n}\n\nCustomSetterObserver.prototype.dispose = PLATFORM.noop;\n\nexport interface GetterObserver extends IBindingTargetObserver { }\n\n// Used when there is no setter, and the getter is dependent on other properties of the object;\n// Used when there is a setter but the value of the getter can change based on properties set outside of the setter.\n/*@internal*/\n@subscriberCollection(MutationKind.instance)\nexport class GetterObserver implements GetterObserver {\n  public dispose: () => void;\n  private controller: GetterController;\n\n  constructor(\n    private overrides: ComputedOverrides,\n    public obj: IObservable,\n    public propertyKey: string,\n    private descriptor: PropertyDescriptor,\n    private observerLocator: IObserverLocator,\n    private lifecycle: ILifecycle\n  ) {\n    this.controller = new GetterController(\n      overrides,\n      obj,\n      propertyKey,\n      descriptor,\n      this,\n      observerLocator,\n      lifecycle\n    );\n  }\n\n  public getValue(): IIndexable | Primitive {\n    return this.controller.value;\n  }\n\n  // tslint:disable-next-line:no-empty\n  public setValue(newValue: IIndexable | Primitive): void { }\n\n  public flush(flags: LifecycleFlags): void {\n    const oldValue = this.controller.value;\n    const newValue = this.controller.getValueAndCollectDependencies();\n\n    if (oldValue !== newValue) {\n      this.callSubscribers(newValue, oldValue, flags | LifecycleFlags.updateTargetInstance);\n    }\n  }\n\n  public subscribe(subscriber: IPropertySubscriber): void {\n    this.addSubscriber(subscriber);\n    this.controller.onSubscriberAdded();\n  }\n\n  public unsubscribe(subscriber: IPropertySubscriber): void {\n    this.removeSubscriber(subscriber);\n    this.controller.onSubscriberRemoved();\n  }\n}\n\nGetterObserver.prototype.dispose = PLATFORM.noop;\n\n/*@internal*/\nexport class GetterController {\n  public value: IIndexable | Primitive;\n  public isCollecting: boolean = false;\n\n  private dependencies: ISubscribable<MutationKind.instance>[] = [];\n  private subscriberCount: number = 0;\n\n  constructor(\n    private overrides: ComputedOverrides,\n    private instance: IObservable,\n    private propertyName: string,\n    descriptor: PropertyDescriptor,\n    private owner: GetterObserver,\n    observerLocator: IObserverLocator,\n    private lifecycle: ILifecycle\n  ) {\n    const proxy = new Proxy(instance, createGetterTraps(observerLocator, this));\n    const getter = descriptor.get;\n    const ctrl = this;\n\n    Reflect.defineProperty(instance, propertyName, {\n      get: function(): IIndexable | Primitive {\n        if (ctrl.subscriberCount < 1 || ctrl.isCollecting) {\n          ctrl.value = getter.apply(proxy);\n        }\n\n        return ctrl.value;\n      }\n    });\n  }\n\n  public addDependency(subscribable: ISubscribable<MutationKind.instance>): void {\n    if (this.dependencies.includes(subscribable)) {\n      return;\n    }\n\n    this.dependencies.push(subscribable);\n  }\n\n  public onSubscriberAdded(): void {\n    this.subscriberCount++;\n\n    if (this.subscriberCount > 1) {\n      return;\n    }\n\n    this.getValueAndCollectDependencies(true);\n  }\n\n  public getValueAndCollectDependencies(requireCollect: boolean = false): IIndexable | Primitive {\n    const dynamicDependencies = !this.overrides.static || requireCollect;\n\n    if (dynamicDependencies) {\n      this.unsubscribeAllDependencies();\n      this.isCollecting = true;\n    }\n\n    this.value = this.instance[this.propertyName]; // triggers observer collection\n\n    if (dynamicDependencies) {\n      this.isCollecting = false;\n      this.dependencies.forEach(x => { x.subscribe(this); });\n    }\n\n    return this.value;\n  }\n\n  public onSubscriberRemoved(): void {\n    this.subscriberCount--;\n\n    if (this.subscriberCount === 0) {\n      this.unsubscribeAllDependencies();\n    }\n  }\n\n  public handleChange(): void {\n    this.lifecycle.enqueueFlush(this.owner);\n  }\n\n  private unsubscribeAllDependencies(): void {\n    this.dependencies.forEach(x => { x.unsubscribe(this); });\n    this.dependencies.length = 0;\n  }\n}\n\nfunction createGetterTraps(observerLocator: IObserverLocator, controller: GetterController): ReturnType<typeof proxyOrValue> {\n  return {\n    get: function(instance: IIndexable, key: string): IIndexable | Primitive {\n      const value = instance[key];\n\n      if (key === '$observers' || typeof value === 'function' || !controller.isCollecting) {\n        return value;\n      }\n\n      // TODO: fix this\n      if (instance instanceof Array) {\n        controller.addDependency(observerLocator.getArrayObserver(instance));\n\n        if (key === 'length') {\n          controller.addDependency(observerLocator.getArrayObserver(instance).getLengthObserver());\n        }\n      } else if (instance instanceof Map) {\n        controller.addDependency(observerLocator.getMapObserver(instance));\n\n        if (key === 'size') {\n          controller.addDependency(observerLocator.getMapObserver(instance).getLengthObserver());\n        }\n      } else if (instance instanceof Set) {\n        controller.addDependency(observerLocator.getSetObserver(instance));\n\n        if (key === 'size') {\n          return observerLocator.getSetObserver(instance).getLengthObserver();\n        }\n      } else {\n        controller.addDependency(observerLocator.getObserver(instance, key) as IBindingTargetObserver);\n      }\n\n      return proxyOrValue(observerLocator, controller, value);\n    }\n  };\n}\n\nfunction proxyOrValue(observerLocator: IObserverLocator, controller: GetterController, value: IIndexable): ProxyHandler<IIndexable> {\n  if (!(value instanceof Object)) {\n    return value;\n  }\n\n  return new Proxy(value, createGetterTraps(observerLocator, controller));\n}\n","import { DI, IIndexable, Primitive } from '@aurelia/kernel';\nimport { IBindingTargetAccessor, IBindingTargetObserver, IObservable, IPropertySubscriber, LifecycleFlags } from '../observation';\nimport { propertyObserver } from './property-observer';\n\nexport interface IDirtyChecker {\n  createProperty(obj: IObservable, propertyName: string): IBindingTargetAccessor;\n}\n\nexport const IDirtyChecker = DI.createInterface<IDirtyChecker>()\n  .withDefault(x => x.singleton(DirtyChecker));\n\n/*@internal*/\nexport class DirtyChecker {\n  private tracked: DirtyCheckProperty[] = [];\n  private checkDelay: number = 120;\n\n  public createProperty(obj: IObservable, propertyName: string): DirtyCheckProperty {\n    return new DirtyCheckProperty(this, obj, propertyName);\n  }\n\n  public addProperty(property: DirtyCheckProperty): void {\n    const tracked = this.tracked;\n\n    tracked.push(property);\n\n    if (tracked.length === 1) {\n      this.scheduleDirtyCheck();\n    }\n  }\n\n  public removeProperty(property: DirtyCheckProperty): void {\n    const tracked = this.tracked;\n    tracked.splice(tracked.indexOf(property), 1);\n  }\n\n  public scheduleDirtyCheck(): void {\n    setTimeout(() => { this.check(); }, this.checkDelay);\n  }\n\n  public check(): void {\n    const tracked = this.tracked;\n    let i = tracked.length;\n\n    while (i--) {\n      const current = tracked[i];\n\n      if (current.isDirty()) {\n        current.flush(LifecycleFlags.fromFlush);\n      }\n    }\n\n    if (tracked.length) {\n      this.scheduleDirtyCheck();\n    }\n  }\n}\n\nexport interface DirtyCheckProperty extends IBindingTargetObserver { }\n\n/*@internal*/\n@propertyObserver()\nexport class DirtyCheckProperty implements DirtyCheckProperty {\n  public oldValue: IIndexable | Primitive;\n\n  constructor(\n    private dirtyChecker: DirtyChecker,\n    public obj: IObservable,\n    public propertyKey: string) {\n\n    }\n\n  public isDirty(): boolean {\n    return this.oldValue !== this.obj[this.propertyKey];\n  }\n\n  public getValue(): IIndexable | Primitive {\n    return this.obj[this.propertyKey];\n  }\n\n  public setValue(newValue: IIndexable | Primitive): void {\n    this.obj[this.propertyKey] = newValue;\n  }\n\n  public flush(flags: LifecycleFlags): void {\n    const oldValue = this.oldValue;\n    const newValue = this.getValue();\n\n    this.callSubscribers(newValue, oldValue, flags | LifecycleFlags.updateTargetInstance);\n\n    this.oldValue = newValue;\n  }\n\n  public subscribe(subscriber: IPropertySubscriber): void {\n    if (!this.hasSubscribers()) {\n      this.oldValue = this.getValue();\n      this.dirtyChecker.addProperty(this);\n    }\n    this.addSubscriber(subscriber);\n  }\n\n  public unsubscribe(subscriber: IPropertySubscriber): void {\n    if (this.removeSubscriber(subscriber) && !this.hasSubscribers()) {\n      this.dirtyChecker.removeProperty(this);\n    }\n  }\n}\n","import { IIndexable, Primitive } from '@aurelia/kernel';\nimport { DOM, IElement, IInputElement, INode, INodeObserver } from '../dom';\nimport { ILifecycle } from '../lifecycle';\nimport {\n  CollectionKind, IBatchedCollectionSubscriber, IBindingTargetObserver, ICollectionObserver,\n  IndexMap, IObserversLookup,  IPropertySubscriber, LifecycleFlags\n} from '../observation';\nimport { IEventSubscriber } from './event-manager';\nimport { IObserverLocator } from './observer-locator';\nimport { SetterObserver } from './property-observation';\nimport { targetObserver } from './target-observer';\n\nconst inputValueDefaults = {\n  ['button']: '',\n  ['checkbox']: 'on',\n  ['color']: '#000000',\n  ['date']: '',\n  ['datetime-local']: '',\n  ['email']: '',\n  ['file']: '',\n  ['hidden']: '',\n  ['image']: '',\n  ['month']: '',\n  ['number']: '',\n  ['password']: '',\n  ['radio']: 'on',\n  ['range']: '50',\n  ['reset']: '',\n  ['search']: '',\n  ['submit']: '',\n  ['tel']: '',\n  ['text']: '',\n  ['time']: '',\n  ['url']: '',\n  ['week']: ''\n};\n\nconst handleEventFlags = LifecycleFlags.fromDOMEvent | LifecycleFlags.updateSourceExpression;\n\nexport interface ValueAttributeObserver extends\n  IBindingTargetObserver<INode, string, Primitive | IIndexable> { }\n\n@targetObserver('')\nexport class ValueAttributeObserver implements ValueAttributeObserver {\n  public currentValue: Primitive | IIndexable;\n  public currentFlags: LifecycleFlags;\n  public oldValue: Primitive | IIndexable;\n  public defaultValue: Primitive | IIndexable;\n\n  public flush: () => void;\n\n  constructor(\n    public lifecycle: ILifecycle,\n    public obj: INode,\n    public propertyKey: string,\n    public handler: IEventSubscriber\n  ) {\n    // note: input.files can be assigned and this was fixed in Firefox 57:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1384030\n\n    // input.value (for type='file') however, can only be assigned an empty string\n    if (propertyKey === 'value') {\n      const nodeType = obj['type'];\n      this.defaultValue = inputValueDefaults[nodeType || 'text'];\n      if (nodeType === 'file') {\n        this.flush = this.flushFileChanges;\n      }\n    } else {\n      this.defaultValue = '';\n    }\n    this.oldValue = this.currentValue = obj[propertyKey];\n  }\n\n  public getValue(): Primitive | IIndexable {\n    return this.obj[this.propertyKey];\n  }\n\n  public setValueCore(newValue: Primitive | IIndexable, flags: LifecycleFlags): void {\n    this.obj[this.propertyKey] = newValue;\n    if (flags & LifecycleFlags.fromBind) {\n      return;\n    }\n    this.callSubscribers(this.currentValue, this.oldValue, flags);\n  }\n\n  public handleEvent(): void {\n    const oldValue = this.oldValue = this.currentValue;\n    const newValue = this.currentValue = this.getValue();\n    if (oldValue !== newValue) {\n      this.callSubscribers(newValue, oldValue, handleEventFlags);\n      this.oldValue = newValue;\n    }\n  }\n\n  public subscribe(subscriber: IPropertySubscriber): void {\n    if (!this.hasSubscribers()) {\n      this.oldValue = this.getValue();\n      this.handler.subscribe(this.obj, this);\n    }\n    this.addSubscriber(subscriber);\n  }\n\n  public unsubscribe(subscriber: IPropertySubscriber): void {\n    if (this.removeSubscriber(subscriber) && !this.hasSubscribers()) {\n      this.handler.dispose();\n    }\n  }\n\n  private flushFileChanges(): void {\n    const currentValue = this.currentValue;\n    if (this.oldValue !== currentValue) {\n      if (currentValue === '') {\n        this.setValueCore(currentValue, this.currentFlags);\n        this.oldValue = this.currentValue;\n      }\n    }\n  }\n}\n\nValueAttributeObserver.prototype.propertyKey = '';\nValueAttributeObserver.prototype.handler = null;\n\nconst defaultHandleBatchedChangeFlags = LifecycleFlags.fromFlush | LifecycleFlags.updateTargetInstance;\n\ninterface IInternalInputElement extends IInputElement {\n  matcher?: typeof defaultMatcher;\n  model?: Primitive | IIndexable;\n  $observers?: IObserversLookup & {\n    model?: SetterObserver;\n    value?: ValueAttributeObserver;\n  };\n}\n\nexport interface CheckedObserver extends\n  IBindingTargetObserver<IInternalInputElement, string, Primitive | IIndexable>,\n  IBatchedCollectionSubscriber,\n  IPropertySubscriber { }\n\n@targetObserver()\nexport class CheckedObserver implements CheckedObserver {\n  public currentValue: Primitive | IIndexable;\n  public currentFlags: LifecycleFlags;\n  public oldValue: Primitive | IIndexable;\n  public defaultValue: Primitive | IIndexable;\n\n  public flush: () => void;\n\n  private arrayObserver: ICollectionObserver<CollectionKind.array>;\n  private valueObserver: ValueAttributeObserver | SetterObserver;\n\n  constructor(\n    public lifecycle: ILifecycle,\n    public obj: IInternalInputElement,\n    public handler: IEventSubscriber,\n    public observerLocator: IObserverLocator\n  ) { }\n\n  public getValue(): Primitive | IIndexable {\n    return this.currentValue;\n  }\n\n  public setValueCore(newValue: Primitive | IIndexable, flags: LifecycleFlags): void {\n    if (!this.valueObserver) {\n      this.valueObserver = this.obj['$observers'] && (this.obj['$observers'].model || this.obj['$observers'].value);\n      if (this.valueObserver) {\n        this.valueObserver.subscribe(this);\n      }\n    }\n    if (this.arrayObserver) {\n      this.arrayObserver.unsubscribeBatched(this);\n      this.arrayObserver = null;\n    }\n    if (this.obj.type === 'checkbox' && Array.isArray(newValue)) {\n      this.arrayObserver = this.observerLocator.getArrayObserver(newValue);\n      this.arrayObserver.subscribeBatched(this);\n    }\n    this.synchronizeElement();\n  }\n\n  // handleBatchedCollectionChange (todo: rename to make this explicit?)\n  public handleBatchedChange(): void {\n    this.synchronizeElement();\n    this.notify(defaultHandleBatchedChangeFlags);\n  }\n\n  // handlePropertyChange (todo: rename normal subscribe methods in target observers to batched, since that's what they really are)\n  public handleChange(newValue: Primitive | IIndexable, previousValue: Primitive | IIndexable, flags: LifecycleFlags): void {\n    this.synchronizeElement();\n    this.notify(flags);\n  }\n\n  public synchronizeElement(): void {\n    const value = this.currentValue;\n    const element = this.obj;\n    const elementValue = element.hasOwnProperty('model') ? element['model'] : element.value;\n    const isRadio = element.type === 'radio';\n    const matcher = element['matcher'] || ((a: Primitive | IIndexable, b: Primitive | IIndexable) => a === b);\n\n    if (isRadio) {\n      element.checked = !!matcher(value, elementValue);\n    } else if (value === true) {\n      element.checked = true;\n    } else if (Array.isArray(value)) {\n      element.checked = value.findIndex(item => !!matcher(item, elementValue)) !== -1;\n    } else {\n      element.checked = false;\n    }\n  }\n\n  public notify(flags: LifecycleFlags): void {\n    if (flags & LifecycleFlags.fromBind) {\n      return;\n    }\n    const oldValue = this.oldValue;\n    const newValue = this.currentValue;\n    if (newValue === oldValue) {\n      return;\n    }\n    this.callSubscribers(this.currentValue, this.oldValue, flags);\n  }\n\n  public handleEvent(): void {\n    let value = this.currentValue;\n    const element = this.obj;\n    const elementValue = element.hasOwnProperty('model') ? element['model'] : element.value;\n    let index;\n    const matcher = element['matcher'] || defaultMatcher;\n\n    if (element.type === 'checkbox') {\n      if (Array.isArray(value)) {\n        index = value.findIndex(item => !!matcher(item, elementValue));\n        if (element.checked && index === -1) {\n          value.push(elementValue);\n        } else if (!element.checked && index !== -1) {\n          value.splice(index, 1);\n        }\n        // when existing value is array, do not invoke callback as only the array element has changed\n        return;\n      }\n      value = element.checked;\n    } else if (element.checked) {\n      value = elementValue;\n    } else {\n      return;\n    }\n    this.oldValue = this.currentValue;\n    this.currentValue = value;\n    this.notify(handleEventFlags);\n  }\n\n  public subscribe(subscriber: IPropertySubscriber): void {\n    if (!this.hasSubscribers()) {\n      this.handler.subscribe(this.obj, this);\n    }\n    this.addSubscriber(subscriber);\n  }\n\n  public unsubscribe(subscriber: IPropertySubscriber): void {\n    if (this.removeSubscriber(subscriber) && !this.hasSubscribers()) {\n      this.handler.dispose();\n    }\n  }\n\n  public unbind(): void {\n    if (this.arrayObserver) {\n      this.arrayObserver.unsubscribeBatched(this);\n      this.arrayObserver = null;\n    }\n    if (this.valueObserver) {\n      this.valueObserver.unsubscribe(this);\n    }\n  }\n}\n\nCheckedObserver.prototype.handler = null;\nCheckedObserver.prototype.observerLocator = null;\n\nconst childObserverOptions = {\n  childList: true,\n  subtree: true,\n  characterData: true\n};\n\ntype UntypedArray = (Primitive | IIndexable)[];\n\nfunction defaultMatcher(a: Primitive | IIndexable, b: Primitive | IIndexable): boolean {\n  return a === b;\n}\n\nexport interface ISelectElement extends IElement {\n  multiple: boolean;\n  value: string;\n  options: ArrayLike<IOptionElement>;\n  matcher?: typeof defaultMatcher;\n}\nexport interface IOptionElement extends IElement {\n  model?: Primitive | IIndexable;\n  selected: boolean;\n  value: string;\n}\n\nexport interface SelectValueObserver extends\n  IBindingTargetObserver<ISelectElement, string, Primitive | IIndexable | UntypedArray>,\n  IBatchedCollectionSubscriber,\n  IPropertySubscriber { }\n\n@targetObserver()\nexport class SelectValueObserver implements SelectValueObserver {\n  public currentValue: Primitive | IIndexable | UntypedArray;\n  public currentFlags: LifecycleFlags;\n  public oldValue: Primitive | IIndexable | UntypedArray;\n  public defaultValue: Primitive | UntypedArray;\n\n  public flush: () => void;\n\n  private arrayObserver: ICollectionObserver<CollectionKind.array>;\n  private nodeObserver: INodeObserver;\n\n  constructor(\n    public lifecycle: ILifecycle,\n    public obj: ISelectElement,\n    public handler: IEventSubscriber,\n    public observerLocator: IObserverLocator\n  ) { }\n\n  public getValue(): Primitive | IIndexable | UntypedArray {\n    return this.currentValue;\n  }\n\n  public setValueCore(newValue: Primitive | UntypedArray, flags: LifecycleFlags): void {\n    const isArray = Array.isArray(newValue);\n    if (!isArray && newValue !== null && newValue !== undefined && this.obj.multiple) {\n      throw new Error('Only null or Array instances can be bound to a multi-select.');\n    }\n    if (this.arrayObserver) {\n      this.arrayObserver.unsubscribeBatched(this);\n      this.arrayObserver = null;\n    }\n    if (isArray) {\n      this.arrayObserver = this.observerLocator.getArrayObserver(<(Primitive | IIndexable)[]>newValue);\n      this.arrayObserver.subscribeBatched(this);\n    }\n    this.synchronizeOptions();\n    this.notify(flags);\n  }\n\n  // called when the array mutated (items sorted/added/removed, etc)\n  public handleBatchedChange(indexMap: number[]): void {\n    // we don't need to go through the normal setValue logic and can directly call synchronizeOptions here,\n    // because the change already waited one tick (batched) and there's no point in calling notify when the instance didn't change\n    this.synchronizeOptions(indexMap);\n  }\n\n  // called when a different value was assigned\n  public handleChange(newValue: Primitive | UntypedArray, previousValue: Primitive | UntypedArray, flags: LifecycleFlags): void {\n    this.setValue(newValue, flags);\n  }\n\n  public notify(flags: LifecycleFlags): void {\n    if (flags & LifecycleFlags.fromBind) {\n      return;\n    }\n    const oldValue = this.oldValue;\n    const newValue = this.currentValue;\n    if (newValue === oldValue) {\n      return;\n    }\n    this.callSubscribers(newValue, oldValue, flags);\n  }\n\n  public handleEvent(): void {\n    // \"from-view\" changes are always synchronous now, so immediately sync the value and notify subscribers\n    const shouldNotify = this.synchronizeValue();\n    if (shouldNotify) {\n      this.notify(handleEventFlags);\n    }\n  }\n\n  public synchronizeOptions(indexMap?: IndexMap): void {\n    const currentValue = this.currentValue;\n    const isArray = Array.isArray(currentValue);\n    const obj = this.obj;\n    const matcher = obj.matcher || defaultMatcher;\n    const options = obj.options;\n    let i = options.length;\n\n    while (i--) {\n      const option = options[i];\n      const optionValue = option.hasOwnProperty('model') ? option.model : option.value;\n      if (isArray) {\n        option.selected = (<UntypedArray>currentValue).findIndex(item => !!matcher(optionValue, item)) !== -1;\n        continue;\n      }\n      option.selected = !!matcher(optionValue, currentValue);\n    }\n  }\n\n  public synchronizeValue(): boolean {\n    // Spec for synchronizing value from `SelectObserver` to `<select/>`\n    // When synchronizing value to observed <select/> element, do the following steps:\n    // A. If `<select/>` is multiple\n    //    1. Check if current value, called `currentValue` is an array\n    //      a. If not an array, return true to signal value has changed\n    //      b. If is an array:\n    //        i. gather all current selected <option/>, in to array called `values`\n    //        ii. loop through the `currentValue` array and remove items that are nolonger selected based on matcher\n    //        iii. loop through the `values` array and add items that are selected based on matcher\n    //        iv. Return false to signal value hasn't changed\n    // B. If the select is single\n    //    1. Let `value` equal the first selected option, if no option selected, then `value` is `null`\n    //    2. assign `this.currentValue` to `this.oldValue`\n    //    3. assign `value` to `this.currentValue`\n    //    4. return `true` to signal value has changed\n    const obj = this.obj;\n    const options = obj.options;\n    const len = options.length;\n    const currentValue = this.currentValue;\n    let i = 0;\n\n    if (obj.multiple) {\n      // A.\n      if (!Array.isArray(currentValue)) {\n        // A.1.a\n        return true;\n      }\n      // A.1.b\n      // multi select\n      let option: IOptionElement;\n      const matcher = obj.matcher || defaultMatcher;\n      // A.1.b.i\n      const values: UntypedArray = [];\n      while (i < len) {\n        option = options[i];\n        if (option.selected) {\n          values.push(option.hasOwnProperty('model')\n            ? option.model\n            : option.value\n          );\n        }\n        ++i;\n      }\n      // A.1.b.ii\n      i = 0;\n      while (i < currentValue.length) {\n        const a = currentValue[i];\n        // Todo: remove arrow fn\n        if (values.findIndex(b => !!matcher(a, b)) === -1) {\n          currentValue.splice(i, 1);\n        } else {\n          ++i;\n        }\n      }\n      // A.1.b.iii\n      i = 0;\n      while (i < values.length) {\n        const a = values[i];\n        // Todo: remove arrow fn\n        if (currentValue.findIndex(b => !!matcher(a, b)) === -1) {\n          currentValue.push(a);\n        }\n        ++i;\n      }\n      // A.1.b.iv\n      return false;\n    }\n    // B. single select\n    // B.1\n    let value: Primitive | IIndexable | UntypedArray = null;\n    while (i < len) {\n      const option = options[i];\n      if (option.selected) {\n        value = option.hasOwnProperty('model')\n          ? option.model\n          : option.value;\n        break;\n      }\n      ++i;\n    }\n    // B.2\n    this.oldValue = this.currentValue;\n    // B.3\n    this.currentValue = value;\n    // B.4\n    return true;\n  }\n\n  public subscribe(subscriber: IPropertySubscriber): void {\n    if (!this.hasSubscribers()) {\n      this.handler.subscribe(this.obj, this);\n    }\n    this.addSubscriber(subscriber);\n  }\n\n  public unsubscribe(subscriber: IPropertySubscriber): void {\n    if (this.removeSubscriber(subscriber) && !this.hasSubscribers()) {\n      this.handler.dispose();\n    }\n  }\n\n  public bind(): void {\n    this.nodeObserver = DOM.createNodeObserver(\n      this.obj,\n      this.handleNodeChange.bind(this),\n      childObserverOptions\n    );\n  }\n\n  public unbind(): void {\n    this.nodeObserver.disconnect();\n    this.nodeObserver = null;\n\n    if (this.arrayObserver) {\n      this.arrayObserver.unsubscribeBatched(this);\n      this.arrayObserver = null;\n    }\n  }\n\n  public handleNodeChange(): void {\n    this.synchronizeOptions();\n    const shouldNotify = this.synchronizeValue();\n    if (shouldNotify) {\n      this.notify(handleEventFlags);\n    }\n  }\n}\n\nSelectValueObserver.prototype.handler = null;\nSelectValueObserver.prototype.observerLocator = null;\n","import { IIndexable, Primitive } from '@aurelia/kernel';\nimport { ILifecycle } from '../lifecycle';\nimport { CollectionKind, ICollectionObserver, IObservedMap, LifecycleFlags } from '../observation';\nimport { nativePush, nativeSplice } from './array-observer';\nimport { collectionObserver } from './collection-observer';\n\nconst proto = Map.prototype;\nexport const nativeSet = proto.set; // TODO: probably want to make these internal again\nexport const nativeClear = proto.clear;\nexport const nativeDelete = proto.delete;\n\n// note: we can't really do much with Map due to the internal data structure not being accessible so we're just using the native calls\n// fortunately, map/delete/clear are easy to reconstruct for the indexMap\n\n// https://tc39.github.io/ecma262/#sec-map.prototype.map\nfunction observeSet(this: IObservedMap, key: IIndexable | Primitive, value: IIndexable | Primitive): ReturnType<typeof nativeSet> {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativeSet.call(this, key, value);\n  }\n  const oldSize = this.size;\n  nativeSet.call(this, key, value);\n  const newSize = this.size;\n  if (newSize === oldSize) {\n    let i = 0;\n    for (const entry of this.entries()) {\n      if (entry[0] === key) {\n        if (entry[1] !== value) {\n          o.indexMap[i] = -2;\n        }\n        return this;\n      }\n      i++;\n    }\n    return this;\n  }\n  o.indexMap[oldSize] = -2;\n  o.callSubscribers('set', arguments, LifecycleFlags.isCollectionMutation);\n  return this;\n}\n\n// https://tc39.github.io/ecma262/#sec-map.prototype.clear\nfunction observeClear(this: IObservedMap): ReturnType<typeof nativeClear>  {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativeClear.call(this);\n  }\n  const size = this.size;\n  if (size > 0) {\n    const indexMap = o.indexMap;\n    let i = 0;\n    for (const entry of this.keys()) {\n      if (indexMap[i] > -1) {\n        nativePush.call(indexMap.deletedItems, entry);\n      }\n      i++;\n    }\n    nativeClear.call(this);\n    indexMap.length = 0;\n    o.callSubscribers('clear', arguments, LifecycleFlags.isCollectionMutation);\n  }\n  return undefined;\n}\n\n// https://tc39.github.io/ecma262/#sec-map.prototype.delete\nfunction observeDelete(this: IObservedMap, value: IIndexable | Primitive): ReturnType<typeof nativeDelete> {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativeDelete.call(this, value);\n  }\n  const size = this.size;\n  if (size === 0) {\n    return false;\n  }\n  let i = 0;\n  const indexMap = o.indexMap;\n  for (const entry of this.keys()) {\n    if (entry === value) {\n      if (indexMap[i] > -1) {\n        nativePush.call(indexMap.deletedItems, entry);\n      }\n      nativeSplice.call(indexMap, i, 1);\n      return nativeDelete.call(this, value);\n    }\n    i++;\n  }\n  o.callSubscribers('delete', arguments, LifecycleFlags.isCollectionMutation);\n  return false;\n}\n\nfor (const observe of [observeSet, observeClear, observeDelete]) {\n  Object.defineProperty(observe, 'observing', { value: true, writable: false, configurable: false, enumerable: false });\n}\n\nexport function enableMapObservation(): void {\n  if (proto.set['observing'] !== true) proto.set = observeSet;\n  if (proto.clear['observing'] !== true) proto.clear = observeClear;\n  if (proto.delete['observing'] !== true) proto.delete = observeDelete;\n}\n\nenableMapObservation();\n\nexport function disableMapObservation(): void {\n  if (proto.set['observing'] === true) proto.set = nativeSet;\n  if (proto.clear['observing'] === true) proto.clear = nativeClear;\n  if (proto.delete['observing'] === true) proto.delete = nativeDelete;\n}\n\nexport interface MapObserver extends ICollectionObserver<CollectionKind.map> {}\n\n@collectionObserver(CollectionKind.map)\nexport class MapObserver implements MapObserver {\n  public resetIndexMap: () => void;\n  public lifecycle: ILifecycle;\n\n  public collection: IObservedMap;\n\n  constructor(lifecycle: ILifecycle, map: IObservedMap) {\n    this.lifecycle = lifecycle;\n    map.$observer = this;\n    this.collection = map;\n    this.resetIndexMap();\n  }\n}\n\nexport function getMapObserver(lifecycle: ILifecycle, map: IObservedMap): MapObserver {\n  return (map.$observer as MapObserver) || new MapObserver(lifecycle, map);\n}\n","import { IIndexable, Primitive } from '@aurelia/kernel';\nimport { ILifecycle } from '../lifecycle';\nimport { CollectionKind, ICollectionObserver, IObservedSet, LifecycleFlags } from '../observation';\n// tslint:disable:no-reserved-keywords\nimport { nativePush, nativeSplice } from './array-observer';\nimport { collectionObserver } from './collection-observer';\n\nconst proto = Set.prototype;\nexport const nativeAdd = proto.add; // TODO: probably want to make these internal again\nexport const nativeClear = proto.clear;\nexport const nativeDelete = proto.delete;\n\n// note: we can't really do much with Set due to the internal data structure not being accessible so we're just using the native calls\n// fortunately, add/delete/clear are easy to reconstruct for the indexMap\n\n// https://tc39.github.io/ecma262/#sec-set.prototype.add\nfunction observeAdd(this: IObservedSet, value: IIndexable | Primitive): ReturnType<typeof nativeAdd> {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativeAdd.call(this, value);\n  }\n  const oldSize = this.size;\n  nativeAdd.call(this, value);\n  const newSize = this.size;\n  if (newSize === oldSize) {\n    return this;\n  }\n  o.indexMap[oldSize] = -2;\n  o.callSubscribers('add', arguments, LifecycleFlags.isCollectionMutation);\n  return this;\n}\n\n// https://tc39.github.io/ecma262/#sec-set.prototype.clear\nfunction observeClear(this: IObservedSet): ReturnType<typeof nativeClear>  {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativeClear.call(this);\n  }\n  const size = this.size;\n  if (size > 0) {\n    const indexMap = o.indexMap;\n    let i = 0;\n    for (const entry of this.keys()) {\n      if (indexMap[i] > -1) {\n        nativePush.call(indexMap.deletedItems, entry);\n      }\n      i++;\n    }\n    nativeClear.call(this);\n    indexMap.length = 0;\n    o.callSubscribers('clear', arguments, LifecycleFlags.isCollectionMutation);\n  }\n  return undefined;\n}\n\n// https://tc39.github.io/ecma262/#sec-set.prototype.delete\nfunction observeDelete(this: IObservedSet, value: IIndexable | Primitive): ReturnType<typeof nativeDelete> {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativeDelete.call(this, value);\n  }\n  const size = this.size;\n  if (size === 0) {\n    return false;\n  }\n  let i = 0;\n  const indexMap = o.indexMap;\n  for (const entry of this.keys()) {\n    if (entry === value) {\n      if (indexMap[i] > -1) {\n        nativePush.call(indexMap.deletedItems, entry);\n      }\n      nativeSplice.call(indexMap, i, 1);\n      return nativeDelete.call(this, value);\n    }\n    i++;\n  }\n  o.callSubscribers('delete', arguments, LifecycleFlags.isCollectionMutation);\n  return false;\n}\n\nfor (const observe of [observeAdd, observeClear, observeDelete]) {\n  Object.defineProperty(observe, 'observing', { value: true, writable: false, configurable: false, enumerable: false });\n}\n\nexport function enableSetObservation(): void {\n  if (proto.add['observing'] !== true) proto.add = observeAdd;\n  if (proto.clear['observing'] !== true) proto.clear = observeClear;\n  if (proto.delete['observing'] !== true) proto.delete = observeDelete;\n}\n\nenableSetObservation();\n\nexport function disableSetObservation(): void {\n  if (proto.add['observing'] === true) proto.add = nativeAdd;\n  if (proto.clear['observing'] === true) proto.clear = nativeClear;\n  if (proto.delete['observing'] === true) proto.delete = nativeDelete;\n}\n\nexport interface SetObserver extends ICollectionObserver<CollectionKind.set> {}\n\n@collectionObserver(CollectionKind.set)\nexport class SetObserver implements SetObserver {\n  public resetIndexMap: () => void;\n\n  public collection: IObservedSet;\n\n  constructor(lifecycle: ILifecycle, observedSet: IObservedSet) {\n    this.lifecycle = lifecycle;\n    observedSet.$observer = this;\n    this.collection = observedSet;\n    this.resetIndexMap();\n  }\n}\n\nexport function getSetObserver(lifecycle: ILifecycle, observedSet: IObservedSet): SetObserver {\n  return (observedSet.$observer as SetObserver) || new SetObserver(lifecycle, observedSet);\n}\n","import { DI } from '@aurelia/kernel';\nimport { INode } from '../dom';\n\nexport interface ISVGAnalyzer {\n  isStandardSvgAttribute(node: INode, attributeName: string): boolean;\n}\n\nexport const ISVGAnalyzer = DI.createInterface<ISVGAnalyzer>()\n  .withDefault(x => x.singleton(class {\n    public isStandardSvgAttribute(node: INode, attributeName: string): boolean {\n      return false;\n    }\n  })\n);\n","import { DI, IIndexable, inject, Primitive, Reporter } from '@aurelia/kernel';\nimport { DOM, IHTMLElement, IInputElement } from '../dom';\nimport { ILifecycle } from '../lifecycle';\nimport {\n  AccessorOrObserver, CollectionKind, CollectionObserver, IBindingContext,\n  IBindingTargetAccessor, IBindingTargetObserver, ICollectionObserver,\n  IObservable,  IObservedArray, IObservedMap, IObservedSet, IOverrideContext\n} from '../observation';\nimport { getArrayObserver } from './array-observer';\nimport { createComputedObserver } from './computed-observer';\nimport { IDirtyChecker } from './dirty-checker';\nimport { CheckedObserver, ISelectElement, SelectValueObserver, ValueAttributeObserver } from './element-observation';\nimport { IEventManager } from './event-manager';\nimport { getMapObserver } from './map-observer';\nimport { PrimitiveObserver, SetterObserver } from './property-observation';\nimport { getSetObserver } from './set-observer';\nimport { ISVGAnalyzer } from './svg-analyzer';\nimport { ClassAttributeAccessor, DataAttributeAccessor, ElementPropertyAccessor, PropertyAccessor, StyleAttributeAccessor, XLinkAttributeAccessor } from './target-accessors';\n\nconst toStringTag = Object.prototype.toString;\n\nexport interface IObjectObservationAdapter {\n  getObserver(object: IObservable, propertyName: string, descriptor: PropertyDescriptor): IBindingTargetObserver;\n}\n\nexport interface IObserverLocator {\n  getObserver(obj: IObservable, propertyName: string): AccessorOrObserver;\n  getAccessor(obj: IObservable, propertyName: string): IBindingTargetAccessor;\n  addAdapter(adapter: IObjectObservationAdapter): void;\n  getArrayObserver(observedArray: (IIndexable | Primitive)[]): ICollectionObserver<CollectionKind.array>;\n  getMapObserver(observedMap: Map<IIndexable | Primitive, IIndexable | Primitive>): ICollectionObserver<CollectionKind.map>;\n  getSetObserver(observedSet: Set<IIndexable | Primitive>): ICollectionObserver<CollectionKind.set>;\n}\n\nexport const IObserverLocator = DI.createInterface<IObserverLocator>()\n  .withDefault(x => x.singleton(ObserverLocator));\n\nfunction getPropertyDescriptor(subject: object, name: string): PropertyDescriptor {\n  let pd = Object.getOwnPropertyDescriptor(subject, name);\n  let proto = Object.getPrototypeOf(subject);\n\n  while (pd === undefined && proto !== null) {\n    pd = Object.getOwnPropertyDescriptor(proto, name);\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return pd;\n}\n\n@inject(ILifecycle, IEventManager, IDirtyChecker, ISVGAnalyzer)\n/*@internal*/\nexport class ObserverLocator implements IObserverLocator {\n  private adapters: IObjectObservationAdapter[] = [];\n\n  constructor(\n    private lifecycle: ILifecycle,\n    private eventManager: IEventManager,\n    private dirtyChecker: IDirtyChecker,\n    private svgAnalyzer: ISVGAnalyzer\n  ) {}\n\n  public getObserver(obj: IObservable | IBindingContext | IOverrideContext, propertyName: string): AccessorOrObserver {\n    if (obj.$synthetic === true) {\n      return obj.getObservers().getOrCreate(obj, propertyName);\n    }\n    let observersLookup = obj.$observers;\n    let observer;\n\n    if (observersLookup && propertyName in observersLookup) {\n      return observersLookup[propertyName];\n    }\n\n    observer = this.createPropertyObserver(obj, propertyName);\n\n    if (!observer.doNotCache) {\n      if (observersLookup === undefined) {\n        observersLookup = this.getOrCreateObserversLookup(obj);\n      }\n\n      observersLookup[propertyName] = observer;\n    }\n\n    return observer;\n  }\n\n  public addAdapter(adapter: IObjectObservationAdapter): void {\n    this.adapters.push(adapter);\n  }\n\n  public getAccessor(obj: IObservable, propertyName: string): IBindingTargetAccessor {\n    if (DOM.isNodeInstance(obj)) {\n      const tagName = obj['tagName'];\n      // this check comes first for hot path optimization\n      if (propertyName === 'textContent') {\n        return new ElementPropertyAccessor(this.lifecycle, obj, propertyName);\n      }\n\n      // TODO: optimize and make pluggable\n      if (propertyName === 'class' || propertyName === 'style' || propertyName === 'css'\n        || propertyName === 'value' && (tagName === 'INPUT' || tagName === 'SELECT')\n        || propertyName === 'checked' && tagName === 'INPUT'\n        || propertyName === 'model' && tagName === 'INPUT'\n        || /^xlink:.+$/.exec(propertyName)) {\n        return this.getObserver(obj, propertyName);\n      }\n\n      if (/^\\w+:|^data-|^aria-/.test(propertyName)\n        || this.svgAnalyzer.isStandardSvgAttribute(obj, propertyName)\n        || tagName === 'IMG' && propertyName === 'src'\n        || tagName === 'A' && propertyName === 'href'\n      ) {\n        return new DataAttributeAccessor(this.lifecycle, obj, propertyName);\n      }\n      return new ElementPropertyAccessor(this.lifecycle, obj, propertyName);\n    }\n\n    return new PropertyAccessor(obj, propertyName);\n  }\n\n  public getArrayObserver(observedArray: IObservedArray): ICollectionObserver<CollectionKind.array> {\n    return getArrayObserver(this.lifecycle, observedArray);\n  }\n\n  public getMapObserver(observedMap: IObservedMap): ICollectionObserver<CollectionKind.map>  {\n    return getMapObserver(this.lifecycle, observedMap);\n  }\n\n  public getSetObserver(observedSet: IObservedSet): ICollectionObserver<CollectionKind.set>  {\n    return getSetObserver(this.lifecycle, observedSet);\n  }\n\n  private getOrCreateObserversLookup(obj: IObservable): Record<string, AccessorOrObserver | IBindingTargetObserver> {\n    return obj.$observers || this.createObserversLookup(obj);\n  }\n\n  private createObserversLookup(obj: IObservable): Record<string, IBindingTargetObserver> {\n    const value: Record<string, IBindingTargetObserver> = {};\n    if (!Reflect.defineProperty(obj, '$observers', {\n      enumerable: false,\n      configurable: false,\n      writable: false,\n      value: value\n    })) {\n      Reporter.write(0, obj);\n    }\n    return value;\n  }\n\n  private getAdapterObserver(obj: IObservable, propertyName: string, descriptor: PropertyDescriptor): IBindingTargetObserver | null {\n    for (let i = 0, ii = this.adapters.length; i < ii; i++) {\n      const adapter = this.adapters[i];\n      const observer = adapter.getObserver(obj, propertyName, descriptor);\n      if (observer) {\n        return observer;\n      }\n    }\n    return null;\n  }\n\n  private createPropertyObserver(obj: IObservable, propertyName: string): AccessorOrObserver {\n    if (!(obj instanceof Object)) {\n      return new PrimitiveObserver(obj, propertyName) as IBindingTargetAccessor;\n    }\n\n    let isNode: boolean;\n    if (DOM.isNodeInstance(obj)) {\n      if (propertyName === 'class') {\n        return new ClassAttributeAccessor(this.lifecycle, obj);\n      }\n\n      if (propertyName === 'style' || propertyName === 'css') {\n        return new StyleAttributeAccessor(this.lifecycle, <IHTMLElement>obj);\n      }\n\n      const tagName = obj['tagName'];\n      const handler = this.eventManager.getElementHandler(obj, propertyName);\n      if (propertyName === 'value' && tagName === 'SELECT') {\n        return new SelectValueObserver(this.lifecycle, <ISelectElement>obj, handler, this);\n      }\n\n      if (propertyName === 'checked' && tagName === 'INPUT') {\n        return new CheckedObserver(this.lifecycle, <IInputElement>obj, handler, this);\n      }\n\n      if (handler) {\n        return new ValueAttributeObserver(this.lifecycle, obj, propertyName, handler);\n      }\n\n      const xlinkResult = /^xlink:(.+)$/.exec(propertyName);\n      if (xlinkResult) {\n        return new XLinkAttributeAccessor(this.lifecycle, <IHTMLElement>obj, propertyName, xlinkResult[1]);\n      }\n\n      if (propertyName === 'role'\n        || /^\\w+:|^data-|^aria-/.test(propertyName)\n        || this.svgAnalyzer.isStandardSvgAttribute(obj, propertyName)) {\n        return new DataAttributeAccessor(this.lifecycle, obj, propertyName);\n      }\n      isNode = true;\n    }\n\n    const tag = toStringTag.call(obj);\n    switch (tag) {\n      case '[object Array]':\n        if (propertyName === 'length') {\n          return this.getArrayObserver(<IObservedArray>obj).getLengthObserver();\n        }\n        return this.dirtyChecker.createProperty(obj, propertyName);\n      case '[object Map]':\n        if (propertyName === 'size') {\n          return this.getMapObserver(<IObservedMap>obj).getLengthObserver();\n        }\n        return this.dirtyChecker.createProperty(obj, propertyName);\n      case '[object Set]':\n        if (propertyName === 'size') {\n          return this.getSetObserver(<IObservedSet>obj).getLengthObserver();\n        }\n        return this.dirtyChecker.createProperty(obj, propertyName);\n    }\n\n    const descriptor = getPropertyDescriptor(obj, propertyName) as PropertyDescriptor & {\n      // tslint:disable-next-line:no-reserved-keywords\n      get: PropertyDescriptor['get'] & { getObserver(obj: IObservable): IBindingTargetObserver };\n    };\n\n    if (descriptor) {\n      if (descriptor.get || descriptor.set) {\n        if (descriptor.get && descriptor.get.getObserver) {\n          return descriptor.get.getObserver(obj);\n        }\n\n        // attempt to use an adapter before resorting to dirty checking.\n        const adapterObserver = this.getAdapterObserver(obj, propertyName, descriptor);\n        if (adapterObserver) {\n          return adapterObserver;\n        }\n        if (isNode) {\n          // TODO: use MutationObserver\n          return this.dirtyChecker.createProperty(obj, propertyName);\n        }\n\n        return createComputedObserver(this, this.dirtyChecker, this.lifecycle, obj, propertyName, descriptor);\n      }\n    }\n    return new SetterObserver(obj, propertyName);\n  }\n}\n\nexport function getCollectionObserver(lifecycle: ILifecycle, collection: IObservedMap | IObservedSet | IObservedArray): CollectionObserver {\n  switch (toStringTag.call(collection)) {\n    case '[object Array]':\n      return getArrayObserver(lifecycle, <IObservedArray>collection);\n    case '[object Map]':\n      return getMapObserver(lifecycle, <IObservedMap>collection);\n    case '[object Set]':\n      return getSetObserver(lifecycle, <IObservedSet>collection);\n  }\n  return null;\n}\n","import { inject, Reporter } from '@aurelia/kernel';\nimport { IScope, LifecycleFlags } from '../../observation';\nimport { Binding } from '../binding';\nimport { bindingBehavior } from '../binding-behavior';\nimport { BindingMode } from '../binding-mode';\nimport { CheckedObserver, SelectValueObserver, ValueAttributeObserver } from '../element-observation';\nimport { EventSubscriber, IEventSubscriber } from '../event-manager';\nimport { IObserverLocator } from '../observer-locator';\n\nexport type UpdateTriggerableObserver = ((ValueAttributeObserver & Required<ValueAttributeObserver>) | (CheckedObserver & Required<CheckedObserver>) | (SelectValueObserver & Required<SelectValueObserver>)) & {\n  originalHandler?: IEventSubscriber;\n};\n\nexport type UpdateTriggerableBinding = Binding & {\n  targetObserver: UpdateTriggerableObserver;\n};\n\n@bindingBehavior('updateTrigger')\n@inject(IObserverLocator)\nexport class UpdateTriggerBindingBehavior {\n  constructor(private observerLocator: IObserverLocator) {}\n\n  public bind(flags: LifecycleFlags, scope: IScope, binding: UpdateTriggerableBinding, ...events: string[]): void {\n    if (events.length === 0) {\n      throw Reporter.error(9);\n    }\n\n    if (binding.mode !== BindingMode.twoWay && binding.mode !== BindingMode.fromView) {\n      throw Reporter.error(10);\n    }\n\n    // ensure the binding's target observer has been set.\n    const targetObserver = <UpdateTriggerableObserver>this.observerLocator.getObserver(binding.target, binding.targetProperty);\n    if (!targetObserver.handler) {\n      throw Reporter.error(10);\n    }\n\n    binding.targetObserver = targetObserver;\n\n    // stash the original element subscribe function.\n    targetObserver.originalHandler = binding.targetObserver.handler;\n\n    // replace the element subscribe function with one that uses the correct events.\n    targetObserver.handler = new EventSubscriber(events);\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: UpdateTriggerableBinding): void {\n    // restore the state of the binding.\n    binding.targetObserver.handler.dispose();\n    binding.targetObserver.handler = binding.targetObserver.originalHandler;\n    binding.targetObserver.originalHandler = null;\n  }\n}\n","import { IIndexable, IServiceLocator, Primitive } from '@aurelia/kernel';\nimport { INode } from '../dom';\nimport { IBindScope, ILifecycle, State } from '../lifecycle';\nimport { IAccessor, IScope, LifecycleFlags } from '../observation';\nimport { hasBind, hasUnbind, IsBindingBehavior, StrictAny } from './ast';\nimport { IConnectableBinding } from './connectable';\nimport { IObserverLocator } from './observer-locator';\n\nexport interface Call extends IConnectableBinding {}\nexport class Call {\n  public $nextBind: IBindScope = null;\n  public $prevBind: IBindScope = null;\n\n  public $state: State = State.none;\n  public $scope: IScope;\n\n  public targetObserver: IAccessor;\n\n  constructor(\n    public sourceExpression: IsBindingBehavior,\n    target: INode,\n    targetProperty: string,\n    observerLocator: IObserverLocator,\n    public locator: IServiceLocator) {\n    this.targetObserver = observerLocator.getObserver(target, targetProperty);\n  }\n\n  public callSource(args: IIndexable): Primitive | IIndexable {\n    const overrideContext = this.$scope.overrideContext;\n    Object.assign(overrideContext, args);\n    const result = this.sourceExpression.evaluate(LifecycleFlags.mustEvaluate, this.$scope, this.locator);\n\n    for (const prop in args) {\n      delete overrideContext[prop];\n    }\n\n    return result;\n  }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        return;\n      }\n\n      this.$unbind(flags | LifecycleFlags.fromBind);\n    }\n    // add isBinding flag\n    this.$state |= State.isBinding;\n\n    this.$scope = scope;\n\n    const sourceExpression = this.sourceExpression;\n    if (hasBind(sourceExpression)) {\n      sourceExpression.bind(flags, scope, this);\n    }\n\n    this.targetObserver.setValue($args => this.callSource($args), flags);\n\n    // add isBound flag and remove isBinding flag\n    this.$state |= State.isBound;\n    this.$state &= ~State.isBinding;\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (!(this.$state & State.isBound)) {\n      return;\n    }\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    const sourceExpression = this.sourceExpression;\n    if (hasUnbind(sourceExpression)) {\n      sourceExpression.unbind(flags, this.$scope, this);\n    }\n\n    this.$scope = null;\n    this.targetObserver.setValue(null, flags);\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n  }\n  // tslint:disable:no-empty no-any\n  public observeProperty(obj: StrictAny, propertyName: StrictAny): void { }\n  public handleChange(newValue: any, previousValue: any, flags: LifecycleFlags): void { }\n  // tslint:enable:no-empty no-any\n}\n","import { DI, PLATFORM, Reporter } from '@aurelia/kernel';\nimport { AccessMember, AccessScope, CallMember, CallScope, ExpressionKind, ForOfStatement, Interpolation, IsBindingBehavior, PrimitiveLiteral } from './ast';\n\nexport interface IExpressionParser {\n  cache(expressions: Record<string, Interpolation | ForOfStatement | IsBindingBehavior>): void;\n  parse(expression: string, bindingType: BindingType.ForCommand): ForOfStatement;\n  parse(expression: string, bindingType: BindingType.Interpolation): Interpolation;\n  parse(expression: string, bindingType: Exclude<BindingType, BindingType.ForCommand | BindingType.Interpolation>): IsBindingBehavior;\n  parse(expression: string, bindingType: BindingType): Interpolation | ForOfStatement | IsBindingBehavior;\n}\n\nexport const IExpressionParser = DI.createInterface<IExpressionParser>()\n  .withDefault(x => x.singleton(ExpressionParser));\n\n/*@internal*/\nexport class ExpressionParser implements IExpressionParser {\n  private expressionLookup: Record<string, IsBindingBehavior>;\n  private interpolationLookup: Record<string, Interpolation>;\n  private forOfLookup: Record<string, ForOfStatement>;\n  constructor() {\n    this.expressionLookup = Object.create(null);\n    this.interpolationLookup = Object.create(null);\n    this.forOfLookup = Object.create(null);\n  }\n\n  public parse(expression: string, bindingType: BindingType.ForCommand): ForOfStatement;\n  public parse(expression: string, bindingType: BindingType.Interpolation): Interpolation;\n  public parse(expression: string, bindingType: Exclude<BindingType, BindingType.ForCommand | BindingType.Interpolation>): IsBindingBehavior;\n  public parse(expression: string, bindingType: BindingType): Interpolation | ForOfStatement | IsBindingBehavior {\n    switch (bindingType) {\n      case BindingType.Interpolation:\n      {\n        let found = this.interpolationLookup[expression];\n        if (found === undefined) {\n          found = this.interpolationLookup[expression] = this.parseCore(expression, bindingType);\n        }\n        return found;\n      }\n      case BindingType.ForCommand:\n      {\n        let found = this.forOfLookup[expression];\n        if (found === undefined) {\n          found = this.forOfLookup[expression] = this.parseCore(expression, bindingType);\n        }\n        return found;\n      }\n      default:\n      {\n        // Allow empty strings for normal bindings and those that are empty by default (such as a custom attribute without an equals sign)\n        // But don't cache it, because empty strings are always invalid for any other type of binding\n        if (expression.length === 0 && (bindingType & (BindingType.BindCommand | BindingType.OneTimeCommand | BindingType.ToViewCommand))) {\n          return PrimitiveLiteral.$empty;\n        }\n        let found = this.expressionLookup[expression];\n        if (found === undefined) {\n          found = this.expressionLookup[expression] = this.parseCore(expression, bindingType);\n        }\n        return found;\n      }\n    }\n  }\n\n  public cache(expressions: Record<string, Interpolation | ForOfStatement | IsBindingBehavior>): void {\n    const { forOfLookup, expressionLookup, interpolationLookup } = this;\n    for (const expression in expressions) {\n      const expr = expressions[expression];\n      switch (expr.$kind) {\n        case ExpressionKind.Interpolation:\n          interpolationLookup[expression] = expr;\n          break;\n        case ExpressionKind.ForOfStatement:\n          forOfLookup[expression] = expr;\n          break;\n        default:\n          expressionLookup[expression] = expr;\n      }\n    }\n  }\n\n  private parseCore(expression: string, bindingType: BindingType.ForCommand): ForOfStatement;\n  private parseCore(expression: string, bindingType: BindingType.Interpolation): Interpolation;\n  private parseCore(expression: string, bindingType: Exclude<BindingType, BindingType.ForCommand | BindingType.Interpolation>): IsBindingBehavior;\n  private parseCore(expression: string, bindingType: BindingType): Interpolation | ForOfStatement | IsBindingBehavior {\n    try {\n      const parts = expression.split('.');\n      const firstPart = parts[0];\n      let current: Interpolation | ForOfStatement | IsBindingBehavior;\n\n      if (firstPart.endsWith('()')) {\n        current = new CallScope(firstPart.replace('()', ''), PLATFORM.emptyArray);\n      } else {\n        current = new AccessScope(parts[0]);\n      }\n\n      let index = 1;\n\n      while (index < parts.length) {\n        const currentPart = parts[index];\n\n        if (currentPart.endsWith('()')) {\n          current = new CallMember(current, currentPart.replace('()', ''), PLATFORM.emptyArray);\n        } else {\n          current = new AccessMember(current, parts[index]);\n        }\n\n        index++;\n      }\n\n      return current;\n    } catch (e) {\n      throw Reporter.error(3, e);\n    }\n  }\n}\n\nexport const enum BindingType {\n              None = 0,\n     Interpolation = 0b10000000_0000,\n        IsRef      = 0b01010000_0000,\n        IsIterator = 0b00100000_0000,\n        IsCustom   = 0b00010000_0000,\n        IsFunction = 0b00001000_0000,\n        IsEvent    = 0b00000100_0000,\n        IsProperty = 0b00000010_0000,\n        IsCommand  = 0b00000001_0000,\nIsPropertyCommand  = 0b00000011_0000,\n   IsEventCommand  = 0b00000101_0000,\nDelegationStrategyDelta =     0b0110,\n           Command =          0b1111,\n    OneTimeCommand = 0b00000011_0001,\n     ToViewCommand = 0b00000011_0010,\n   FromViewCommand = 0b00000011_0011,\n     TwoWayCommand = 0b00000011_0100,\n       BindCommand = 0b00000011_0101,\n    TriggerCommand = 0b00000101_0110,\n    CaptureCommand = 0b00000101_0111,\n   DelegateCommand = 0b00000101_1000,\n       CallCommand = 0b00001001_1001,\n    OptionsCommand = 0b00000001_1010,\n        ForCommand = 0b00100001_1011,\n     CustomCommand = 0b00010001_1100\n}\n","import { IServiceLocator } from '@aurelia/kernel';\nimport { IBindScope, State } from '../lifecycle';\nimport { IBindingTargetAccessor, IScope, LifecycleFlags } from '../observation';\nimport { IExpression, Interpolation } from './ast';\nimport { IBinding, IBindingTarget } from './binding';\nimport { BindingMode } from './binding-mode';\nimport { connectable, IConnectableBinding, IPartialConnectableBinding } from './connectable';\nimport { IObserverLocator } from './observer-locator';\n\n// tslint:disable:no-any\n\nconst { toView, oneTime } = BindingMode;\n\nexport class MultiInterpolationBinding implements IBinding {\n  public $nextBind: IBindScope = null;\n  public $prevBind: IBindScope = null;\n\n  public $state: State = State.none;\n\n  public $scope: IScope = null;\n\n  public parts: InterpolationBinding[];\n\n  constructor(\n    public observerLocator: IObserverLocator,\n    public interpolation: Interpolation,\n    public target: IBindingTarget,\n    public targetProperty: string,\n    public mode: BindingMode,\n    public locator: IServiceLocator) {\n\n    // Note: the child expressions of an Interpolation expression are full Aurelia expressions, meaning they may include\n    // value converters and binding behaviors.\n    // Each expression represents one ${interpolation}, and for each we create a child TextBinding unless there is only one,\n    // in which case the renderer will create the TextBinding directly\n    const expressions = interpolation.expressions;\n    const parts = this.parts = Array(expressions.length);\n    for (let i = 0, ii = expressions.length; i < ii; ++i) {\n      parts[i] = new InterpolationBinding(expressions[i], interpolation, target, targetProperty, mode, observerLocator, locator, i === 0);\n    }\n  }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        return;\n      }\n      this.$unbind(flags);\n    }\n    this.$state |= State.isBound;\n    this.$scope = scope;\n\n    const parts = this.parts;\n    for (let i = 0, ii = parts.length; i < ii; ++i) {\n      parts[i].$bind(flags, scope);\n    }\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (!(this.$state & State.isBound)) {\n      return;\n    }\n    this.$state &= ~State.isBound;\n    this.$scope = null;\n    const parts = this.parts;\n    for (let i = 0, ii = parts.length; i < ii; ++i) {\n      parts[i].$unbind(flags);\n    }\n  }\n}\n\nexport interface InterpolationBinding extends IConnectableBinding {}\n\n@connectable()\nexport class InterpolationBinding implements IPartialConnectableBinding {\n  public $scope: IScope;\n  public $state: State = State.none;\n\n  public targetObserver: IBindingTargetAccessor;\n\n  constructor(\n    public sourceExpression: IExpression,\n    public interpolation: Interpolation,\n    public target: IBindingTarget,\n    public targetProperty: string,\n    public mode: BindingMode,\n    public observerLocator: IObserverLocator,\n    public locator: IServiceLocator,\n    public isFirst: boolean) {\n\n    this.targetObserver = observerLocator.getAccessor(target, targetProperty);\n  }\n\n  public updateTarget(value: any, flags: LifecycleFlags): void {\n    this.targetObserver.setValue(value, flags | LifecycleFlags.updateTargetInstance);\n  }\n\n  public handleChange(newValue: any, previousValue: any, flags: LifecycleFlags): void {\n    if (!(this.$state & State.isBound)) {\n      return;\n    }\n\n    previousValue = this.targetObserver.getValue();\n    newValue = this.interpolation.evaluate(flags, this.$scope, this.locator);\n    if (newValue !== previousValue) {\n      this.updateTarget(newValue, flags);\n    }\n\n    if ((this.mode & oneTime) === 0) {\n      this.version++;\n      this.sourceExpression.connect(flags, this.$scope, this);\n      this.unobserve(false);\n    }\n  }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        return;\n      }\n      this.$unbind(flags);\n    }\n\n    this.$state |= State.isBound;\n    this.$scope = scope;\n\n    const sourceExpression = this.sourceExpression;\n    if (sourceExpression.bind) {\n      sourceExpression.bind(flags, scope, this);\n    }\n\n    // since the interpolation already gets the whole value, we only need to let the first\n    // text binding do the update if there are multiple\n    if (this.isFirst) {\n      this.updateTarget(this.interpolation.evaluate(flags, scope, this.locator), flags);\n    }\n    if (this.mode & toView) {\n      sourceExpression.connect(flags, scope, this);\n    }\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (!(this.$state & State.isBound)) {\n      return;\n    }\n    this.$state &= ~State.isBound;\n\n    const sourceExpression = this.sourceExpression;\n    if (sourceExpression.unbind) {\n      sourceExpression.unbind(flags, this.$scope, this);\n    }\n\n    this.$scope = null;\n    this.unobserve(true);\n  }\n}\n","import { IServiceLocator, Reporter } from '@aurelia/kernel';\nimport { IBindScope, ILifecycle, State } from '../lifecycle';\nimport { IScope, LifecycleFlags } from '../observation';\nimport { IExpression } from './ast';\nimport { IBindingTarget } from './binding';\nimport { connectable, IConnectableBinding, IPartialConnectableBinding } from './connectable';\nimport { IObserverLocator } from './observer-locator';\n\n// tslint:disable:no-any\n\nexport interface LetBinding extends IConnectableBinding {}\n\n@connectable()\nexport class LetBinding implements IPartialConnectableBinding {\n  public $nextBind: IBindScope = null;\n  public $prevBind: IBindScope = null;\n\n  public $state: State = State.none;\n  public $scope: IScope = null;\n  public $lifecycle: ILifecycle;\n\n  public target: IBindingTarget = null;\n\n  constructor(\n    public sourceExpression: IExpression,\n    public targetProperty: string,\n    public observerLocator: IObserverLocator,\n    public locator: IServiceLocator,\n    private toViewModel: boolean = false) {\n    this.$lifecycle = locator.get(ILifecycle);\n  }\n\n  public handleChange(newValue: any, previousValue: any, flags: LifecycleFlags): void {\n    if (!(this.$state & State.isBound)) {\n      return;\n    }\n\n    if (flags & LifecycleFlags.updateTargetInstance) {\n      const { target, targetProperty } = this;\n      previousValue = target[targetProperty];\n      newValue = this.sourceExpression.evaluate(flags, this.$scope, this.locator);\n      if (newValue !== previousValue) {\n        target[targetProperty] = newValue;\n      }\n      return;\n    }\n\n    throw Reporter.error(15, flags);\n  }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        return;\n      }\n      this.$unbind(flags | LifecycleFlags.fromBind);\n    }\n    // add isBinding flag\n    this.$state |= State.isBinding;\n\n    this.$scope = scope;\n    this.target = this.toViewModel ? scope.bindingContext : scope.overrideContext;\n\n    const sourceExpression = this.sourceExpression;\n    if (sourceExpression.bind) {\n      sourceExpression.bind(flags, scope, this);\n    }\n    // sourceExpression might have been changed during bind\n    this.target[this.targetProperty] = this.sourceExpression.evaluate(LifecycleFlags.fromBind, scope, this.locator);\n    this.sourceExpression.connect(flags, scope, this);\n\n    // add isBound flag and remove isBinding flag\n    this.$state |= State.isBound;\n    this.$state &= ~State.isBinding;\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (!(this.$state & State.isBound)) {\n      return;\n    }\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    const sourceExpression = this.sourceExpression;\n    if (sourceExpression.unbind) {\n      sourceExpression.unbind(flags, this.$scope, this);\n    }\n    this.$scope = null;\n    this.unobserve(true);\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n  }\n}\n","import { IDisposable, IServiceLocator } from '@aurelia/kernel';\nimport { INode } from '../dom';\nimport { IBindScope, State } from '../lifecycle';\nimport { IScope, LifecycleFlags } from '../observation';\nimport { hasBind, hasUnbind, IsBindingBehavior, StrictAny } from './ast';\nimport { IBinding } from './binding';\nimport { IConnectableBinding } from './connectable';\nimport { DelegationStrategy, IEventManager } from './event-manager';\n\nexport interface Listener extends IConnectableBinding {}\nexport class Listener implements IBinding {\n  public $nextBind: IBindScope = null;\n  public $prevBind: IBindScope = null;\n\n  public $state: State = State.none;\n\n  public $scope: IScope;\n\n  private handler: IDisposable;\n\n  constructor(\n    public targetEvent: string,\n    public delegationStrategy: DelegationStrategy,\n    public sourceExpression: IsBindingBehavior,\n    public target: INode,\n    public preventDefault: boolean,\n    private eventManager: IEventManager,\n    public locator: IServiceLocator) { }\n\n  public callSource(event: Event): ReturnType<IsBindingBehavior['evaluate']> {\n    const overrideContext = this.$scope.overrideContext;\n    overrideContext['$event'] = event;\n\n    const result = this.sourceExpression.evaluate(LifecycleFlags.mustEvaluate, this.$scope, this.locator);\n\n    delete overrideContext['$event'];\n\n    if (result !== true && this.preventDefault) {\n      event.preventDefault();\n    }\n\n    return result;\n  }\n\n  public handleEvent(event: Event): void {\n    this.callSource(event);\n  }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        return;\n      }\n\n      this.$unbind(flags | LifecycleFlags.fromBind);\n    }\n    // add isBinding flag\n    this.$state |= State.isBinding;\n\n    this.$scope = scope;\n\n    const sourceExpression = this.sourceExpression;\n    if (hasBind(sourceExpression)) {\n      sourceExpression.bind(flags, scope, this);\n    }\n\n    this.handler = this.eventManager.addEventListener(\n      this.target,\n      this.targetEvent,\n      this,\n      this.delegationStrategy\n    );\n\n    // add isBound flag and remove isBinding flag\n    this.$state |= State.isBound;\n    this.$state &= ~State.isBinding;\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (!(this.$state & State.isBound)) {\n      return;\n    }\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    const sourceExpression = this.sourceExpression;\n    if (hasUnbind(sourceExpression)) {\n      sourceExpression.unbind(flags, this.$scope, this);\n    }\n\n    this.$scope = null;\n    this.handler.dispose();\n    this.handler = null;\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n  }\n  // tslint:disable:no-empty no-any\n  public observeProperty(obj: StrictAny, propertyName: StrictAny): void { }\n  public handleChange(newValue: any, previousValue: any, flags: LifecycleFlags): void { }\n  // tslint:enable:no-empty no-any\n}\n","import { IServiceLocator } from '@aurelia/kernel';\nimport { IBindScope, State } from '../lifecycle';\nimport { IScope, LifecycleFlags } from '../observation';\nimport { hasBind, hasUnbind, IsBindingBehavior, StrictAny } from './ast';\nimport { IBinding, IBindingTarget } from './binding';\nimport { IConnectableBinding } from './connectable';\n\nexport interface Ref extends IConnectableBinding {}\nexport class Ref implements IBinding {\n  public $nextBind: IBindScope = null;\n  public $prevBind: IBindScope = null;\n\n  public $state: State = State.none;\n\n  public $scope: IScope;\n\n  constructor(\n    public sourceExpression: IsBindingBehavior,\n    public target: IBindingTarget,\n    public locator: IServiceLocator) { }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        return;\n      }\n\n      this.$unbind(flags | LifecycleFlags.fromBind);\n    }\n    // add isBinding flag\n    this.$state |= State.isBinding;\n\n    this.$scope = scope;\n\n    const sourceExpression = this.sourceExpression;\n    if (hasBind(sourceExpression)) {\n      sourceExpression.bind(flags, scope, this);\n    }\n\n    this.sourceExpression.assign(flags, this.$scope, this.locator, this.target);\n\n    // add isBound flag and remove isBinding flag\n    this.$state |= State.isBound;\n    this.$state &= ~State.isBinding;\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (!(this.$state & State.isBound)) {\n      return;\n    }\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    if (this.sourceExpression.evaluate(flags, this.$scope, this.locator) === this.target) {\n      this.sourceExpression.assign(flags, this.$scope, this.locator, null);\n    }\n\n    const sourceExpression = this.sourceExpression;\n    if (hasUnbind(sourceExpression)) {\n      sourceExpression.unbind(flags, this.$scope, this);\n    }\n\n    this.$scope = null;\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n  }\n  // tslint:disable:no-empty no-any\n  public observeProperty(obj: StrictAny, propertyName: StrictAny): void { }\n  public handleChange(newValue: any, previousValue: any, flags: LifecycleFlags): void { }\n  // tslint:enable:no-empty no-any\n}\n","// tslint:disable:no-reserved-keywords\nimport { Constructable, DI, Immutable, Omit, PLATFORM } from '@aurelia/kernel';\nimport { ForOfStatement, Interpolation, IsBindingBehavior } from './binding/ast';\nimport { BindingMode } from './binding/binding-mode';\nimport { DelegationStrategy } from './binding/event-manager';\nimport { INode } from './dom';\nimport { ResourceDescription } from './resource';\n\n/*@internal*/\nexport const customElementName = 'custom-element';\n/*@internal*/\nexport function customElementKey(name: string): string {\n  return `${customElementName}:${name}`;\n}\n/*@internal*/\nexport function customElementBehavior(node: any): any {\n  return node.$customElement || null;\n}\n\n/*@internal*/\nexport const customAttributeName = 'custom-attribute';\n/*@internal*/\nexport function customAttributeKey(name: string): string {\n  return `${customAttributeName}:${name}`;\n}\n\nexport type BindableSource = Omit<IBindableDescription, 'property'>;\n\nexport interface IBindableDescription {\n  mode?: BindingMode;\n  callback?: string;\n  attribute?: string;\n  property?: string;\n}\n\nexport const enum TargetedInstructionType {\n  textBinding = 'a',\n  interpolation = 'b',\n  propertyBinding = 'c',\n  iteratorBinding = 'd',\n  listenerBinding = 'e',\n  callBinding = 'f',\n  refBinding = 'g',\n  stylePropertyBinding = 'h',\n  setProperty = 'i',\n  setAttribute = 'j',\n  hydrateElement = 'k',\n  hydrateAttribute = 'l',\n  hydrateTemplateController = 'm',\n  letElement = 'n',\n  letBinding = 'o',\n  renderStrategy = 'z',\n}\n\nconst instructionTypeValues = 'abcdefghijkl';\n\nexport interface IBuildInstruction {\n  required: boolean;\n  compiler?: string;\n}\n\nexport interface ITemplateDefinition {\n  name?: string;\n  cache?: '*' | number;\n  template?: string | INode;\n  instructions?: TargetedInstruction[][];\n  dependencies?: any[];\n  build?: IBuildInstruction;\n  surrogates?: TargetedInstruction[];\n  bindables?: Record<string, IBindableDescription>;\n  containerless?: boolean;\n  shadowOptions?: ShadowRootInit;\n  hasSlots?: boolean;\n}\n\nexport type TemplateDefinition = ResourceDescription<ITemplateDefinition>;\nexport type TemplatePartDefinitions = Record<string, Immutable<ITemplateDefinition>>;\nexport type BindableDefinitions = Record<string, Immutable<IBindableDescription>>;\n\nexport interface IAttributeDefinition {\n  name: string;\n  defaultBindingMode?: BindingMode;\n  aliases?: string[];\n  isTemplateController?: boolean;\n  bindables?: Record<string, IBindableDescription>;\n}\n\nexport type AttributeDefinition = Immutable<Required<IAttributeDefinition>> | null;\n\nexport const ITargetedInstruction = DI.createInterface<ITargetedInstruction>();\nexport interface ITargetedInstruction {\n  type: TargetedInstructionType;\n}\n\nexport type TargetedInstruction =\n  ITextBindingInstruction |\n  IInterpolationInstruction |\n  IPropertyBindingInstruction |\n  IIteratorBindingInstruction |\n  IListenerBindingInstruction |\n  ICallBindingInstruction |\n  IRefBindingInstruction |\n  IStylePropertyBindingInstruction |\n  ISetPropertyInstruction |\n  ISetAttributeInstruction |\n  IHydrateElementInstruction |\n  IHydrateAttributeInstruction |\n  IHydrateTemplateController |\n  IRenderStrategyInstruction |\n  ILetElementInstruction;\n\nexport function isTargetedInstruction(value: { type?: string }): value is TargetedInstruction {\n  const type = value.type;\n  return typeof type === 'string' && instructionTypeValues.indexOf(type) !== -1;\n}\n\nexport interface ITextBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.textBinding;\n  from: string | Interpolation;\n}\n\nexport interface IInterpolationInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.interpolation;\n  from: string | Interpolation;\n  to: string;\n}\n\nexport interface IInterpolationInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.interpolation;\n  from: string | Interpolation;\n  to: string;\n}\n\nexport interface IPropertyBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.propertyBinding;\n  mode: BindingMode;\n  from: string | IsBindingBehavior;\n  to: string;\n  oneTime?: boolean;\n}\n\nexport interface IIteratorBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.iteratorBinding;\n  from: string | ForOfStatement;\n  to: string;\n}\n\nexport interface IListenerBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.listenerBinding;\n  from: string | IsBindingBehavior;\n  to: string;\n  strategy: DelegationStrategy;\n  preventDefault: boolean;\n}\n\nexport interface ICallBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.callBinding;\n  from: string | IsBindingBehavior;\n  to: string;\n}\n\nexport interface IRefBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.refBinding;\n  from: string | IsBindingBehavior;\n}\n\nexport interface IStylePropertyBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.stylePropertyBinding;\n  from: string | IsBindingBehavior;\n  to: string;\n}\n\nexport interface ISetPropertyInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.setProperty;\n  value: unknown;\n  to: string;\n}\n\nexport interface ISetAttributeInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.setAttribute;\n  value: unknown;\n  to: string;\n}\n\nexport interface IHydrateElementInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.hydrateElement;\n  res: string;\n  instructions: TargetedInstruction[];\n  parts?: Record<string, ITemplateDefinition>;\n}\n\nexport interface IHydrateAttributeInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.hydrateAttribute;\n  res: string;\n  instructions: TargetedInstruction[];\n}\n\nexport interface IHydrateTemplateController extends ITargetedInstruction {\n  type: TargetedInstructionType.hydrateTemplateController;\n  res: string;\n  instructions: TargetedInstruction[];\n  def: ITemplateDefinition;\n  link?: boolean;\n}\n\nexport interface IRenderStrategyInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.renderStrategy;\n  name: string;\n}\n\nexport interface ILetElementInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.letElement;\n  instructions: ILetBindingInstruction[];\n  toViewModel: boolean;\n}\n\nexport interface ILetBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.letBinding;\n  from: string | IsBindingBehavior | Interpolation;\n  to: string;\n}\n\ntype CustomElementStaticProperties = Pick<TemplateDefinition, 'containerless' | 'shadowOptions' | 'bindables'>;\ntype CustomAttributeStaticProperties = Pick<AttributeDefinition, 'bindables'>;\n\nexport type CustomElementConstructor = Constructable & CustomElementStaticProperties;\nexport type CustomAttributeConstructor = Constructable & CustomAttributeStaticProperties;\n\n/*@internal*/\nexport const buildRequired: IBuildInstruction = Object.freeze({\n  required: true,\n  compiler: 'default'\n});\n\nconst buildNotRequired: IBuildInstruction = Object.freeze({\n  required: false,\n  compiler: 'default'\n});\n\n// Note: this is a little perf thing; having one predefined class with the properties always\n// assigned in the same order ensures the browser can keep reusing the same generated hidden\n// class\nclass DefaultTemplateDefinition implements Required<ITemplateDefinition> {\n  public name: ITemplateDefinition['name'];\n  public cache: ITemplateDefinition['cache'];\n  public template: ITemplateDefinition['template'];\n  public instructions: ITemplateDefinition['instructions'];\n  public dependencies: ITemplateDefinition['dependencies'];\n  public build: ITemplateDefinition['build'];\n  public surrogates: ITemplateDefinition['surrogates'];\n  public bindables: ITemplateDefinition['bindables'];\n  public containerless: ITemplateDefinition['containerless'];\n  public shadowOptions: ITemplateDefinition['shadowOptions'];\n  public hasSlots: ITemplateDefinition['hasSlots'];\n\n  constructor() {\n    this.name = 'unnamed';\n    this.template = null;\n    this.cache = 0;\n    this.build = buildNotRequired;\n    this.bindables = PLATFORM.emptyObject;\n    this.instructions = <this['instructions']>PLATFORM.emptyArray;\n    this.dependencies = <this['dependencies']>PLATFORM.emptyArray;\n    this.surrogates = <this['surrogates']>PLATFORM.emptyArray;\n    this.containerless = false;\n    this.shadowOptions = null;\n    this.hasSlots = false;\n  }\n}\n\nconst templateDefinitionAssignables = [\n  'name',\n  'template',\n  'cache',\n  'build',\n  'containerless',\n  'shadowOptions',\n  'hasSlots'\n];\n\nconst templateDefinitionArrays = [\n  'instructions',\n  'dependencies',\n  'surrogates'\n];\n\nexport function buildTemplateDefinition(\n  ctor: CustomElementConstructor,\n  name: string): TemplateDefinition;\nexport function buildTemplateDefinition(\n  ctor: null,\n  def: Immutable<ITemplateDefinition>): TemplateDefinition;\nexport function buildTemplateDefinition(\n  ctor: CustomElementConstructor | null,\n  nameOrDef: string | Immutable<ITemplateDefinition>): TemplateDefinition;\nexport function buildTemplateDefinition(\n  ctor: CustomElementConstructor | null,\n  name: string | null,\n  template: string | INode,\n  cache?: number | '*' | null,\n  build?: IBuildInstruction | boolean | null,\n  bindables?: Record<string, IBindableDescription> | null,\n  instructions?: ReadonlyArray<ReadonlyArray<TargetedInstruction>> | null,\n  dependencies?: ReadonlyArray<unknown> | null,\n  surrogates?: ReadonlyArray<TargetedInstruction> | null,\n  containerless?: boolean | null,\n  shadowOptions?: { mode: 'open' | 'closed' } | null,\n  hasSlots?: boolean | null): TemplateDefinition;\nexport function buildTemplateDefinition(\n  ctor: CustomElementConstructor | null,\n  nameOrDef: string | Immutable<ITemplateDefinition> | null,\n  template?: string | INode | null,\n  cache?: number | '*' | null,\n  build?: IBuildInstruction | boolean | null,\n  bindables?: Record<string, IBindableDescription> | null,\n  instructions?: ReadonlyArray<ReadonlyArray<TargetedInstruction>> | null,\n  dependencies?: ReadonlyArray<unknown> | null,\n  surrogates?: ReadonlyArray<TargetedInstruction> | null,\n  containerless?: boolean | null,\n  shadowOptions?: { mode: 'open' | 'closed' } | null,\n  hasSlots?: boolean | null): TemplateDefinition {\n\n  const def = new DefaultTemplateDefinition();\n\n  // all cases fall through intentionally\n  const argLen = arguments.length;\n  switch (argLen) {\n    case 12: if (hasSlots !== null) def.hasSlots = hasSlots;\n    case 11: if (shadowOptions !== null) def.shadowOptions = shadowOptions;\n    case 10: if (containerless !== null) def.containerless = containerless;\n    case 9: if (surrogates !== null) def.surrogates = PLATFORM.toArray(surrogates);\n    case 8: if (dependencies !== null) def.dependencies = PLATFORM.toArray(dependencies);\n    case 7: if (instructions !== null) def.instructions = <TargetedInstruction[][]>PLATFORM.toArray(instructions);\n    case 6: if (bindables !== null) def.bindables = { ...bindables };\n    case 5: if (build !== null) def.build = build === true ? buildRequired : build === false ? buildNotRequired : { ...build };\n    case 4: if (cache !== null) def.cache = cache;\n    case 3: if (template !== null) def.template = template;\n    case 2:\n      if (ctor !== null) {\n        if (ctor['bindables']) {\n          def.bindables = { ...ctor.bindables };\n        }\n        if (ctor['containerless']) {\n          def.containerless = ctor.containerless;\n        }\n        if (ctor['shadowOptions']) {\n          def.shadowOptions = ctor.shadowOptions;\n        }\n      }\n      if (typeof nameOrDef === 'string') {\n        if (nameOrDef.length > 0) {\n          def.name = nameOrDef;\n        }\n      } else if (nameOrDef !== null) {\n        templateDefinitionAssignables.forEach(prop => {\n          if (nameOrDef[prop]) {\n            def[prop] = nameOrDef[prop];\n          }\n        });\n        templateDefinitionArrays.forEach(prop => {\n          if (nameOrDef[prop]) {\n            def[prop] = PLATFORM.toArray(nameOrDef[prop]);\n          }\n        });\n        if (nameOrDef['bindables']) {\n          if (def.bindables === PLATFORM.emptyObject) {\n            def.bindables = { ...nameOrDef.bindables };\n          } else {\n            Object.assign(def.bindables, nameOrDef.bindables);\n          }\n        }\n      }\n  }\n\n  // special handling for invocations that quack like a @customElement decorator\n  if (argLen === 2 && ctor !== null) {\n    if (typeof nameOrDef === 'string' || !('build' in nameOrDef)) {\n      def.build = buildRequired;\n    }\n  }\n\n  return def;\n}\n","import { Constructable, PLATFORM } from '@aurelia/kernel';\nimport { BindingMode } from '../binding/binding-mode';\nimport { BindableSource, IBindableDescription } from '../definitions';\n\ntype WithBindables = { bindables: Record<string, IBindableDescription> };\ntype BindableDecorator = <T extends InstanceType<Constructable & Partial<WithBindables>>>\n  (target: T, prop: string) => void;\n\n/**\n * Decorator: Specifies custom behavior for a bindable property.\n * @param config The overrides\n */\nexport function bindable(config?: BindableSource): BindableDecorator;\n/**\n * Decorator: Specifies a bindable property on a class.\n * @param prop The property name\n */\nexport function bindable(prop: string): ClassDecorator;\n/**\n * Decorator: Specifies a bindable property on a class.\n * @param target The class\n * @param prop The property name\n */\nexport function bindable<T extends InstanceType<Constructable & Partial<WithBindables>>>(target: T, prop: string): void;\nexport function bindable<T extends InstanceType<Constructable & Partial<WithBindables>>>(configOrTarget?: BindableSource | T, prop?: string): void | BindableDecorator | ClassDecorator {\n  let config: IBindableDescription;\n\n  const decorator = function decorate($target: T, $prop: string): void {\n    const Type = $target.constructor as Constructable & Partial<WithBindables>;\n    let bindables = Type.bindables;\n    if (bindables === undefined) {\n      bindables = Type.bindables = {};\n    }\n    if (!config.attribute) {\n      config.attribute = PLATFORM.kebabCase($prop);\n    }\n    if (!config.callback) {\n      config.callback = `${$prop}Changed`;\n    }\n    if (!config.mode) {\n      config.mode = BindingMode.toView;\n    }\n    if (arguments.length > 1) {\n      // Non invocation:\n      // - @bindable\n      // Invocation with or w/o opts:\n      // - @bindable()\n      // - @bindable({...opts})\n      config.property = $prop;\n    }\n    bindables[config.property] = config;\n  };\n  if (arguments.length > 1) {\n    // Non invocation:\n    // - @bindable\n    config = {};\n    return decorator(configOrTarget as T, prop);\n  } else if (typeof configOrTarget === 'string') {\n    // ClassDecorator\n    // - @bindable('bar')\n    // Direct call:\n    // - @bindable('bar')(Foo)\n    config = {};\n    return decorator as BindableDecorator;\n  }\n\n  // Invocation with or w/o opts:\n  // - @bindable()\n  // - @bindable({...opts})\n  config = (configOrTarget || {}) as IBindableDescription;\n  return decorator as BindableDecorator;\n}\n","import { Constructable, IIndexable } from '@aurelia/kernel';\nimport { buildTemplateDefinition, isTargetedInstruction, TargetedInstruction, TargetedInstructionType, TemplateDefinition } from '../definitions';\nimport { DOM, INode } from '../dom';\nimport { IRenderContext, IView, IViewFactory } from '../lifecycle';\nimport { ICustomElementType, IRenderingEngine, ITemplate } from './lifecycle-render';\n\ntype ChildType = RenderPlan | string | INode;\n\nexport function createElement(tagOrType: string | Constructable, props?: IIndexable, children?: ArrayLike<ChildType>): RenderPlan {\n  if (typeof tagOrType === 'string') {\n    return createElementForTag(tagOrType, props, children);\n  } else {\n    return createElementForType(tagOrType as ICustomElementType, props, children);\n  }\n}\n\nexport class RenderPlan {\n  private lazyDefinition: TemplateDefinition;\n\n  constructor(\n    private readonly node: INode,\n    private readonly instructions: TargetedInstruction[][],\n    private readonly dependencies: ReadonlyArray<any>\n  ) {}\n\n  public get definition(): TemplateDefinition {\n    return this.lazyDefinition || (this.lazyDefinition =\n      buildTemplateDefinition(null, null, this.node, null, typeof this.node === 'string', null, this.instructions, this.dependencies))\n  }\n\n  public getElementTemplate(engine: IRenderingEngine, Type?: ICustomElementType): ITemplate {\n    return engine.getElementTemplate(this.definition, Type);\n  }\n\n  public createView(engine: IRenderingEngine, parentContext?: IRenderContext): IView {\n    return this.getViewFactory(engine, parentContext).create();\n  }\n\n  public getViewFactory(engine: IRenderingEngine, parentContext?: IRenderContext): IViewFactory {\n    return engine.getViewFactory(this.definition, parentContext);\n  }\n\n  /*@internal*/\n  public mergeInto(parent: INode, instructions: TargetedInstruction[][], dependencies: any[]): void {\n    DOM.appendChild(parent, this.node);\n    instructions.push(...this.instructions);\n    dependencies.push(...this.dependencies);\n  }\n}\n\nfunction createElementForTag(tagName: string, props?: IIndexable, children?: ArrayLike<ChildType>): RenderPlan {\n  const instructions: TargetedInstruction[] = [];\n  const allInstructions = [];\n  const dependencies = [];\n  const element = DOM.createElement(tagName);\n  let hasInstructions = false;\n\n  if (props) {\n    Object.keys(props)\n      .forEach(to => {\n        const value = props[to];\n\n        if (isTargetedInstruction(value)) {\n          hasInstructions = true;\n          instructions.push(value);\n        } else {\n          DOM.setAttribute(element, to, value);\n        }\n      });\n  }\n\n  if (hasInstructions) {\n    DOM.setAttribute(element, 'class', 'au');\n    allInstructions.push(instructions);\n  }\n\n  if (children) {\n    addChildren(element, children, allInstructions, dependencies);\n  }\n\n  return new RenderPlan(element, allInstructions, dependencies);\n}\n\nfunction createElementForType(Type: ICustomElementType, props?: IIndexable, children?: ArrayLike<ChildType>): RenderPlan {\n  const tagName = Type.description.name;\n  const instructions: TargetedInstruction[] = [];\n  const allInstructions = [instructions];\n  const dependencies = [];\n  const childInstructions = [];\n  const bindables = Type.description.bindables;\n  const element = DOM.createElement(tagName);\n\n  DOM.setAttribute(element, 'class', 'au');\n\n  if (!dependencies.includes(Type)) {\n    dependencies.push(Type);\n  }\n\n  instructions.push({\n    type: TargetedInstructionType.hydrateElement,\n    res: tagName,\n    instructions: childInstructions\n  });\n\n  if (props) {\n    Object.keys(props)\n      .forEach(to => {\n        const value = props[to];\n\n        if (isTargetedInstruction(value)) {\n          childInstructions.push(value);\n        } else {\n          const bindable = bindables[to];\n\n          if (bindable) {\n            childInstructions.push({\n              type: TargetedInstructionType.setProperty,\n              to,\n              value\n            });\n          } else {\n            childInstructions.push({\n              type: TargetedInstructionType.setAttribute,\n              to,\n              value\n            });\n          }\n        }\n      });\n  }\n\n  if (children) {\n    addChildren(element, children, allInstructions, dependencies);\n  }\n\n  return new RenderPlan(element, allInstructions, dependencies);\n}\n\nfunction addChildren(parent: INode, children: ArrayLike<ChildType>, allInstructions: TargetedInstruction[][], dependencies: any[]): void {\n  for (let i = 0, ii = children.length; i < ii; ++i) {\n    const current = children[i];\n\n    if (typeof current === 'string') {\n      DOM.appendChild(parent, DOM.createTextNode(current));\n    } else if (DOM.isNodeInstance(current)) {\n      DOM.appendChild(parent, current);\n    } else {\n      current.mergeInto(parent, allInstructions, dependencies);\n    }\n  }\n}\n","import { Writable } from '@aurelia/kernel';\nimport { IEncapsulationSource } from '../dom';\nimport { Hooks, IView, State } from '../lifecycle';\nimport { LifecycleFlags } from '../observation';\nimport { ICustomAttribute, ICustomElement } from './lifecycle-render';\n\n/*@internal*/\nexport function $attachAttribute(this: Writable<ICustomAttribute>, flags: LifecycleFlags, encapsulationSource?: IEncapsulationSource): void {\n  if (this.$state & State.isAttached) {\n    return;\n  }\n  const lifecycle = this.$lifecycle;\n  lifecycle.beginAttach();\n  // add isAttaching flag\n  this.$state |= State.isAttaching;\n  flags |= LifecycleFlags.fromAttach;\n\n  const hooks = this.$hooks;\n\n  if (hooks & Hooks.hasAttaching) {\n    this.attaching(flags, encapsulationSource);\n  }\n\n  // add isAttached flag, remove isAttaching flag\n  this.$state |= State.isAttached;\n  this.$state &= ~State.isAttaching;\n\n  if (hooks & Hooks.hasAttached) {\n    lifecycle.enqueueAttached(<Required<typeof this>>this);\n  }\n  lifecycle.endAttach(flags);\n}\n\n/*@internal*/\nexport function $attachElement(this: Writable<ICustomElement>, flags: LifecycleFlags, encapsulationSource?: IEncapsulationSource): void {\n  if (this.$state & State.isAttached) {\n    return;\n  }\n  const lifecycle = this.$lifecycle;\n  lifecycle.beginAttach();\n  // add isAttaching flag\n  this.$state |= State.isAttaching;\n  flags |= LifecycleFlags.fromAttach;\n\n  const hooks = this.$hooks;\n  encapsulationSource = this.$projector.provideEncapsulationSource(encapsulationSource === undefined ? this.$host : encapsulationSource);\n\n  if (hooks & Hooks.hasAttaching) {\n    this.attaching(flags, encapsulationSource);\n  }\n\n  let current = this.$attachableHead;\n  while (current !== null) {\n    current.$attach(flags, encapsulationSource);\n    current = current.$nextAttach;\n  }\n\n  if (!(this.$state & State.isMounted)) {\n    lifecycle.enqueueMount(this);\n  }\n\n  // add isAttached flag, remove isAttaching flag\n  this.$state |= State.isAttached;\n  this.$state &= ~State.isAttaching;\n\n  if (hooks & Hooks.hasAttached) {\n    lifecycle.enqueueAttached(<Required<typeof this>>this);\n  }\n  lifecycle.endAttach(flags);\n}\n\n/*@internal*/\nexport function $attachView(this: Writable<IView>, flags: LifecycleFlags, encapsulationSource?: IEncapsulationSource): void {\n  if (this.$state & State.isAttached) {\n    return;\n  }\n  // add isAttaching flag\n  this.$state |= State.isAttaching;\n  flags |= LifecycleFlags.fromAttach;\n\n  let current = this.$attachableHead;\n  while (current !== null) {\n    current.$attach(flags, encapsulationSource);\n    current = current.$nextAttach;\n  }\n\n  if (!(this.$state & State.isMounted)) {\n    this.$lifecycle.enqueueMount(this);\n  }\n\n  // add isAttached flag, remove isAttaching flag\n  this.$state |= State.isAttached;\n  this.$state &= ~State.isAttaching;\n}\n\n/*@internal*/\nexport function $detachAttribute(this: Writable<ICustomAttribute>, flags: LifecycleFlags): void {\n  if (this.$state & State.isAttached) {\n    const lifecycle = this.$lifecycle;\n    lifecycle.beginDetach();\n    // add isDetaching flag\n    this.$state |= State.isDetaching;\n    flags |= LifecycleFlags.fromDetach;\n\n    const hooks = this.$hooks;\n    if (hooks & Hooks.hasDetaching) {\n      this.detaching(flags);\n    }\n\n    // remove isAttached and isDetaching flags\n    this.$state &= ~(State.isAttached | State.isDetaching);\n\n    if (hooks & Hooks.hasDetached) {\n      lifecycle.enqueueDetached(<Required<typeof this>>this);\n    }\n    lifecycle.endDetach(flags);\n  }\n}\n\n/*@internal*/\nexport function $detachElement(this: Writable<ICustomElement>, flags: LifecycleFlags): void {\n  if (this.$state & State.isAttached) {\n    const lifecycle = this.$lifecycle;\n    lifecycle.beginDetach();\n    // add isDetaching flag\n    this.$state |= State.isDetaching;\n    flags |= LifecycleFlags.fromDetach;\n\n    if (this.$state & State.isMounted) {\n      // Only unmount if either:\n      // - No parent view/element is queued for unmount yet, or\n      // - Aurelia is stopping (in which case all nodes need to return to their fragments for a clean mount on next start)\n      if (((flags & LifecycleFlags.parentUnmountQueued) ^ LifecycleFlags.parentUnmountQueued) | (flags & LifecycleFlags.fromStopTask)) {\n        lifecycle.enqueueUnmount(this);\n        flags |= LifecycleFlags.parentUnmountQueued;\n      }\n    }\n\n    const hooks = this.$hooks;\n    if (hooks & Hooks.hasDetaching) {\n      this.detaching(flags);\n    }\n\n    let current = this.$attachableTail;\n    while (current !== null) {\n      current.$detach(flags);\n      current = current.$prevAttach;\n    }\n\n    // remove isAttached and isDetaching flags\n    this.$state &= ~(State.isAttached | State.isDetaching);\n\n    if (hooks & Hooks.hasDetached) {\n      lifecycle.enqueueDetached(<Required<typeof this>>this);\n    }\n    lifecycle.endDetach(flags);\n  }\n}\n\n/*@internal*/\nexport function $detachView(this: Writable<IView>, flags: LifecycleFlags): void {\n  if (this.$state & State.isAttached) {\n    // add isDetaching flag\n    this.$state |= State.isDetaching;\n    flags |= LifecycleFlags.fromDetach;\n\n    if (this.$state & State.isMounted) {\n      // Only unmount if either:\n      // - No parent view/element is queued for unmount yet, or\n      // - Aurelia is stopping (in which case all nodes need to return to their fragments for a clean mount on next start)\n      if (((flags & LifecycleFlags.parentUnmountQueued) ^ LifecycleFlags.parentUnmountQueued) | (flags & LifecycleFlags.fromStopTask)) {\n        this.$lifecycle.enqueueUnmount(this);\n        flags |= LifecycleFlags.parentUnmountQueued;\n      }\n    }\n\n    let current = this.$attachableTail;\n    while (current !== null) {\n      current.$detach(flags);\n      current = current.$prevAttach;\n    }\n\n    // remove isAttached and isDetaching flags\n    this.$state &= ~(State.isAttached | State.isDetaching);\n  }\n}\n\n/*@internal*/\nexport function $cacheAttribute(this: Writable<ICustomAttribute>, flags: LifecycleFlags): void {\n  flags |= LifecycleFlags.fromCache;\n  if (this.$hooks & Hooks.hasCaching) {\n    this.caching(flags);\n  }\n}\n\n/*@internal*/\nexport function $cacheElement(this: Writable<ICustomElement>, flags: LifecycleFlags): void {\n  flags |= LifecycleFlags.fromCache;\n  if (this.$hooks & Hooks.hasCaching) {\n    this.caching(flags);\n  }\n\n  let current = this.$attachableTail;\n  while (current !== null) {\n    current.$cache(flags);\n    current = current.$prevAttach;\n  }\n}\n\n/*@internal*/\nexport function $cacheView(this: Writable<IView>, flags: LifecycleFlags): void {\n  flags |= LifecycleFlags.fromCache;\n  let current = this.$attachableTail;\n  while (current !== null) {\n    current.$cache(flags);\n    current = current.$prevAttach;\n  }\n}\n\n/*@internal*/\nexport function $mountElement(this: Writable<ICustomElement>, flags: LifecycleFlags): void {\n  this.$state |= State.isMounted;\n  this.$projector.project(this.$nodes);\n}\n\n/*@internal*/\nexport function $unmountElement(this: Writable<ICustomElement>, flags: LifecycleFlags): void {\n  this.$state &= ~State.isMounted;\n  this.$projector.take(this.$nodes);\n}\n\n/*@internal*/\nexport function $mountView(this: Writable<IView>, flags: LifecycleFlags): void {\n  this.$state |= State.isMounted;\n  this.$state &= ~State.needsMount;\n  this.$nodes.insertBefore(this.location);\n}\n\n/*@internal*/\nexport function $unmountView(this: Writable<IView>, flags: LifecycleFlags): boolean {\n  this.$state &= ~State.isMounted;\n  this.$state |= State.needsMount;\n  this.$nodes.remove();\n\n  if (this.isFree) {\n    this.isFree = false;\n    if (this.cache.tryReturnToCache(this)) {\n      this.$state |= State.isCached;\n      return true;\n    }\n  }\n  return false;\n}\n","import { Writable } from '@aurelia/kernel';\nimport { Hooks, IView, State } from '../lifecycle';\nimport { IScope, LifecycleFlags } from '../observation';\nimport { ICustomAttribute, ICustomElement } from './lifecycle-render';\n\n/*@internal*/\nexport function $bindAttribute(this: Writable<ICustomAttribute>, flags: LifecycleFlags, scope: IScope): void {\n  flags |= LifecycleFlags.fromBind;\n\n  if (this.$state & State.isBound) {\n    if (this.$scope === scope) {\n      return;\n    }\n\n    this.$unbind(flags);\n  }\n  const lifecycle = this.$lifecycle;\n  lifecycle.beginBind();\n  // add isBinding flag\n  this.$state |= State.isBinding;\n\n  const hooks = this.$hooks;\n\n  if (hooks & Hooks.hasBound) {\n    lifecycle.enqueueBound(this);\n  }\n\n  this.$scope = scope;\n\n  if (hooks & Hooks.hasBinding) {\n    this.binding(flags);\n  }\n\n  // add isBound flag and remove isBinding flag\n  this.$state |= State.isBound;\n  this.$state &= ~State.isBinding;\n\n  lifecycle.endBind(flags);\n}\n\n/*@internal*/\nexport function $bindElement(this: Writable<ICustomElement>, flags: LifecycleFlags): void {\n  if (this.$state & State.isBound) {\n    return;\n  }\n  const lifecycle = this.$lifecycle;\n  lifecycle.beginBind();\n  // add isBinding flag\n  this.$state |= State.isBinding;\n\n  const hooks = this.$hooks;\n  flags |= LifecycleFlags.fromBind;\n\n  if (hooks & Hooks.hasBound) {\n    lifecycle.enqueueBound(this);\n  }\n\n  if (hooks & Hooks.hasBinding) {\n    this.binding(flags);\n  }\n\n  const scope = this.$scope;\n  let current = this.$bindableHead;\n  while (current !== null) {\n    current.$bind(flags, scope);\n    current = current.$nextBind;\n  }\n\n  // add isBound flag and remove isBinding flag\n  this.$state |= State.isBound;\n  this.$state &= ~State.isBinding;\n\n  lifecycle.endBind(flags);\n}\n\n/*@internal*/\nexport function $bindView(this: Writable<IView>, flags: LifecycleFlags, scope: IScope): void {\n  flags |= LifecycleFlags.fromBind;\n\n  if (this.$state & State.isBound) {\n    if (this.$scope === scope) {\n      return;\n    }\n\n    this.$unbind(flags);\n  }\n  // add isBinding flag\n  this.$state |= State.isBinding;\n\n  this.$scope = scope;\n  let current = this.$bindableHead;\n  while (current !== null) {\n    current.$bind(flags, scope);\n    current = current.$nextBind;\n  }\n\n  // add isBound flag and remove isBinding flag\n  this.$state |= State.isBound;\n  this.$state &= ~State.isBinding;\n}\n\n/*@internal*/\nexport function $unbindAttribute(this: Writable<ICustomAttribute>, flags: LifecycleFlags): void {\n  if (this.$state & State.isBound) {\n    const lifecycle = this.$lifecycle;\n    lifecycle.beginUnbind();\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    const hooks = this.$hooks;\n    flags |= LifecycleFlags.fromUnbind;\n\n    if (hooks & Hooks.hasUnbound) {\n      lifecycle.enqueueUnbound(this);\n    }\n\n    if (hooks & Hooks.hasUnbinding) {\n      this.unbinding(flags);\n    }\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n\n    lifecycle.endUnbind(flags);\n  }\n}\n\n/*@internal*/\nexport function $unbindElement(this: Writable<ICustomElement>, flags: LifecycleFlags): void {\n  if (this.$state & State.isBound) {\n    const lifecycle = this.$lifecycle;\n    lifecycle.beginUnbind();\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    const hooks = this.$hooks;\n    flags |= LifecycleFlags.fromUnbind;\n\n    if (hooks & Hooks.hasUnbound) {\n      lifecycle.enqueueUnbound(this);\n    }\n\n    if (hooks & Hooks.hasUnbinding) {\n      this.unbinding(flags);\n    }\n\n    let current = this.$bindableTail;\n    while (current !== null) {\n      current.$unbind(flags);\n      current = current.$prevBind;\n    }\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n\n    lifecycle.endUnbind(flags);\n  }\n}\n\n/*@internal*/\nexport function $unbindView(this: Writable<IView>, flags: LifecycleFlags): void {\n  if (this.$state & State.isBound) {\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    flags |= LifecycleFlags.fromUnbind;\n\n    let current = this.$bindableTail;\n    while (current !== null) {\n      current.$unbind(flags);\n      current = current.$prevBind;\n    }\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n    this.$scope = null;\n  }\n}\n","import { Reporter } from '@aurelia/kernel';\nimport { INodeSequence, IRenderLocation } from '../dom';\nimport { IAttach, IBindScope, ILifecycle, ILifecycleUnbind, IMountable, IRenderContext, IView, IViewCache, IViewFactory, State } from '../lifecycle';\nimport { IScope, LifecycleFlags } from '../observation';\nimport { $attachView, $cacheView, $detachView, $mountView, $unmountView } from './lifecycle-attach';\nimport { $bindView, $unbindView } from './lifecycle-bind';\nimport { ITemplate } from './lifecycle-render';\n\n/*@internal*/\nexport interface View extends IView {}\n\n/*@internal*/\nexport class View implements IView {\n  public $bindableHead: IBindScope = null;\n  public $bindableTail: IBindScope = null;\n\n  public $nextBind: IBindScope = null;\n  public $prevBind: IBindScope = null;\n\n  public $attachableHead: IAttach = null;\n  public $attachableTail: IAttach = null;\n\n  public $nextAttach: IAttach = null;\n  public $prevAttach: IAttach = null;\n\n  public $nextMount: IMountable = null;\n  public $mountFlags: LifecycleFlags = 0;\n  public $nextUnmount: IMountable = null;\n  public $unmountFlags: LifecycleFlags = 0;\n\n  public $nextUnbindAfterDetach: ILifecycleUnbind = null;\n\n  public $state: State = State.none;\n  public $scope: IScope = null;\n  public $nodes: INodeSequence;\n  public $context: IRenderContext;\n  public location: IRenderLocation;\n  public isFree: boolean = false;\n\n  constructor(\n    public readonly $lifecycle: ILifecycle,\n    public cache: IViewCache) {}\n\n  public hold(location: IRenderLocation, flags: LifecycleFlags): void {\n    if (!location.parentNode) { // unmet invariant: location must be a child of some other node\n      throw Reporter.error(60); // TODO: organize error codes\n    }\n    this.location = location;\n    const lastChild = this.$nodes.lastChild;\n    if (lastChild && lastChild.nextSibling === location) {\n      this.$state &= ~State.needsMount;\n    } else {\n      this.$state |= State.needsMount;\n    }\n  }\n\n  public lockScope(scope: IScope): void {\n    this.$scope = scope;\n    this.$bind = lockedBind;\n  }\n\n  public release(flags: LifecycleFlags): any {\n    this.isFree = true;\n    if (this.$state & State.isAttached) {\n      return this.cache.canReturnToCache(this);\n    }\n\n    return this.$unmount(flags);\n  }\n}\n\n/*@internal*/\nexport class ViewFactory implements IViewFactory {\n  public static maxCacheSize: number = 0xFFFF;\n  public isCaching: boolean = false;\n\n  private cacheSize: number = -1;\n  private cache: View[] = null;\n\n  constructor(\n    public name: string,\n    private template: ITemplate,\n    private lifecycle: ILifecycle\n  ) {}\n\n  public setCacheSize(size: number | '*', doNotOverrideIfAlreadySet: boolean): void {\n    if (size) {\n      if (size === '*') {\n        size = ViewFactory.maxCacheSize;\n      } else if (typeof size === 'string') {\n        size = parseInt(size, 10);\n      }\n\n      if (this.cacheSize === -1 || !doNotOverrideIfAlreadySet) {\n        this.cacheSize = size;\n      }\n    }\n\n    if (this.cacheSize > 0) {\n      this.cache = [];\n    } else {\n      this.cache = null;\n    }\n\n    this.isCaching = this.cacheSize > 0;\n  }\n\n  public canReturnToCache(view: IView): boolean {\n    return this.cache !== null && this.cache.length < this.cacheSize;\n  }\n\n  public tryReturnToCache(view: View): boolean {\n    if (this.canReturnToCache(view)) {\n      view.$cache(LifecycleFlags.none);\n      this.cache.push(view);\n      return true;\n    }\n\n    return false;\n  }\n\n  public create(): IView {\n    const cache = this.cache;\n    let view: View;\n\n    if (cache !== null && cache.length > 0) {\n      view = cache.pop();\n      view.$state &= ~State.isCached;\n      return view;\n    }\n\n    view = new View(this.lifecycle, this);\n    this.template.render(view);\n    if (!view.$nodes) {\n      throw Reporter.error(90);\n    }\n    return view;\n  }\n}\n\nfunction lockedBind(this: View, flags: LifecycleFlags): void {\n  if (this.$state & State.isBound) {\n    return;\n  }\n\n  flags |= LifecycleFlags.fromBind;\n  const lockedScope = this.$scope;\n  let current = this.$bindableHead;\n  while (current !== null) {\n    current.$bind(flags, lockedScope);\n    current = current.$nextBind;\n  }\n\n  this.$state |= State.isBound;\n}\n\n((proto: IView): void => {\n  proto.$bind = $bindView;\n  proto.$unbind = $unbindView;\n  proto.$attach = $attachView;\n  proto.$detach = $detachView;\n  proto.$cache = $cacheView;\n  proto.$mount = $mountView;\n  proto.$unmount = $unmountView;\n})(View.prototype);\n","import { all, Constructable, Decoratable, Decorated, DI, IContainer, IDisposable, IIndexable, Immutable, ImmutableArray, inject, IResolver, Omit, PLATFORM, Registration, Reporter, Writable } from '@aurelia/kernel';\nimport { Interpolation } from '../binding/ast';\nimport { Binding } from '../binding/binding';\nimport { Scope } from '../binding/binding-context';\nimport { BindingMode } from '../binding/binding-mode';\nimport { Call } from '../binding/call';\nimport { IEventManager } from '../binding/event-manager';\nimport { BindingType, IExpressionParser } from '../binding/expression-parser';\nimport { InterpolationBinding, MultiInterpolationBinding } from '../binding/interpolation-binding';\nimport { LetBinding } from '../binding/let-binding';\nimport { Listener } from '../binding/listener';\nimport { IObserverLocator } from '../binding/observer-locator';\nimport { Observer } from '../binding/property-observation';\nimport { Ref } from '../binding/ref';\nimport { subscriberCollection } from '../binding/subscriber-collection';\nimport { BindableDefinitions, buildTemplateDefinition, customAttributeKey, customElementBehavior, CustomElementConstructor, customElementKey, IAttributeDefinition, ICallBindingInstruction, IHydrateAttributeInstruction, IHydrateElementInstruction, IHydrateTemplateController, IInterpolationInstruction, IIteratorBindingInstruction, ILetElementInstruction, IListenerBindingInstruction, IPropertyBindingInstruction, IRefBindingInstruction, IRenderStrategyInstruction, ISetAttributeInstruction, ISetPropertyInstruction, IStylePropertyBindingInstruction, ITargetedInstruction, ITemplateDefinition, ITextBindingInstruction, TargetedInstructionType, TemplateDefinition, TemplatePartDefinitions } from '../definitions';\nimport { DOM, INode, INodeSequence, INodeSequenceFactory, IRenderLocation, NodeSequence, NodeSequenceFactory } from '../dom';\nimport { Hooks, IAttach, IAttachables, IBindables, IBindScope, IBindSelf, ILifecycle, ILifecycleHooks, ILifecycleUnbindAfterDetach, IMountable, IRenderable, IRenderContext, IState, IViewFactory, State } from '../lifecycle';\nimport { IAccessor, IChangeTracker, IPropertySubscriber, ISubscribable, ISubscriberCollection, LifecycleFlags, MutationKind } from '../observation';\nimport { IResourceDescriptions, IResourceKind, IResourceType, ResourceDescription } from '../resource';\nimport { ViewFactory } from './view';\n\nexport interface IRenderStrategy<TTarget = any, TInstruction extends IRenderStrategyInstruction = any> {\n  render(renderable: IRenderable, target: TTarget, instruction: TInstruction): void;\n}\n\nexport interface IRenderStrategySource {\n  name: string;\n}\n\nexport type IRenderStrategyType = IResourceType<IRenderStrategySource, IRenderStrategy>;\n\ntype RenderStrategyDecorator = <T extends Constructable>(target: Decoratable<IRenderStrategy, T>) => Decorated<IRenderStrategy, T> & IRenderStrategyType;\n\nexport function renderStrategy(nameOrSource: string | IRenderStrategySource): RenderStrategyDecorator {\n  return target => RenderStrategyResource.define(nameOrSource, target);\n}\n\nexport const RenderStrategyResource: IResourceKind<IRenderStrategySource, IRenderStrategyType> = {\n  name: 'render-strategy',\n\n  keyFrom(name: string): string {\n    return `${this.name}:${name}`;\n  },\n\n  isType<T extends Constructable & Partial<IRenderStrategyType>>(Type: T): Type is T & IRenderStrategyType {\n    return Type.kind === this;\n  },\n\n  define<T extends Constructable>(nameOrSource: string | IRenderStrategySource, ctor: T): T & IRenderStrategyType {\n    const description = typeof nameOrSource === 'string' ? { name: nameOrSource } : nameOrSource;\n    const Type = ctor as T & Writable<IRenderStrategyType>;\n\n    Type.kind = RenderStrategyResource;\n    Type.description = description;\n    Type.register = registerRenderStrategy;\n\n    return <IRenderStrategyType & T>Type;\n  }\n};\n\n/*@internal*/\nexport function registerRenderStrategy(this: IRenderStrategyType, container: IContainer): void {\n  const resourceKey = RenderStrategyResource.keyFrom(this.description.name);\n  container.register(Registration.singleton(resourceKey, this));\n}\n\nexport interface ITemplateCompiler {\n  readonly name: string;\n  compile(definition: ITemplateDefinition, resources: IResourceDescriptions, viewCompileFlags?: ViewCompileFlags): TemplateDefinition;\n}\n\nexport const ITemplateCompiler = DI.createInterface<ITemplateCompiler>().noDefault();\n\nexport enum ViewCompileFlags {\n  none        = 0b0_001,\n  surrogate   = 0b0_010,\n  shadowDOM   = 0b0_100,\n}\n\nexport interface ICustomElementType extends\n  IResourceType<ITemplateDefinition, ICustomElement>,\n  CustomElementConstructor { }\n\nexport type IElementHydrationOptions = Immutable<Pick<IHydrateElementInstruction, 'parts'>>;\n\nexport interface ICustomElement extends Partial<IChangeTracker>, ILifecycleHooks, ILifecycleRender, IBindSelf, ILifecycleUnbindAfterDetach, IAttach, IMountable, IState, IRenderable {\n  readonly $projector: IElementProjector;\n  readonly $host: ICustomElementHost;\n  $hydrate(renderingEngine: IRenderingEngine, host: INode, options?: IElementHydrationOptions): void;\n}\n\nexport interface ICustomElementHost extends IRenderLocation {\n  $customElement?: ICustomElement;\n}\n\nexport type ElementDefinition = Immutable<Required<ITemplateDefinition>> | null;\n\nexport interface ICustomElementResource extends IResourceKind<ITemplateDefinition, ICustomElementType> {\n  behaviorFor(node: INode): ICustomElement | null;\n}\n\nexport interface IElementProjector {\n  readonly host: ICustomElementHost;\n  readonly children: ArrayLike<ICustomElementHost>;\n\n  provideEncapsulationSource(parentEncapsulationSource: ICustomElementHost): ICustomElementHost;\n  project(nodes: INodeSequence): void;\n  take(nodes: INodeSequence): void;\n\n  subscribeToChildrenChange(callback: () => void): void;\n}\n\nexport interface ICustomAttributeType extends\n  IResourceType<IAttributeDefinition, ICustomAttribute>,\n  Immutable<Pick<Partial<IAttributeDefinition>, 'bindables'>> { }\n\ntype OptionalHooks = ILifecycleHooks & Omit<IRenderable, Exclude<keyof IRenderable, '$mount' | '$unmount'>>;\ntype RequiredLifecycleProperties = Readonly<Pick<IRenderable, '$scope'>> & IState;\n\nexport interface IElementTemplateProvider {\n  getElementTemplate(renderingEngine: IRenderingEngine, customElementType: ICustomElementType): ITemplate;\n}\n\nexport interface ILifecycleRender {\n  /**\n   * Only applies to `@customElement`. This hook is not invoked for `@customAttribute`s\n   *\n   * Called during `$hydrate`, after `this.$scope` and `this.$projector` are set.\n   *\n   * If this hook is implemented, it will be used instead of `renderingEngine.getElementTemplate`.\n   * This allows you to completely override the default rendering behavior.\n   *\n   * It is the responsibility of the implementer to:\n   * - Populate `this.$bindables` with any Bindings, child Views, custom elements and custom attributes\n   * - Populate `this.$attachables` with any child Views, custom elements and custom attributes\n   * - Populate `this.$nodes` with the nodes that need to be appended to the host\n   * - Populate `this.$context` with the RenderContext / Container scoped to this instance\n   *\n   * @param host The DOM node that declares this custom element\n   * @param parts Replaceable parts, if any\n   *\n   * @returns Either an implementation of `IElementTemplateProvider`, or void\n   *\n   * @description\n   * This is the first \"hydrate\" lifecycle hook. It happens only once per instance (contrary to bind/attach\n   * which can happen many times per instance), though it can happen many times per type (once for each instance)\n   */\n  render?(host: INode, parts: Immutable<Pick<IHydrateElementInstruction, 'parts'>>): IElementTemplateProvider | void;\n}\n\nexport interface ICustomAttribute extends Partial<IChangeTracker>, IBindScope, ILifecycleUnbindAfterDetach, IAttach, OptionalHooks, RequiredLifecycleProperties {\n  $hydrate(renderingEngine: IRenderingEngine): void;\n}\n\n/*@internal*/\nexport function $hydrateAttribute(this: Writable<ICustomAttribute>, renderingEngine: IRenderingEngine): void {\n  const Type = this.constructor as ICustomAttributeType;\n\n  renderingEngine.applyRuntimeBehavior(Type, this);\n\n  if (this.$hooks & Hooks.hasCreated) {\n    this.created();\n  }\n}\n\n/*@internal*/\nexport function $hydrateElement(this: Writable<ICustomElement>, renderingEngine: IRenderingEngine, host: INode, options: IElementHydrationOptions = PLATFORM.emptyObject): void {\n  const Type = this.constructor as ICustomElementType;\n  const description = Type.description;\n\n  this.$scope = Scope.create(this, null);\n  this.$host = host;\n  this.$projector = determineProjector(this, host, description);\n\n  renderingEngine.applyRuntimeBehavior(Type, this);\n\n  if (this.$hooks & Hooks.hasRender) {\n    const result = this.render(host, options.parts);\n\n    if (result && 'getElementTemplate' in result) {\n      const template = result.getElementTemplate(renderingEngine, Type);\n      template.render(this, host, options.parts);\n    }\n  } else {\n    const template = renderingEngine.getElementTemplate(description, Type);\n    template.render(this, host, options.parts);\n  }\n\n  if (this.$hooks & Hooks.hasCreated) {\n    this.created();\n  }\n}\n\n/*@internal*/\nexport const defaultShadowOptions = {\n  mode: 'open' as 'open' | 'closed'\n};\n\nfunction determineProjector(\n  $customElement: ICustomElement,\n  host: ICustomElementHost,\n  definition: TemplateDefinition\n): IElementProjector {\n  if (definition.shadowOptions || definition.hasSlots) {\n    if (definition.containerless) {\n      throw Reporter.error(21);\n    }\n\n    return new ShadowDOMProjector($customElement, host, definition);\n  }\n\n  if (definition.containerless) {\n    return new ContainerlessProjector($customElement, host);\n  }\n\n  return new HostProjector($customElement, host);\n}\n\nexport interface IRenderingEngine {\n  getElementTemplate(definition: TemplateDefinition, componentType?: ICustomElementType): ITemplate;\n  getViewFactory(source: Immutable<ITemplateDefinition>, parentContext?: IRenderContext): IViewFactory;\n\n  applyRuntimeBehavior(Type: ICustomAttributeType, instance: ICustomAttribute): void;\n  applyRuntimeBehavior(Type: ICustomElementType, instance: ICustomElement): void;\n\n  createRenderer(context: IRenderContext): IRenderer;\n}\n\nexport const IRenderingEngine = DI.createInterface<IRenderingEngine>()\n  .withDefault(x => x.singleton(RenderingEngine));\n\nconst defaultCompilerName = 'default';\n\n@inject(IContainer, ILifecycle, IObserverLocator, IEventManager, IExpressionParser, all(ITemplateCompiler))\n/*@internal*/\nexport class RenderingEngine implements IRenderingEngine {\n  private templateLookup: Map<TemplateDefinition, ITemplate> = new Map();\n  private factoryLookup: Map<Immutable<ITemplateDefinition>, IViewFactory> = new Map();\n  private behaviorLookup: Map<ICustomElementType | ICustomAttributeType, RuntimeBehavior> = new Map();\n  private compilers: Record<string, ITemplateCompiler>;\n\n  constructor(\n    private container: IContainer,\n    private lifecycle: ILifecycle,\n    private observerLocator: IObserverLocator,\n    private eventManager: IEventManager,\n    private parser: IExpressionParser,\n    templateCompilers: ITemplateCompiler[]\n  ) {\n    this.compilers = templateCompilers.reduce(\n      (acc, item) => {\n        acc[item.name] = item;\n        return acc;\n      },\n      Object.create(null)\n    );\n  }\n\n  public getElementTemplate(definition: TemplateDefinition, componentType?: ICustomElementType): ITemplate {\n    if (!definition) {\n      return null;\n    }\n\n    let found = this.templateLookup.get(definition);\n\n    if (!found) {\n      found = this.templateFromSource(definition);\n\n      //If the element has a view, support Recursive Components by adding self to own view template container.\n      if (found.renderContext !== null && componentType) {\n        componentType.register(<ExposedContext>found.renderContext);\n      }\n\n      this.templateLookup.set(definition, found);\n    }\n\n    return found;\n  }\n\n  public getViewFactory(definition: Immutable<ITemplateDefinition>, parentContext?: IRenderContext): IViewFactory {\n    if (!definition) {\n      return null;\n    }\n\n    let factory = this.factoryLookup.get(definition);\n\n    if (!factory) {\n      const validSource = buildTemplateDefinition(null, definition)\n      const template = this.templateFromSource(validSource, parentContext);\n      factory = new ViewFactory(validSource.name, template, this.lifecycle);\n      factory.setCacheSize(validSource.cache, true);\n      this.factoryLookup.set(definition, factory);\n    }\n\n    return factory;\n  }\n\n  public applyRuntimeBehavior(Type: ICustomAttributeType | ICustomElementType, instance: ICustomAttribute | ICustomElement): void {\n    let found = this.behaviorLookup.get(Type);\n\n    if (!found) {\n      found = RuntimeBehavior.create(Type, instance);\n      this.behaviorLookup.set(Type, found);\n    }\n\n    found.applyTo(instance, this.lifecycle);\n  }\n\n  public createRenderer(context: IRenderContext): IRenderer {\n    return new Renderer(\n      context,\n      this.observerLocator,\n      this.eventManager,\n      this.parser,\n      this\n    );\n  }\n\n  private templateFromSource(definition: TemplateDefinition, parentContext?: IRenderContext): ITemplate {\n    parentContext = parentContext || <ExposedContext>this.container;\n\n    if (definition && definition.template) {\n      if (definition.build.required) {\n        const compilerName = definition.build.compiler || defaultCompilerName;\n        const compiler = this.compilers[compilerName];\n\n        if (!compiler) {\n          throw Reporter.error(20, compilerName);\n        }\n\n        definition = compiler.compile(<ITemplateDefinition>definition, new RuntimeCompilationResources(<ExposedContext>parentContext), ViewCompileFlags.surrogate);\n      }\n\n      return new CompiledTemplate(this, parentContext, definition);\n    }\n\n    return noViewTemplate;\n  }\n}\nconst childObserverOptions = { childList: true };\n\n/*@internal*/\nexport class ShadowDOMProjector implements IElementProjector {\n  public shadowRoot: ICustomElementHost;\n\n  constructor(\n    $customElement: ICustomElement,\n    public host: ICustomElementHost,\n    definition: TemplateDefinition\n  ) {\n    this.shadowRoot = DOM.attachShadow(host, definition.shadowOptions || defaultShadowOptions);\n    host.$customElement = $customElement;\n    this.shadowRoot.$customElement = $customElement;\n  }\n\n  get children(): ArrayLike<INode> {\n    return this.host.childNodes;\n  }\n\n  public subscribeToChildrenChange(callback: () => void): void {\n    DOM.createNodeObserver(this.host, callback, childObserverOptions);\n  }\n\n  public provideEncapsulationSource(parentEncapsulationSource: INode): INode {\n    return this.shadowRoot;\n  }\n\n  public project(nodes: INodeSequence): void {\n    nodes.appendTo(this.host);\n    this.project = PLATFORM.noop;\n  }\n\n  public take(nodes: INodeSequence): void {\n    // No special behavior is required because the host element removal\n    // will result in the projected nodes being removed, since they are in\n    // the ShadowDOM.\n  }\n}\n\n/*@internal*/\nexport class ContainerlessProjector implements IElementProjector {\n  public host: ICustomElementHost;\n  private childNodes: ArrayLike<INode>;\n\n  constructor(private $customElement: ICustomElement, host: ICustomElementHost) {\n    if (host.childNodes.length) {\n      this.childNodes = PLATFORM.toArray(host.childNodes);\n    } else {\n      this.childNodes = PLATFORM.emptyArray;\n    }\n\n    this.host = DOM.convertToRenderLocation(host);\n    this.host.$customElement = $customElement;\n  }\n\n  get children(): ArrayLike<INode> {\n    return this.childNodes;\n  }\n\n  public subscribeToChildrenChange(callback: () => void): void {\n    // Do nothing since this scenario will never have children.\n  }\n\n  public provideEncapsulationSource(parentEncapsulationSource: INode): INode {\n    if (!parentEncapsulationSource) {\n      throw Reporter.error(22);\n    }\n\n    return parentEncapsulationSource;\n  }\n\n  public project(nodes: INodeSequence): void {\n    if (this.$customElement.$state & State.needsMount) {\n      this.$customElement.$state &= ~State.needsMount;\n      nodes.insertBefore(this.host);\n    }\n  }\n\n  public take(nodes: INodeSequence): void {\n    this.$customElement.$state |= State.needsMount;\n    nodes.remove();\n  }\n}\n\n/*@internal*/\nexport class HostProjector implements IElementProjector {\n  private readonly isAppHost: boolean;\n  constructor($customElement: ICustomElement, public host: ICustomElementHost) {\n    host.$customElement = $customElement;\n    this.isAppHost = host.hasOwnProperty('$au');\n  }\n\n  get children(): ArrayLike<INode> {\n    return PLATFORM.emptyArray;\n  }\n\n  public subscribeToChildrenChange(callback: () => void): void {\n    // Do nothing since this scenario will never have children.\n  }\n\n  public provideEncapsulationSource(parentEncapsulationSource: INode): INode {\n    return parentEncapsulationSource || this.host;\n  }\n\n  public project(nodes: INodeSequence): void {\n    nodes.appendTo(this.host);\n    if (!this.isAppHost) {\n      this.project = PLATFORM.noop;\n    }\n  }\n\n  public take(nodes: INodeSequence): void {\n    // No special behavior is required because the host element removal\n    // will result in the projected nodes being removed, since they are children.\n    if (this.isAppHost) {\n      // The only exception to that is the app host, which is not part of a removable node sequence\n      nodes.remove();\n    }\n  }\n}\n\n/** @internal */\nexport class RuntimeBehavior {\n  public bindables: BindableDefinitions;\n\n  private constructor() {}\n\n  public static create(Component: ICustomElementType | ICustomAttributeType, instance: ICustomAttribute | ICustomElement): RuntimeBehavior {\n    const behavior = new RuntimeBehavior();\n\n    behavior.bindables = Component.description.bindables;\n\n    return behavior;\n  }\n\n  public applyTo(instance: ICustomAttribute | ICustomElement, lifecycle: ILifecycle): void {\n    instance.$lifecycle = lifecycle;\n    if ('$projector' in instance) {\n      this.applyToElement(lifecycle, instance);\n    } else {\n      this.applyToCore(instance);\n    }\n  }\n\n  private applyToElement(lifecycle: ILifecycle, instance: ICustomElement): void {\n    const observers = this.applyToCore(instance);\n\n    observers.$children = new ChildrenObserver(lifecycle, instance);\n\n    Reflect.defineProperty(instance, '$children', {\n      enumerable: false,\n      get: function(): unknown {\n        return this.$observers.$children.getValue();\n      }\n    });\n  }\n\n  private applyToCore(instance: ICustomAttribute | ICustomElement): IIndexable {\n    const observers = {};\n    const bindables = this.bindables;\n    const observableNames = Object.getOwnPropertyNames(bindables);\n\n    for (let i = 0, ii = observableNames.length; i < ii; ++i) {\n      const name = observableNames[i];\n\n      observers[name] = new Observer(\n        instance,\n        name,\n        bindables[name].callback\n      );\n\n      createGetterSetter(instance, name);\n    }\n\n    Reflect.defineProperty(instance, '$observers', {\n      enumerable: false,\n      value: observers\n    });\n\n    return observers;\n  }\n}\n\nfunction createGetterSetter(instance: ICustomAttribute | ICustomElement, name: string): void {\n  Reflect.defineProperty(instance, name, {\n    enumerable: true,\n    get: function(): unknown { return this.$observers[name].getValue(); },\n    set: function(value: unknown): void { this.$observers[name].setValue(value, LifecycleFlags.updateTargetInstance); }\n  });\n}\n\nexport interface IChildrenObserver extends\n  IAccessor,\n  ISubscribable<MutationKind.instance>,\n  ISubscriberCollection<MutationKind.instance> { }\n\n/*@internal*/\n@subscriberCollection(MutationKind.instance)\nexport class ChildrenObserver implements Partial<IChildrenObserver> {\n  public hasChanges: boolean = false;\n\n  private children: ICustomElement[] = null;\n  private observing: boolean = false;\n\n  constructor(\n    private lifecycle: ILifecycle,\n    private customElement: ICustomElement & { $childrenChanged?(): void }\n  ) { }\n\n  public getValue(): ICustomElement[] {\n    if (!this.observing) {\n      this.observing = true;\n      this.customElement.$projector.subscribeToChildrenChange(() => this.onChildrenChanged());\n      this.children = findElements(this.customElement.$projector.children);\n    }\n\n    return this.children;\n  }\n\n  public setValue(newValue: unknown): void { /* do nothing */ }\n\n  public flush(this: ChildrenObserver & IChildrenObserver, flags: LifecycleFlags): void {\n    this.callSubscribers(this.children, undefined, flags | LifecycleFlags.updateTargetInstance);\n    this.hasChanges = false;\n  }\n\n  public subscribe(this: ChildrenObserver & IChildrenObserver, subscriber: IPropertySubscriber): void {\n    this.addSubscriber(subscriber);\n  }\n\n  public unsubscribe(this: ChildrenObserver & IChildrenObserver, subscriber: IPropertySubscriber): void {\n    this.removeSubscriber(subscriber);\n  }\n\n  private onChildrenChanged(): void {\n    this.children = findElements(this.customElement.$projector.children);\n\n    if ('$childrenChanged' in this.customElement) {\n      this.customElement.$childrenChanged();\n    }\n\n    this.lifecycle.enqueueFlush(this);\n    this.hasChanges = true;\n  }\n}\n\n/*@internal*/\nexport function findElements(nodes: ArrayLike<INode>): ICustomElement[] {\n  const components: ICustomElement[] = [];\n\n  for (let i = 0, ii = nodes.length; i < ii; ++i) {\n    const current = nodes[i];\n    const component = customElementBehavior(current);\n\n    if (component !== null) {\n      components.push(component);\n    }\n  }\n\n  return components;\n}\n\n/*@internal*/\nexport class RuntimeCompilationResources implements IResourceDescriptions {\n  constructor(private context: ExposedContext) {}\n\n  public find<TSource>(kind: IResourceKind<TSource>, name: string): ResourceDescription<TSource> | null {\n    const key = kind.keyFrom(name);\n    const resolver = this.context.getResolver<TSource>(key, false);\n\n    if (resolver !== null && resolver.getFactory) {\n      const factory = resolver.getFactory(this.context);\n\n      if (factory !== null) {\n        return (factory.type as IResourceType<TSource>).description || null;\n      }\n    }\n\n    return null;\n  }\n\n  public create<TSource, TType extends IResourceType<TSource>>(kind: IResourceKind<TSource, TType>, name: string): InstanceType<TType> | null {\n    const key = kind.keyFrom(name);\n    if (this.context.has(key, false)) {\n      return this.context.get<any>(key) || null;\n    }\n    return null;\n  }\n}\n\n// The basic template abstraction that allows consumers to create\n// instances of an INodeSequence on-demand. Templates are contextual in that they are, in the very least,\n// part of a particular application, with application-level resources, but they also may have their\n// own scoped resources or be part of another view (via a template controller) which provides a\n// context for the template.\nexport interface ITemplate {\n  readonly renderContext: IRenderContext;\n  render(renderable: IRenderable, host?: INode, parts?: TemplatePartDefinitions): void;\n}\n\n// This is the main implementation of ITemplate.\n// It is used to create instances of IView based on a compiled TemplateDefinition.\n// TemplateDefinitions are hand-coded today, but will ultimately be the output of the\n// TemplateCompiler either through a JIT or AOT process.\n// Essentially, CompiledTemplate wraps up the small bit of code that is needed to take a TemplateDefinition\n// and create instances of it on demand.\n/*@internal*/\nexport class CompiledTemplate implements ITemplate {\n  public readonly factory: INodeSequenceFactory;\n  public readonly renderContext: IRenderContext;\n\n  constructor(renderingEngine: IRenderingEngine, parentRenderContext: IRenderContext, private templateDefinition: TemplateDefinition) {\n    this.factory = NodeSequenceFactory.createFor(templateDefinition.template);\n    this.renderContext = createRenderContext(renderingEngine, parentRenderContext, templateDefinition.dependencies);\n  }\n\n  public render(renderable: IRenderable, host?: INode, parts?: TemplatePartDefinitions): void {\n    const nodes = (<Writable<IRenderable>>renderable).$nodes = this.factory.createNodeSequence();\n    (<Writable<IRenderable>>renderable).$context = this.renderContext;\n    this.renderContext.render(renderable, nodes.findTargets(), this.templateDefinition, host, parts);\n  }\n}\n\n// This is an implementation of ITemplate that always returns a node sequence representing \"no DOM\" to render.\n/*@internal*/\nexport const noViewTemplate: ITemplate = {\n  renderContext: null,\n  render(renderable: IRenderable): void {\n    (<Writable<IRenderable>>renderable).$nodes = NodeSequence.empty;\n    (<Writable<IRenderable>>renderable).$context = null;\n  }\n};\n\n\n/*@internal*/\nexport type ExposedContext = IRenderContext & IDisposable & IContainer;\n\nexport function createRenderContext(renderingEngine: IRenderingEngine, parentRenderContext: IRenderContext, dependencies: ImmutableArray<any>): IRenderContext {\n  const context = <ExposedContext>parentRenderContext.createChild();\n  const renderableProvider = new InstanceProvider();\n  const elementProvider = new InstanceProvider();\n  const instructionProvider = new InstanceProvider<ITargetedInstruction>();\n  const factoryProvider = new ViewFactoryProvider(renderingEngine);\n  const renderLocationProvider = new InstanceProvider<IRenderLocation>();\n  const renderer = renderingEngine.createRenderer(context);\n\n  DOM.registerElementResolver(context, elementProvider);\n\n  context.registerResolver(IViewFactory, factoryProvider);\n  context.registerResolver(IRenderable, renderableProvider);\n  context.registerResolver(ITargetedInstruction, instructionProvider);\n  context.registerResolver(IRenderLocation, renderLocationProvider);\n\n  if (dependencies) {\n    context.register(...dependencies);\n  }\n\n  context.render = function(renderable: IRenderable, targets: ArrayLike<INode>, templateDefinition: TemplateDefinition, host?: INode, parts?: TemplatePartDefinitions): void {\n    renderer.render(renderable, targets, templateDefinition, host, parts);\n  };\n\n  context.beginComponentOperation = function(renderable: IRenderable, target: INode, instruction: ITargetedInstruction, factory?: IViewFactory, parts?: TemplatePartDefinitions, location?: IRenderLocation): IDisposable {\n    renderableProvider.prepare(renderable);\n    elementProvider.prepare(target);\n    instructionProvider.prepare(instruction);\n\n    if (factory) {\n      factoryProvider.prepare(factory, parts);\n    }\n\n    if (location) {\n      renderLocationProvider.prepare(location);\n    }\n\n    return context;\n  };\n\n  context.dispose = function(): void {\n    factoryProvider.dispose();\n    renderableProvider.dispose();\n    instructionProvider.dispose();\n    elementProvider.dispose();\n    renderLocationProvider.dispose();\n  };\n\n  return context;\n}\n\n/*@internal*/\nexport class InstanceProvider<T> implements IResolver {\n  private instance: T = null;\n\n  public prepare(instance: T): void {\n    this.instance = instance;\n  }\n\n  public resolve(handler: IContainer, requestor: IContainer): T {\n    if (this.instance === undefined) { // unmet precondition: call prepare\n      throw Reporter.error(50); // TODO: organize error codes\n    }\n    return this.instance;\n  }\n\n  public dispose(): void {\n    this.instance = null;\n  }\n}\n\n/*@internal*/\nexport class ViewFactoryProvider implements IResolver {\n  private factory: IViewFactory;\n  private replacements: TemplatePartDefinitions;\n\n  constructor(private renderingEngine: IRenderingEngine) {}\n\n  public prepare(factory: IViewFactory, parts: TemplatePartDefinitions): void {\n    this.factory = factory;\n    this.replacements = parts || PLATFORM.emptyObject;\n  }\n\n  public resolve(handler: IContainer, requestor: ExposedContext): IViewFactory {\n    const factory = this.factory;\n    if (factory === undefined) { // unmet precondition: call prepare\n      throw Reporter.error(50); // TODO: organize error codes\n    }\n    if (!factory.name || !factory.name.length) { // unmet invariant: factory must have a name\n      throw Reporter.error(51); // TODO: organize error codes\n    }\n    const found = this.replacements[factory.name];\n    if (found) {\n      return this.renderingEngine.getViewFactory(found, requestor);\n    }\n\n    return this.factory;\n  }\n\n  public dispose(): void {\n    this.factory = null;\n    this.replacements = null;\n  }\n}\n\nexport function addBindable(renderable: IBindables, bindable: IBindScope): void {\n  bindable.$prevBind = renderable.$bindableTail;\n  bindable.$nextBind = null;\n  if (renderable.$bindableTail === null) {\n    renderable.$bindableHead = bindable;\n  } else {\n    renderable.$bindableTail.$nextBind = bindable;\n  }\n  renderable.$bindableTail = bindable;\n}\n\nexport function addAttachable(renderable: IAttachables, attachable: IAttach): void {\n  attachable.$prevAttach = renderable.$attachableTail;\n  attachable.$nextAttach = null;\n  if (renderable.$attachableTail === null) {\n    renderable.$attachableHead = attachable;\n  } else {\n    renderable.$attachableTail.$nextAttach = attachable;\n  }\n  renderable.$attachableTail = attachable;\n}\n\nexport interface IRenderer {\n  render(renderable: IRenderable, targets: ArrayLike<INode>, templateDefinition: TemplateDefinition, host?: INode, parts?: TemplatePartDefinitions): void;\n  hydrateElementInstance(renderable: IRenderable, target: INode, instruction: Immutable<IHydrateElementInstruction>, component: ICustomElement): void;\n}\n\n// tslint:disable:function-name\n// tslint:disable:no-any\n\n/* @internal */\nexport class Renderer implements IRenderer {\n  constructor(\n    private context: IRenderContext,\n    private observerLocator: IObserverLocator,\n    private eventManager: IEventManager,\n    private parser: IExpressionParser,\n    private renderingEngine: IRenderingEngine\n  ) { }\n\n  public render(renderable: IRenderable, targets: ArrayLike<INode>, definition: TemplateDefinition, host?: INode, parts?: TemplatePartDefinitions): void {\n    const targetInstructions = definition.instructions;\n\n    if (targets.length !== targetInstructions.length) {\n      if (targets.length > targetInstructions.length) {\n        throw Reporter.error(30);\n      } else {\n        throw Reporter.error(31);\n      }\n    }\n    for (let i = 0, ii = targets.length; i < ii; ++i) {\n      const instructions = targetInstructions[i];\n      const target = targets[i];\n\n      for (let j = 0, jj = instructions.length; j < jj; ++j) {\n        const current = instructions[j];\n        (this as any)[current.type](renderable, target, current, parts);\n      }\n    }\n\n    if (host) {\n      const surrogateInstructions = definition.surrogates;\n\n      for (let i = 0, ii = surrogateInstructions.length; i < ii; ++i) {\n        const current = surrogateInstructions[i];\n        (this as any)[current.type](renderable, host, current, parts);\n      }\n    }\n  }\n\n  public hydrateElementInstance(renderable: IRenderable, target: INode, instruction: Immutable<IHydrateElementInstruction>, component: ICustomElement): void {\n    const childInstructions = instruction.instructions;\n\n    component.$hydrate(this.renderingEngine, target, instruction);\n\n    for (let i = 0, ii = childInstructions.length; i < ii; ++i) {\n      const current = childInstructions[i];\n      const currentType = current.type;\n\n      (this as any)[currentType](renderable, component, current);\n    }\n\n    addBindable(renderable, component);\n    addAttachable(renderable, component);\n  }\n\n  public [TargetedInstructionType.textBinding](renderable: IRenderable, target: any, instruction: Immutable<ITextBindingInstruction>): void {\n    const next = target.nextSibling;\n    DOM.treatAsNonWhitespace(next);\n    DOM.remove(target);\n    const $from = instruction.from as any;\n    const expr = ($from.$kind ? $from : this.parser.parse($from, BindingType.Interpolation)) as Interpolation;\n    if (expr.isMulti) {\n      addBindable(renderable, new MultiInterpolationBinding(this.observerLocator, expr, next, 'textContent', BindingMode.toView, this.context));\n    } else {\n      addBindable(renderable, new InterpolationBinding(expr.firstExpression, expr, next, 'textContent', BindingMode.toView, this.observerLocator, this.context, true));\n    }\n  }\n\n  public [TargetedInstructionType.interpolation](renderable: IRenderable, target: any, instruction: Immutable<IInterpolationInstruction>): void {\n    const $from = instruction.from as any;\n    const expr = ($from.$kind ? $from : this.parser.parse($from, BindingType.Interpolation)) as Interpolation;\n    if (expr.isMulti) {\n      addBindable(renderable, new MultiInterpolationBinding(this.observerLocator, expr, target, instruction.to, BindingMode.toView, this.context));\n    } else {\n      addBindable(renderable, new InterpolationBinding(expr.firstExpression, expr, target, instruction.to, BindingMode.toView, this.observerLocator, this.context, true));\n    }\n  }\n\n  public [TargetedInstructionType.propertyBinding](renderable: IRenderable, target: any, instruction: Immutable<IPropertyBindingInstruction>): void {\n    const $from = instruction.from as any;\n    addBindable(renderable, new Binding($from.$kind ? $from : this.parser.parse($from, BindingType.IsPropertyCommand | instruction.mode), target, instruction.to, instruction.mode, this.observerLocator, this.context));\n  }\n\n  public [TargetedInstructionType.iteratorBinding](renderable: IRenderable, target: any, instruction: Immutable<IIteratorBindingInstruction>): void {\n    const $from = instruction.from as any;\n    addBindable(renderable, new Binding($from.$kind ? $from : this.parser.parse($from, BindingType.ForCommand), target, instruction.to, BindingMode.toView, this.observerLocator, this.context));\n  }\n\n  public [TargetedInstructionType.listenerBinding](renderable: IRenderable, target: any, instruction: Immutable<IListenerBindingInstruction>): void {\n    const $from = instruction.from as any;\n    addBindable(renderable, new Listener(instruction.to, instruction.strategy, $from.$kind ? $from : this.parser.parse($from, BindingType.IsEventCommand | (instruction.strategy + BindingType.DelegationStrategyDelta)), target, instruction.preventDefault, this.eventManager, this.context));\n  }\n\n  public [TargetedInstructionType.callBinding](renderable: IRenderable, target: any, instruction: Immutable<ICallBindingInstruction>): void {\n    const $from = instruction.from as any;\n    addBindable(renderable, new Call($from.$kind ? $from : this.parser.parse($from, BindingType.CallCommand), target, instruction.to, this.observerLocator, this.context));\n  }\n\n  public [TargetedInstructionType.refBinding](renderable: IRenderable, target: any, instruction: Immutable<IRefBindingInstruction>): void {\n    const $from = instruction.from as any;\n    addBindable(renderable, new Ref($from.$kind ? $from : this.parser.parse($from, BindingType.IsRef), target, this.context));\n  }\n\n  public [TargetedInstructionType.stylePropertyBinding](renderable: IRenderable, target: any, instruction: Immutable<IStylePropertyBindingInstruction>): void {\n    const $from = instruction.from as any;\n    addBindable(renderable, new Binding($from.$kind ? $from : this.parser.parse($from, BindingType.IsPropertyCommand | BindingMode.toView), (<any>target).style, instruction.to, BindingMode.toView, this.observerLocator, this.context));\n  }\n\n  public [TargetedInstructionType.setProperty](renderable: IRenderable, target: any, instruction: Immutable<ISetPropertyInstruction>): void {\n    target[instruction.to] = instruction.value;\n  }\n\n  public [TargetedInstructionType.setAttribute](renderable: IRenderable, target: any, instruction: Immutable<ISetAttributeInstruction>): void {\n    DOM.setAttribute(target, instruction.to, instruction.value);\n  }\n\n  public [TargetedInstructionType.hydrateElement](renderable: IRenderable, target: any, instruction: Immutable<IHydrateElementInstruction>): void {\n    const context = this.context;\n    const operation = context.beginComponentOperation(renderable, target, instruction, null, null, target, true);\n    const component = context.get<ICustomElement>(customElementKey(instruction.res));\n\n    this.hydrateElementInstance(renderable, target, instruction, component);\n    operation.dispose();\n  }\n\n  public [TargetedInstructionType.hydrateAttribute](renderable: IRenderable, target: any, instruction: Immutable<IHydrateAttributeInstruction>): void {\n    const childInstructions = instruction.instructions;\n    const context = this.context;\n\n    const operation = context.beginComponentOperation(renderable, target, instruction);\n    const component = context.get<ICustomAttribute>(customAttributeKey(instruction.res));\n    component.$hydrate(this.renderingEngine);\n\n    for (let i = 0, ii = childInstructions.length; i < ii; ++i) {\n      const current = childInstructions[i];\n      (this as any)[current.type](renderable, component, current);\n    }\n\n    addBindable(renderable, component);\n    addAttachable(renderable, component);\n\n    operation.dispose();\n  }\n\n  public [TargetedInstructionType.hydrateTemplateController](renderable: IRenderable, target: any, instruction: Immutable<IHydrateTemplateController>, parts?: TemplatePartDefinitions): void {\n    const childInstructions = instruction.instructions;\n    const factory = this.renderingEngine.getViewFactory(instruction.def, this.context);\n    const context = this.context;\n    const operation = context.beginComponentOperation(renderable, target, instruction, factory, parts, DOM.convertToRenderLocation(target), false);\n\n    const component = context.get<ICustomAttribute>(customAttributeKey(instruction.res));\n    component.$hydrate(this.renderingEngine);\n\n    if (instruction.link) {\n      (component as any).link(renderable.$attachableTail);\n    }\n\n    for (let i = 0, ii = childInstructions.length; i < ii; ++i) {\n      const current = childInstructions[i];\n      (this as any)[current.type](renderable, component, current);\n    }\n\n    addBindable(renderable, component);\n    addAttachable(renderable, component);\n\n    operation.dispose();\n  }\n\n  public [TargetedInstructionType.renderStrategy](renderable: IRenderable, target: any, instruction: Immutable<IRenderStrategyInstruction>): void {\n    const strategyName = instruction.name;\n    if (this[strategyName] === undefined) {\n      const strategy = this.context.get<IRenderStrategy>(RenderStrategyResource.keyFrom(strategyName));\n      if (strategy === null || strategy === undefined) {\n        throw new Error(`Unknown renderStrategy \"${strategyName}\"`);\n      }\n      this[strategyName] = strategy.render.bind(strategy);\n    }\n    this[strategyName](renderable, target, instruction);\n  }\n\n  public [TargetedInstructionType.letElement](renderable: IRenderable, target: any, instruction: Immutable<ILetElementInstruction>): void {\n    target.remove();\n    const childInstructions = instruction.instructions;\n    const toViewModel = instruction.toViewModel;\n    for (let i = 0, ii = childInstructions.length; i < ii; ++i) {\n      const childInstruction = childInstructions[i];\n      const $from: any = childInstruction.from;\n      addBindable(renderable, new LetBinding(\n        $from.$kind ? $from : this.parser.parse($from, BindingType.IsPropertyCommand),\n        childInstruction.to,\n        this.observerLocator,\n        this.context,\n        toViewModel\n      ));\n    }\n  }\n}\n","import { Constructable, Decoratable, Decorated, IContainer, Registration, Reporter, Writable } from '@aurelia/kernel';\nimport { buildTemplateDefinition, customElementBehavior, customElementKey, customElementName, ITemplateDefinition } from '../definitions';\nimport { Hooks, State } from '../lifecycle';\nimport { $attachElement, $cacheElement, $detachElement, $mountElement, $unmountElement } from './lifecycle-attach';\nimport { $bindElement, $unbindElement } from './lifecycle-bind';\nimport { $hydrateElement, defaultShadowOptions, ICustomElement, ICustomElementHost, ICustomElementResource, ICustomElementType } from './lifecycle-render';\n\ntype CustomElementDecorator = <T extends Constructable>(target: Decoratable<ICustomElement, T>) => Decorated<ICustomElement, T> & ICustomElementType;\n/**\n * Decorator: Indicates that the decorated class is a custom element.\n */\nexport function customElement(nameOrSource: string | ITemplateDefinition): CustomElementDecorator {\n  return target => CustomElementResource.define(nameOrSource, target);\n}\n\ntype HasShadowOptions = Pick<ITemplateDefinition, 'shadowOptions'>;\n\n/**\n * Decorator: Indicates that the custom element should render its view in ShadowDOM.\n */\nexport function useShadowDOM<T extends Constructable>(options?: HasShadowOptions['shadowOptions']): (target: T & HasShadowOptions) => Decorated<HasShadowOptions, T>;\n/**\n * Decorator: Indicates that the custom element should render its view in ShadowDOM.\n */\nexport function useShadowDOM<T extends Constructable>(target: (T & HasShadowOptions)): Decorated<HasShadowOptions, T>;\nexport function useShadowDOM<T extends Constructable>(targetOrOptions?: (T & HasShadowOptions) | HasShadowOptions['shadowOptions']):  Decorated<HasShadowOptions, T> | ((target: T & HasShadowOptions) => Decorated<HasShadowOptions, T>) {\n  const options = typeof targetOrOptions === 'function' || !targetOrOptions\n    ? defaultShadowOptions\n    : targetOrOptions as HasShadowOptions['shadowOptions'];\n\n  function useShadowDOMDecorator(target: T & HasShadowOptions): Decorated<HasShadowOptions, T> {\n    target.shadowOptions = options;\n    return target;\n  }\n\n  return typeof targetOrOptions === 'function' ? useShadowDOMDecorator(targetOrOptions) : useShadowDOMDecorator;\n}\n\ntype HasContainerless = Pick<ITemplateDefinition, 'containerless'>;\n\nfunction containerlessDecorator<T extends Constructable>(target: T & HasContainerless): Decorated<HasContainerless, T> {\n  target.containerless = true;\n  return target;\n}\n\n/**\n * Decorator: Indicates that the custom element should be rendered without its element container.\n */\nexport function containerless(): typeof containerlessDecorator;\n/**\n * Decorator: Indicates that the custom element should be rendered without its element container.\n */\nexport function containerless<T extends Constructable>(target: T & HasContainerless): Decorated<HasContainerless, T>;\nexport function containerless<T extends Constructable>(target?: T & HasContainerless): Decorated<HasContainerless, T> | typeof containerlessDecorator {\n  return target === undefined ? containerlessDecorator : containerlessDecorator<T>(target);\n}\n\nexport const CustomElementResource: ICustomElementResource = {\n  name: customElementName,\n\n  keyFrom: customElementKey,\n\n  isType<T extends Constructable & Partial<ICustomElementType>>(Type: T): Type is T & ICustomElementType {\n    return Type.kind === this;\n  },\n\n  behaviorFor: <(node: ICustomElementHost) => ICustomElement | null>customElementBehavior,\n\n  define<T extends Constructable>(nameOrSource: string | ITemplateDefinition, ctor: T = null): T & ICustomElementType {\n    if (!nameOrSource) {\n      throw Reporter.error(70);\n    }\n    const Type = (ctor === null ? class HTMLOnlyElement { /* HTML Only */ } : ctor) as T & Writable<ICustomElementType>;\n    const description = buildTemplateDefinition(<ICustomElementType><unknown>Type, nameOrSource);\n    const proto: Writable<ICustomElement> = Type.prototype;\n\n    Type.kind = CustomElementResource;\n    Type.description = description;\n    Type.register = registerElement;\n\n    proto.$hydrate = $hydrateElement;\n    proto.$bind = $bindElement;\n    proto.$attach = $attachElement;\n    proto.$detach = $detachElement;\n    proto.$unbind = $unbindElement;\n    proto.$cache = $cacheElement;\n\n    proto.$prevBind = null;\n    proto.$nextBind = null;\n    proto.$prevAttach = null;\n    proto.$nextAttach = null;\n\n    proto.$nextUnbindAfterDetach = null;\n\n    proto.$scope = null;\n    proto.$hooks = 0;\n    proto.$state = State.needsMount;\n\n    proto.$bindableHead = null;\n    proto.$bindableTail = null;\n    proto.$attachableHead = null;\n    proto.$attachableTail = null;\n\n    proto.$mount = $mountElement;\n    proto.$unmount = $unmountElement;\n\n    proto.$nextMount = null;\n    proto.$nextUnmount = null;\n\n    proto.$projector = null;\n\n    if ('flush' in proto) {\n      proto.$nextFlush = null;\n    }\n\n    if ('binding' in proto) proto.$hooks |= Hooks.hasBinding;\n    if ('bound' in proto) {\n      proto.$hooks |= Hooks.hasBound;\n      proto.$nextBound = null;\n    }\n\n    if ('unbinding' in proto) proto.$hooks |= Hooks.hasUnbinding;\n    if ('unbound' in proto) {\n      proto.$hooks |= Hooks.hasUnbound;\n      proto.$nextUnbound = null;\n    }\n\n    if ('render' in proto) proto.$hooks |= Hooks.hasRender;\n    if ('created' in proto) proto.$hooks |= Hooks.hasCreated;\n    if ('attaching' in proto) proto.$hooks |= Hooks.hasAttaching;\n    if ('attached' in proto) {\n      proto.$hooks |= Hooks.hasAttached;\n      proto.$nextAttached = null;\n    }\n    if ('detaching' in proto) proto.$hooks |= Hooks.hasDetaching;\n    if ('caching' in proto) proto.$hooks |= Hooks.hasCaching;\n    if ('detached' in proto) {\n      proto.$hooks |= Hooks.hasDetached;\n      proto.$nextDetached = null;\n    }\n\n    return <ICustomElementType & T>Type;\n  }\n};\n\n/*@internal*/\nexport function registerElement(this: ICustomElementType, container: IContainer): void {\n  const resourceKey = CustomElementResource.keyFrom(this.description.name);\n  container.register(Registration.transient(resourceKey, this));\n}\n\n// tslint:enable:align\n\n// TODO\n// ## DefaultSlotProjector\n// An implementation of IElementProjector that can handle a subset of default\n// slot projection scenarios without needing real Shadow DOM.\n// ### Conditions\n// We can do a one-time, static composition of the content and view,\n// to emulate shadow DOM, if the following constraints are met:\n// * There must be exactly one slot and it must be a default slot.\n// * The default slot must not have any fallback content.\n// * The default slot must not have a custom element as its immediate parent or\n//   a slot attribute (re-projection).\n// ### Projection\n// The projector copies all content nodes to the slot's location.\n// The copy process should inject a comment node before and after the slotted\n// content, so that the bounds of the content can be clearly determined,\n// even if the slotted content has template controllers or string interpolation.\n// ### Encapsulation Source\n// Uses the same strategy as HostProjector.\n// ### Children\n// The projector adds a mutation observer to the parent node of the\n// slot comment. When direct children of that node change, the projector\n// will gather up all nodes between the start and end slot comments.\n","import { Constructable, Immutable, inject } from '@aurelia/kernel';\nimport {\n  IHydrateElementInstruction,\n  ITargetedInstruction,\n  ITemplateDefinition,\n  TargetedInstruction,\n  TemplateDefinition\n} from '../../definitions';\nimport { CompositionCoordinator, IRenderable, IView, IViewFactory } from '../../lifecycle';\nimport { LifecycleFlags } from '../../observation';\nimport { bindable } from '../bindable';\nimport { createElement, RenderPlan } from '../create-element';\nimport { customElement } from '../custom-element';\nimport { ICustomElement, IRenderingEngine } from '../lifecycle-render';\n\nconst composeSource: ITemplateDefinition = {\n  name: 'au-compose',\n  containerless: true\n};\n\nconst composeProps = ['subject', 'composing'];\n\ntype Subject = IViewFactory | IView | RenderPlan | Constructable | TemplateDefinition;\n\nexport interface Compose extends ICustomElement {}\n@customElement(composeSource)\n@inject(IRenderable, ITargetedInstruction, IRenderingEngine, CompositionCoordinator)\nexport class Compose {\n  @bindable public subject: Subject | Promise<Subject> = null;\n  @bindable public composing: boolean = false;\n\n  private properties: Record<string, TargetedInstruction> = null;\n  private lastSubject: Subject | Promise<Subject> = null;\n\n  constructor(\n    private renderable: IRenderable,\n    instruction: Immutable<IHydrateElementInstruction>,\n    private renderingEngine: IRenderingEngine,\n    private coordinator: CompositionCoordinator\n  ) {\n    this.coordinator.onSwapComplete = () => {\n      this.composing = false;\n    };\n\n    this.properties = instruction.instructions\n      .filter((x: any) => !composeProps.includes(x.to))\n      .reduce((acc, item: any) => {\n        if (item.to) {\n          acc[item.to] = item;\n        }\n\n        return acc;\n      }, {});\n  }\n\n  public binding(flags: LifecycleFlags): void {\n    this.startComposition(this.subject, undefined, flags);\n    this.coordinator.binding(flags, this.$scope);\n  }\n\n  public attaching(flags: LifecycleFlags): void {\n    this.coordinator.attaching(flags);\n  }\n\n  public detaching(flags: LifecycleFlags): void {\n    this.coordinator.detaching(flags);\n  }\n\n  public unbinding(flags: LifecycleFlags): void {\n    this.lastSubject = null;\n    this.coordinator.unbinding(flags);\n  }\n\n  public caching(flags: LifecycleFlags): void {\n    this.coordinator.caching(flags);\n  }\n\n  public subjectChanged(newValue: any, previousValue: any, flags: LifecycleFlags): void {\n    this.startComposition(newValue, previousValue, flags);\n  }\n\n  private startComposition(subject: any, previousSubject: any, flags: LifecycleFlags): void {\n    if (this.lastSubject === subject) {\n      return;\n    }\n\n    this.lastSubject = subject;\n\n    if (subject instanceof Promise) {\n      subject = subject.then(x => this.resolveView(x, flags));\n    } else {\n      subject = this.resolveView(subject, flags);\n    }\n\n    this.composing = true;\n    this.coordinator.compose(subject, flags);\n  }\n\n  private resolveView(subject: Subject, flags: LifecycleFlags): IView {\n    const view = this.provideViewFor(subject);\n\n    if (view) {\n      view.hold(this.$projector.host, flags);\n      view.lockScope(this.renderable.$scope);\n      return view;\n    }\n\n    return null;\n  }\n\n  private provideViewFor(subject: Subject): IView | null {\n    if (!subject) {\n      return null;\n    }\n\n    if ('lockScope' in subject) { // IView\n      return subject;\n    }\n\n    if ('createView' in subject) { // RenderPlan\n      return subject.createView(\n        this.renderingEngine,\n        this.renderable.$context\n      );\n    }\n\n    if ('create' in subject) { // IViewFactory\n      return subject.create();\n    }\n\n    if ('template' in subject) { // Raw Template Definition\n      return this.renderingEngine.getViewFactory(\n        subject,\n        this.renderable.$context\n      ).create();\n    }\n\n    // Constructable (Custom Element Constructor)\n    return createElement(\n      subject,\n      this.properties,\n      this.$projector.children\n    ).createView(\n      this.renderingEngine,\n      this.renderable.$context\n    );\n  }\n}\n","import { Constructable, Decoratable, Decorated, IContainer, Omit, PLATFORM, Registration, Writable } from '@aurelia/kernel';\nimport { BindingMode } from '../binding/binding-mode';\nimport { customAttributeKey, customAttributeName, IAttributeDefinition } from '../definitions';\nimport { Hooks } from '../lifecycle';\nimport { IResourceKind, ResourceDescription } from '../resource';\nimport { $attachAttribute, $cacheAttribute, $detachAttribute } from './lifecycle-attach';\nimport { $bindAttribute, $unbindAttribute } from './lifecycle-bind';\nimport { $hydrateAttribute, ICustomAttribute, ICustomAttributeType } from './lifecycle-render';\n\ntype CustomAttributeDecorator = <T extends Constructable>(target: Decoratable<ICustomAttribute, T>) => Decorated<ICustomAttribute, T> & ICustomAttributeType;\n/**\n * Decorator: Indicates that the decorated class is a custom attribute.\n */\nexport function customAttribute(nameOrDef: string | IAttributeDefinition): CustomAttributeDecorator {\n  return target => CustomAttributeResource.define(nameOrDef, target);\n}\n\n/**\n * Decorator: Applied to custom attributes. Indicates that whatever element the\n * attribute is placed on should be converted into a template and that this\n * attribute controls the instantiation of the template.\n */\nexport function templateController(nameOrDef: string | Omit<IAttributeDefinition, 'isTemplateController'>): CustomAttributeDecorator {\n  return target => CustomAttributeResource.define(\n    typeof nameOrDef === 'string'\n    ? { isTemplateController: true , name: nameOrDef }\n    : { isTemplateController: true, ...nameOrDef },\n    target);\n}\n\nexport const CustomAttributeResource: IResourceKind<IAttributeDefinition, ICustomAttributeType> = {\n  name: customAttributeName,\n\n  keyFrom: customAttributeKey,\n\n  isType<T extends Constructable & Partial<ICustomAttributeType>>(Type: T): Type is T & ICustomAttributeType {\n    return Type.kind === this;\n  },\n\n  define<T extends Constructable>(nameOrSource: string | IAttributeDefinition, ctor: T): T & ICustomAttributeType {\n    const Type = ctor as T & Writable<ICustomAttributeType>;\n    const description = createCustomAttributeDescription(typeof nameOrSource === 'string' ? { name: nameOrSource } : nameOrSource, <T & ICustomAttributeType>Type);\n    const proto: Writable<ICustomAttribute> = Type.prototype;\n\n    Type.kind = CustomAttributeResource;\n    Type.description = description;\n    Type.register = registerAttribute;\n\n    proto.$hydrate = $hydrateAttribute;\n    proto.$bind = $bindAttribute;\n    proto.$attach = $attachAttribute;\n    proto.$detach = $detachAttribute;\n    proto.$unbind = $unbindAttribute;\n    proto.$cache = $cacheAttribute;\n\n    proto.$prevBind = null;\n    proto.$nextBind = null;\n    proto.$prevAttach = null;\n    proto.$nextAttach = null;\n\n    proto.$nextUnbindAfterDetach = null;\n\n    proto.$scope = null;\n    proto.$hooks = 0;\n    proto.$state = 0;\n\n    if ('flush' in proto) {\n      proto.$nextFlush = null;\n    }\n\n    if ('binding' in proto) proto.$hooks |= Hooks.hasBinding;\n    if ('bound' in proto) {\n      proto.$hooks |= Hooks.hasBound;\n      proto.$nextBound = null;\n    }\n\n    if ('unbinding' in proto) proto.$hooks |= Hooks.hasUnbinding;\n    if ('unbound' in proto) {\n      proto.$hooks |= Hooks.hasUnbound;\n      proto.$nextUnbound = null;\n    }\n\n    if ('created' in proto) proto.$hooks |= Hooks.hasCreated;\n    if ('attaching' in proto) proto.$hooks |= Hooks.hasAttaching;\n    if ('attached' in proto) {\n      proto.$hooks |= Hooks.hasAttached;\n      proto.$nextAttached = null;\n    }\n    if ('detaching' in proto) proto.$hooks |= Hooks.hasDetaching;\n    if ('caching' in proto) proto.$hooks |= Hooks.hasCaching;\n    if ('detached' in proto) {\n      proto.$hooks |= Hooks.hasDetached;\n      proto.$nextDetached = null;\n    }\n\n    return <ICustomAttributeType & T>Type;\n  }\n};\n\n/*@internal*/\nexport function registerAttribute(this: ICustomAttributeType, container: IContainer): void {\n  const description = this.description;\n  const resourceKey = CustomAttributeResource.keyFrom(description.name);\n  const aliases = description.aliases;\n\n  container.register(Registration.transient(resourceKey, this));\n\n  for (let i = 0, ii = aliases.length; i < ii; ++i) {\n    const aliasKey = CustomAttributeResource.keyFrom(aliases[i]);\n    container.register(Registration.alias(resourceKey, aliasKey));\n  }\n}\n\n/*@internal*/\nexport function createCustomAttributeDescription(def: IAttributeDefinition, Type: ICustomAttributeType): ResourceDescription<IAttributeDefinition> {\n  return {\n    name: def.name,\n    aliases: def.aliases || PLATFORM.emptyArray,\n    defaultBindingMode: def.defaultBindingMode || BindingMode.toView,\n    isTemplateController: def.isTemplateController || false,\n    bindables: {...Type.bindables, ...def.bindables}\n  };\n}\n","import { inject } from '@aurelia/kernel';\nimport { IRenderLocation } from '../../dom';\nimport { CompositionCoordinator, IView, IViewFactory } from '../../lifecycle';\nimport { LifecycleFlags } from '../../observation';\nimport { bindable } from '../bindable';\nimport { templateController } from '../custom-attribute';\nimport { ICustomAttribute } from '../lifecycle-render';\n\nexport interface If extends ICustomAttribute {}\n@templateController('if')\n@inject(IViewFactory, IRenderLocation, CompositionCoordinator)\nexport class If {\n  @bindable public value: boolean = false;\n\n  public elseFactory: IViewFactory = null;\n\n  public ifView: IView = null;\n  public elseView: IView = null;\n\n  constructor(\n    public ifFactory: IViewFactory,\n    public location: IRenderLocation,\n    public coordinator: CompositionCoordinator) { }\n\n  public binding(flags: LifecycleFlags): void {\n    const view = this.updateView(flags);\n    this.coordinator.compose(view, flags);\n    this.coordinator.binding(flags, this.$scope);\n  }\n\n  public attaching(flags: LifecycleFlags): void {\n    this.coordinator.attaching(flags);\n  }\n\n  public detaching(flags: LifecycleFlags): void {\n    this.coordinator.detaching(flags);\n  }\n\n  public unbinding(flags: LifecycleFlags): void {\n    this.coordinator.unbinding(flags);\n  }\n\n  public caching(flags: LifecycleFlags): void {\n    if (this.ifView !== null && this.ifView.release(flags)) {\n      this.ifView = null;\n    }\n\n    if (this.elseView !== null && this.elseView.release(flags)) {\n      this.elseView = null;\n    }\n\n    this.coordinator.caching(flags);\n  }\n\n  public valueChanged(newValue: boolean, oldValue: boolean, flags: LifecycleFlags): void {\n    if (flags & LifecycleFlags.fromFlush) {\n      const view = this.updateView(flags);\n      this.coordinator.compose(view, flags);\n    } else {\n      this.$lifecycle.enqueueFlush(this);\n    }\n  }\n\n  public flush(flags: LifecycleFlags): void {\n    const view = this.updateView(flags);\n    this.coordinator.compose(view, flags);\n  }\n\n  /*@internal*/\n  public updateView(flags: LifecycleFlags): IView {\n    let view: IView;\n\n    if (this.value) {\n      view = this.ifView = this.ensureView(this.ifView, this.ifFactory, flags);\n    } else if (this.elseFactory !== null) {\n      view = this.elseView  = this.ensureView(this.elseView, this.elseFactory, flags);\n    } else {\n      view = null;\n    }\n\n    return view;\n  }\n\n  /*@internal*/\n  public ensureView(view: IView, factory: IViewFactory, flags: LifecycleFlags): IView {\n    if (view === null) {\n      view = factory.create();\n    }\n\n    view.hold(this.location, flags);\n\n    return view;\n  }\n}\n\nexport interface Else extends ICustomAttribute {}\n\n@templateController('else')\n@inject(IViewFactory)\nexport class Else {\n  constructor(private factory: IViewFactory) { }\n\n  public link(ifBehavior: If): void {\n    ifBehavior.elseFactory = this.factory;\n  }\n}\n","import { inject } from '@aurelia/kernel';\nimport { ForOfStatement } from '../../binding/ast';\nimport { Binding } from '../../binding/binding';\nimport { BindingContext, Scope } from '../../binding/binding-context';\nimport { getCollectionObserver } from '../../binding/observer-locator';\nimport { SetterObserver } from '../../binding/property-observation';\nimport { INode, IRenderLocation } from '../../dom';\nimport { IRenderable, IView, IViewFactory, State } from '../../lifecycle';\nimport { CollectionObserver, IBatchedCollectionSubscriber, IObservedArray, IScope, LifecycleFlags, ObservedCollection } from '../../observation';\nimport { bindable } from '../bindable';\nimport { templateController } from '../custom-attribute';\nimport { ICustomAttribute } from '../lifecycle-render';\n\nexport interface Repeat<T extends ObservedCollection> extends ICustomAttribute, IBatchedCollectionSubscriber {}\n\n@inject(IRenderLocation, IRenderable, IViewFactory)\n@templateController('repeat')\nexport class Repeat<T extends ObservedCollection = IObservedArray> {\n  @bindable public items: T;\n\n  public $scope: IScope;\n  public $observers: { items: SetterObserver };\n\n  public encapsulationSource: INode = null;\n  public views: IView[] = [];\n  public observer: CollectionObserver = null;\n  public hasPendingInstanceMutation: boolean = false;\n\n  public forOf: ForOfStatement;\n  public local: string;\n\n  constructor(\n    public location: IRenderLocation,\n    public renderable: IRenderable,\n    public factory: IViewFactory) { }\n\n  public binding(flags: LifecycleFlags): void {\n    this.checkCollectionObserver();\n  }\n\n  public bound(flags: LifecycleFlags): void {\n    let current = this.renderable.$bindableHead;\n    while (current !== null) {\n      if ((<Binding>current).target === this && (<Binding>current).targetProperty === 'items') {\n        this.forOf = (<Binding>current).sourceExpression as ForOfStatement;\n        break;\n      }\n      current = current.$nextBind;\n    }\n    this.local = this.forOf.declaration.evaluate(flags, this.$scope, null);\n\n    this.processViews(null, flags);\n  }\n\n  public attaching(flags: LifecycleFlags): void {\n    const { views, location } = this;\n    for (let i = 0, ii = views.length; i < ii; ++i) {\n      const view = views[i];\n      view.hold(location, flags);\n      view.$attach(flags);\n    }\n  }\n\n  public detaching(flags: LifecycleFlags): void {\n    const { views } = this;\n    for (let i = 0, ii = views.length; i < ii; ++i) {\n      const view = views[i];\n      view.$detach(flags);\n      view.release(flags);\n    }\n  }\n\n  public unbound(flags: LifecycleFlags): void {\n    this.checkCollectionObserver();\n\n    const { views } = this;\n    for (let i = 0, ii = views.length; i < ii; ++i) {\n      const view = views[i];\n      view.$unbind(flags);\n    }\n  }\n\n  // called by SetterObserver (sync)\n  public itemsChanged(newValue: T, oldValue: T, flags: LifecycleFlags): void {\n    this.checkCollectionObserver();\n    this.processViews(null, flags | LifecycleFlags.updateTargetInstance);\n  }\n\n  // called by a CollectionObserver (async)\n  public handleBatchedChange(indexMap: number[] | null): void {\n    this.processViews(indexMap, LifecycleFlags.fromFlush | LifecycleFlags.updateTargetInstance);\n  }\n\n  // if the indexMap === null, it is an instance mutation, otherwise it's an items mutation\n  private processViews(indexMap: number[] | null, flags: LifecycleFlags): void {\n    const { views, $lifecycle } = this;\n    if (this.$state & State.isBound) {\n      const { local, $scope, factory, forOf, items } = this;\n      const oldLength = views.length;\n      const newLength = forOf.count(items);\n      if (oldLength < newLength) {\n        views.length = newLength;\n        for (let i = oldLength; i < newLength; ++i) {\n          views[i] = factory.create();\n        }\n      } else if (newLength < oldLength) {\n        $lifecycle.beginDetach();\n        for (let i = newLength, view = views[i]; i < oldLength; view = views[++i]) {\n          view.release(flags);\n          view.$detach(flags);\n        }\n        $lifecycle.endDetach(flags);\n        $lifecycle.beginUnbind();\n        for (let i = newLength, view = views[i]; i < oldLength; view = views[++i]) {\n          view.$unbind(flags);\n        }\n        $lifecycle.endUnbind(flags);\n        views.length = newLength;\n        if (newLength === 0) {\n          return;\n        }\n      } else if (newLength === 0) {\n        return;\n      }\n\n      $lifecycle.beginBind();\n      if (indexMap === null) {\n        forOf.iterate(items, (arr, i, item) => {\n          const view = views[i];\n          if (!!view.$scope && view.$scope.bindingContext[local] === item) {\n            view.$bind(flags, Scope.fromParent($scope, view.$scope.bindingContext));\n          } else {\n            view.$bind(flags, Scope.fromParent($scope, BindingContext.create(local, item)));\n          }\n        });\n      } else {\n        forOf.iterate(items, (arr, i, item) => {\n          const view = views[i];\n          if (indexMap[i] === i && !!view.$scope) {\n            view.$bind(flags, Scope.fromParent($scope, view.$scope.bindingContext));\n          } else {\n            view.$bind(flags, Scope.fromParent($scope, BindingContext.create(local, item)));\n          }\n        });\n      }\n      $lifecycle.endBind(flags);\n    }\n\n    if (this.$state & State.isAttached) {\n      const { location } = this;\n      $lifecycle.beginAttach();\n      if (indexMap === null) {\n        for (let i = 0, ii = views.length; i < ii; ++i) {\n          const view = views[i];\n          view.hold(location, flags);\n          view.$attach(flags);\n        }\n      } else {\n        for (let i = 0, ii = views.length; i < ii; ++i) {\n          if (indexMap[i] !== i) {\n            const view = views[i];\n            view.hold(location, flags);\n            view.$attach(flags);\n          }\n        }\n      }\n      $lifecycle.endAttach(flags);\n    }\n  }\n\n  private checkCollectionObserver(): void {\n    const oldObserver = this.observer;\n    if (this.$state & (State.isBound | State.isBinding)) {\n      const newObserver = this.observer = getCollectionObserver(this.$lifecycle, this.items);\n      if (oldObserver !== newObserver) {\n        if (oldObserver) {\n          oldObserver.unsubscribeBatched(this);\n        }\n      }\n      if (newObserver) {\n        newObserver.subscribeBatched(this);\n      }\n    } else if (oldObserver) {\n      oldObserver.unsubscribeBatched(this);\n    }\n  }\n}\n","import { inject } from '@aurelia/kernel';\nimport { IRenderLocation } from '../../dom';\nimport { IView, IViewFactory } from '../../lifecycle';\nimport { LifecycleFlags } from '../../observation';\nimport { templateController } from '../custom-attribute';\nimport { ICustomAttribute } from '../lifecycle-render';\n\nexport interface Replaceable extends ICustomAttribute {}\n@templateController('replaceable')\n@inject(IViewFactory, IRenderLocation)\nexport class Replaceable {\n  private currentView: IView;\n\n  constructor(private factory: IViewFactory, location: IRenderLocation) {\n    this.currentView = this.factory.create();\n    this.currentView.hold(location, LifecycleFlags.fromCreate);\n  }\n\n  public binding(flags: LifecycleFlags): void {\n    this.currentView.$bind(flags, this.$scope);\n  }\n\n  public attaching(flags: LifecycleFlags): void {\n    this.currentView.$attach(flags);\n  }\n\n  public detaching(flags: LifecycleFlags): void {\n    this.currentView.$detach(flags);\n  }\n\n  public unbinding(flags: LifecycleFlags): void {\n    this.currentView.$unbind(flags);\n  }\n}\n","import { inject } from '@aurelia/kernel';\nimport { Scope } from '../../binding/binding-context';\nimport { IRenderLocation } from '../../dom';\nimport { IView, IViewFactory, State } from '../../lifecycle';\nimport { LifecycleFlags } from '../../observation';\nimport { bindable } from '../bindable';\nimport { templateController } from '../custom-attribute';\nimport { ICustomAttribute } from '../lifecycle-render';\n\nexport interface With extends ICustomAttribute {}\n@templateController('with')\n@inject(IViewFactory, IRenderLocation)\nexport class With {\n  @bindable public value: any = null;\n\n  private currentView: IView = null;\n\n  constructor(private factory: IViewFactory, location: IRenderLocation) {\n    this.currentView = this.factory.create();\n    this.currentView.hold(location, LifecycleFlags.fromCreate);\n  }\n\n  public valueChanged(this: With): void {\n    if (this.$state & State.isBound) {\n      this.bindChild(LifecycleFlags.fromBindableHandler);\n    }\n  }\n\n  public binding(flags: LifecycleFlags): void {\n    this.bindChild(flags);\n  }\n\n  public attaching(flags: LifecycleFlags): void {\n    this.currentView.$attach(flags);\n  }\n\n  public detaching(flags: LifecycleFlags): void {\n    this.currentView.$detach(flags);\n  }\n\n  public unbinding(flags: LifecycleFlags): void {\n    this.currentView.$unbind(flags);\n  }\n\n  private bindChild(flags: LifecycleFlags): void {\n    const scope = Scope.fromParent(this.$scope, this.value);\n    this.currentView.$bind(flags, scope);\n  }\n}\n","import { DI, IContainer, IRegistry, PLATFORM, Registration } from '@aurelia/kernel';\nimport { LifecycleFlags } from './observation';\nimport { ICustomElement, IRenderingEngine } from './templating/lifecycle-render';\n\nexport interface ISinglePageApp {\n  host: any;\n  component: any;\n}\n\nexport class Aurelia {\n  private components: ICustomElement[] = [];\n  private startTasks: (() => void)[] = [];\n  private stopTasks: (() => void)[] = [];\n  private isStarted: boolean = false;\n  private _root: ICustomElement = null;\n\n  constructor(private container: IContainer = DI.createContainer()) {\n    Registration\n      .instance(Aurelia, this)\n      .register(container, Aurelia);\n  }\n\n  public register(...params: (IRegistry | Record<string, Partial<IRegistry>>)[]): this {\n    this.container.register(...params);\n    return this;\n  }\n\n  public app(config: ISinglePageApp): this {\n    const component: ICustomElement = config.component;\n    const host = config.host;\n\n    const startTask = () => {\n      host.$au = this;\n      if (!this.components.includes(component)) {\n        this._root = component;\n        this.components.push(component);\n        const re = this.container.get(IRenderingEngine);\n        component.$hydrate(re, host);\n      }\n\n      component.$bind(LifecycleFlags.fromStartTask | LifecycleFlags.fromBind);\n      component.$attach(LifecycleFlags.fromStartTask, host);\n    };\n\n    this.startTasks.push(startTask);\n\n    this.stopTasks.push(() => {\n      component.$detach(LifecycleFlags.fromStopTask);\n      component.$unbind(LifecycleFlags.fromStopTask | LifecycleFlags.fromUnbind);\n      host.$au = null;\n    });\n\n    if (this.isStarted) {\n      startTask();\n    }\n\n    return this;\n  }\n\n  public root(): ICustomElement | null {\n    return this._root;\n  }\n\n  public start(): this {\n    for (const runStartTask of this.startTasks) {\n      runStartTask();\n    }\n    this.isStarted = true;\n    return this;\n  }\n\n  public stop(): this {\n    this.isStarted = false;\n    for (const runStopTask of this.stopTasks) {\n      runStopTask();\n    }\n    return this;\n  }\n}\n\n(<any>PLATFORM.global).Aurelia = Aurelia;\n"],"names":["LifecycleFlags","MutationKind","DI","PLATFORM","CompositionCoordinator","Registration","inject","Reporter","XLinkAttributeAccessor","DataAttributeAccessor","StyleAttributeAccessor","ClassAttributeAccessor","ElementPropertyAccessor","AttrBindingBehavior","BindingMode","OneTimeBindingBehavior","ToViewBindingBehavior","FromViewBindingBehavior","TwoWayBindingBehavior","dispose","SetterObserver","Observer","register","oneTime","toView","fromView","Binding","DebounceBindingBehavior","SanitizeValueConverter","DelegationStrategy","SelfBindingBehavior","SignalBindingBehavior","ThrottleBindingBehavior","flush","CollectionLengthObserver","ArrayObserver","GetterObserver","CustomSetterObserver","DirtyCheckProperty","ValueAttributeObserver","CheckedObserver","SelectValueObserver","proto","MapObserver","nativeClear","nativeDelete","observeClear","observeDelete","SetObserver","toStringTag","ObserverLocator","UpdateTriggerBindingBehavior","InterpolationBinding","LetBinding","ViewCompileFlags","RenderingEngine","IContainer","all","childObserverOptions","ChildrenObserver","Compose","tslib_1.__decorate","If","Else","Repeat","Replaceable","With"],"mappings":";;;;;;IAAA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;;IAEA;IACA;IACA;AACA,AAmCA;AACA,IAAO,SAAS,UAAU,CAAC,UAAU,EAAE,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE;IAC1D,IAAI,IAAI,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,MAAM,GAAG,IAAI,KAAK,IAAI,GAAG,IAAI,GAAG,MAAM,CAAC,wBAAwB,CAAC,MAAM,EAAE,GAAG,CAAC,GAAG,IAAI,EAAE,CAAC,CAAC;IACjI,IAAI,IAAI,OAAO,OAAO,KAAK,QAAQ,IAAI,OAAO,OAAO,CAAC,QAAQ,KAAK,UAAU,EAAE,CAAC,GAAG,OAAO,CAAC,QAAQ,CAAC,UAAU,EAAE,MAAM,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;IACnI,SAAS,KAAK,IAAI,CAAC,GAAG,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;IACtJ,IAAI,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;IAClE,CAAC;;ICpDD,WAAY,cAAc;QACxB,mDAAqD,CAAA;QACrD,wEAAqD,CAAA;QACrD,2DAAqD,CAAA;QACrD,mFAAqD,CAAA;QACrD,+EAAqD,CAAA;QACrD,wDAAqD,CAAA;QACrD,mFAAqD,CAAA;QACrD,mFAAqD,CAAA;QACrD,wFAAqD,CAAA;QACrD,wDAAqD,CAAA;QACrD,8DAAqD,CAAA;QACrD,wEAAqD,CAAA;QACrD,sEAAqD,CAAA;QACrD,uEAAqD,CAAA;QACrD,qEAAqD,CAAA;QACrD,6DAAqD,CAAA;QACrD,kEAAqD,CAAA;QACrD,kEAAqD,CAAA;QACrD,kEAAqD,CAAA;QACrD,gEAAqD,CAAA;QACrD,mEAAqD,CAAA;QACrD,uEAAqD,CAAA;QACrD,mFAAqD,CAAA;QACrD,sFAAqD,CAAA;QACrD,kFAAqD,CAAA;QACrD,uFAAqD,CAAA;;;QAGrD,6EAAqD,CAAA;IACvD,CAAC,EA9BWA,sBAAc,KAAdA,sBAAc,QA8BzB;AAmED,IAGA,WAAY,YAAY;QACtB,uDAAiB,CAAA;QACjB,2DAAiB,CAAA;IACnB,CAAC,EAHWC,oBAAY,KAAZA,oBAAY,QAGvB;;UCnBY,WAAW,GAAGC,SAAE,CAAC,eAAe,EAAe,CAAC,SAAS,EAAE,CAAC;AA+BzE,UAAa,YAAY,GAAGA,SAAE,CAAC,eAAe,EAAgB,CAAC,SAAS,EAAE,CAAC;IAoS3E,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;AAwNlD,UAAa,UAAU,GAAGA,SAAE,CAAC,eAAe,EAAc,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC;AACpG,UAAa,eAAe,GAAG,UAA8C,CAAC;AAC9E,UAAa,cAAc,GAAG,UAA6C,CAAC;AAC5E,UAAa,gBAAgB,GAAG,UAA+C,CAAC;IAEhF;AACA,UAAa,SAAS;QAAtB;0BACsB,cAAS,GAAW,CAAC,CAAC;0BACtB,gBAAW,GAAW,CAAC,CAAC;0BACxB,gBAAW,GAAW,CAAC,CAAC;0BACxB,gBAAW,GAAW,CAAC,CAAC;0BAExB,cAAS,GAAmB,IAAI,CAAC;0BACjC,cAAS,GAAmB,IAAI,CAAC;0BAEjC,gBAAW,GAAsD,IAAI,CAAC;0BACtE,gBAAW,GAAsD,IAAI,CAAC;0BAEtE,cAAS,GAAsD,IAAI,CAAC;0BACpE,cAAS,GAAsD,IAAI,CAAC;0BAEpE,cAAS,GAAoB,IAAI,CAAC;0BAClC,cAAS,GAAoB,IAAI,CAAC;0BAElC,cAAS,GAAoB,IAAI,CAAC;0BAClC,cAAS,GAAoB,IAAI,CAAC;0BAElC,iBAAY,GAAuB,IAAI,CAAC;0BACxC,iBAAY,GAAuB,IAAI,CAAC;0BAExC,gBAAW,GAAsB,IAAI,CAAC;0BACtC,gBAAW,GAAsB,IAAI,CAAC;0BAEtC,iBAAY,GAAuB,IAAI,CAAC;0BACxC,iBAAY,GAAuB,IAAI,CAAC;0BAExC,0BAAqB,GAAgC,IAAI,CAAC;0BAC1D,0BAAqB,GAAgC,IAAI,CAAC;0BAE1D,gBAAW,GAAsB,IAAI,CAAC;0BACtC,gBAAW,GAAsB,IAAI,CAAC;0BAEtC,YAAO,GAAkB,IAAI,CAAC;0BAC9B,YAAO,GAAkB,OAAO,CAAC,OAAO,EAAE,CAAC;0BAE3C,eAAU,GAAW,CAAC,CAAC;0BACvB,iBAAY,GAAW,CAAC,CAAC;0BACzB,eAAU,GAAW,CAAC,CAAC;0BACvB,eAAU,GAAW,CAAC,CAAC;0BACvB,eAAU,GAAW,CAAC,CAAC;0BACvB,kBAAa,GAAW,CAAC,CAAC;0BAC1B,iBAAY,GAAW,CAAC,CAAC;0BACzB,kBAAa,GAAW,CAAC,CAAC;0BAC1B,2BAAsB,GAAW,CAAC,CAAC;0BACnC,iBAAY,GAAW,CAAC,CAAC;;;;0BAKzB,eAAU,GAAmB,MAAM,CAAC;0BACpC,UAAK,GAA4BC,eAAQ,CAAC,IAAI,CAAC;0BAC/C,iBAAY,GAAwB,MAAM,CAAC;0BAC3C,YAAO,GAAmCA,eAAQ,CAAC,IAAI,CAAC;0BACxD,eAAU,GAAwB,MAAM,CAAC;0BACzC,UAAK,GAAiCA,eAAQ,CAAC,IAAI,CAAC;0BACpD,eAAU,GAAoB,MAAM,CAAC;0BACrC,UAAK,GAA6BA,eAAQ,CAAC,IAAI,CAAC;0BAChD,eAAU,GAAoB,MAAM,CAAC;0BACrC,WAAM,GAA8BA,eAAQ,CAAC,IAAI,CAAC;0BAClD,kBAAa,GAAuB,MAAM,CAAC;0BAC3C,aAAQ,GAAmCA,eAAQ,CAAC,IAAI,CAAC;0BACzD,iBAAY,GAAsB,MAAM,CAAC;0BACzC,aAAQ,GAAkCA,eAAQ,CAAC,IAAI,CAAC;0BACxD,kBAAa,GAAuB,MAAM,CAAC;0BAC3C,aAAQ,GAAmCA,eAAQ,CAAC,IAAI,CAAC;0BACzD,2BAAsB,GAAgC,MAAM,CAAC;0BAC7D,YAAO,GAA2CA,eAAQ,CAAC,IAAI,CAAC;0BAChE,iBAAY,GAAsB,MAAM,CAAC;0BACzC,YAAO,GAAiCA,eAAQ,CAAC,IAAI,CAAC;0BAEtD,SAAI,GAA2B,IAAI,CAAC;SAiZzD;QA/YQ,YAAY,CAAC,IAAoB;YACtC,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,EAAE;gBACtB,IAAI,CAAC,IAAI,GAAG,IAAI,sBAAsB,EAAE,CAAC;aAC1C;YACD,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;SACzB;QAEM,UAAU,CAAC,IAAoB;YACpC,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,EAAE;gBACtB,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,EAAE;oBACtB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;iBAClB;qBAAM;oBACL,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;iBAC5B;aACF;SACF;QAEM,YAAY,CAAC,SAAyB;;;;YAI3C,IAAI,IAAI,CAAC,SAAS,KAAK,IAAI,EAAE;gBAC3B,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,iBAAiB,CAACH,sBAAc,CAAC,cAAc,CAAC,CAAC,CAAC;aAC/F;YACD,IAAI,SAAS,CAAC,UAAU,KAAK,IAAI,EAAE;gBACjC,SAAS,CAAC,UAAU,GAAG,MAAM,CAAC;gBAC9B,IAAI,CAAC,SAAS,CAAC,UAAU,GAAG,SAAS,CAAC;gBACtC,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;gBAC3B,EAAE,IAAI,CAAC,UAAU,CAAC;aACnB;YACD,OAAO,IAAI,CAAC,OAAO,CAAC;SACrB;QAEM,iBAAiB,CAAC,KAAqB;YAC5C,KAAK,IAAIA,sBAAc,CAAC,aAAa,CAAC;;;YAGtC,OAAO,IAAI,CAAC,UAAU,GAAG,CAAC,EAAE;gBAC1B,IAAI,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC;gBACxC,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;gBACvC,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC;gBACpB,IAAI,IAAoB,CAAC;gBACzB,GAAG;oBACD,IAAI,GAAG,OAAO,CAAC,UAAU,CAAC;oBAC1B,OAAO,CAAC,UAAU,GAAG,IAAI,CAAC;oBAC1B,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;oBACrB,OAAO,GAAG,IAAI,CAAC;iBAChB,QAAQ,OAAO,KAAK,MAAM,EAAE;aAC9B;SACF;QAEM,SAAS;YACd,EAAE,IAAI,CAAC,SAAS,CAAC;SAClB;QAEM,YAAY,CAAC,SAA0B;;YAE5C,IAAI,SAAS,CAAC,UAAU,KAAK,IAAI,EAAE;gBACjC,SAAS,CAAC,UAAU,GAAG,MAAM,CAAC;gBAC9B,IAAI,CAAC,SAAS,CAAC,UAAU,GAAG,SAAS,CAAC;gBACtC,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;gBAC3B,EAAE,IAAI,CAAC,UAAU,CAAC;aACnB;SACF;QAEM,cAAc,CAAC,SAA8B;;;;;;YAOlD,IAAI,SAAS,CAAC,YAAY,KAAK,IAAI,EAAE;gBACnC,SAAS,CAAC,YAAY,GAAG,MAAM,CAAC;gBAChC,IAAI,CAAC,WAAW,CAAC,YAAY,GAAG,SAAS,CAAC;gBAC1C,IAAI,CAAC,WAAW,GAAG,SAAS,CAAC;gBAC7B,EAAE,IAAI,CAAC,YAAY,CAAC;aACrB;;YAED,IAAI,SAAS,CAAC,UAAU,KAAK,IAAI,EAAE;gBACjC,SAAS,CAAC,UAAU,GAAG,MAAM,CAAC;gBAC9B,IAAI,CAAC,SAAS,CAAC,UAAU,GAAG,SAAS,CAAC;gBACtC,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;gBAC3B,EAAE,IAAI,CAAC,UAAU,CAAC;aACnB;SACF;QAEM,mBAAmB,CAAC,KAAqB;;YAE9C,IAAI,IAAI,CAAC,YAAY,GAAG,CAAC,EAAE;gBACzB,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC;gBACtB,IAAI,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC;gBAC5C,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,GAAiC,IAAI,CAAC;gBACzE,IAAI,IAAoB,CAAC;gBACzB,GAAG;oBACD,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;oBACvB,IAAI,GAAG,OAAO,CAAC,YAAY,CAAC;oBAC5B,OAAO,CAAC,YAAY,GAAG,IAAI,CAAC;oBAC5B,OAAO,GAAG,IAAI,CAAC;iBAChB,QAAQ,OAAO,KAAK,MAAM,EAAE;aAC9B;SACF;QAEM,iBAAiB,CAAC,KAAqB;;;YAG5C,IAAI,KAAK,GAAGA,sBAAc,CAAC,aAAa,EAAE;gBACxC,IAAI,CAAC,iBAAiB,CAAC,KAAK,GAAGA,sBAAc,CAAC,aAAa,CAAC,CAAC;aAC9D;;;YAGD,OAAO,IAAI,CAAC,UAAU,GAAG,CAAC,EAAE;gBAC1B,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC;gBACpB,IAAI,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC;gBACxC,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,GAAiC,IAAI,CAAC;gBACrE,IAAI,IAAoB,CAAC;gBACzB,GAAG;oBACD,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;oBACrB,IAAI,GAAG,OAAO,CAAC,UAAU,CAAC;oBAC1B,OAAO,CAAC,UAAU,GAAG,IAAI,CAAC;oBAC1B,OAAO,GAAG,IAAI,CAAC;iBAChB,QAAQ,OAAO,KAAK,MAAM,EAAE;aAC9B;SACF;QAEM,OAAO,CAAC,KAAqB;;YAElC,IAAI,EAAE,IAAI,CAAC,SAAS,KAAK,CAAC,EAAE;gBAC1B,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;oBACzC,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;oBACvB,OAAO,IAAI,CAAC,IAAI,CAAC;iBAClB;gBAED,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;gBAE7B,OAAO,aAAa,CAAC,IAAI,CAAC;aAC3B;SACF;QAEM,gBAAgB,CAAC,KAAqB;;;YAG3C,IAAI,KAAK,GAAGA,sBAAc,CAAC,aAAa,EAAE;gBACxC,IAAI,CAAC,iBAAiB,CAAC,KAAK,GAAGA,sBAAc,CAAC,aAAa,CAAC,CAAC;aAC9D;;;YAGD,OAAO,IAAI,CAAC,UAAU,GAAG,CAAC,EAAE;gBAC1B,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC;gBACpB,IAAI,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC;gBACxC,IAAI,IAAqB,CAAC;gBAC1B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;gBACvC,GAAG;oBACD,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;oBACrB,IAAI,GAAG,OAAO,CAAC,UAAU,CAAC;oBAC1B,OAAO,CAAC,UAAU,GAAG,IAAI,CAAC;oBAC1B,OAAO,GAAG,IAAI,CAAC;iBAChB,QAAQ,OAAO,KAAK,MAAM,EAAE;aAC9B;SACF;QAEM,WAAW;;YAEhB,EAAE,IAAI,CAAC,WAAW,CAAC;SACpB;QAEM,cAAc,CAAC,SAA4B;;;;YAIhD,IAAI,SAAS,CAAC,YAAY,KAAK,IAAI,EAAE;gBACnC,SAAS,CAAC,YAAY,GAAG,MAAM,CAAC;gBAChC,IAAI,CAAC,WAAW,CAAC,YAAY,GAAG,SAAS,CAAC;gBAC1C,IAAI,CAAC,WAAW,GAAG,SAAS,CAAC;gBAC7B,EAAE,IAAI,CAAC,YAAY,CAAC;aACrB;SACF;QAEM,SAAS,CAAC,KAAqB;;YAEpC,IAAI,EAAE,IAAI,CAAC,WAAW,KAAK,CAAC,EAAE;gBAC5B,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;oBACzC,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;oBACvB,OAAO,IAAI,CAAC,IAAI,CAAC;iBAClB;gBAED,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;gBAE/B,OAAO,aAAa,CAAC,IAAI,CAAC;aAC3B;SACF;QAEM,kBAAkB,CAAC,KAAqB;;;YAG7C,OAAO,IAAI,CAAC,YAAY,GAAG,CAAC,EAAE;gBAC5B,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC;gBACtB,IAAI,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC;gBAC5C,IAAI,IAAuB,CAAC;gBAC5B,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;gBAC3C,GAAG;oBACD,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;oBACvB,IAAI,GAAG,OAAO,CAAC,YAAY,CAAC;oBAC5B,OAAO,CAAC,YAAY,GAAG,IAAI,CAAC;oBAC5B,OAAO,GAAG,IAAI,CAAC;iBAChB,QAAQ,OAAO,KAAK,MAAM,EAAE;aAC9B;SACF;QAEM,WAAW;;YAEhB,EAAE,IAAI,CAAC,WAAW,CAAC;SACpB;QAEM,YAAY,CAAC,SAA0B;;;;YAI5C,IAAI,SAAS,CAAC,UAAU,KAAK,IAAI,EAAE;gBACjC,SAAS,CAAC,UAAU,GAAG,MAAM,CAAC;gBAC9B,IAAI,CAAC,SAAS,CAAC,UAAU,GAAG,SAAS,CAAC;gBACtC,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;gBAC3B,EAAE,IAAI,CAAC,UAAU,CAAC;aACnB;SACF;QAEM,eAAe,CAAC,SAA6B;;;;YAIlD,IAAI,SAAS,CAAC,aAAa,KAAK,IAAI,EAAE;gBACpC,SAAS,CAAC,aAAa,GAAG,MAAM,CAAC;gBACjC,IAAI,CAAC,YAAY,CAAC,aAAa,GAAG,SAAS,CAAC;gBAC5C,IAAI,CAAC,YAAY,GAAG,SAAS,CAAC;gBAC9B,EAAE,IAAI,CAAC,aAAa,CAAC;aACtB;SACF;QAEM,SAAS,CAAC,KAAqB;;YAEpC,IAAI,EAAE,IAAI,CAAC,WAAW,KAAK,CAAC,EAAE;gBAC5B,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;oBACzC,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;oBACvB,OAAO,IAAI,CAAC,IAAI,CAAC;iBAClB;gBAED,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;gBAE/B,OAAO,aAAa,CAAC,IAAI,CAAC;aAC3B;SACF;QAEM,kBAAkB,CAAC,KAAqB;;;YAG7C,IAAI,CAAC,iBAAiB,CAAC,KAAK,GAAGA,sBAAc,CAAC,aAAa,CAAC,CAAC;;;YAI7D,IAAI,IAAI,CAAC,UAAU,GAAG,CAAC,EAAE;gBACvB,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC;gBACpB,IAAI,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC;gBAC7C,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;gBACvC,IAAI,SAA8B,CAAC;gBAEnC,GAAG;oBACD,YAAY,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;oBAC3B,SAAS,GAAG,YAAY,CAAC,UAAU,CAAC;oBACpC,YAAY,CAAC,UAAU,GAAG,IAAI,CAAC;oBAC/B,YAAY,GAAG,SAAS,CAAC;iBAC1B,QAAQ,YAAY,KAAK,MAAM,EAAE;aACnC;;;;;;;YAOD,IAAI,CAAC,mBAAmB,CAACA,sBAAc,CAAC,YAAY,CAAC,CAAC;YAEtD,IAAI,IAAI,CAAC,aAAa,GAAG,CAAC,EAAE;gBAC1B,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC;gBACvB,IAAI,eAAe,GAAG,IAAI,CAAC,YAAY,CAAC,aAAa,CAAC;gBACtD,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;gBAC7C,IAAI,YAAoC,CAAC;gBAEzC,GAAG;oBACD,eAAe,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;oBAChC,YAAY,GAAG,eAAe,CAAC,aAAa,CAAC;oBAC7C,eAAe,CAAC,aAAa,GAAG,IAAI,CAAC;oBACrC,eAAe,GAAG,YAAY,CAAC;iBAChC,QAAQ,eAAe,KAAK,MAAM,EAAE;aACtC;SACF;QAEM,WAAW;;YAEhB,EAAE,IAAI,CAAC,WAAW,CAAC;SACpB;QAEM,cAAc,CAAC,SAA4B;;;;YAIhD,IAAI,SAAS,CAAC,YAAY,KAAK,IAAI,EAAE;gBACnC,SAAS,CAAC,YAAY,GAAG,MAAM,CAAC;gBAChC,IAAI,CAAC,WAAW,CAAC,YAAY,GAAG,SAAS,CAAC;gBAC1C,IAAI,CAAC,WAAW,GAAG,SAAS,CAAC;gBAC7B,EAAE,IAAI,CAAC,YAAY,CAAC;aACrB;SACF;QAEM,eAAe,CAAC,SAA6B;;;;YAIlD,IAAI,SAAS,CAAC,aAAa,KAAK,IAAI,EAAE;gBACpC,SAAS,CAAC,aAAa,GAAG,MAAM,CAAC;gBACjC,IAAI,CAAC,YAAY,CAAC,aAAa,GAAG,SAAS,CAAC;gBAC5C,IAAI,CAAC,YAAY,GAAG,SAAS,CAAC;gBAC9B,EAAE,IAAI,CAAC,aAAa,CAAC;aACtB;SACF;QAEM,wBAAwB,CAAC,SAAsC;;;;YAIpE,IAAI,SAAS,CAAC,sBAAsB,KAAK,IAAI,EAAE;gBAC7C,SAAS,CAAC,sBAAsB,GAAG,MAAM,CAAC;gBAC1C,IAAI,CAAC,qBAAqB,CAAC,sBAAsB,GAAG,SAAS,CAAC;gBAC9D,IAAI,CAAC,qBAAqB,GAAG,SAAS,CAAC;gBACvC,EAAE,IAAI,CAAC,sBAAsB,CAAC;aAC/B;SACF;QAEM,SAAS,CAAC,KAAqB;;YAEpC,IAAI,EAAE,IAAI,CAAC,WAAW,KAAK,CAAC,EAAE;gBAC5B,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;oBACzC,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;oBACvB,OAAO,IAAI,CAAC,IAAI,CAAC;iBAClB;gBAED,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;gBAE/B,OAAO,aAAa,CAAC,IAAI,CAAC;aAC3B;SACF;QAEM,kBAAkB,CAAC,KAAqB;;;YAG7C,IAAI,CAAC,iBAAiB,CAAC,KAAK,GAAGA,sBAAc,CAAC,SAAS,GAAGA,sBAAc,CAAC,cAAc,CAAC,CAAC;YAEzF,IAAI,IAAI,CAAC,YAAY,GAAG,CAAC,EAAE;gBACzB,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC;gBACtB,IAAI,cAAc,GAAG,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC;gBACnD,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;gBAC3C,IAAI,WAAkC,CAAC;gBAEvC,GAAG;oBACD,cAAc,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;oBAC/B,WAAW,GAAG,cAAc,CAAC,YAAY,CAAC;oBAC1C,cAAc,CAAC,YAAY,GAAG,IAAI,CAAC;oBACnC,cAAc,GAAG,WAAW,CAAC;iBAC9B,QAAQ,cAAc,KAAK,MAAM,EAAE;aACrC;YAED,IAAI,IAAI,CAAC,aAAa,GAAG,CAAC,EAAE;gBAC1B,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC;gBACvB,IAAI,eAAe,GAAG,IAAI,CAAC,YAAY,CAAC,aAAa,CAAC;gBACtD,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;gBAC7C,IAAI,YAAoC,CAAC;gBAEzC,GAAG;oBACD,eAAe,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;oBAChC,YAAY,GAAG,eAAe,CAAC,aAAa,CAAC;oBAC7C,eAAe,CAAC,aAAa,GAAG,IAAI,CAAC;oBACrC,eAAe,GAAG,YAAY,CAAC;iBAChC,QAAQ,eAAe,KAAK,MAAM,EAAE;aACtC;YAED,IAAI,IAAI,CAAC,sBAAsB,GAAG,CAAC,EAAE;gBACnC,IAAI,CAAC,WAAW,EAAE,CAAC;gBACnB,IAAI,CAAC,sBAAsB,GAAG,CAAC,CAAC;gBAChC,IAAI,aAAa,GAAG,IAAI,CAAC,qBAAqB,CAAC,sBAAsB,CAAC;gBACtE,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC;gBAC/D,IAAI,UAAgC,CAAC;gBAErC,GAAG;oBACD,aAAa,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;oBAC7B,UAAU,GAAG,aAAa,CAAC,sBAAsB,CAAC;oBAClD,aAAa,CAAC,sBAAsB,GAAG,IAAI,CAAC;oBAC5C,aAAa,GAAG,UAAU,CAAC;iBAC5B,QAAQ,aAAa,KAAK,MAAM,EAAE;gBACnC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;aACvB;SACF;KACF;AAGD,AAAaI,kCAAsB,GAAnC,MAAa,sBAAsB;QAWjC,YAA4B,UAAsB;YAAtB,eAAU,GAAV,UAAU,CAAY;YAV3C,mBAAc,GAAeD,eAAQ,CAAC,IAAI,CAAC;YAE1C,UAAK,GAA4B,IAAI,CAAC;YACtC,aAAQ,GAAmB,aAAa,CAAC,IAAI,CAAC;YAE9C,gBAAW,GAAU,IAAI,CAAC;YAE1B,YAAO,GAAY,KAAK,CAAC;YACzB,eAAU,GAAY,KAAK,CAAC;SAEkB;QAE/C,OAAO,QAAQ,CAAC,SAAqB;YAC1C,OAAOE,mBAAY,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,QAAQ,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;SACrE;QAEM,OAAO,CAAC,KAAY,EAAE,KAAqB;YAChD,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE;gBACtB,IAAI,KAAK,YAAY,OAAO,EAAE;oBAC5B,IAAI,CAAC,OAAO,CAAC,IAAI,WAAW,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;oBAC3C,IAAI,CAAC,WAAW,EAAE,CAAC;iBACpB;qBAAM;oBACL,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;iBACzB;aACF;iBAAM;gBACL,IAAI,KAAK,YAAY,OAAO,EAAE;oBAC5B,IAAI,CAAC,OAAO,CAAC,IAAI,WAAW,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;iBAC5C;qBAAM;oBACL,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;iBACrB;gBAED,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,EAAE;oBAC7B,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC;iBACxB;aACF;SACF;QAEM,OAAO,CAAC,KAAqB,EAAE,KAAa;YACjD,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;YACnB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;YAEpB,IAAI,IAAI,CAAC,WAAW,KAAK,IAAI,EAAE;gBAC7B,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;aACtC;SACF;QAEM,SAAS,CAAC,KAAqB;YACpC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;YAEvB,IAAI,IAAI,CAAC,WAAW,KAAK,IAAI,EAAE;gBAC7B,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;aACjC;SACF;QAEM,SAAS,CAAC,KAAqB;YACpC,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;YAExB,IAAI,IAAI,CAAC,WAAW,KAAK,IAAI,EAAE;gBAC7B,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;aACjC;SACF;QAEM,SAAS,CAAC,KAAqB;YACpC,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;YAErB,IAAI,IAAI,CAAC,WAAW,KAAK,IAAI,EAAE;gBAC7B,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;aACjC;SACF;QAEM,OAAO,CAAC,KAAqB;YAClC,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;SACzB;QAEO,OAAO,CAAC,IAAyB;YACvC,IAAI,IAAI,CAAC,KAAK,KAAK,IAAI,EAAE;gBACvB,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;aACjB;YAED,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACvB;QAEO,IAAI,CAAC,IAAW,EAAE,KAAqB;YAC7C,IAAI,IAAI,CAAC,WAAW,KAAK,IAAI,EAAE;gBAC7B,OAAO;aACR;YAED,MAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;YACnC,MAAM,QAAQ,GAAG,IAAI,sBAAsB,EAAE,CAAC;YAE9C,IAAI,aAA6B,CAAC;YAClC,IAAI,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;YACnC,IAAI,WAAW,KAAK,IAAI,EAAE;gBACxB,aAAa,GAAG,aAAa,CAAC,IAAI,CAAC;aACpC;iBAAM;gBACL,UAAU,CAAC,wBAAwB,CAAC,WAAW,CAAC,CAAC;gBACjD,UAAU,CAAC,WAAW,EAAE,CAAC;gBACzB,WAAW,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;gBAC3B,aAAa,GAAG,UAAU,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;aAC7C;YACD,QAAQ,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;YAEhC,WAAW,GAAG,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;YAEtC,IAAI,WAAW,KAAK,IAAI,EAAE;gBACxB,aAAa,GAAG,aAAa,CAAC,IAAI,CAAC;aACpC;iBAAM;gBACL,IAAI,IAAI,CAAC,OAAO,EAAE;oBAChB,UAAU,CAAC,SAAS,EAAE,CAAC;oBACvB,WAAW,CAAC,KAAK,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;oBACrC,UAAU,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;iBAC3B;gBACD,IAAI,IAAI,CAAC,UAAU,EAAE;oBACnB,UAAU,CAAC,WAAW,EAAE,CAAC;oBACzB,WAAW,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;oBAC3B,aAAa,GAAG,UAAU,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;iBAC7C;qBAAM;oBACL,aAAa,GAAG,aAAa,CAAC,IAAI,CAAC;iBACpC;aACF;YACD,QAAQ,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;YAEhC,IAAI,QAAQ,CAAC,IAAI,EAAE;gBACjB,IAAI,CAAC,QAAQ,GAAG,aAAa,CAAC,IAAI,CAAC;gBACnC,IAAI,CAAC,cAAc,EAAE,CAAC;aACvB;iBAAM;gBACL,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;gBACzB,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC;oBACxB,IAAI,CAAC,cAAc,EAAE,CAAC;oBACtB,IAAI,CAAC,WAAW,EAAE,CAAC;iBACpB,CAAC,CAAC;aACJ;SACF;QAEO,WAAW;YACjB,IAAI,IAAI,CAAC,KAAK,KAAK,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;gBAChD,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;gBAC9B,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;gBAEtB,IAAI,WAAW,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE;oBACxB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC;iBAC9B;qBAAM;oBACL,IAAI,CAAC,IAAI,CAAC,IAAI,EAAEL,sBAAc,CAAC,iBAAiB,CAAC,CAAC;iBACnD;aACF;iBAAM;gBACL,IAAI,CAAC,QAAQ,GAAG,aAAa,CAAC,IAAI,CAAC;aACpC;SACF;KACF,CAAA;AArJYI,kCAAsB;QADlCE,aAAM,CAAC,UAAU,CAAC;OACNF,8BAAsB,CAqJlC;UAEY,aAAa,GAAG;QAC3B,IAAI,EAAE;YACJ,IAAI,EAAE,IAAI;YACV,SAAS,KAAc,OAAO,KAAK,CAAC,EAAE;;YAEtC,MAAM,MAAW;YACjB,IAAI,KAAuB,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC,EAAE;SACvD;KACF,CAAC;AASF,UAAa,sBAAsB;QAAnC;YACS,SAAI,GAAY,IAAI,CAAC;;YAGrB,UAAK,GAAc,IAAI,CAAC;YAEvB,UAAK,GAAqB,EAAE,CAAC;YAC7B,WAAM,GAAkB,IAAI,CAAC;YAC7B,YAAO,GAAe,IAAI,CAAC;SA8EpC;QA5EQ,OAAO,CAAC,IAAoB;YACjC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;gBACd,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC;gBAClB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACtB,IAAI,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC;aAC5C;SACF;QAEM,UAAU,CAAC,IAAoB;YACpC,IAAI,IAAI,CAAC,IAAI,EAAE;gBACb,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;gBACrC,IAAI,GAAG,KAAK,CAAC,CAAC,EAAE;oBACd,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;iBAC3B;aACF;YACD,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;gBAC3B,IAAI,IAAI,CAAC,KAAK,KAAK,IAAI,EAAE;oBACvB,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;oBAC5B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;iBACnB;aACF;SACF;QAEM,SAAS;YACd,IAAI,IAAI,CAAC,IAAI,EAAE;gBACb,OAAO,KAAK,CAAC;aACd;YAED,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,SAAS,EAAE,CAAC,CAAC;SAC7C;QAEM,MAAM;YACX,IAAI,IAAI,CAAC,SAAS,EAAE,EAAE;gBACpB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC;gBACpC,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC;aACnB;SACF;QAEM,IAAI;YACT,IAAI,IAAI,CAAC,MAAM,KAAK,IAAI,EAAE;gBACxB,IAAI,IAAI,CAAC,IAAI,EAAE;oBACb,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,OAAO,EAAE,CAAC;iBACjC;qBAAM;;oBAEL,IAAI,CAAC,MAAM,GAAG,IAAI,OAAO,CAAC,CAAC,OAAO,KAAK,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,CAAC;iBAChE;aACF;YAED,OAAO,IAAI,CAAC,MAAM,CAAC;SACpB;QAEO,WAAW;YACjB,IAAI,IAAI,CAAC,IAAI,EAAE;gBACb,OAAO;aACR;YAED,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,EAAE;gBACjC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;aACrB;SACF;QAEO,QAAQ,CAAC,YAAqB;YACpC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;YAEjB,IAAI,YAAY,IAAI,IAAI,CAAC,KAAK,KAAK,IAAI,EAAE;gBACvC,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAACJ,sBAAc,CAAC,iBAAiB,CAAC,CAAC;gBAChE,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAACA,sBAAc,CAAC,iBAAiB,CAAC,CAAC;gBAChE,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAACA,sBAAc,CAAC,iBAAiB,CAAC,CAAC;gBAC9D,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAACA,sBAAc,CAAC,iBAAiB,CAAC,CAAC;aACjE;YACD,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;YAE5B,IAAI,IAAI,CAAC,OAAO,KAAK,IAAI,EAAE;gBACzB,IAAI,CAAC,OAAO,EAAE,CAAC;aAChB;SACF;KACF;IAED;AACA,UAAa,WAAW;QAItB,YACU,WAAmC,EACnC,OAAuB;YADvB,gBAAW,GAAX,WAAW,CAAwB;YACnC,YAAO,GAAP,OAAO,CAAgB;YAL1B,SAAI,GAAY,KAAK,CAAC;YACrB,gBAAW,GAAY,KAAK,CAAC;SAKjC;QAEG,OAAO,EAAE,CAAC,MAAc;YAC7B,OAAO,OAAO,IAAI,MAAM,CAAC;SAC1B;QAEM,KAAK;YACV,IAAI,IAAI,CAAC,WAAW,EAAE;gBACpB,OAAO,aAAa,CAAC,IAAI,CAAC;aAC3B;YAED,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;gBAChC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;gBAClB,OAAO,CAAC,CAAC;aACV,CAAC,CAAC;YAEH,OAAO,IAAI,CAAC;SACb;QAEM,SAAS;YACd,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC;SACnB;QAEM,MAAM;YACX,IAAI,IAAI,CAAC,SAAS,EAAE,EAAE;gBACpB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;aACzB;SACF;QAEM,IAAI;YACT,OAAO,IAAI,CAAC,OAAO,CAAC;SACrB;QAEO,SAAS,CAAC,KAAY;YAC5B,IAAI,IAAI,CAAC,WAAW,EAAE;gBACpB,OAAO;aACR;YAED,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;YACjB,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,EAAEA,sBAAc,CAAC,iBAAiB,CAAC,CAAC;SACnE;KACF;IAED;IACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAqCA;AACA,UAAa,WAAW;QAMtB,YACE,OAAmB,EACnB,QAA8B;YAE9B,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC;YAClB,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;YACzB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;YACzB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK;gBAC/B,IAAI,IAAI,CAAC,WAAW,KAAK,IAAI,EAAE;oBAC7B,OAAO;iBACR;gBACD,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;gBACjB,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;gBACrB,OAAO,KAAK,CAAC;aACd,CAAC,CAAC;SACJ;QAEM,SAAS;YACd,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC;SACnB;QAEM,MAAM;YACX,IAAI,IAAI,CAAC,SAAS,EAAE,EAAE;gBACpB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;aACzB;SACF;QAEM,IAAI;YACT,OAAO,IAAI,CAAC,OAAO,CAAC;SACrB;KACF;;aC38Ce,eAAe,CAAC,YAA6C;QAC3E,OAAO,UAAkC,MAAS;YAChD,OAAO,uBAAuB,CAAC,MAAM,CAAC,YAAY,EAAE,MAAM,CAAC,CAAC;SAC7D,CAAC;IACJ,CAAC;AAED,UAAa,uBAAuB,GAAgE;QAClG,IAAI,EAAE,kBAAkB;QAExB,OAAO,CAAC,IAAY;YAClB,OAAO,GAAG,IAAI,CAAC,IAAI,IAAI,IAAI,EAAE,CAAC;SAC/B;QAED,MAAM,CAA0B,IAAO;YACrC,OAAQ,IAAiC,CAAC,IAAI,KAAK,IAAI,CAAC;SACzD;QAED,MAAM,CAA0B,YAA6C,EAAE,IAAO;YACpF,MAAM,IAAI,GAAG,IAAgC,CAAC;YAC9C,MAAM,WAAW,GAAG,OAAO,YAAY,KAAK,QAAQ;kBAChD,EAAE,IAAI,EAAE,YAAY,EAAE;kBACtB,YAAY,CAAC;YAEhB,IAAuC,CAAC,IAAI,GAAG,uBAAuB,CAAC;YACvE,IAAuC,CAAC,WAAW,GAAG,WAAW,CAAC;YACnE,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;YAEzB,OAAO,IAAI,CAAC;SACb;KACF,CAAC;IAEF,SAAS,QAAQ,CAA6B,SAAqB;QACjE,SAAS,CAAC,QAAQ,CAChBK,mBAAY,CAAC,SAAS,CACpB,uBAAuB,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,EACtD,IAAI,CACL,CACF,CAAC;IACJ,CAAC;;UC7CY,YAAY,GAAG,CAAC,CAAC;AAC9B,UAAa,cAAc,GAAG,CAAC,CAAC;AAChC,UAAa,SAAS,GAAG,CAAC,CAAC;AAC3B,UAAa,YAAY,GAAG,CAAC,CAAC;AAC9B,UAAa,sBAAsB,GAAG,EAAE,CAAC;IAEzC,SAAS,gBAAgB,CAAC,IAAW;QACnC,OAAO,IAAI,CAAC,WAAW,KAAK,QAAQ,CAAC;IACvC,CAAC;AAOD,UAAa,KAAK,GAAGH,SAAE,CAAC,eAAe,EAAS,CAAC,SAAS,EAAE,CAAC;AAS7D,UAAa,oBAAoB,GAAGA,SAAE,CAAC,eAAe,EAAwB,CAAC,SAAS,EAAE,CAAC;AA6C3F,UAAa,eAAe,GAAGA,SAAE,CAAC,eAAe,EAAmB,CAAC,SAAS,EAAE,CAAC;IAwCjF;AACA,UAAa,GAAG,GAAG;QACjB,sBAAsB,CAAC,YAAgC;YACrD,IAAI,YAAY,KAAK,SAAS,IAAI,YAAY,KAAK,IAAI,EAAE;gBACvD,OAA0B,QAAQ,CAAC,sBAAsB,EAAE,CAAC;aAC7D;YACD,IAAe,YAAa,CAAC,QAAQ,GAAG,CAAC,EAAE;gBACzC,IAAe,YAAa,CAAC,OAAO,KAAK,SAAS,EAAE;oBAClD,OAAkB,YAAa,CAAC,OAAO,CAAC;iBACzC;gBACD,MAAM,QAAQ,GAAG,QAAQ,CAAC,sBAAsB,EAAE,CAAC;gBACnD,QAAQ,CAAC,WAAW,CAAM,YAAY,CAAC,CAAC;gBACxC,OAA0B,QAAQ,CAAC;aACpC;YACD,OAAO,GAAG,CAAC,cAAc,CAAS,YAAY,CAAC,CAAC,OAAO,CAAC;SACzD;QACD,cAAc,CAAC,MAAe;YAC5B,IAAI,MAAM,KAAK,SAAS,EAAE;gBACxB,OAAiB,QAAQ,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;aACrD;YACD,MAAM,QAAQ,GAAG,QAAQ,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;YACpD,QAAQ,CAAC,SAAS,GAAG,MAAM,CAAC;YAC5B,OAAiB,QAAQ,CAAC;SAC3B;QACD,QAAQ,CAAC,IAAW,EAAE,SAAiB;YAC/B,IAAK,CAAC,SAAS,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;SACtC;QACD,gBAAgB,CAAC,SAAiB,EAAE,UAAe,EAAE,SAAiB,EAAE,OAAa;YACnF,CAAO,SAAU,IAAI,QAAQ,EAAE,gBAAgB,CAAC,SAAS,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;SACjF;QACD,WAAW,CAAC,MAAa,EAAE,KAAY;YAC/B,MAAO,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;SAClC;QACD,YAAY,CAAC,IAAc,EAAE,OAAuB;YAClD,OAAa,IAAK,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;SAC1C;QACD,SAAS,CAA0B,IAAO,EAAE,IAAc;YACxD,OAAa,IAAK,CAAC,SAAS,CAAC,IAAI,KAAK,KAAK,CAAC,CAAC;SAC9C;QACD,uBAAuB,CAAC,IAAW;YACjC,IAAI,gBAAgB,CAAC,IAAI,CAAC,EAAE;gBAC1B,OAAO,IAAI,CAAC;aACb;YACD,IAAU,IAAK,CAAC,UAAU,KAAK,IAAI,EAAE;gBACnC,MAAMK,eAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;aAC1B;YACD,MAAM,WAAW,GAAoB,QAAQ,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;YACtE,MAAM,aAAa,GAAoB,QAAQ,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;YAC1E,GAAG,CAAC,WAAW,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;YACnC,GAAG,CAAC,YAAY,CAAC,aAAa,EAAE,WAAW,CAAC,CAAC;YAC7C,WAAW,CAAC,MAAM,GAAG,aAAa,CAAC;YACnC,aAAa,CAAC,MAAM,GAAG,IAAI,CAAC;YAC5B,OAAO,WAAW,CAAC;SACpB;QACD,aAAa,CAAC,IAAY;YACxB,OAAiB,QAAQ,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;SAC/C;QACD,aAAa,CAAC,IAAY;YACxB,OAAO,QAAQ,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;SACrC;QACD,kBAAkB,CAAC,MAAa,EAAE,QAA0B,EAAE,OAA6B;YACzF,MAAM,QAAQ,GAAG,IAAI,gBAAgB,CAAC,QAAQ,CAAC,CAAC;YAChD,QAAQ,CAAC,OAAO,CAAM,MAAM,EAAE,OAAO,CAAC,CAAC;YACvC,OAAO,QAAQ,CAAC;SACjB;QACD,cAAc,CAAC,IAAY;YACzB,OAAc,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;SAC7C;QACD,YAAY,CAAC,IAAW,EAAE,IAAY;YACpC,OAAa,IAAK,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;SACvC;QACD,QAAQ,CAAC,IAAW,EAAE,SAAiB;YACrC,OAAa,IAAK,CAAC,SAAS,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;SAClD;QACD,YAAY,CAAC,YAAmB,EAAE,aAAoB;YAC9C,aAAc,CAAC,UAAU,CAAC,YAAY,CAAC,YAAY,EAAE,aAAa,CAAC,CAAC;SAC3E;QACD,eAAe,CAAC,IAAW;YACzB,IAAU,IAAK,CAAC,qBAAqB,KAAK,IAAI,EAAE;gBAC9C,OAAO,KAAK,CAAC;aACd;YACD,MAAM,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC;YAC9B,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;YACxB,IAAI,CAAC,GAAG,CAAC,CAAC;;YAEV,OAAO,CAAC,GAAG,GAAG,EAAE;;gBAEd,IAAI,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,GAAG,IAAI,EAAE;oBAC7B,OAAO,KAAK,CAAC;iBACd;gBACD,CAAC,EAAE,CAAC;aACL;YACD,OAAO,IAAI,CAAC;SACb;QACD,iBAAiB,CAAC,IAAW;YAC3B,OAAO,IAAI,CAAC,QAAQ,KAAK,YAAY,CAAC;SACvC;QACD,sBAAsB,CAAC,IAAW;YAChC,OAAO,IAAI,CAAC,QAAQ,KAAK,sBAAsB,CAAC;SACjD;QACD,iBAAiB,CAAC,IAAW;YAC3B,OAAO,IAAI,CAAC,QAAQ,KAAK,YAAY,CAAC;SACvC;QACD,cAAc,CAAC,aAAkB;YAC/B,OAAO,aAAa,CAAC,QAAQ,GAAG,CAAC,CAAC;SACnC;QACD,cAAc,CAAC,IAAW;YACxB,OAAO,IAAI,CAAC,QAAQ,KAAK,SAAS,CAAC;SACpC;QACD,iBAAiB,CAAC,aAAoB,EAAE,SAAgB;YACtD,OAAO,aAAa,CAAC,UAAU,EAAE;gBAC/B,GAAG,CAAC,WAAW,CAAC,SAAS,EAAE,aAAa,CAAC,UAAU,CAAC,CAAC;aACtD;SACF;QACD,uBAAuB,CAAC,SAAqB,EAAE,QAAmB;YAChE,SAAS,CAAC,gBAAgB,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;YAC5C,SAAS,CAAC,gBAAgB,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;YAC9C,SAAS,CAAC,gBAAgB,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;YAClD,SAAS,CAAC,gBAAgB,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;SAClD;QACD,MAAM,CAAC,IAAe;YACpB,IAAU,IAAK,CAAC,MAAM,EAAE;gBAChB,IAAK,CAAC,MAAM,EAAE,CAAC;aACtB;iBAAM;gBACC,IAAK,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;aAC1C;SACF;QACD,eAAe,CAAC,IAAW,EAAE,IAAY;YACjC,IAAK,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;SACnC;QACD,WAAW,CAAC,IAAW,EAAE,SAAiB;YAClC,IAAK,CAAC,SAAS,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;SACzC;QACD,mBAAmB,CAAC,SAAiB,EAAE,UAAe,EAAE,SAAiB,EAAE,OAAa;YACtF,CAAO,SAAU,IAAI,QAAQ,EAAE,mBAAmB,CAAC,SAAS,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;SACpF;QACD,WAAW,CAAC,QAAe,EAAE,QAAe;YAC1C,IAAI,QAAQ,CAAC,UAAU,EAAE;gBACjB,QAAS,CAAC,UAAU,CAAC,YAAY,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;aAC7D;SACF;QACD,YAAY,CAAC,IAAW,EAAE,IAAY,EAAE,KAAU;YAC1C,IAAK,CAAC,YAAY,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;SACvC;QACD,oBAAoB,CAAC,IAAW;;YAExB,IAAK,CAAC,qBAAqB,GAAG,IAAI,CAAC;SAC1C;KACF,CAAC;IAEF;IACA;IACA;IACA,MAAM,aAAa,GAAkB;QACnC,UAAU,EAAE,IAAI;QAChB,SAAS,EAAE,IAAI;QACf,UAAU,EAAEJ,eAAQ,CAAC,UAAU;QAC/B,WAAW,KAA+C,OAAOA,eAAQ,CAAC,UAAU,CAAC,EAAE;QACvF,YAAY,CAAC,OAAc,KAA+D;QAC1F,QAAQ,CAAC,MAAa,KAA2D;QACjF,MAAM,MAA0D;KACjE,CAAC;AAEF,UAAa,YAAY,GAAG;QAC1B,KAAK,EAAE,aAAa;KACrB,CAAC;IAEF;;;;;;AAMA,UAAa,gBAAgB;QAO3B,YAAY,IAAW;YACrB,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;YACvB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;YACtB,IAAI,CAAC,UAAU,GAAG,CAAC,IAAI,CAAC,CAAC;YACzB,IAAI,CAAC,OAAO,GAAG,CAAC,IAAI,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;SACrC;QAEM,WAAW;YAChB,OAAO,IAAI,CAAC,OAAO,CAAC;SACrB;QAEM,YAAY,CAAC,OAAc;YAC1B,OAAQ,CAAC,UAAU,CAAC,YAAY,CAAC,IAAI,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;SAClE;QAEM,QAAQ,CAAC,MAAa;YACrB,MAAO,CAAC,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;SAC5C;QAEM,MAAM;YACL,IAAI,CAAC,UAAW,CAAC,MAAM,EAAE,CAAC;SACjC;KACF;IACD;IAEA;IACA;IACA;IACA;IACA;IACA;AACA,UAAa,oBAAoB;QAW/B,YAAY,QAA2B;YACrC,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;;YAEzB,MAAM,cAAc,GAAS,QAAS,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;YAC/D,IAAI,CAAC,GAAG,CAAC,CAAC;YACV,IAAI,EAAE,GAAG,cAAc,CAAC,MAAM,CAAC;YAC/B,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC,EAAE,CAAC,CAAC;YACzC,OAAO,CAAC,GAAG,EAAE,EAAE;;;;gBAIb,MAAM,MAAM,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;gBACjC,IAAI,MAAM,CAAC,QAAQ,KAAK,WAAW,EAAE;;;oBAGnC,OAAO,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,uBAAuB,CAAC,MAAM,CAAC,CAAC;iBAClD;qBAAM;;oBAEL,OAAO,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC;iBACrB;gBACD,EAAE,CAAC,CAAC;aACL;YACD,MAAM,aAAa,GAAG,QAAQ,CAAC,UAAU,CAAC;YAC1C,CAAC,GAAG,CAAC,CAAC;YACN,EAAE,GAAG,aAAa,CAAC,MAAM,CAAC;YAC1B,MAAM,UAAU,GAAG,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC,EAAE,CAAC,CAAC;YAC/C,OAAO,CAAC,GAAG,EAAE,EAAE;gBACb,UAAU,CAAC,CAAC,CAAC,GAAG,aAAa,CAAC,CAAC,CAAoB,CAAC;gBACpD,EAAE,CAAC,CAAC;aACL;YAED,IAAI,CAAC,UAAU,GAAG,QAAQ,CAAC,UAAU,CAAC;YACtC,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC,SAAS,CAAC;YAEpC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC;SAC9B;QAEM,WAAW;;YAEhB,OAAO,IAAI,CAAC,OAAO,CAAC;SACrB;QAEM,YAAY,CAAC,OAAwB;;YAEpC,OAAQ,CAAC,UAAU,CAAC,YAAY,CAAC,IAAI,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;;;;YAI/D,IAAI,gBAAgB,CAAC,OAAO,CAAC,EAAE;gBAC7B,IAAI,CAAC,GAAG,GAAG,OAAO,CAAC;gBACnB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,GAAG,OAAO,CAAC,MAAM,CAAC;gBAC1C,IAAI,KAAK,CAAC,MAAM,KAAK,IAAI,EAAE;oBACzB,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC;iBACrB;qBAAM;;;;;;;;oBAQL,KAAK,CAAC,MAAM,GAAGA,eAAQ,CAAC,WAAW,CAAC;iBACrC;aACF;SACF;QAEM,QAAQ,CAAC,MAAa;;YAErB,MAAO,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;;;YAGzC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC;SAC9B;QAEM,MAAM;YACX,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;YAC/B,IAAI,IAAI,CAAC,KAAK,KAAK,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,KAAK,IAAI,EAAE;;;;gBAIrD,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;gBACrB,IAAI,IAAW,CAAC;gBAChB,IAAI,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC;gBACrC,OAAO,OAAO,KAAK,GAAG,EAAE;oBACtB,IAAI,GAAG,OAAO,CAAC,WAAW,CAAC;;oBAErB,QAAS,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;oBACrC,OAAO,GAAG,IAAI,CAAC;iBAChB;gBACD,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC;gBACzB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC;aAC9B;iBAAM;;gBAEL,IAAI,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC;gBAE9B,IAAI,OAAO,CAAC,UAAU,KAAK,QAAQ,EAAE;oBACnC,MAAM,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC;oBAC3B,IAAI,IAAW,CAAC;oBAEhB,OAAO,OAAO,KAAK,IAAI,EAAE;wBACvB,IAAI,GAAG,OAAO,CAAC,WAAW,CAAC;;wBAErB,QAAS,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;wBAErC,IAAI,OAAO,KAAK,GAAG,EAAE;4BACnB,MAAM;yBACP;wBAED,OAAO,GAAG,IAAI,CAAC;qBAChB;iBACF;aACF;SACF;KACF;AAUD,UAAa,mBAAmB;QAI9B,YAAY,QAA2B;YACrC,MAAM,UAAU,GAAG,QAAQ,CAAC,UAAU,CAAC;YACvC,QAAQ,UAAU,CAAC,MAAM;gBACvB,KAAK,CAAC;oBACJ,IAAI,CAAC,kBAAkB,GAAG,MAAM,YAAY,CAAC,KAAK,CAAC;oBACnD,OAAO;gBACT,KAAK,CAAC;oBACJ,MAAM,MAAM,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;oBAC7B,IAAI,MAAM,CAAC,QAAQ,KAAK,WAAW,IAAI,MAAM,CAAC,QAAQ,KAAK,UAAU,EAAE;wBACrE,MAAM,IAAI,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;wBAC3B,IAAI,IAAI,CAAC,QAAQ,KAAK,SAAS,IAAI,IAAI,CAAC,WAAW,KAAK,GAAG,EAAE;4BAC3D,IAAI,CAAC,WAAW,GAAG,EAAE,CAAC;4BACtB,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;4BACvB,IAAI,CAAC,IAAI,GAAmB,IAAI,CAAC;4BACjC,IAAI,CAAC,IAAI,GAAG,gBAAgB,CAAC;4BAC7B,OAAO;yBACR;qBACF;;gBAEH;oBACE,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;oBACtB,IAAI,CAAC,IAAI,GAAmB,QAAQ,CAAC;oBACrC,IAAI,CAAC,IAAI,GAAG,oBAAoB,CAAC;aACpC;SACF;QAEM,OAAO,SAAS,CAAC,YAA4B;YAClD,MAAM,QAAQ,GAAG,GAAG,CAAC,sBAAsB,CAAC,YAAY,CAAC,CAAC;YAC1D,OAAO,IAAI,mBAAmB,CAAC,QAAQ,CAAC,CAAC;SAC1C;QAEM,kBAAkB;YACvB,OAAO,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;SAC3D;KACF;IAED;AACA,UAAa,QAAQ;QAcnB,YAAY,IAAW;YAFhB,gBAAW,GAAW,EAAE,CAAC;YAG9B,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;SACzB;QAfD,IAAW,UAAU;YACnB,OAAO,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC;SACpC;QAcM,MAAM,MAA6B;KAC3C;IACD,CAAC,KAAK;QACJ,KAAK,CAAC,eAAe,GAAG,IAAI,CAAC;QAC7B,KAAK,CAAC,UAAU,GAAG,IAAI,CAAC;QACxB,KAAK,CAAC,SAAS,GAAG,IAAI,CAAC;QACvB,KAAK,CAAC,UAAU,GAAGA,eAAQ,CAAC,UAAU,CAAC;QACvC,KAAK,CAAC,QAAQ,GAAG,WAAW,CAAC;QAC7B,KAAK,CAAC,QAAQ,GAAG,YAAY,CAAC;IAChC,CAAC,EAAsB,QAAQ,CAAC,SAAS,CAAC,CAAC;;aCpgB3B,oBAAoB,CAAyB,YAAe;QAC1E,OAAO,UAAS,MAAgB;YAC9B,MAAM,KAAK,GAA2E,MAAM,CAAC,SAAS,CAAC;YAEvG,KAAK,CAAC,gBAAgB,gBAAwB;YAC9C,KAAK,CAAC,YAAY,GAAG,IAAI,CAAC;YAC1B,KAAK,CAAC,YAAY,GAAG,IAAI,CAAC;YAC1B,KAAK,CAAC,YAAY,GAAG,IAAI,CAAC;YAC1B,KAAK,CAAC,gBAAgB,GAAG,IAAI,CAAC;YAE9B,KAAK,CAAC,aAAa,GAAG,aAAa,CAAC;YACpC,KAAK,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;YAC1C,KAAK,CAAC,aAAa,GAAG,aAAa,CAAC;YACpC,KAAK,CAAC,cAAc,GAAG,cAAc,CAAC;YACtC,KAAK,CAAC,eAAe,IAAI,YAAY,KAAKF,oBAAY,CAAC,QAAQ,GAAG,uBAAuB,GAAG,yBAAyB,CAAC,CAAC;SACxH,CAAC;IACJ,CAAC;IAED,SAAS,aAAa,CAAyD,UAAuC;QACpH,IAAI,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,EAAE;YAClC,OAAO,KAAK,CAAC;SACd;QACD,MAAM,eAAe,GAAG,IAAI,CAAC,gBAAgB,CAAC;QAC9C,IAAI,EAAE,eAAe,uBAA+B,EAAE;YACpD,IAAI,CAAC,YAAY,GAAG,UAAU,CAAC;YAC/B,IAAI,CAAC,gBAAgB,wBAAgC;YACrD,OAAO,IAAI,CAAC;SACb;QACD,IAAI,EAAE,eAAe,uBAA+B,EAAE;YACpD,IAAI,CAAC,YAAY,GAAG,UAAU,CAAC;YAC/B,IAAI,CAAC,gBAAgB,wBAAgC;YACrD,OAAO,IAAI,CAAC;SACb;QACD,IAAI,EAAE,eAAe,uBAA+B,EAAE;YACpD,IAAI,CAAC,YAAY,GAAG,UAAU,CAAC;YAC/B,IAAI,CAAC,gBAAgB,wBAAgC;YACrD,OAAO,IAAI,CAAC;SACb;QACD,IAAI,EAAE,eAAe,2BAAmC,EAAE;YACxD,IAAI,CAAC,gBAAgB,GAAG,CAAC,UAAU,CAAC,CAAC;YACrC,IAAI,CAAC,gBAAgB,4BAAoC;YACzD,OAAO,IAAI,CAAC;SACb;QACD,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QACvC,OAAO,IAAI,CAAC;IACd,CAAC;IAED,SAAS,gBAAgB,CAAyD,UAA+B;QAC/G,MAAM,eAAe,GAAG,IAAI,CAAC,gBAAgB,CAAC;QAC9C,IAAI,CAAC,eAAe,2BAAmC,IAAI,CAAC,YAAY,KAAK,UAAU,EAAE;YACvF,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;YACzB,IAAI,CAAC,gBAAgB,IAAI,qBAA6B;YACtD,OAAO,IAAI,CAAC;SACb;QACD,IAAI,CAAC,eAAe,2BAAmC,IAAI,CAAC,YAAY,KAAK,UAAU,EAAE;YACvF,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;YACzB,IAAI,CAAC,gBAAgB,IAAI,qBAA6B;YACtD,OAAO,IAAI,CAAC;SACb;QACD,IAAI,CAAC,eAAe,2BAAmC,IAAI,CAAC,YAAY,KAAK,UAAU,EAAE;YACvF,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;YACzB,IAAI,CAAC,gBAAgB,IAAI,qBAA6B;YACtD,OAAO,IAAI,CAAC;SACb;QACD,IAAI,eAAe,4BAAoC;YACrD,MAAM,WAAW,GAAG,IAAI,CAAC,gBAAgB,CAAC;YAC1C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBACpD,IAAI,WAAW,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;oBACjC,WAAW,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;oBACzB,IAAI,EAAE,KAAK,CAAC,EAAE;wBACZ,IAAI,CAAC,gBAAgB,IAAI,yBAAiC;qBAC3D;oBACD,OAAO,IAAI,CAAC;iBACb;aACF;SACF;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAED,SAAS,uBAAuB,CAE9B,QAAgC,EAChC,aAAqC,EACrC,KAAqB;;;;;;;;QAQrB,MAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC;QACtC,MAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC;QACtC,MAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC;QACtC,IAAI,WAAW,GAAG,IAAI,CAAC,gBAAgB,CAAC;QACxC,IAAI,WAAW,KAAK,IAAI,EAAE;YACxB,WAAW,GAAG,WAAW,CAAC,KAAK,EAAE,CAAC;SACnC;QACD,IAAI,WAAW,KAAK,IAAI,EAAE;YACxB,WAAW,CAAC,YAAY,CAAC,QAAQ,EAAE,aAAa,EAAE,KAAK,CAAC,CAAC;SAC1D;QACD,IAAI,WAAW,KAAK,IAAI,EAAE;YACxB,WAAW,CAAC,YAAY,CAAC,QAAQ,EAAE,aAAa,EAAE,KAAK,CAAC,CAAC;SAC1D;QACD,IAAI,WAAW,KAAK,IAAI,EAAE;YACxB,WAAW,CAAC,YAAY,CAAC,QAAQ,EAAE,aAAa,EAAE,KAAK,CAAC,CAAC;SAC1D;QACD,MAAM,MAAM,GAAG,WAAW,IAAI,WAAW,CAAC,MAAM,CAAC;QACjD,IAAI,MAAM,KAAK,SAAS,IAAI,MAAM,GAAG,CAAC,EAAE;YACtC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;gBAC/B,MAAM,UAAU,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;gBAClC,IAAI,UAAU,KAAK,IAAI,EAAE;oBACvB,UAAU,CAAC,YAAY,CAAC,QAAQ,EAAE,aAAa,EAAE,KAAK,CAAC,CAAC;iBACzD;aACF;SACF;IACH,CAAC;IAED,SAAS,yBAAyB,CAAyH,MAAc,EAAE,IAAuB,EAAE,KAAqB;QACvN,MAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC;QACtC,MAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC;QACtC,MAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC;QACtC,IAAI,WAAW,GAAG,IAAI,CAAC,gBAAgB,CAAC;QACxC,IAAI,WAAW,KAAK,IAAI,EAAE;YACxB,WAAW,GAAG,WAAW,CAAC,KAAK,EAAE,CAAC;SACnC;QACD,IAAI,WAAW,KAAK,IAAI,EAAE;YACxB,WAAW,CAAC,YAAY,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;SAC/C;QACD,IAAI,WAAW,KAAK,IAAI,EAAE;YACxB,WAAW,CAAC,YAAY,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;SAC/C;QACD,IAAI,WAAW,KAAK,IAAI,EAAE;YACxB,WAAW,CAAC,YAAY,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;SAC/C;QACD,MAAM,MAAM,GAAG,WAAW,IAAI,WAAW,CAAC,MAAM,CAAC;QACjD,IAAI,MAAM,KAAK,SAAS,IAAI,MAAM,GAAG,CAAC,EAAE;YACtC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;gBAC/B,MAAM,UAAU,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;gBAClC,IAAI,UAAU,KAAK,IAAI,EAAE;oBACvB,UAAU,CAAC,YAAY,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;iBAC9C;aACF;SACF;QACD,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;IACpC,CAAC;IAED,SAAS,cAAc;QACrB,OAAO,IAAI,CAAC,gBAAgB,kBAA0B;IACxD,CAAC;IAED,SAAS,aAAa,CAAyD,UAA+B;;;;QAI5G,MAAM,eAAe,GAAG,IAAI,CAAC,gBAAgB,CAAC;QAC9C,IAAI,CAAC,eAAe,2BAAmC,IAAI,CAAC,YAAY,KAAK,UAAU,EAAE;YACvF,OAAO,IAAI,CAAC;SACb;QACD,IAAI,CAAC,eAAe,2BAAmC,IAAI,CAAC,YAAY,KAAK,UAAU,EAAE;YACvF,OAAO,IAAI,CAAC;SACb;QACD,IAAI,CAAC,eAAe,2BAAmC,IAAI,CAAC,YAAY,KAAK,UAAU,EAAE;YACvF,OAAO,IAAI,CAAC;SACb;QACD,IAAI,eAAe,4BAAoC;;YAErD,MAAM,WAAW,GAAG,IAAI,CAAC,gBAAgB,CAAC;YAC1C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBACpD,IAAI,WAAW,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;oBACjC,OAAO,IAAI,CAAC;iBACb;aACF;SACF;QACD,OAAO,KAAK,CAAC;IACf,CAAC;AAED,aAAgB,2BAA2B;QACzC,OAAO,UAAS,MAAgB;YAC9B,MAAM,KAAK,GAA0D,MAAM,CAAC,SAAS,CAAC;YAEtF,KAAK,CAAC,uBAAuB,gBAAwB;YACrD,KAAK,CAAC,mBAAmB,GAAG,IAAI,CAAC;YACjC,KAAK,CAAC,mBAAmB,GAAG,IAAI,CAAC;YACjC,KAAK,CAAC,mBAAmB,GAAG,IAAI,CAAC;YACjC,KAAK,CAAC,uBAAuB,GAAG,IAAI,CAAC;YAErC,KAAK,CAAC,oBAAoB,GAAG,oBAAoB,CAAC;YAClD,KAAK,CAAC,uBAAuB,GAAG,uBAAuB,CAAC;YACxD,KAAK,CAAC,oBAAoB,GAAG,oBAAoB,CAAC;YAClD,KAAK,CAAC,qBAAqB,GAAG,qBAAqB,CAAC;YACpD,KAAK,CAAC,sBAAsB,GAAG,gCAAgC,CAAC;SACjE,CAAC;IACJ,CAAC;IAED,SAAS,oBAAoB,CAA8D,UAAoE;QAC7J,IAAI,IAAI,CAAC,oBAAoB,CAAC,UAAU,CAAC,EAAE;YACzC,OAAO,KAAK,CAAC;SACd;QACD,MAAM,eAAe,GAAG,IAAI,CAAC,uBAAuB,CAAC;QACrD,IAAI,EAAE,eAAe,uBAA+B,EAAE;YACpD,IAAI,CAAC,mBAAmB,GAAG,UAAU,CAAC;YACtC,IAAI,CAAC,uBAAuB,wBAAgC;YAC5D,OAAO,IAAI,CAAC;SACb;QACD,IAAI,EAAE,eAAe,uBAA+B,EAAE;YACpD,IAAI,CAAC,mBAAmB,GAAG,UAAU,CAAC;YACtC,IAAI,CAAC,uBAAuB,wBAAgC;YAC5D,OAAO,IAAI,CAAC;SACb;QACD,IAAI,EAAE,eAAe,uBAA+B,EAAE;YACpD,IAAI,CAAC,mBAAmB,GAAG,UAAU,CAAC;YACtC,IAAI,CAAC,uBAAuB,wBAAgC;YAC5D,OAAO,IAAI,CAAC;SACb;QACD,IAAI,EAAE,eAAe,2BAAmC,EAAE;YACxD,IAAI,CAAC,uBAAuB,GAAG,CAAC,UAAU,CAAC,CAAC;YAC5C,IAAI,CAAC,uBAAuB,4BAAoC;YAChE,OAAO,IAAI,CAAC;SACb;QACD,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAC9C,OAAO,IAAI,CAAC;IACd,CAAC;IAED,SAAS,uBAAuB,CAA8D,UAAwC;QACpI,MAAM,eAAe,GAAG,IAAI,CAAC,uBAAuB,CAAC;QACrD,IAAI,CAAC,eAAe,2BAAmC,IAAI,CAAC,mBAAmB,KAAK,UAAU,EAAE;YAC9F,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;YAChC,IAAI,CAAC,uBAAuB,IAAI,qBAA6B;YAC7D,OAAO,IAAI,CAAC;SACb;QACD,IAAI,CAAC,eAAe,2BAAmC,IAAI,CAAC,mBAAmB,KAAK,UAAU,EAAE;YAC9F,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;YAChC,IAAI,CAAC,uBAAuB,IAAI,qBAA6B;YAC7D,OAAO,IAAI,CAAC;SACb;QACD,IAAI,CAAC,eAAe,2BAAmC,IAAI,CAAC,mBAAmB,KAAK,UAAU,EAAE;YAC9F,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;YAChC,IAAI,CAAC,uBAAuB,IAAI,qBAA6B;YAC7D,OAAO,IAAI,CAAC;SACb;QACD,IAAI,eAAe,4BAAoC;YACrD,MAAM,WAAW,GAAG,IAAI,CAAC,uBAAuB,CAAC;YACjD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBACpD,IAAI,WAAW,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;oBACjC,WAAW,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;oBACzB,IAAI,EAAE,KAAK,CAAC,EAAE;wBACZ,IAAI,CAAC,uBAAuB,IAAI,yBAAiC;qBAClE;oBACD,OAAO,IAAI,CAAC;iBACb;aACF;SACF;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAED,SAAS,gCAAgC,CAA8D,QAAkB;QACvH,MAAM,WAAW,GAAG,IAAI,CAAC,mBAAmB,CAAC;QAC7C,MAAM,WAAW,GAAG,IAAI,CAAC,mBAAmB,CAAC;QAC7C,MAAM,WAAW,GAAG,IAAI,CAAC,mBAAmB,CAAC;QAC7C,IAAI,WAAW,GAAG,IAAI,CAAC,uBAAuB,CAAC;QAC/C,IAAI,WAAW,KAAK,IAAI,EAAE;YACxB,WAAW,GAAG,WAAW,CAAC,KAAK,EAAE,CAAC;SACnC;QACD,IAAI,WAAW,KAAK,IAAI,EAAE;YACxB,WAAW,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CAAC;SAC3C;QACD,IAAI,WAAW,KAAK,IAAI,EAAE;YACxB,WAAW,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CAAC;SAC3C;QACD,IAAI,WAAW,KAAK,IAAI,EAAE;YACxB,WAAW,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CAAC;SAC3C;QACD,MAAM,MAAM,GAAG,WAAW,IAAI,WAAW,CAAC,MAAM,CAAC;QACjD,IAAI,MAAM,KAAK,SAAS,IAAI,MAAM,GAAG,CAAC,EAAE;YACtC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;gBAC/B,MAAM,UAAU,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;gBAClC,IAAI,UAAU,KAAK,IAAI,EAAE;oBACvB,UAAU,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CAAC;iBAC1C;aACF;SACF;IACH,CAAC;IAED,SAAS,qBAAqB;QAC5B,OAAO,IAAI,CAAC,uBAAuB,kBAA0B;IAC/D,CAAC;IAED,SAAS,oBAAoB,CAA8D,UAAwC;;;;QAIjI,MAAM,eAAe,GAAG,IAAI,CAAC,uBAAuB,CAAC;QACrD,IAAI,CAAC,eAAe,2BAAmC,IAAI,CAAC,mBAAmB,KAAK,UAAU,EAAE;YAC9F,OAAO,IAAI,CAAC;SACb;QACD,IAAI,CAAC,eAAe,2BAAmC,IAAI,CAAC,mBAAmB,KAAK,UAAU,EAAE;YAC9F,OAAO,IAAI,CAAC;SACb;QACD,IAAI,CAAC,eAAe,2BAAmC,IAAI,CAAC,mBAAmB,KAAK,UAAU,EAAE;YAC9F,OAAO,IAAI,CAAC;SACb;QACD,IAAI,eAAe,4BAAoC;;YAErD,MAAM,WAAW,GAAG,IAAI,CAAC,uBAAuB,CAAC;YACjD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBACpD,IAAI,WAAW,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;oBACjC,OAAO,IAAI,CAAC;iBACb;aACF;SACF;QACD,OAAO,KAAK,CAAC;IACf,CAAC;;IC/SD,SAAS,QAAQ,CAA8B,QAAgC,EAAE,KAAqB;QACpG,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;QACvC,QAAQ,GAAG,QAAQ,KAAK,IAAI,IAAI,QAAQ,KAAK,SAAS,GAAG,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC;QACtF,IAAI,YAAY,KAAK,QAAQ,EAAE;YAC7B,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC;YAC7B,IAAI,CAAC,KAAK,IAAID,sBAAc,CAAC,SAAS,GAAGA,sBAAc,CAAC,QAAQ,CAAC;gBAC/D,EAAE,CAAC,KAAK,GAAGA,sBAAc,CAAC,cAAc,KAAK,GAAG,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE;gBAC5E,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;aACpC;iBAAM;gBACL,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;gBAC1B,OAAO,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;aAC1C;SACF;QACD,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;IAC3B,CAAC;IAED,SAAS,KAAK,CAA8B,KAAqB;QAC/D,IAAI,KAAK,GAAGA,sBAAc,CAAC,cAAc,EAAE;YACzC,IAAI,GAAG,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;;gBAEhC,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;gBAClC,OAAO;aACR;SACF;QACD,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;;;QAGvC,IAAI,IAAI,CAAC,QAAQ,KAAK,YAAY,EAAE;YAClC,IAAI,CAAC,YAAY,CAAC,YAAY,EAAE,IAAI,CAAC,YAAY,GAAG,KAAK,GAAGA,sBAAc,CAAC,oBAAoB,CAAC,CAAC;YACjG,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC;SACnC;IACH,CAAC;IAED,SAAS,OAAO;QACd,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;QACzB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QACrB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;QAEzB,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC;QAChB,IAAI,CAAC,WAAW,GAAG,EAAE,CAAC;IACxB,CAAC;AAED,aAAgB,cAAc,CAAC,eAAuC,IAAI;QACxE,OAAO,UAAS,MAAgB;YAC9B,oBAAoB,CAACC,oBAAY,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,CAAC;YACpD,MAAM,KAAK,GAA0B,MAAM,CAAC,SAAS,CAAC;YAEtD,KAAK,CAAC,UAAU,GAAG,IAAI,CAAC;YAExB,KAAK,CAAC,YAAY,GAAG,YAAY,CAAC;YAClC,KAAK,CAAC,QAAQ,GAAG,YAAY,CAAC;YAC9B,KAAK,CAAC,YAAY,GAAG,YAAY,CAAC;YAElC,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC;YACjB,KAAK,CAAC,WAAW,GAAG,EAAE,CAAC;YAEvB,KAAK,CAAC,QAAQ,GAAG,KAAK,CAAC,QAAQ,IAAI,QAAQ,CAAC;YAC5C,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,KAAK,IAAI,KAAK,CAAC;YACnC,KAAK,CAAC,OAAO,GAAG,KAAK,CAAC,OAAO,IAAI,OAAO,CAAC;SAC1C,CAAC;IACJ,CAAC;;ICtED;IACA,MAAM,gBAAgB,GAAG,8BAA8B,CAAC;AAKxD,AAAaO,kCAAsB,GAAnC,MAAa,sBAAsB;;;;;;QAYjC,YACS,SAAqB,EACrB,GAAiB,EACjB,WAAmB,EACnB,aAAqB;YAHrB,cAAS,GAAT,SAAS,CAAY;YACrB,QAAG,GAAH,GAAG,CAAc;YACjB,gBAAW,GAAX,WAAW,CAAQ;YACnB,kBAAa,GAAb,aAAa,CAAQ;YAE5B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;SACrD;QAEM,QAAQ;YACb,OAAO,IAAI,CAAC,GAAG,CAAC,cAAc,CAAC,gBAAgB,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;SACtE;QAEM,YAAY,CAAC,QAAgB;YAClC,IAAI,CAAC,GAAG,CAAC,cAAc,CAAC,gBAAgB,EAAE,IAAI,CAAC,aAAa,EAAE,QAAQ,CAAC,CAAC;SACzE;KACF,CAAA;AA5BYA,kCAAsB;QADlC,cAAc,CAAC,EAAE,CAAC;OACNA,8BAAsB,CA4BlC;AAEDA,kCAAsB,CAAC,SAAS,CAAC,aAAa,GAAG,EAAE,CAAC;AAKpD,AAAaC,iCAAqB,GAAlC,MAAa,qBAAqB;QAKhC,YACS,SAAqB,EACrB,GAAU,EACV,WAAmB;YAFnB,cAAS,GAAT,SAAS,CAAY;YACrB,QAAG,GAAH,GAAG,CAAO;YACV,gBAAW,GAAX,WAAW,CAAQ;YAE1B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;SACrD;QAEM,QAAQ;YACb,OAAO,GAAG,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;SACrD;QAEM,YAAY,CAAC,QAAgB;YAClC,IAAI,QAAQ,KAAK,IAAI,EAAE;gBACrB,GAAG,CAAC,eAAe,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;aACjD;iBAAM;gBACL,GAAG,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;aACxD;SACF;KACF,CAAA;AAxBYA,iCAAqB;QADjC,cAAc,EAAE;OACJA,6BAAqB,CAwBjC;AAKYC,kCAAsB,GAAnC,MAAa,sBAAsB;QAUjC,YACS,SAAqB,EACrB,GAAiB;YADjB,cAAS,GAAT,SAAS,CAAY;YACrB,QAAG,GAAH,GAAG,CAAc;YAExB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,YAAY,GAAG,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC;SACvD;QAEM,QAAQ;YACb,OAAO,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC;SAC/B;;QAGM,YAAY,CAAC,KAAa,EAAE,KAAa;YAC9C,IAAI,QAAQ,GAAG,EAAE,CAAC;YAElB,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,IAAI,OAAO,KAAK,CAAC,OAAO,KAAK,UAAU,IAAI,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,EAAE;gBACtH,QAAQ,GAAG,WAAW,CAAC;gBACvB,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;aACzC;YAED,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,WAAW,CAAC,KAAK,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;SACpD;QAEM,YAAY,CAAC,QAA6B;YAC/C,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,IAAI,EAAE,CAAC;YACjC,IAAI,KAAK,CAAC;YACV,IAAI,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;YAE3B,IAAI,QAAQ,KAAK,IAAI,EAAE;gBACrB,IAAI,QAAQ,YAAY,MAAM,EAAE;oBAC9B,IAAI,KAAK,CAAC;oBACV,KAAK,KAAK,IAAa,QAAS,EAAE;wBAChC,IAAI,QAAQ,CAAC,cAAc,CAAC,KAAK,CAAC,EAAE;4BAClC,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;4BACxB,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC,IAAI,IAAI,CAAC,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;4BAC9D,MAAM,CAAC,KAAK,CAAC,GAAG,OAAO,CAAC;4BACxB,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;yBACjC;qBACF;iBACF;qBAAM,IAAa,QAAS,CAAC,MAAM,EAAE;oBACpC,MAAM,EAAE,GAAG,oMAAoM,CAAC;oBAChN,IAAI,IAAI,CAAC;oBACT,OAAO,CAAC,IAAI,GAAG,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,IAAI,EAAE;wBAC1C,KAAK,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;wBAChB,IAAI,CAAC,KAAK,EAAE;4BAAE,SAAS;yBAAE;wBAEzB,MAAM,CAAC,KAAK,CAAC,GAAG,OAAO,CAAC;wBACxB,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;qBACnC;iBACF;aACF;YAED,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;YACrB,IAAI,CAAC,OAAO,IAAI,CAAC,CAAC;YAClB,IAAI,OAAO,KAAK,CAAC,EAAE;gBACjB,OAAO;aACR;YAED,OAAO,IAAI,CAAC,CAAC;YACb,KAAK,KAAK,IAAI,MAAM,EAAE;gBACpB,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC,KAAK,OAAO,EAAE;oBAC9D,SAAS;iBACV;gBACD,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;aACtC;SACF;KACF,CAAA;AA5EYA,kCAAsB;QADlC,cAAc,EAAE;OACJA,8BAAsB,CA4ElC;AAEDA,kCAAsB,CAAC,SAAS,CAAC,MAAM,GAAG,IAAI,CAAC;AAC/CA,kCAAsB,CAAC,SAAS,CAAC,OAAO,GAAG,CAAC,CAAC;AAC7CA,kCAAsB,CAAC,SAAS,CAAC,WAAW,GAAG,OAAO,CAAC;AAKvD,AAAaC,kCAAsB,GAAnC,MAAa,sBAAsB;QASjC,YACS,SAAqB,EACrB,GAAU;YADV,cAAS,GAAT,SAAS,CAAY;YACrB,QAAG,GAAH,GAAG,CAAO;SAAK;QAEjB,QAAQ;YACb,OAAO,IAAI,CAAC,YAAY,CAAC;SAC1B;QAEM,YAAY,CAAC,QAAgB;YAClC,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,IAAI,EAAE,CAAC;YACvC,IAAI,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;YAC3B,IAAI,KAAK,CAAC;YACV,IAAI,IAAI,CAAC;;YAGT,IAAI,QAAQ,CAAC,MAAM,EAAE;gBACnB,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC;gBACtB,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;gBAC9B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,MAAM,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;oBACtD,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;oBAChB,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;wBAChB,SAAS;qBACV;oBACD,SAAS,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC;oBAC1B,GAAG,CAAC,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;iBAC1B;aACF;;YAGD,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;YAC3B,IAAI,CAAC,OAAO,IAAI,CAAC,CAAC;;YAGlB,IAAI,OAAO,KAAK,CAAC,EAAE;gBACjB,OAAO;aACR;;YAGD,OAAO,IAAI,CAAC,CAAC;YACb,KAAK,IAAI,IAAI,SAAS,EAAE;gBACtB,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,SAAS,CAAC,IAAI,CAAC,KAAK,OAAO,EAAE;oBAClE,SAAS;iBACV;;;;;gBAMD,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;aACjC;SACF;KACF,CAAA;AA5DYA,kCAAsB;QADlC,cAAc,CAAC,EAAE,CAAC;OACNA,8BAAsB,CA4DlC;AAEDA,kCAAsB,CAAC,SAAS,CAAC,UAAU,GAAG,IAAI,CAAC;AACnDA,kCAAsB,CAAC,SAAS,CAAC,OAAO,GAAG,CAAC,CAAC;AAC7CA,kCAAsB,CAAC,SAAS,CAAC,SAAS,GAAG,IAAI,CAAC;AAKlD,AAAaC,mCAAuB,GAApC,MAAa,uBAAuB;QAClC,YACS,SAAqB,EACrB,GAAe,EACf,WAAmB;YAFnB,cAAS,GAAT,SAAS,CAAY;YACrB,QAAG,GAAH,GAAG,CAAY;YACf,gBAAW,GAAX,WAAW,CAAQ;SAAK;QAE1B,QAAQ;YACb,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;SACnC;QAEM,YAAY,CAAC,KAA6B;YAC/C,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,KAAK,CAAC;SACpC;KACF,CAAA;AAbYA,mCAAuB;QADnC,cAAc,CAAC,EAAE,CAAC;OACNA,+BAAuB,CAanC;UAIY,gBAAgB;QAC3B,YAAmB,GAAe,EAAS,WAAmB;YAA3C,QAAG,GAAH,GAAG,CAAY;YAAS,gBAAW,GAAX,WAAW,CAAQ;SAAK;QAE5D,QAAQ;YACb,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;SACnC;QAEM,QAAQ,CAAC,KAA6B;YAC3C,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,KAAK,CAAC;SACpC;KACF;;AC1PYC,+BAAmB,GAAhC,MAAa,mBAAmB;QACvB,IAAI,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAgB;YAChE,OAAO,CAAC,cAAc,GAAG,IAAIJ,6BAAqB,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,cAAc,CAAC,CAAC;SAC7H;;QAGM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAgB,KAAW;KAChF,CAAA;AAPYI,+BAAmB;QAD/B,eAAe,CAAC,MAAM,CAAC;OACXA,2BAAmB,CAO/B;;ICdD;;;;;;;;AAQA,IAAA,WAAY,WAAW;QACrB,mDAAiB,CAAA;QACjB,iDAAiB,CAAA;QACjB,qDAAiB,CAAA;QACjB,iDAAiB,CAAA;QACjB,mDAAiB,CAAA;IACnB,CAAC,EANWC,mBAAW,KAAXA,mBAAW,QAMtB;;ICTD,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,GAAGA,mBAAW,CAAC;AAI1D,UAAsB,mBAAmB;QACvC,YAAoB,IAAiB;YAAjB,SAAI,GAAJ,IAAI,CAAa;SAAI;QAElC,IAAI,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA2B;YAC3E,OAAO,CAAC,YAAY,GAAG,OAAO,CAAC,IAAI,CAAC;YACpC,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;SAC1B;QAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA2B;YAC7E,OAAO,CAAC,IAAI,GAAG,OAAO,CAAC,YAAY,CAAC;YACpC,OAAO,CAAC,YAAY,GAAG,IAAI,CAAC;SAC7B;KACF;AAGD,AAAaC,kCAAsB,GAAnC,MAAa,sBAAuB,SAAQ,mBAAmB;QAC7D;YACE,KAAK,CAAC,OAAO,CAAC,CAAC;SAChB;KACF,CAAA;AAJYA,kCAAsB;QADlC,eAAe,CAAC,SAAS,CAAC;OACdA,8BAAsB,CAIlC;AAGYC,iCAAqB,GAAlC,MAAa,qBAAsB,SAAQ,mBAAmB;QAC5D;YACE,KAAK,CAAC,MAAM,CAAC,CAAC;SACf;KACF,CAAA;AAJYA,iCAAqB;QADjC,eAAe,CAAC,QAAQ,CAAC;OACbA,6BAAqB,CAIjC;AAGYC,mCAAuB,GAApC,MAAa,uBAAwB,SAAQ,mBAAmB;QAC9D;YACE,KAAK,CAAC,QAAQ,CAAC,CAAC;SACjB;KACF,CAAA;AAJYA,mCAAuB;QADnC,eAAe,CAAC,UAAU,CAAC;OACfA,+BAAuB,CAInC;AAGYC,iCAAqB,GAAlC,MAAa,qBAAsB,SAAQ,mBAAmB;QAC5D;YACE,KAAK,CAAC,MAAM,CAAC,CAAC;SACf;KACF,CAAA;AAJYA,iCAAqB;QADjC,eAAe,CAAC,QAAQ,CAAC;OACbA,6BAAqB,CAIjC;;IC7CD,MAAM,cAAc,GAAG,OAAO,CAAC,cAAc,CAAC;IAC9C;IACA;IACA;IACA,MAAM,0BAA0B,GAAuB;QACrD,GAAG,EAAE,SAAS;QACd,GAAG,EAAE,SAAS;QACd,UAAU,EAAE,IAAI;QAChB,YAAY,EAAE,IAAI;KACnB,CAAC;IAEF,SAAS,SAAS,CAAyB,UAA+B;QACxE,IAAI,IAAI,CAAC,SAAS,KAAK,KAAK,EAAE;YAC5B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;YACtB,MAAM,EAAE,GAAG,EAAE,WAAW,EAAE,GAAG,IAAI,CAAC;YAClC,IAAI,CAAC,YAAY,GAAG,GAAG,CAAC,WAAW,CAAC,CAAC;YACrC,0BAA0B,CAAC,GAAG,GAAG,MAAM,IAAI,CAAC,QAAQ,EAAE,CAAC;YACvD,0BAA0B,CAAC,GAAG,GAAG,KAAK,MAAM,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAElB,sBAAc,CAAC,oBAAoB,CAAC,CAAC,EAAE,CAAC;YACzG,IAAI,CAAC,cAAc,CAAC,GAAG,EAAE,WAAW,EAAE,0BAA0B,CAAC,EAAE;gBACjEO,eAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,WAAW,EAAE,GAAG,CAAC,CAAC;aACrC;SACF;QACD,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;IACjC,CAAC;IAED,SAASY,SAAO;QACd,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAClC,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC;QAChB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;QACxB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;IAC3B,CAAC;AAED,aAAgB,gBAAgB;QAC9B,OAAO,UAAS,MAAgB;YAC9B,oBAAoB,CAAClB,oBAAY,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,CAAC;YACpD,MAAM,KAAK,GAAqB,MAAM,CAAC,SAAS,CAAC;YAEjD,KAAK,CAAC,SAAS,GAAG,KAAK,CAAC;YACxB,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC;YACjB,KAAK,CAAC,WAAW,GAAG,IAAI,CAAC;;;;;;YAMzB,KAAK,CAAC,YAAY,GAAG,MAAM,EAAE,CAAC;YAE9B,KAAK,CAAC,SAAS,GAAG,KAAK,CAAC,SAAS,IAAI,SAAS,CAAC;YAC/C,KAAK,CAAC,WAAW,GAAG,KAAK,CAAC,WAAW,IAAI,KAAK,CAAC,gBAAgB,CAAC;YAEhE,KAAK,CAAC,OAAO,GAAG,KAAK,CAAC,OAAO,IAAIkB,SAAO,CAAC;SAC1C,CAAC;IACJ,CAAC;;ICpDD,MAAM,IAAI,GAAGhB,eAAQ,CAAC,IAAI,CAAC;IAE3B;IACA;IACA;AACA,UAAa,iBAAiB;QAa5B,YAAY,GAAc,EAAE,WAAwB;YAH7C,eAAU,GAAY,IAAI,CAAC;;YAKhC,IAAI,WAAW,KAAK,QAAQ,EAAE;;gBAE5B,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;gBACf,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC;aACtC;iBAAM;gBACL,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC;aACtC;SACF;QAEO,eAAe;YACrB,OAAgB,IAAI,CAAC,GAAI,CAAC,MAAM,CAAC;SAClC;QACO,eAAe;YACrB,OAAO,SAAS,CAAC;SAClB;KACF;IACD,iBAAiB,CAAC,SAAS,CAAC,QAAQ,GAAG,IAAI,CAAC;IAC5C,iBAAiB,CAAC,SAAS,CAAC,SAAS,GAAG,IAAI,CAAC;IAC7C,iBAAiB,CAAC,SAAS,CAAC,WAAW,GAAG,IAAI,CAAC;IAC/C,iBAAiB,CAAC,SAAS,CAAC,OAAO,GAAG,IAAI,CAAC;AAK3C,AAAaiB,0BAAc,GAA3B,MAAa,cAAc;QAMzB,YAAY,GAAe,EAAE,WAAmB;YAC9C,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;YACf,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;SAChC;QAEM,QAAQ;YACb,OAAO,IAAI,CAAC,YAAY,CAAC;SAC1B;QACM,QAAQ,CAAC,QAAgC,EAAE,KAAqB;YACrE,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;YACvC,IAAI,YAAY,KAAK,QAAQ,EAAE;gBAC7B,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC;gBAC7B,IAAI,EAAE,KAAK,GAAGpB,sBAAc,CAAC,QAAQ,CAAC,EAAE;oBACtC,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC;iBACrD;;;;;;;gBAOD,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;oBACnB,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,QAAQ,CAAC;iBACvC;aACF;SACF;KACF,CAAA;AAhCYoB,0BAAc;QAD1B,gBAAgB,EAAE;OACNA,sBAAc,CAgC1B;AAKYC,oBAAQ,GAArB,MAAa,QAAQ;QAOnB,YACE,QAAgB,EAChB,YAAoB,EACpB,YAAoB;YAElB,IAAI,CAAC,GAAG,GAAG,QAAQ,CAAC;YACpB,IAAI,CAAC,WAAW,GAAG,YAAY,CAAC;YAChC,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC,YAAY,CAAC,CAAC;YAC3C,IAAI,CAAC,QAAQ,GAAG,YAAY,IAAI,QAAQ;kBACpC,QAAQ,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC;kBACrC,IAAI,CAAC;SACZ;QAEM,QAAQ;YACb,OAAO,IAAI,CAAC,YAAY,CAAC;SAC1B;QAEM,QAAQ,CAAC,QAAgC,EAAE,KAAqB;YACrE,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;YAEvC,IAAI,YAAY,KAAK,QAAQ,EAAE;gBAC7B,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC;gBAE7B,IAAI,EAAE,KAAK,GAAGrB,sBAAc,CAAC,QAAQ,CAAC,EAAE;oBACtC,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,YAAY,CAAC,CAAC;oBAE3D,IAAI,YAAY,KAAK,SAAS,EAAE;wBAC9B,IAAI,CAAC,YAAY,GAAG,QAAQ,GAAG,YAAY,CAAC;qBAC7C;oBAED,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC;iBACrD;aACF;SACF;KACF,CAAA;AAzCYqB,oBAAQ;QADpB,gBAAgB,EAAE;OACNA,gBAAQ,CAyCpB;;IClHD;AACA,UAAa,uBAAuB;QAC3B,WAAW,CAAC,GAAuC,EAAE,GAAW;YACrE,IAAI,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC;YACzB,IAAI,QAAQ,KAAK,SAAS,EAAE;gBAC1B,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,IAAID,sBAAc,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;aACrD;YACD,OAAO,QAAQ,CAAC;SACjB;KACF;AAED,UAAa,cAAc;QAOzB,YAAoB,QAA8B,EAAE,KAAyD;YAJ7F,eAAU,GAAS,IAAI,CAAC;YAKtC,IAAI,QAAQ,KAAK,SAAS,EAAE;gBAC1B,IAAI,KAAK,KAAK,SAAS,EAAE;;;oBAGvB,IAAI,CAAM,QAAQ,CAAC,GAAG,KAAK,CAAC;iBAC7B;qBAAM;;oBAEL,KAAK,MAAM,IAAI,IAAgB,QAAQ,EAAE;wBACvC,IAAI,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE;4BACjC,IAAI,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;yBAC7B;qBACF;iBACF;aACF;SACF;QAIM,OAAO,MAAM,CAAC,QAA8B,EAAE,KAAyD;YAC5G,OAAO,IAAI,cAAc,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;SAC5C;;QAGM,OAAO,GAAG,CAAC,KAAa,EAAE,IAAY,EAAE,QAAgB;YAC7D,IAAI,KAAK,KAAK,SAAS,EAAE;gBACvB,MAAMb,eAAQ,CAAC,KAAK,0BAA6B,CAAC;aACnD;YACD,IAAI,KAAK,KAAK,IAAI,EAAE;gBAClB,MAAMA,eAAQ,CAAC,KAAK,qBAAwB,CAAC;aAC9C;YACD,IAAI,eAAe,GAAG,KAAK,CAAC,eAAe,CAAC;YAE5C,IAAI,QAAQ,GAAG,CAAC,EAAE;;gBAEhB,OAAO,QAAQ,GAAG,CAAC,EAAE;oBACnB,IAAI,eAAe,CAAC,qBAAqB,KAAK,IAAI,EAAE;wBAClD,OAAO,SAAS,CAAC;qBAClB;oBACD,QAAQ,EAAE,CAAC;oBACX,eAAe,GAAG,eAAe,CAAC,qBAAqB,CAAC;iBACzD;gBAED,OAAO,IAAI,IAAI,eAAe,GAAG,eAAe,GAAG,eAAe,CAAC,cAAc,CAAC;aACnF;;YAGD,OAAO,eAAe,IAAI,EAAE,IAAI,IAAI,eAAe,CAAC,IAAI,EAAE,eAAe,CAAC,cAAc,IAAI,IAAI,IAAI,eAAe,CAAC,cAAc,CAAC,EAAE;gBACnI,eAAe,GAAG,eAAe,CAAC,qBAAqB,CAAC;aACzD;YAED,IAAI,eAAe,EAAE;;gBAEnB,OAAO,IAAI,IAAI,eAAe,GAAG,eAAe,GAAG,eAAe,CAAC,cAAc,CAAC;aACnF;;YAGD,OAAO,KAAK,CAAC,cAAc,IAAI,KAAK,CAAC,eAAe,CAAC;SACtD;QAEM,YAAY;YACjB,IAAI,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC;YAChC,IAAI,SAAS,KAAK,SAAS,EAAE;gBAC3B,IAAI,CAAC,UAAU,GAAG,SAAS,GAAG,IAAI,uBAAuB,EAA2B,CAAC;aACtF;YACD,OAAO,SAAS,CAAC;SAClB;KACF;AAED,UAAa,KAAK;QAChB,YACkB,cAA4C,EAC5C,eAAiC;YADjC,mBAAc,GAAd,cAAc,CAA8B;YAC5C,oBAAe,GAAf,eAAe,CAAkB;SAC9C;QAEE,OAAO,MAAM,CAAC,EAAgC,EAAE,EAA2B;YAChF,OAAO,IAAI,KAAK,CAAC,EAAE,EAAE,EAAE,KAAK,IAAI,IAAI,EAAE,KAAK,SAAS,GAAG,eAAe,CAAC,MAAM,CAAC,EAAE,EAAE,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC;SAC7F;QAEM,OAAO,YAAY,CAAC,EAAoB;YAC7C,IAAI,EAAE,KAAK,IAAI,IAAI,EAAE,KAAK,SAAS,EAAE;gBACnC,MAAMA,eAAQ,CAAC,KAAK,8BAAiC,CAAC;aACvD;YACD,OAAO,IAAI,KAAK,CAAC,EAAE,CAAC,cAAc,EAAE,EAAE,CAAC,CAAC;SACzC;QAEM,OAAO,UAAU,CAAC,EAAU,EAAE,EAAgC;YACnE,IAAI,EAAE,KAAK,IAAI,IAAI,EAAE,KAAK,SAAS,EAAE;gBACnC,MAAMA,eAAQ,CAAC,KAAK,0BAA6B,CAAC;aACnD;YACD,OAAO,IAAI,KAAK,CAAC,EAAE,EAAE,eAAe,CAAC,MAAM,CAAC,EAAE,EAAE,EAAE,CAAC,eAAe,CAAC,CAAC,CAAC;SACtE;KACF;AAED,UAAa,eAAe;QAK1B,YACkB,cAA4C,EAC5C,qBAA8C;YAD9C,mBAAc,GAAd,cAAc,CAA8B;YAC5C,0BAAqB,GAArB,qBAAqB,CAAyB;YAJhD,eAAU,GAAS,IAAI,CAAC;SAKnC;QAEE,OAAO,MAAM,CAAC,EAAgC,EAAE,GAA4B;YACjF,OAAO,IAAI,eAAe,CAAC,EAAE,EAAE,GAAG,KAAK,SAAS,GAAG,IAAI,GAAG,GAAG,CAAC,CAAC;SAChE;QAEM,YAAY;YACjB,IAAI,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC;YAChC,IAAI,SAAS,KAAK,SAAS,EAAE;gBAC3B,IAAI,CAAC,UAAU,GAAG,SAAS,GAAG,IAAI,uBAAuB,EAAE,CAAC;aAC7D;YACD,OAAO,SAA8C,CAAC;SACvD;KACF;;UCrIY,SAAS,GAAGL,SAAE,CAAC,eAAe,EAAa,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC;IAEjG;AACA,UAAa,QAAQ;QAGnB;YACE,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;SACpC;QAEM,cAAc,CAAC,IAAY,EAAE,KAAsB;YACxD,MAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YACrC,IAAI,SAAS,KAAK,SAAS,EAAE;gBAC3B,OAAO;aACR;YACD,KAAK,MAAM,QAAQ,IAAI,SAAS,CAAC,IAAI,EAAE,EAAE;gBACvC,QAAQ,CAAC,YAAY,CAAC,SAAS,EAAE,SAAS,EAAE,KAAK,GAAGF,sBAAc,CAAC,oBAAoB,CAAC,CAAC;aAC1F;SACF;QAEM,iBAAiB,CAAC,IAAY,EAAE,QAA6B;YAClE,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;YAC7B,MAAM,SAAS,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;YAChC,IAAI,SAAS,KAAK,SAAS,EAAE;gBAC3B,OAAO,CAAC,IAAI,CAAC,GAAG,IAAI,GAAG,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;aACrC;iBAAM;gBACL,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;aACzB;SACF;QAEM,oBAAoB,CAAC,IAAY,EAAE,QAA6B;YACrE,MAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YACrC,IAAI,SAAS,EAAE;gBACb,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;aAC5B;SACF;KACF;;aCvCe,cAAc,CAAC,YAA4C;QACzE,OAAO,UAAkC,MAAS;YAChD,OAAO,sBAAsB,CAAC,MAAM,CAAC,YAAY,EAAE,MAAM,CAAC,CAAC;SAC5D,CAAC;IACJ,CAAC;AAED,UAAa,sBAAsB,GAA8D;QAC/F,IAAI,EAAE,iBAAiB;QAEvB,OAAO,CAAC,IAAY;YAClB,OAAO,GAAG,IAAI,CAAC,IAAI,IAAI,IAAI,EAAE,CAAC;SAC/B;QAED,MAAM,CAA0B,IAAO;YACrC,OAAQ,IAAgC,CAAC,IAAI,KAAK,IAAI,CAAC;SACxD;QAED,MAAM,CAA0B,YAA4C,EAAE,IAAO;YACnF,MAAM,IAAI,GAAG,IAA+B,CAAC;YAC7C,MAAM,WAAW,GAAG,OAAO,YAAY,KAAK,QAAQ;kBAChD,EAAE,IAAI,EAAE,YAAY,EAAE;kBACtB,YAAY,CAAC;YAEhB,IAAsC,CAAC,IAAI,GAAG,sBAAsB,CAAC;YACrE,IAAsC,CAAC,WAAW,GAAG,WAAW,CAAC;YAClE,IAAI,CAAC,QAAQ,GAAGsB,UAAQ,CAAC;YAEzB,OAAO,IAAI,CAAC;SACb;KACF,CAAC;IAEF,SAASA,UAAQ,CAA4B,SAAqB;QAChE,SAAS,CAAC,QAAQ,CAChBjB,mBAAY,CAAC,SAAS,CACpB,sBAAsB,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,EACrD,IAAI,CACL,CACF,CAAC;IACJ,CAAC;;aCyEe,QAAQ,CAAC,IAA6B;QACpD,OAAO,CAAC,IAAI,CAAC,KAAK,4CAAwD;IAC5E,CAAC;AACD,aAAgB,QAAQ,CAAC,IAA6B;QACpD,OAAO,CAAC,IAAI,CAAC,KAAK,4CAAwD;IAC5E,CAAC;AACD,aAAgB,aAAa,CAAC,IAA6B;QACzD,OAAO,CAAC,IAAI,CAAC,KAAK,wDAAkE;IACtF,CAAC;AACD,aAAgB,WAAW,CAAC,IAA6B;QACvD,OAAO,CAAC,IAAI,CAAC,KAAK,oDAA8D;IAClF,CAAC;AACD,aAAgB,YAAY,CAAC,IAA6B;QACxD,OAAO,CAAC,IAAI,CAAC,KAAK,wDAAgE;IACpF,CAAC;AACD,aAAgB,cAAc,CAAC,IAA6B;QAC1D,OAAO,CAAC,IAAI,CAAC,KAAK,4DAAoE;IACxF,CAAC;AACD,aAAgB,SAAS,CAAC,IAA6B;QACrD,OAAO,CAAC,IAAI,CAAC,KAAK,gDAA0D;IAC9E,CAAC;AACD,aAAgB,UAAU,CAAC,IAA6B;QACtD,OAAO,CAAC,IAAI,CAAC,KAAK,sDAA4D;IAChF,CAAC;AACD,aAAgB,OAAO,CAAC,IAA6B;QACnD,OAAO,CAAC,IAAI,CAAC,KAAK,8CAAsD;IAC1E,CAAC;AACD,aAAgB,SAAS,CAAC,IAA6B;QACrD,OAAO,CAAC,IAAI,CAAC,KAAK,kDAA0D;IAC9E,CAAC;AACD,aAAgB,SAAS,CAAC,IAA6B;QACrD,OAAO,CAAC,IAAI,CAAC,KAAK,oDAA0D;IAC9E,CAAC;AACD,aAAgB,eAAe,CAAC,WAAmD;QACjF,IAAI,WAAW,KAAK,SAAS,IAAI,WAAW,CAAC,MAAM,KAAK,CAAC,EAAE;YACzD,OAAO,IAAI,CAAC;SACb;QACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;YAC3C,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,EAAE;gBAClC,OAAO,KAAK,CAAC;aACd;SACF;QACD,OAAO,IAAI,CAAC;IACd,CAAC;AACD,aAAgB,aAAa,CAAC,IAA6B;QACzD,IAAI,SAAS,CAAC,IAAI,CAAC,EAAE;YACnB,QAAQ,IAAI,CAAC,KAAK;gBAChB;oBACE,OAAO,eAAe,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBACxC;oBACE,OAAO,eAAe,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBACtC;oBACE,OAAO,eAAe,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;gBAC3C;oBACE,OAAO,IAAI,CAAC;aACf;SACF;QACD,OAAO,KAAK,CAAC;IACf,CAAC;AAcD,UAAa,eAAe;QAK1B,YACkB,UAA6B,EAC7B,IAAY,EACZ,IAA6B;YAF7B,eAAU,GAAV,UAAU,CAAmB;YAC7B,SAAI,GAAJ,IAAI,CAAQ;YACZ,SAAI,GAAJ,IAAI,CAAyB;YAC7C,IAAI,CAAC,WAAW,GAAG,uBAAuB,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAC9D,IAAI,CAAC,iBAAiB,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC;YAC7C,IAAI,CAAC,mBAAmB,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC;SAClD;QAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;YAC5E,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;SACxD;QAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB,EAAE,KAAgB;YAC5F,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;SAC7D;QAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;YAC/E,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;SAChD;QAEM,IAAI,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;YAC5E,IAAI,KAAK,KAAK,SAAS,EAAE;gBACvB,MAAME,eAAQ,CAAC,KAAK,2BAA8B,IAAI,CAAC,CAAC;aACzD;YACD,IAAI,KAAK,KAAK,IAAI,EAAE;gBAClB,MAAMA,eAAQ,CAAC,KAAK,sBAAyB,IAAI,CAAC,CAAC;aACpD;YACD,IAAI,CAAC,OAAO,EAAE;gBACZ,MAAMA,eAAQ,CAAC,KAAK,sBAAyB,IAAI,CAAC,CAAC;aACpD;YACD,MAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;YAChC,IAAI,CAAC,OAAO,EAAE;gBACZ,MAAMA,eAAQ,CAAC,KAAK,sBAAyB,IAAI,CAAC,CAAC;aACpD;YACD,IAAI,IAAI,CAAC,iBAAiB,EAAE;gBACzB,IAAI,CAAC,UAA8B,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;aAClE;YACD,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;YACrC,MAAM,QAAQ,GAAG,OAAO,CAAC,GAAG,CAAkB,WAAW,CAAC,CAAC;YAC3D,IAAI,CAAC,QAAQ,EAAE;gBACb,MAAMA,eAAQ,CAAC,KAAK,4BAA+B,IAAI,CAAC,CAAC;aAC1D;YACD,IAAI,OAAO,CAAC,WAAW,CAAC,KAAK,SAAS,IAAI,OAAO,CAAC,WAAW,CAAC,KAAK,IAAI,EAAE;gBACvE,MAAMA,eAAQ,CAAC,KAAK,mCAAsC,IAAI,CAAC,CAAC;aACjE;YACD,OAAO,CAAC,WAAW,CAAC,GAAG,QAAQ,CAAC;YAChC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAgB,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;SAC1H;QAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;YAC9E,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;YACrC,OAAO,CAAC,WAAW,CAAC,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;YACnD,OAAO,CAAC,WAAW,CAAC,GAAG,IAAI,CAAC;YAC5B,IAAI,IAAI,CAAC,mBAAmB,EAAE;gBAC3B,IAAI,CAAC,UAA+C,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;aACrF;SACF;QAEM,MAAM,CAAI,OAAoB;YACnC,OAAO,OAAO,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC;SAC3C;KACF;AAED,UAAa,cAAc;QAGzB,YACkB,UAA4B,EAC5B,IAAY,EACZ,IAA6B;YAF7B,eAAU,GAAV,UAAU,CAAkB;YAC5B,SAAI,GAAJ,IAAI,CAAQ;YACZ,SAAI,GAAJ,IAAI,CAAyB;YAC7C,IAAI,CAAC,YAAY,GAAG,sBAAsB,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAC/D;QAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;YAC5E,IAAI,CAAC,OAAO,EAAE;gBACZ,MAAMA,eAAQ,CAAC,KAAK,sBAAyB,IAAI,CAAC,CAAC;aACpD;YACD,MAAM,SAAS,GAAG,OAAO,CAAC,GAAG,CAAiE,IAAI,CAAC,YAAY,CAAC,CAAC;YACjH,IAAI,CAAC,SAAS,EAAE;gBACd,MAAMA,eAAQ,CAAC,KAAK,6BAAgC,IAAI,CAAC,CAAC;aAC3D;YACD,IAAI,QAAQ,IAAI,SAAS,EAAE;gBACzB,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;gBACvB,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;gBACxB,MAAM,MAAM,GAAG,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;gBAC9B,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;gBAC5D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,EAAE,CAAC,EAAE;oBAC5B,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;iBACzD;gBACD,OAAO,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;aAClD;YACD,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;SACxD;QAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB,EAAE,KAAgB;YAC5F,IAAI,CAAC,OAAO,EAAE;gBACZ,MAAMA,eAAQ,CAAC,KAAK,sBAAyB,IAAI,CAAC,CAAC;aACpD;YACD,MAAM,SAAS,GAAG,OAAO,CAAC,GAAG,CAAmE,IAAI,CAAC,YAAY,CAAC,CAAC;YACnH,IAAI,CAAC,SAAS,EAAE;gBACd,MAAMA,eAAQ,CAAC,KAAK,6BAAgC,IAAI,CAAC,CAAC;aAC3D;YACD,IAAI,UAAU,IAAI,SAAS,EAAE;gBAC3B,KAAK,GAAG,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC,SAAS,EAAE,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;aACzG;YACD,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;SAC7D;QAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;YAC/E,IAAI,KAAK,KAAK,SAAS,EAAE;gBACvB,MAAMA,eAAQ,CAAC,KAAK,2BAA8B,IAAI,CAAC,CAAC;aACzD;YACD,IAAI,KAAK,KAAK,IAAI,EAAE;gBAClB,MAAMA,eAAQ,CAAC,KAAK,sBAAyB,IAAI,CAAC,CAAC;aACpD;YACD,IAAI,CAAC,OAAO,EAAE;gBACZ,MAAMA,eAAQ,CAAC,KAAK,sBAAyB,IAAI,CAAC,CAAC;aACpD;YACD,MAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;YAChC,IAAI,CAAC,OAAO,EAAE;gBACZ,MAAMA,eAAQ,CAAC,KAAK,sBAAyB,IAAI,CAAC,CAAC;aACpD;YACD,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;YAC/C,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;YACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBAC7C,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;aACxC;YACD,MAAM,SAAS,GAAG,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,YAAY,CAA2B,CAAC;YAC3E,IAAI,CAAC,SAAS,EAAE;gBACd,MAAMA,eAAQ,CAAC,KAAK,6BAAgC,IAAI,CAAC,CAAC;aAC3D;YACD,MAAM,OAAO,GAAG,SAAS,CAAC,OAAO,CAAC;YAClC,IAAI,OAAO,KAAK,SAAS,EAAE;gBACzB,OAAO;aACR;YACD,MAAM,QAAQ,GAAG,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;YACxC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBAChD,QAAQ,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;aACjD;SACF;QAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;YAC9E,MAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;YAChC,MAAM,SAAS,GAAG,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,YAAY,CAA2B,CAAC;YAC3E,MAAM,OAAO,GAAG,SAAS,CAAC,OAAO,CAAC;YAClC,IAAI,OAAO,KAAK,SAAS,EAAE;gBACzB,OAAO;aACR;YACD,MAAM,QAAQ,GAAG,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;YACxC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBAChD,QAAQ,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;aACpD;SACF;QAEM,MAAM,CAAI,OAAoB;YACnC,OAAO,OAAO,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;SAC1C;KACF;AAED,UAAa,MAAM;QAEjB,YACkB,MAAoB,EACpB,KAAe;YADf,WAAM,GAAN,MAAM,CAAc;YACpB,UAAK,GAAL,KAAK,CAAU;SAAK;QAE/B,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;YAC5E,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC,CAAC;SAC9F;QAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;YAC/E,OAAO;SACR;QAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB,EAAE,KAAgB;YAC5F,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;YAChD,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;SACzD;QAEM,MAAM,CAAI,OAAoB;YACnC,OAAO,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;SAClC;KACF;AAED,UAAa,WAAW;QAGtB,YACkB,SAAmB,EACnB,GAAa,EACb,EAAY;YAFZ,cAAS,GAAT,SAAS,CAAU;YACnB,QAAG,GAAH,GAAG,CAAU;YACb,OAAE,GAAF,EAAE,CAAU;SAAK;QAE5B,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;YAC5E,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC;kBACpD,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC;kBACxC,IAAI,CAAC,EAAE,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;SAC7C;QAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;YAC/E,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;YACjC,IAAI,SAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE;gBAC1C,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;gBAC9C,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;aACzC;iBAAM;gBACL,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;gBAC9C,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;aACxC;SACF;QAEM,MAAM,CAAI,OAAoB;YACnC,OAAO,OAAO,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;SACvC;KACF;AAED,UAAa,UAAU;QAMrB,YACkB,WAAmB,CAAC;YAApB,aAAQ,GAAR,QAAQ,CAAY;SAAK;QAEpC,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;YAC5E,IAAI,KAAK,KAAK,SAAS,EAAE;gBACvB,MAAMA,eAAQ,CAAC,KAAK,2BAA8B,IAAI,CAAC,CAAC;aACzD;YACD,IAAI,KAAK,KAAK,IAAI,EAAE;gBAClB,MAAMA,eAAQ,CAAC,KAAK,sBAAyB,IAAI,CAAC,CAAC;aACpD;YACD,IAAI,EAAE,GAAG,KAAK,CAAC,eAAe,CAAC;YAC/B,IAAI,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC;YACtB,OAAO,CAAC,EAAE,IAAI,EAAE,EAAE;gBAChB,EAAE,GAAG,EAAE,CAAC,qBAAqB,CAAC;aAC/B;YACD,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,EAAE,CAAC,cAAc,GAAG,SAAS,CAAC;SACpD;QAEM,MAAM,CAAI,OAAoB;YACnC,OAAO,OAAO,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;SACtC;;IAzBsB,gBAAK,GAAe,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC;IACtC,kBAAO,GAAe,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC;AA2BjE,UAAa,WAAW;QAEtB,YACkB,IAAY,EACZ,WAAmB,CAAC;YADpB,SAAI,GAAJ,IAAI,CAAQ;YACZ,aAAQ,GAAR,QAAQ,CAAY;SAAK;QAEpC,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;YAC5E,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;YACvB,OAAO,cAAc,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,CAAC;SAC7D;QAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB,EAAE,KAAgB;YAC5F,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;YACvB,MAAM,OAAO,GAAG,cAAc,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC/D,OAAO,OAAO,IAAI,OAAO,CAAC,IAAI,CAAC,GAAG,KAAK,IAAI,SAAS,CAAC;SACtD;QAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;YAC/E,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;YACvB,MAAM,OAAO,GAAG,cAAc,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC/D,OAAO,CAAC,eAAe,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;SACxC;QAEM,MAAM,CAAI,OAAoB;YACnC,OAAO,OAAO,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;SACvC;KACF;AAED,UAAa,YAAY;QAEvB,YACkB,MAAsB,EACtB,IAAY;YADZ,WAAM,GAAN,MAAM,CAAgB;YACtB,SAAI,GAAJ,IAAI,CAAQ;SAAK;QAE5B,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;YAC5E,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;YAC7D,OAAO,QAAQ,KAAK,IAAI,IAAI,QAAQ,KAAK,SAAS,GAAG,QAAQ,GAAG,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACrF;QAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB,EAAE,KAAgB;YAC5F,IAAI,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;YAC3D,IAAI,QAAQ,KAAK,IAAI,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;gBACrD,QAAQ,GAAG,EAAE,CAAC;gBACd,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;aACrD;YACD,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;YAC5B,OAAO,KAAK,CAAC;SACd;QAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;YAC/E,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;YACrD,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;YAC3C,IAAI,GAAG,EAAE;gBACP,OAAO,CAAC,eAAe,CAAC,GAAG,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;aACzC;SACF;QAEM,MAAM,CAAI,OAAoB;YACnC,OAAO,OAAO,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;SACxC;KACF;AAED,UAAa,WAAW;QAEtB,YACkB,MAAsB,EACtB,GAAa;YADb,WAAM,GAAN,MAAM,CAAgB;YACtB,QAAG,GAAH,GAAG,CAAU;SAAK;QAE7B,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;YAC5E,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;YAC7D,IAAI,QAAQ,KAAK,IAAI,IAAI,QAAQ,KAAK,SAAS,EAAE;gBAC/C,OAAO,SAAS,CAAC;aAClB;YACD,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;;;;YAIrD,OAAO,QAAQ,CAAM,GAAG,CAAC,CAAC;SAC3B;QAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB,EAAE,KAAgB;YAC5F,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;YAC7D,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;;YAErD,OAAO,QAAQ,CAAM,GAAG,CAAC,GAAG,KAAK,CAAC;SACnC;QAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;YAC/E,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;YACrD,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;YAC3C,IAAI,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,KAAK,IAAI,EAAE;gBAC3C,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;gBACxC,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;;;gBAGlD,IAAI,EAAE,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,SAAS,CAAC,GAAG,CAAC,CAAC,EAAE;oBAC3C,OAAO,CAAC,eAAe,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;iBACnC;aACF;SACF;QAEM,MAAM,CAAI,OAAoB;YACnC,OAAO,OAAO,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;SACvC;KACF;AAED,UAAa,SAAS;QAGpB,YACkB,IAAY,EACZ,IAA6B,EAC7B,WAAmB,CAAC;YAFpB,SAAI,GAAJ,IAAI,CAAQ;YACZ,SAAI,GAAJ,IAAI,CAAyB;YAC7B,aAAQ,GAAR,QAAQ,CAAY;SAAK;QAEpC,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA+B;YACnF,MAAM,IAAI,GAAG,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;YACxD,MAAM,OAAO,GAAG,cAAc,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;YACpE,MAAM,IAAI,GAAG,WAAW,CAAC,KAAK,EAAE,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;YACpD,IAAI,IAAI,EAAE;gBACR,OAAO,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;aAClC;YACD,OAAO,SAAS,CAAC;SAClB;QAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;YAC/E,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;YACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBAC7C,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;aACxC;SACF;QAEM,MAAM,CAAI,OAAoB;YACnC,OAAO,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;SACrC;KACF;AAED,UAAa,UAAU;QAGrB,YACkB,MAAsB,EACtB,IAAY,EACZ,IAA6B;YAF7B,WAAM,GAAN,MAAM,CAAgB;YACtB,SAAI,GAAJ,IAAI,CAAQ;YACZ,SAAI,GAAJ,IAAI,CAAyB;SAAK;QAE7C,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;YAC5E,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;YAC7D,MAAM,IAAI,GAAG,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;YACxD,MAAM,IAAI,GAAG,WAAW,CAAC,KAAK,EAAE,QAAQ,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;YACrD,IAAI,IAAI,EAAE;gBACR,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;aACnC;YACD,OAAO,SAAS,CAAC;SAClB;QAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;YAC/E,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;YACrD,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;YAC3C,IAAI,WAAW,CAAC,KAAK,GAAG,CAACP,sBAAc,CAAC,YAAY,EAAE,GAAG,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE;gBACrE,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;gBACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;oBAC7C,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;iBACxC;aACF;SACF;QAEM,MAAM,CAAI,OAAoB;YACnC,OAAO,OAAO,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;SACtC;KACF;AAED,UAAa,YAAY;QAGvB,YACkB,IAAoB,EACpB,IAA6B;YAD7B,SAAI,GAAJ,IAAI,CAAgB;YACpB,SAAI,GAAJ,IAAI,CAAyB;SAAK;QAE7C,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;YAC5E,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAc,CAAC;YACpE,IAAI,OAAO,IAAI,KAAK,UAAU,EAAE;gBAC9B,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;aACrE;YACD,IAAI,EAAE,KAAK,GAAGA,sBAAc,CAAC,YAAY,CAAC,KAAK,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,SAAS,CAAC,EAAE;gBACnF,OAAO,SAAS,CAAC;aAClB;YACD,MAAMO,eAAQ,CAAC,KAAK,yBAA4B,IAAI,CAAC,CAAC;SACvD;QAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;YAC/E,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;YACpD,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;YACzC,IAAI,OAAO,IAAI,KAAK,UAAU,EAAE;gBAC9B,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;gBACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;oBAC7C,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;iBACxC;aACF;SACF;QAEM,MAAM,CAAI,OAAoB;YACnC,OAAO,OAAO,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;SACxC;KACF;AAID,UAAa,MAAM;QAGjB,YACkB,SAAyB,EACzB,IAAc,EACd,KAAe;YAFf,cAAS,GAAT,SAAS,CAAgB;YACzB,SAAI,GAAJ,IAAI,CAAU;YACd,UAAK,GAAL,KAAK,CAAU;;;;YAI/B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC;SACjC;QAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;YAC5E,MAAMA,eAAQ,CAAC,KAAK,4BAA+B,IAAI,CAAC,CAAC;SAC1D;QAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;YAC/E,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;YACpD,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;YACzC,IAAI,IAAI,CAAC,SAAS,KAAK,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,SAAS,KAAK,IAAI,IAAI,IAAI,EAAE;gBACvE,OAAO;aACR;YACD,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;SAC3C;QAEO,CAAC,IAAI,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;YAC7D,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;SACpE;QACO,CAAC,IAAI,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;YAC7D,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;SACpE;QACO,CAAC,IAAI,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;;YAE7D,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;SACpE;QACO,CAAC,KAAK,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;YAC9D,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;SACrE;QACO,CAAC,IAAI,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;;YAE7D,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;SACpE;QACO,CAAC,KAAK,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;YAC9D,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;SACrE;QACO,CAAC,YAAY,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;YACrE,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;YAC3C,IAAI,OAAO,KAAK,KAAK,UAAU,EAAE;gBAC/B,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,YAAY,KAAK,CAAC;aACrD;YACD,OAAO,KAAK,CAAC;SACd;QACO,CAAC,IAAI,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;YAC7D,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;YAC3C,IAAI,KAAK,KAAK,IAAI,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;gBAC/C,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,IAAI,KAAK,CAAC;aAC7C;YACD,OAAO,KAAK,CAAC;SACd;;;;;QAKO,CAAC,GAAG,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;;YAE5D,OAAa,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE,GAAS,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE,CAAC;SACjF;QACO,CAAC,GAAG,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;;YAE5D,OAAa,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE,GAAS,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE,CAAC;SACjF;QACO,CAAC,GAAG,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;;YAE5D,OAAa,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE,GAAS,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE,CAAC;SACjF;QACO,CAAC,GAAG,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;;YAE5D,OAAa,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE,GAAS,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE,CAAC;SACjF;QACO,CAAC,GAAG,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;;YAE5D,OAAa,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE,GAAS,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE,CAAC;SACjF;QACO,CAAC,GAAG,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;YAC5D,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;SACnE;QACO,CAAC,GAAG,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;YAC5D,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;SACnE;QACO,CAAC,IAAI,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;YAC7D,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;SACpE;QACO,CAAC,IAAI,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;YAC7D,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;SACpE;;QAGM,MAAM,CAAI,OAAoB;YACnC,OAAO,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;SAClC;KACF;AAID,UAAa,KAAK;QAGhB,YACkB,SAAwB,EACxB,UAA0B;YAD1B,cAAS,GAAT,SAAS,CAAe;YACxB,eAAU,GAAV,UAAU,CAAgB;;;YAG1C,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC;SACjC;QAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;YAC5E,MAAMA,eAAQ,CAAC,KAAK,4BAA+B,IAAI,CAAC,CAAC;SAC1D;QAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;YAC/E,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;SAChD;QAEM,CAAC,MAAM,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;YAC9D,OAAO,KAAK,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;SAC/C;QACM,CAAC,QAAQ,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;YAChE,OAAO,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;SACjD;QACM,CAAC,GAAG,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;YAC3D,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;SAC3C;QACM,CAAC,GAAG,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;YAC3D,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;SAC3C;QACM,CAAC,GAAG,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;YAC3D,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;SAC3C;;QAGM,MAAM,CAAI,OAAoB;YACnC,OAAO,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;SACjC;KACF;AACD,UAAa,gBAAgB;QAS3B,YAA4B,KAAa;YAAb,UAAK,GAAL,KAAK,CAAQ;SAAK;QAEvC,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;YAC5E,OAAO,IAAI,CAAC,KAAK,CAAC;SACnB;QAEM,MAAM,CAAI,OAAoB;YACnC,OAAO,OAAO,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC;SAC5C;;IAhBsB,2BAAU,GAAgC,IAAI,gBAAgB,CAAY,SAAS,CAAC,CAAC;IACrF,sBAAK,GAA2B,IAAI,gBAAgB,CAAO,IAAI,CAAC,CAAC;IACjE,sBAAK,GAA2B,IAAI,gBAAgB,CAAO,IAAI,CAAC,CAAC;IACjE,uBAAM,GAA4B,IAAI,gBAAgB,CAAQ,KAAK,CAAC,CAAC;IACrE,uBAAM,GAA6B,IAAI,gBAAgB,CAAK,EAAE,CAAC,CAAC;AAezF,UAAa,WAAW;QAGtB,YAA4B,KAAiC;YAAjC,UAAK,GAAL,KAAK,CAA4B;SAAK;QAE3D,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;YAC5E,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC;YAC5B,IAAI,MAAM,GAAG,EAAE,CAAC;YAChB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBACjD,MAAM,KAAK,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;gBAC1D,IAAI,KAAK,KAAK,SAAS,IAAI,KAAK,KAAK,IAAI,EAAE;oBACzC,SAAS;iBACV;gBACD,MAAM,IAAI,KAAK,CAAC;aACjB;YACD,OAAO,MAAM,CAAC;SACf;QAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;YAC/E,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBACnD,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;aAC9C;SACF;QAEM,MAAM,CAAI,OAAoB;YACnC,OAAO,OAAO,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;SACvC;KACF;AAED,UAAa,YAAY;QAIvB,YAA4B,QAAiC;YAAjC,aAAQ,GAAR,QAAQ,CAAyB;SAAK;QAE3D,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;YAC5E,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;YAC/B,MAAM,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;YAC/B,MAAM,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;YAC7B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;gBAC/B,MAAM,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;aACzD;YACD,OAAO,MAAM,CAAC;SACf;QAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;YAC/E,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;YAC/B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBACjD,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;aAC5C;SACF;QAEM,MAAM,CAAI,OAAoB;YACnC,OAAO,OAAO,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;SACxC;;IAxBsB,mBAAM,GAAiB,IAAI,YAAY,CAACJ,eAAQ,CAAC,UAAU,CAAC,CAAC;AA2BtF,UAAa,aAAa;QAIxB,YACkB,IAAoC,EACpC,MAA+B;YAD/B,SAAI,GAAJ,IAAI,CAAgC;YACpC,WAAM,GAAN,MAAM,CAAyB;SAAK;QAE/C,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;YAC5E,MAAM,QAAQ,GAA8B,EAAE,CAAC;YAC/C,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;YACvB,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;YAC3B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBAC7C,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;aAC/D;YACD,OAAO,QAAQ,CAAC;SACjB;QAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;YAC/E,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;YACvB,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;YAC3B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBAC7C,MAAM,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;aAC1C;SACF;QAEM,MAAM,CAAI,OAAoB;YACnC,OAAO,OAAO,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;SACzC;;IA3BsB,oBAAM,GAAkB,IAAI,aAAa,CAACA,eAAQ,CAAC,UAAU,EAAEA,eAAQ,CAAC,UAAU,CAAC,CAAC;AA8B7G,UAAa,QAAQ;QAInB,YACkB,MAA6B,EAC7B,WAAqC;YADrC,WAAM,GAAN,MAAM,CAAuB;YAC7B,gBAAW,GAAX,WAAW,CAA0B;YACrD,IAAI,CAAC,WAAW,GAAG,WAAW,IAAIA,eAAQ,CAAC,UAAU,CAAC;SACvD;QAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;YAC5E,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;YACrC,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;YAC3B,IAAI,MAAM,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;YACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBACpD,MAAM,IAAI,WAAW,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;gBACzD,MAAM,IAAI,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;aACzB;YACD,OAAO,MAAM,CAAC;SACf;QAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;YAC/E,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;YACrC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBACpD,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;gBAC9C,CAAC,EAAE,CAAC;aACL;SACF;QAEM,MAAM,CAAI,OAAoB;YACnC,OAAO,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;SACpC;;IA9BsB,eAAM,GAAa,IAAI,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AAiC/D,UAAa,cAAc;QAGzB,YACkB,MAA+D,EAC/E,GAA0B,EACV,IAAoB,EACpB,WAAqC;YAHrC,WAAM,GAAN,MAAM,CAAyD;YAE/D,SAAI,GAAJ,IAAI,CAAgB;YACpB,gBAAW,GAAX,WAAW,CAA0B;YACrD,MAAM,CAAC,GAAG,GAAG,GAAG,CAAC;YACjB,IAAI,CAAC,WAAW,GAAG,WAAW,IAAIA,eAAQ,CAAC,UAAU,CAAC;SACvD;QAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;YAC5E,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;YACrC,MAAM,GAAG,GAAG,WAAW,CAAC,MAAM,CAAC;YAC/B,MAAM,OAAO,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC;YAC3B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,GAAG,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBACrC,OAAO,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;aAC7D;YACD,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAc,CAAC;YACpE,IAAI,OAAO,IAAI,KAAK,UAAU,EAAE;gBAC9B,MAAMI,eAAQ,CAAC,KAAK,yBAA4B,IAAI,CAAC,CAAC;aACvD;YACD,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;SACxD;QAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;YAC/E,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;YACrC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBACpD,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;aAC/C;YACD,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;SAC1C;QAEM,MAAM,CAAI,OAAoB;YACnC,OAAO,OAAO,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;SAC1C;KACF;AAED,UAAa,mBAAmB;;QAG9B,YACkB,QAAiC;YAAjC,aAAQ,GAAR,QAAQ,CAAyB;SAC9C;;QAGE,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;;SAE7E;;QAGM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB,EAAE,GAAe;;SAE5F;QAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;YAC/E,OAAO;SACR;QAEM,MAAM,CAAI,OAAoB;YACnC,OAAO,OAAO,CAAC,wBAAwB,CAAC,IAAI,CAAC,CAAC;SAC/C;KACF;AAED,UAAa,oBAAoB;;QAG/B,YACkB,IAAoC,EACpC,MAA+B;YAD/B,SAAI,GAAJ,IAAI,CAAgC;YACpC,WAAM,GAAN,MAAM,CAAyB;SAC5C;;QAGE,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;;SAE7E;;QAGM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB,EAAE,GAAe;;SAE5F;QAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;YAC/E,OAAO;SACR;QAEM,MAAM,CAAI,OAAoB;YACnC,OAAO,OAAO,CAAC,yBAAyB,CAAC,IAAI,CAAC,CAAC;SAChD;KACF;AAED,UAAa,iBAAiB;QAE5B,YAA4B,IAAY;YAAZ,SAAI,GAAJ,IAAI,CAAQ;SAAK;QAEtC,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;YAC5E,OAAO,IAAI,CAAC,IAAI,CAAC;SAClB;QACM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;YAC/E,OAAO;SACR;QAEM,MAAM,CAAI,OAAoB;YACnC,OAAO,OAAO,CAAC,sBAAsB,CAAC,IAAI,CAAC,CAAC;SAC7C;KACF;IAID,MAAM,WAAW,GAAG,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC;IAE9C;IACA;AACA,UAAa,cAAc;QAGzB,YACkB,WAAuC,EACvC,QAA2B;YAD3B,gBAAW,GAAX,WAAW,CAA4B;YACvC,aAAQ,GAAR,QAAQ,CAAmB;SAAK;QAE3C,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;YAC5E,OAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;SACtD;QAEM,KAAK,CAAC,MAAsD;YACjE,OAAO,mBAAmB,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;SAC9D;;QAGM,OAAO,CAAC,MAAsD,EAAE,IAAyD;YAC9H,qBAAqB,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;SAC/D;QAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;YAC/E,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;YAChD,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;SAC9C;QAEM,MAAM,CAAI,OAAoB;YACnC,OAAO,OAAO,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;SAC1C;KACF;IAED;;;;;AAKA,UAAa,aAAa;QAKxB,YACkB,KAA4B,EAC5B,WAA6C;YAD7C,UAAK,GAAL,KAAK,CAAuB;YAC5B,gBAAW,GAAX,WAAW,CAAkC;YAC3D,IAAI,CAAC,OAAO,GAAG,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC;YACtC,IAAI,CAAC,eAAe,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;SACvC;QAEI,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;YAC5E,IAAI,IAAI,CAAC,OAAO,EAAE;gBAChB,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;gBACrC,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;gBACzB,IAAI,MAAM,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gBACtB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;oBACpD,MAAM,IAAI,WAAW,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;oBACzD,MAAM,IAAI,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;iBACxB;gBACD,OAAO,MAAM,CAAC;aACf;iBAAM;gBACL,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;gBACzB,OAAO,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;aACnF;SACF;QACM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;YAC/E,OAAO;SACR;QAEM,MAAM,CAAI,OAAoB;YACnC,OAAO,OAAO,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;SACzC;KACF;IAED;;;;;;IAMA,eAAe,CAAC,SAAS,CAAC,KAAK,+BAAkC;IACjE,cAAc,CAAC,SAAS,CAAC,KAAK,8BAAiC;IAC/D,MAAM,CAAC,SAAS,CAAC,KAAK,qBAAyB;IAC/C,WAAW,CAAC,SAAS,CAAC,KAAK,wBAA8B;IACzD,UAAU,CAAC,SAAS,CAAC,KAAK,yBAA6B;IACvD,WAAW,CAAC,SAAS,CAAC,KAAK,2BAA8B;IACzD,YAAY,CAAC,SAAS,CAAC,KAAK,2BAA+B;IAC3D,WAAW,CAAC,SAAS,CAAC,KAAK,0BAA8B;IACzD,SAAS,CAAC,SAAS,CAAC,KAAK,wBAA4B;IACrD,UAAU,CAAC,SAAS,CAAC,KAAK,yBAA6B;IACvD,YAAY,CAAC,SAAS,CAAC,KAAK,2BAA+B;IAC3D,MAAM,CAAC,SAAS,CAAC,KAAK,mBAAyB;IAC/C,KAAK,CAAC,SAAS,CAAC,KAAK,kBAAwB;IAC7C,gBAAgB,CAAC,SAAS,CAAC,KAAK,gCAAmC;IACnE,WAAW,CAAC,SAAS,CAAC,KAAK,wBAA8B;IACzD,YAAY,CAAC,SAAS,CAAC,KAAK,4BAA+B;IAC3D,aAAa,CAAC,SAAS,CAAC,KAAK,6BAAgC;IAC7D,QAAQ,CAAC,SAAS,CAAC,KAAK,wBAA2B;IACnD,cAAc,CAAC,SAAS,CAAC,KAAK,6BAAiC;IAC/D,mBAAmB,CAAC,SAAS,CAAC,KAAK,mCAAsC;IACzE,oBAAoB,CAAC,SAAS,CAAC,KAAK,oCAAuC;IAC3E,iBAAiB,CAAC,SAAS,CAAC,KAAK,iCAAoC;IACrE,cAAc,CAAC,SAAS,CAAC,KAAK,2BAAiC;IAC/D,aAAa,CAAC,SAAS,CAAC,KAAK,0BAAgC;IAE7D;IACA,SAAS,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB,EAAE,IAAgC;QAChH,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;QACxB,MAAM,MAAM,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC;QAC1B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,EAAE,CAAC,EAAE;YAC5B,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;SACrD;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,SAAS,WAAW,CAAC,KAAqB,EAAE,GAAc,EAAE,IAAY;QACtE,MAAM,IAAI,GAAG,GAAG,KAAK,IAAI,IAAI,GAAG,KAAK,SAAS,GAAG,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC;QAClE,IAAI,OAAO,IAAI,KAAK,UAAU,EAAE;YAC9B,OAAO,IAAI,CAAC;SACb;QACD,IAAI,EAAE,KAAK,GAAGP,sBAAc,CAAC,YAAY,CAAC,KAAK,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,SAAS,CAAC,EAAE;YACnF,OAAO,IAAI,CAAC;SACb;QACD,MAAMO,eAAQ,CAAC,KAAK,yBAA4B,GAAG,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;IACnE,CAAC;IAED,SAAS,SAAS,CAAC,KAAgB;QACjC,MAAM,SAAS,GAAG,OAAO,KAAK,CAAC;QAC/B,IAAI,SAAS,KAAK,QAAQ;YAAE,OAAO,IAAI,CAAC;QACxC,IAAI,SAAS,KAAK,QAAQ;YAAE,OAAO,KAAK,CAAC;QACzC,MAAM,GAAG,GAAY,KAAM,CAAC,MAAM,CAAC;QACnC,IAAI,GAAG,KAAK,CAAC;YAAE,OAAO,KAAK,CAAC;QAC5B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,EAAE,CAAC,EAAE;YAC5B,MAAM,IAAI,GAAY,KAAM,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YAC3C,IAAI,IAAI,GAAG,IAAI,UAAU,IAAI,GAAG,IAAI,QAAO;gBACzC,OAAO,KAAK,CAAC;aACd;SACF;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAED;AACA,UAAa,qBAAqB,GAAG;QACnC,CAAC,gBAAgB,CAAC,CAAC,MAAmB,EAAE,IAA+D;YACrG,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBAC/C,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;aAC5B;SACF;QACD,CAAC,cAAc,CAAC,CAAC,MAAiC,EAAE,IAA+D;YACjH,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YAC/B,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;YACX,KAAK,MAAM,KAAK,IAAI,MAAM,CAAC,OAAO,EAAE,EAAE;gBACpC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,KAAK,CAAC;aAClB;YACD,qBAAqB,CAAC,gBAAgB,CAAC,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;SACpD;QACD,CAAC,cAAc,CAAC,CAAC,MAAsB,EAAE,IAA+D;YACtG,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YAC/B,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;YACX,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,EAAE,EAAE;gBAC/B,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,GAAG,CAAC;aAChB;YACD,qBAAqB,CAAC,gBAAgB,CAAC,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;SACpD;QACD,CAAC,iBAAiB,CAAC,CAAC,MAAc,EAAE,IAA+D;YACjG,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;YAC1B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;gBAC/B,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;aACZ;YACD,qBAAqB,CAAC,gBAAgB,CAAC,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;SACpD;QACD,CAAC,eAAe,CAAC,CAAC,MAAY,EAAE,IAA+D;YAC7F,OAAO;SACR;QACD,CAAC,oBAAoB,CAAC,CAAC,MAAY,EAAE,IAA+D;YAClG,OAAO;SACR;KACF,CAAC;IAEF;AACA,UAAa,mBAAmB,GAAG;QACjC,CAAC,gBAAgB,CAAC,CAAC,MAAmB,IAAY,OAAO,MAAM,CAAC,MAAM,CAAC,EAAE;QACzE,CAAC,cAAc,CAAC,CAAC,MAAiC,IAAY,OAAO,MAAM,CAAC,IAAI,CAAC,EAAE;QACnF,CAAC,cAAc,CAAC,CAAC,MAAsB,IAAY,OAAO,MAAM,CAAC,IAAI,CAAC,EAAE;QACxE,CAAC,iBAAiB,CAAC,CAAC,MAAc,IAAY,OAAO,MAAM,CAAC,EAAE;QAC9D,CAAC,eAAe,CAAC,CAAC,MAAY,IAAY,OAAO,CAAC,CAAC,EAAE;QACrD,CAAC,oBAAoB,CAAC,CAAC,MAAY,IAAY,OAAO,CAAC,CAAC,EAAE;KAC3D,CAAC;IAEF;IACA;IACA;IACA;IACA;IACA,MAAM,GAAG,GAAG,CAAC,UAAU,EAAE,WAAW,EAAE,YAAY,EAAE,aAAa,EAAE,gBAAgB,EAAE,QAAQ,EAAE,KAAK,EAAE,YAAY,EAAE,UAAU,EAAE,SAAS,EAAE,YAAY,EAAE,WAAW,EAAE,cAAc,EAAE,MAAM,EAAE,WAAW,EAAE,MAAM,EAAE,cAAc,CAAC,CAAC;IACnO,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;QAC5C,MAAM,KAAK,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;;QAE/B,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,IAASJ,eAAQ,CAAC,IAAI,CAAC;QAClD,KAAK,CAAC,OAAO,GAAG,KAAK,CAAC,OAAO,IAAIA,eAAQ,CAAC,IAAI,CAAC;KAChD;;ICttCD;IAEA,MAAM,SAAS,GAAa,EAAE,CAAC;IAC/B,MAAM,gBAAgB,GAAa,EAAE,CAAC;IACtC,IAAI,QAAQ,GAAG,CAAC,CAAC,CAAC;IAClB,SAAS,qBAAqB,CAAC,WAAmB;QAChD,IAAI,WAAW,KAAK,QAAQ,EAAE;YAC5B,QAAQ,IAAI,CAAC,CAAC;YACd,MAAM,EAAE,GAAG,SAAS,CAAC,MAAM,GAAG,gBAAgB,CAAC,MAAM,GAAG,QAAQ,GAAG,CAAC,CAAC;YACrE,KAAK,IAAI,CAAC,GAAG,WAAW,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBACzC,SAAS,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,EAAE,CAAC;gBAC/B,gBAAgB,CAAC,CAAC,CAAC,GAAG,mBAAmB,CAAC,EAAE,CAAC;aAC9C;SACF;IACH,CAAC;IACD,qBAAqB,CAAC,CAAC,CAAC,CAAC,CAAC;IAkB1B;AACA,aAAgB,WAAW,CAA4B,QAAgC;;QAErF,MAAM,aAAa,GAAG,IAAI,CAAC,aAAa,KAAK,SAAS,GAAG,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC;QAChF,IAAI,CAAC,GAAG,aAAa,CAAC;QAEtB,OAAO,CAAC,EAAE,IAAI,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,KAAK,QAAQ;YAAC,CAAC;;QAG/C,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;YACZ,CAAC,GAAG,CAAC,CAAC;YACN,OAAO,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,EAAE;gBACzB,CAAC,EAAE,CAAC;aACL;YACD,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC;YAC9B,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;;YAEzB,IAAI,CAAC,KAAK,aAAa,EAAE;gBACvB,IAAI,CAAC,aAAa,GAAG,CAAC,GAAG,CAAC,CAAC;aAC5B;SACF;;QAED,IAAI,IAAI,CAAC,OAAO,KAAK,SAAS,EAAE;YAC9B,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC;SAClB;QACD,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC;QACzC,qBAAqB,CAAC,CAAC,CAAC,CAAC;IAC3B,CAAC;IAED;AACA,aAAgB,eAAe,CAA4B,GAAe,EAAE,YAAoB;QAC9F,MAAM,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,GAAG,EAAE,YAAY,CAA2B,CAAC;;;;;;;;QAQ/F,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;IAC7B,CAAC;IAED;AACA,aAAgB,SAAS,CAA4B,GAAa;QAChE,MAAM,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC;QACjC,IAAI,QAAgB,CAAC;QACrB,IAAI,QAAgC,CAAC;QACrC,IAAI,GAAG,KAAK,IAAI,EAAE;YAChB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,EAAE,CAAC,EAAE;gBAC9B,QAAQ,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;gBACxB,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAC1B,IAAI,QAAQ,KAAK,IAAI,IAAI,QAAQ,KAAK,SAAS,EAAE;oBAC/C,IAAI,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC;oBACtB,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;iBAC5B;aACF;SACF;aAAM;YACL,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;YAC7B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,EAAE,CAAC,EAAE;gBAC9B,IAAI,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE;oBACzC,QAAQ,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;oBACxB,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC;oBAC1B,IAAI,QAAQ,KAAK,IAAI,IAAI,QAAQ,KAAK,SAAS,EAAE;wBAC/C,IAAI,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC;wBACtB,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;qBAC5B;iBACF;aACF;SACF;IACH,CAAC;IAKD,SAAS,oBAAoB,CAAC,MAA8B;QAC1D,MAAM,KAAK,GAAG,MAAM,CAAC,SAAS,CAAC;QAC/B,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,iBAAiB,CAAC;YAAE,KAAK,CAAC,eAAe,GAAG,eAAe,CAAC;QACtF,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,WAAW,CAAC;YAAE,KAAK,CAAC,SAAS,GAAG,SAAS,CAAC;QACpE,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,aAAa,CAAC;YAAE,KAAK,CAAC,WAAW,GAAG,WAAW,CAAC;QAC1E,OAAO,MAA8B,CAAC;IACxC,CAAC;AAID,aAAgB,WAAW,CAAC,MAA+B;QACzD,OAAO,MAAM,KAAK,SAAS,GAAG,oBAAoB,GAAG,oBAAoB,CAAC,MAAM,CAAC,CAAC;IACpF,CAAC;;IC5GD;IACA,MAAM,WAAEoB,SAAO,UAAEC,QAAM,YAAEC,UAAQ,EAAE,GAAGX,mBAAW,CAAC;IAElD;IACA,MAAM,eAAe,GAAGU,QAAM,GAAGD,SAAO,CAAC;AAKzC,AAAaG,mBAAO,GAApB,MAAa,OAAO;QAYlB,YACS,gBAAoD,EACpD,MAAsB,EACtB,cAAsB,EACtB,IAAiB,EACjB,eAAiC,EACjC,OAAwB;YALxB,qBAAgB,GAAhB,gBAAgB,CAAoC;YACpD,WAAM,GAAN,MAAM,CAAgB;YACtB,mBAAc,GAAd,cAAc,CAAQ;YACtB,SAAI,GAAJ,IAAI,CAAa;YACjB,oBAAe,GAAf,eAAe,CAAkB;YACjC,YAAO,GAAP,OAAO,CAAiB;YAjB1B,iBAAY,GAAwB,IAAI,CAAC;YACzC,eAAU,GAAwB,IAAI,CAAC;YACvC,cAAS,GAAe,IAAI,CAAC;YAC7B,cAAS,GAAe,IAAI,CAAC;YAE7B,WAAM,gBAAqB;YAC3B,WAAM,GAAW,IAAI,CAAC;YAY3B,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;SAC3C;QAEM,YAAY,CAAC,KAAU,EAAE,KAAqB;YACnD,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,GAAG1B,sBAAc,CAAC,oBAAoB,CAAC,CAAC;SAClF;QAEM,YAAY,CAAC,KAAU,EAAE,KAAqB;YACnD,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,KAAK,GAAGA,sBAAc,CAAC,sBAAsB,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;SAC/G;QAEM,YAAY,CAAC,QAAa,EAAE,aAAkB,EAAE,KAAqB;YAC1E,IAAI,EAAE,IAAI,CAAC,MAAM,mBAAiB,EAAE;gBAClC,OAAO;aACR;YAED,MAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;YAC/C,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;YAC3B,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;YAE7B,IAAI,KAAK,GAAGA,sBAAc,CAAC,oBAAoB,EAAE;gBAC/C,MAAM,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC;gBAC3C,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;gBAEvB,aAAa,GAAG,cAAc,CAAC,QAAQ,EAAE,CAAC;;gBAE1C,IAAI,gBAAgB,CAAC,KAAK,gCAAmC,IAAI,CAAC,aAAa,GAAG,CAAC,EAAE;oBACnF,QAAQ,GAAG,gBAAgB,CAAC,QAAQ,CAAC,KAAK,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;iBAC9D;gBACD,IAAI,QAAQ,KAAK,aAAa,EAAE;oBAC9B,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;iBACpC;gBACD,IAAI,CAAC,IAAI,GAAGuB,SAAO,MAAM,CAAC,EAAE;oBAC1B,IAAI,CAAC,OAAO,EAAE,CAAC;oBACf,gBAAgB,CAAC,OAAO,CAAC,KAAK,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;oBAC9C,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;iBACvB;gBACD,OAAO;aACR;YAED,IAAI,KAAK,GAAGvB,sBAAc,CAAC,sBAAsB,EAAE;gBACjD,IAAI,QAAQ,KAAK,gBAAgB,CAAC,QAAQ,CAAC,KAAK,EAAE,MAAM,EAAE,OAAO,CAAC,EAAE;oBAClE,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;iBACpC;gBACD,OAAO;aACR;YAED,MAAMO,eAAQ,CAAC,KAAK,CAAC,EAAE,EAAEP,sBAAc,CAAC,KAAK,CAAC,CAAC,CAAC;SACjD;QAEM,KAAK,CAAC,KAAqB,EAAE,KAAa;YAC/C,IAAI,IAAI,CAAC,MAAM,oBAAkB;gBAC/B,IAAI,IAAI,CAAC,MAAM,KAAK,KAAK,EAAE;oBACzB,OAAO;iBACR;gBACD,IAAI,CAAC,OAAO,CAAC,KAAK,GAAGA,sBAAc,CAAC,QAAQ,CAAC,CAAC;aAC/C;;YAED,IAAI,CAAC,MAAM,sBAAoB;YAE/B,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;YAEpB,IAAI,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;YAC7C,IAAI,OAAO,CAAC,gBAAgB,CAAC,EAAE;gBAC7B,gBAAgB,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;aAC3C;YAED,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;YACvB,IAAI,cAAc,GAAG,IAAI,CAAC,cAAwC,CAAC;YACnE,IAAI,CAAC,cAAc,EAAE;gBACnB,IAAI,IAAI,GAAGyB,UAAQ,EAAE;oBACnB,cAAc,GAAG,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,cAAc,CAA2B,CAAC;iBACrI;qBAAM;oBACL,cAAc,GAAG,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,cAAc,CAA2B,CAAC;iBACrI;aACF;YACD,IAAI,cAAc,CAAC,IAAI,EAAE;gBACvB,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;aAC5B;;YAGD,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;YACzC,IAAI,IAAI,GAAG,eAAe,EAAE;gBAC1B,IAAI,CAAC,YAAY,CAAC,gBAAgB,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,OAAO,CAAC,EAAE,KAAK,CAAC,CAAC;aACjF;YACD,IAAI,IAAI,GAAGD,QAAM,EAAE;gBACjB,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;aACtC;YACD,IAAI,IAAI,GAAGC,UAAQ,EAAE;gBACnB,cAAc,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;aAChC;;YAGD,IAAI,CAAC,MAAM,oBAAkB;YAC7B,IAAI,CAAC,MAAM,IAAI,mBAAiB;SACjC;QAEM,OAAO,CAAC,KAAqB;YAClC,IAAI,EAAE,IAAI,CAAC,MAAM,mBAAiB,EAAE;gBAClC,OAAO;aACR;;YAED,IAAI,CAAC,MAAM,yBAAsB;YAEjC,MAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;YAC/C,IAAI,SAAS,CAAC,gBAAgB,CAAC,EAAE;gBAC/B,gBAAgB,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;aACnD;YACD,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;YAEnB,MAAM,cAAc,GAAG,IAAI,CAAC,cAAwC,CAAC;YACrE,IAAI,cAAc,CAAC,MAAM,EAAE;gBACzB,cAAc,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;aAC9B;YACD,IAAI,cAAc,CAAC,WAAW,EAAE;gBAC9B,cAAc,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;aAClC;YACD,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;;YAGrB,IAAI,CAAC,MAAM,IAAI,EAAE,uCAAkC,CAAC;SACrD;QAEM,OAAO,CAAC,KAAqB;YAClC,IAAI,IAAI,CAAC,MAAM,oBAAkB;gBAC/B,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,KAAK,GAAGzB,sBAAc,CAAC,YAAY,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;aACvF;SACF;QAEM,KAAK,CAAC,KAAqB;YAChC,IAAI,IAAI,CAAC,MAAM,oBAAkB;gBAC/B,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,KAAK,GAAGA,sBAAc,CAAC,YAAY,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,EAAE,KAAK,CAAC,CAAC;aAC1H;SACF;KACF,CAAA;AAzJY0B,mBAAO;QADnB,WAAW,EAAE;OACDA,eAAO,CAyJnB;;IClKD,MAAM,KAAK,GAAG,EAAE,CAAC;IAEjB;AACA,aAAgB,kBAAkB,CAAC,KAAY;QAC7C,MAAM,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC;QACjC,YAAY,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;QAC9B,KAAK,CAAC,SAAS,GAAG,UAAU,CAAC,MAAM,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC;IAC/E,CAAC;IAED;AACA,aAAgB,YAAY,CAA4B,QAAa,EAAE,QAAa,EAAE,KAAqB;QACzG,MAAM,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC;QACjC,YAAY,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;QAC9B,IAAI,EAAE,KAAK,GAAG,KAAK,CAAC,qBAAqB,CAAC,EAAE;YAC1C,KAAK,CAAC,QAAQ,GAAG,KAAK,CAAC;YACvB,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;YAChD,OAAO;SACR;QACD,IAAI,KAAK,CAAC,QAAQ,KAAK,KAAK,EAAE;YAC5B,KAAK,CAAC,QAAQ,GAAG,QAAQ,CAAC;SAC3B;QACD,KAAK,CAAC,SAAS,GAAG,UAAU,CAC1B;YACE,MAAM,EAAE,GAAG,KAAK,CAAC,QAAQ,CAAC;YAC1B,KAAK,CAAC,QAAQ,GAAG,KAAK,CAAC;YACvB,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC;SAC3C,EACD,KAAK,CAAC,KAAK,CACZ,CAAC;IACJ,CAAC;IAED,MAAMD,UAAQ,GAAGX,mBAAW,CAAC,QAAQ,CAAC;AAGtC,AAAaa,mCAAuB,GAApC,MAAa,uBAAuB;QAC3B,IAAI,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B,EAAE,QAAgB,GAAG;YACjG,IAAI,gBAAgB,CAAC;YACrB,IAAI,qBAAqB,CAAC;YAC1B,IAAI,SAAS,CAAC;YAEd,IAAI,OAAO,YAAYD,eAAO,EAAE;gBAC9B,gBAAgB,GAAG,cAAc,CAAC;gBAClC,SAAS,GAAG,YAAY,CAAC;gBACzB,qBAAqB,GAAG,OAAO,CAAC,IAAI,GAAGD,UAAQ,GAAGzB,sBAAc,CAAC,sBAAsB,GAAGA,sBAAc,CAAC,oBAAoB,CAAC;aAC/H;iBAAM;gBACL,gBAAgB,GAAG,YAAY,CAAC;gBAChC,SAAS,GAAG,kBAAkB,CAAC;gBAC/B,qBAAqB,GAAGA,sBAAc,CAAC,oBAAoB,CAAC;aAC7D;;;;YAKD,OAAO,CAAC,eAAe,GAAG,OAAO,CAAC,gBAAgB,CAAC,CAAC;YACpD,OAAO,CAAC,eAAe,CAAC,YAAY,GAAG,gBAAgB,CAAC;;YAGxD,OAAO,CAAC,gBAAgB,CAAC,GAAG,SAAS,CAAC;;YAGtC,OAAO,CAAC,aAAa,GAAG;gBACtB,qBAAqB;gBACrB,KAAK;gBACL,SAAS,EAAE,CAAC;gBACZ,QAAQ,EAAE,KAAK;aAChB,CAAC;SACH;QAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;;YAE9E,MAAM,eAAe,GAAG,OAAO,CAAC,eAAe,CAAC,YAAY,CAAC;YAC7D,OAAO,CAAC,eAAe,CAAC,GAAG,OAAO,CAAC,eAAe,CAAC;YACnD,OAAO,CAAC,eAAe,GAAG,IAAI,CAAC;YAC/B,YAAY,CAAC,OAAO,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;YAC9C,OAAO,CAAC,aAAa,GAAG,IAAI,CAAC;SAC9B;KACF,CAAA;AA1CY2B,mCAAuB;QADnC,eAAe,CAAC,UAAU,CAAC;OACfA,+BAAuB,CA0CnC;;IC1FD,MAAM,YAAY,GAAG,qDAAqD,CAAC;AAU3E,UAAa,UAAU,GAAGzB,SAAE,CAAC,eAAe,EAAc;SACvD,WAAW,CAAC,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC;QACrB,QAAQ,CAAC,KAAa;YAC3B,OAAO,KAAK,CAAC,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;SACxC;KACF,CAAC,CACH,CAAC;IAEF;;;AAKA,AAAa0B,kCAAsB,GAAnC,MAAa,sBAAsB;QACjC,YAAoB,SAAqB;YAArB,cAAS,GAAT,SAAS,CAAY;YACvC,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;SAC5B;;;;;QAMM,MAAM,CAAC,eAAuB;YACnC,IAAI,eAAe,KAAK,IAAI,IAAI,eAAe,KAAK,SAAS,EAAE;gBAC7D,OAAO,IAAI,CAAC;aACb;YAED,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,eAAe,CAAC,CAAC;SACjD;KACF,CAAA;AAhBYA,kCAAsB;QAFlC,cAAc,CAAC,UAAU,CAAC;QAC1BtB,aAAM,CAAC,UAAU,CAAC;OACNsB,8BAAsB,CAgBlC;;ICpBD;IACA;AACA,aAAgB,uBAAuB,CAAC,KAA8B;QACpE,OAAO,CAAC,KAAK,CAAC,YAAY,IAAI,KAAK,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC,MAAM,KAAK,CAAC,QAAQ,IAAI,KAAK,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC,IAAI,IAAI,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,MAAM,CAAC;IACrJ,CAAC;IAED,SAAS,eAAe;QACtB,IAAI,CAAC,uBAAuB,EAAE,CAAC;QAC/B,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC;IACjC,CAAC;IAED,SAAS,mBAAmB,CAAC,KAAoC;QAC/D,KAAK,CAAC,kBAAkB,GAAG,KAAK,CAAC;QACjC,IAAI,MAAM,GAA4B,uBAAuB,CAAC,KAAK,CAA0C,CAAC;QAC9G,MAAM,gBAAgB,GAAG,EAAE,CAAC;;;;QAI5B,OAAO,MAAM,EAAE;YACb,IAAI,MAAM,CAAC,iBAAiB,EAAE;gBAC5B,MAAM,QAAQ,GAAG,MAAM,CAAC,iBAAiB,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;gBACtD,IAAI,QAAQ,EAAE;oBACZ,IAAI,KAAK,CAAC,eAAe,KAAK,eAAe,EAAE;wBAC7C,KAAK,CAAC,uBAAuB,GAAG,KAAK,CAAC,eAAe,CAAC;wBACtD,KAAK,CAAC,eAAe,GAAG,eAAe,CAAC;qBACzC;oBACD,gBAAgB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;iBACjC;aACF;YACD,MAAM,GAAG,MAAM,CAAC,UAAU,CAAC;SAC5B;QAED,KAAK,IAAI,CAAC,GAAG,gBAAgB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,kBAAkB,EAAE,CAAC,EAAE,EAAE;YAClF,MAAM,eAAe,GAAG,gBAAgB,CAAC,CAAC,CAAC,CAAC;YAC5C,IAAI,aAAa,IAAI,eAAe,EAAE;gBACpC,eAAe,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;aACpC;iBAAM;gBACL,eAAe,CAAC,KAAK,CAAC,CAAC;aACxB;SACF;IACH,CAAC;IAED,SAAS,oBAAoB,CAAC,KAAoC;QAChE,KAAK,CAAC,kBAAkB,GAAG,KAAK,CAAC;QACjC,IAAI,MAAM,GAA4B,uBAAuB,CAAC,KAAK,CAA0C,CAAC;QAC9G,OAAO,MAAM,IAAI,CAAC,KAAK,CAAC,kBAAkB,EAAE;YAC1C,IAAI,MAAM,CAAC,kBAAkB,EAAE;gBAC7B,MAAM,QAAQ,GAAG,MAAM,CAAC,kBAAkB,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;gBACvD,IAAI,QAAQ,EAAE;oBACZ,IAAI,KAAK,CAAC,eAAe,KAAK,eAAe,EAAE;wBAC7C,KAAK,CAAC,uBAAuB,GAAG,KAAK,CAAC,eAAe,CAAC;wBACtD,KAAK,CAAC,eAAe,GAAG,eAAe,CAAC;qBACzC;oBACD,IAAI,aAAa,IAAI,QAAQ,EAAE;wBAC7B,QAAQ,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;qBAC7B;yBAAM;wBACL,QAAQ,CAAC,KAAK,CAAC,CAAC;qBACjB;iBACF;aACF;YACD,MAAM,GAAG,MAAM,CAAC,UAAU,CAAC;SAC5B;IACH,CAAC;AAED,UAAa,eAAe;QAG1B,YACU,SAAiB,EACjB,QAA4C,EAC5C,OAAgB;YAFhB,cAAS,GAAT,SAAS,CAAQ;YACjB,aAAQ,GAAR,QAAQ,CAAoC;YAC5C,YAAO,GAAP,OAAO,CAAS;YALlB,UAAK,GAAW,CAAC,CAAC;SAMrB;QAEE,SAAS;YACd,IAAI,CAAC,KAAK,EAAE,CAAC;YACb,IAAI,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;gBACpB,GAAG,CAAC,gBAAgB,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;aACzE;SACF;QAEM,SAAS;YACd,IAAI,CAAC,KAAK,EAAE,CAAC;YACb,IAAI,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;gBACpB,GAAG,CAAC,mBAAmB,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;aAC5E;SACF;KACF;IAED;;;AAGA,UAAa,6BAA6B;QACxC,YACS,KAAsB,EACtB,MAA0D,EAC1D,WAAmB,EAC1B,QAA4C;YAHrC,UAAK,GAAL,KAAK,CAAiB;YACtB,WAAM,GAAN,MAAM,CAAoD;YAC1D,gBAAW,GAAX,WAAW,CAAQ;YAG1B,MAAM,CAAC,WAAW,CAAC,GAAG,QAAQ,CAAC;SAChC;QAEM,OAAO;YACZ,IAAI,CAAC,KAAK,CAAC,SAAS,EAAE,CAAC;YACvB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,IAAI,CAAC;SACtC;KACF;IAED;;;AAGA,UAAa,mBAAmB;QAC9B,YACS,MAAa,EACb,WAAmB,EACnB,QAA4C;YAF5C,WAAM,GAAN,MAAM,CAAO;YACb,gBAAW,GAAX,WAAW,CAAQ;YACnB,aAAQ,GAAR,QAAQ,CAAoC;YAEnD,GAAG,CAAC,gBAAgB,CAAC,WAAW,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC;SACrD;QAEM,OAAO;YACZ,GAAG,CAAC,mBAAmB,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;SACvE;KACF;AAOD,IAAA,WAAY,kBAAkB;QAC5B,2DAAQ,CAAA;QACR,qEAAa,CAAA;QACb,mEAAY,CAAA;IACd,CAAC,EAJWC,0BAAkB,KAAlBA,0BAAkB,QAI7B;AAWD,UAAa,eAAe;QAI1B,YAA6B,MAAgB;YAAhB,WAAM,GAAN,MAAM,CAAU;YAC3C,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;YACrB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;YACnB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;SACrB;QAEM,SAAS,CAAC,IAAW,EAAE,kBAAsD;YAClF,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;YACnB,IAAI,CAAC,OAAO,GAAG,kBAAkB,CAAC;YAElC,MAAM,GAAG,GAAG,GAAG,CAAC,gBAAgB,CAAC;YACjC,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;YAE3B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,MAAM,CAAC,MAAM,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE;gBAC/C,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,kBAAkB,EAAE,IAAI,CAAC,CAAC;aAC1C;SACF;QAEM,OAAO;YACZ,MAAM,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;YACzB,MAAM,kBAAkB,GAAG,IAAI,CAAC,OAAO,CAAC;YACxC,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;YAC3B,MAAM,MAAM,GAAG,GAAG,CAAC,mBAAmB,CAAC;YAEvC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,MAAM,CAAC,MAAM,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE;gBAC/C,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,kBAAkB,EAAE,IAAI,CAAC,CAAC;aAC7C;YAED,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;SACnC;KACF;AAUD,UAAa,aAAa,GAAG3B,SAAE,CAAC,eAAe,EAAiB;SAC7D,WAAW,CAAC,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC;IAE/C;AACA,UAAa,YAAY;QAKvB;YAJO,yBAAoB,GAA6C,EAAE,CAAC;YACpE,sBAAiB,GAAoC,EAAE,CAAC;YACxD,qBAAgB,GAAoC,EAAE,CAAC;YAG5D,IAAI,CAAC,4BAA4B,CAAC;gBAChC,OAAO,EAAE,OAAO;gBAChB,UAAU,EAAE;oBACV,KAAK,EAAE,CAAC,QAAQ,EAAE,OAAO,CAAC;oBAC1B,OAAO,EAAE,CAAC,QAAQ,EAAE,OAAO,CAAC;oBAC5B,KAAK,EAAE,CAAC,QAAQ,EAAE,OAAO,CAAC;iBAC3B;aACF,CAAC,CAAC;YACH,IAAI,CAAC,4BAA4B,CAAC;gBAChC,OAAO,EAAE,UAAU;gBACnB,UAAU,EAAE;oBACV,KAAK,EAAE,CAAC,QAAQ,EAAE,OAAO,CAAC;iBAC3B;aACF,CAAC,CAAC;YACH,IAAI,CAAC,4BAA4B,CAAC;gBAChC,OAAO,EAAE,QAAQ;gBACjB,UAAU,EAAE;oBACV,KAAK,EAAE,CAAC,QAAQ,CAAC;iBAClB;aACF,CAAC,CAAC;YACH,IAAI,CAAC,4BAA4B,CAAC;gBAChC,OAAO,EAAE,kBAAkB;gBAC3B,UAAU,EAAE;oBACV,KAAK,EAAE,CAAC,QAAQ,EAAE,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,CAAC;iBACrD;aACF,CAAC,CAAC;YACH,IAAI,CAAC,4BAA4B,CAAC;gBAChC,OAAO,EAAE,oBAAoB;gBAC7B,UAAU,EAAE;oBACV,SAAS,EAAE,CAAC,QAAQ,CAAC;oBACrB,UAAU,EAAE,CAAC,QAAQ,CAAC;iBACvB;aACF,CAAC,CAAC;SACJ;QAEM,4BAA4B,CAAC,MAA6B;YAC/D,MAAM,UAAU,GAAG,MAAM,CAAC,UAAU,CAAC;YACrC,MAAM,MAAM,GAA6B,IAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC;YAExF,KAAK,MAAM,YAAY,IAAI,UAAU,EAAE;gBACrC,IAAI,UAAU,CAAC,cAAc,CAAC,YAAY,CAAC,EAAE;oBAC3C,MAAM,CAAC,YAAY,CAAC,GAAG,UAAU,CAAC,YAAY,CAAC,CAAC;iBACjD;aACF;SACF;QAEM,iBAAiB,CAAC,MAAa,EAAE,YAAoB;YAC1D,MAAM,OAAO,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC;YAClC,MAAM,MAAM,GAAG,IAAI,CAAC,oBAAoB,CAAC;YAEzC,IAAI,OAAO,EAAE;gBACX,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,CAAC,YAAY,CAAC,EAAE;oBACpD,OAAO,IAAI,eAAe,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;iBAC3D;gBACD,IAAI,YAAY,KAAK,aAAa,IAAI,YAAY,KAAK,WAAW,EAAE;oBAClE,OAAO,IAAI,eAAe,CAAC,MAAM,CAAC,kBAAkB,CAAC,CAAC,KAAK,CAAC,CAAC;iBAC9D;gBACD,IAAI,YAAY,KAAK,WAAW,IAAI,YAAY,KAAK,YAAY,EAAE;oBACjE,OAAO,IAAI,eAAe,CAAC,MAAM,CAAC,oBAAoB,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;iBACxE;aACF;YACD,OAAO,IAAI,CAAC;SACb;QAEM,gBAAgB,CACrB,MAA+B,EAC/B,WAAmB,EACnB,kBAAsD,EACtD,QAA4B;YAE5B,IAAI,iBAA8D,CAAC;YACnE,IAAI,gBAA6D,CAAC;YAClE,IAAI,YAA2D,CAAC;YAEhE,IAAI,QAAQ,KAAK2B,0BAAkB,CAAC,QAAQ,EAAE;gBAC5C,iBAAiB,GAAG,IAAI,CAAC,iBAAiB,CAAC;gBAC3C,YAAY,GAAG,iBAAiB,CAAC,WAAW,CAAC,KAAK,iBAAiB,CAAC,WAAW,CAAC,GAAG,IAAI,eAAe,CAAC,WAAW,EAAE,oBAAoB,EAAE,KAAK,CAAC,CAAC,CAAC;gBAClJ,YAAY,CAAC,SAAS,EAAE,CAAC;gBACzB,MAAM,kBAAkB,GAAG,MAAM,CAAC,kBAAkB,KAAK,MAAM,CAAC,kBAAkB,GAAG,EAAE,CAAC,CAAC;gBACzF,OAAO,IAAI,6BAA6B,CAAC,YAAY,EAAE,kBAAkB,EAAE,WAAW,EAAE,kBAAkB,CAAC,CAAC;aAC7G;YACD,IAAI,QAAQ,KAAKA,0BAAkB,CAAC,SAAS,EAAE;gBAC7C,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;gBACzC,YAAY,GAAG,gBAAgB,CAAC,WAAW,CAAC,KAAK,gBAAgB,CAAC,WAAW,CAAC,GAAG,IAAI,eAAe,CAAC,WAAW,EAAE,mBAAmB,EAAE,IAAI,CAAC,CAAC,CAAC;gBAC9I,YAAY,CAAC,SAAS,EAAE,CAAC;gBACzB,MAAM,iBAAiB,GAAG,MAAM,CAAC,iBAAiB,KAAK,MAAM,CAAC,iBAAiB,GAAG,EAAE,CAAC,CAAC;gBACtF,OAAO,IAAI,6BAA6B,CAAC,YAAY,EAAE,iBAAiB,EAAE,WAAW,EAAE,kBAAkB,CAAC,CAAC;aAC5G;YACD,OAAO,IAAI,mBAAmB,CAAC,MAAM,EAAE,WAAW,EAAE,kBAAkB,CAAC,CAAC;SACzE;KACF;;IChTD;AACA,aAAgB,eAAe,CAAC,KAAY;QAC1C,MAAM,MAAM,GAAG,uBAAuB,CAAC,KAAK,CAAC,CAAC;QAE9C,IAAI,IAAI,CAAC,MAAM,KAAK,MAAM,EAAE;YAC1B,OAAO;SACR;QAED,OAAO,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;IACzC,CAAC;AAOD,AAAaC,+BAAmB,GAAhC,MAAa,mBAAmB;QACvB,IAAI,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;YACxE,IAAI,CAAC,OAAO,CAAC,UAAU,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE;gBAC/C,MAAMvB,eAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;aACzB;YAED,OAAO,CAAC,mBAAmB,GAAG,OAAO,CAAC,UAAU,CAAC;YACjD,OAAO,CAAC,UAAU,GAAG,eAAe,CAAC;SACtC;QAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;YAC1E,OAAO,CAAC,UAAU,GAAG,OAAO,CAAC,mBAAmB,CAAC;YACjD,OAAO,CAAC,mBAAmB,GAAG,IAAI,CAAC;SACpC;KACF,CAAA;AAdYuB,+BAAmB;QAD/B,eAAe,CAAC,MAAM,CAAC;OACXA,2BAAmB,CAc/B;;ACxBYC,iCAAqB,GAAlC,MAAa,qBAAqB;QAChC,YAAoB,QAAmB;YAAnB,aAAQ,GAAR,QAAQ,CAAW;SAAI;QAEpC,IAAI,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA0B;YAC1E,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE;gBACzB,MAAMxB,eAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;aAC1B;YAED,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;gBAC1B,MAAM,IAAI,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;gBAC1B,IAAI,CAAC,QAAQ,CAAC,iBAAiB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;gBAC/C,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC;aACvB;iBAAM,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC/B,MAAM,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;gBACvD,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC;gBAErB,OAAO,CAAC,EAAE,EAAE;oBACV,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;oBACtB,IAAI,CAAC,QAAQ,CAAC,iBAAiB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;iBAChD;gBAED,OAAO,CAAC,MAAM,GAAG,KAAK,CAAC;aACxB;iBAAM;gBACL,MAAMA,eAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;aAC1B;SACF;QAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA0B;YAC5E,MAAM,IAAI,GAAG,OAAO,CAAC,MAAM,CAAC;YAC5B,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC;YAEtB,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;gBACvB,MAAM,KAAK,GAAG,IAAI,CAAC;gBACnB,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC;gBAErB,OAAO,CAAC,EAAE,EAAE;oBACV,IAAI,CAAC,QAAQ,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;iBACvD;aACF;iBAAM;gBACL,IAAI,CAAC,QAAQ,CAAC,oBAAoB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;aACnD;SACF;KACF,CAAA;AA1CYwB,iCAAqB;QAFjC,eAAe,CAAC,QAAQ,CAAC;QACzBzB,aAAM,CAAC,SAAS,CAAC;OACLyB,6BAAqB,CA0CjC;;ICrCD;AACA,aAAgB,QAAQ,CAA4B,QAAa;QAC/D,MAAM,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC;QACjC,MAAM,OAAO,GAAG,CAAC,IAAI,IAAI,EAAE,GAAG,KAAK,CAAC,IAAI,CAAC;QAEzC,IAAI,OAAO,IAAI,KAAK,CAAC,KAAK,EAAE;YAC1B,YAAY,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;YAC9B,KAAK,CAAC,SAAS,GAAG,IAAI,CAAC;YACvB,KAAK,CAAC,IAAI,GAAG,CAAC,IAAI,IAAI,EAAE,CAAC;YACzB,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;YAC/B,OAAO;SACR;QAED,KAAK,CAAC,QAAQ,GAAG,QAAQ,CAAC;QAE1B,IAAI,KAAK,CAAC,SAAS,KAAK,IAAI,EAAE;YAC5B,KAAK,CAAC,SAAS,GAAG,UAAU,CAC1B;gBACE,KAAK,CAAC,SAAS,GAAG,IAAI,CAAC;gBACvB,KAAK,CAAC,IAAI,GAAG,CAAC,IAAI,IAAI,EAAE,CAAC;gBACzB,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;aACtC,EACD,KAAK,CAAC,KAAK,GAAG,OAAO,CACtB,CAAC;SACH;IACH,CAAC;AAGD,AAAaC,mCAAuB,GAApC,MAAa,uBAAuB;QAC3B,IAAI,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B,EAAE,QAAgB,GAAG;YACjG,IAAI,gBAAwB,CAAC;YAE7B,IAAI,OAAO,YAAYN,eAAO,EAAE;gBAC9B,IAAI,OAAO,CAAC,IAAI,KAAKZ,mBAAW,CAAC,MAAM,EAAE;oBACvC,gBAAgB,GAAG,cAAc,CAAC;iBACnC;qBAAM;oBACL,gBAAgB,GAAG,cAAc,CAAC;iBACnC;aACF;iBAAM;gBACL,gBAAgB,GAAG,YAAY,CAAC;aACjC;;;;YAKD,OAAO,CAAC,eAAe,GAAG,OAAO,CAAC,gBAAgB,CAAC,CAAC;YACpD,OAAO,CAAC,eAAe,CAAC,YAAY,GAAG,gBAAgB,CAAC;;YAGxD,OAAO,CAAC,gBAAgB,CAAC,GAAG,QAAQ,CAAC;;YAGrC,OAAO,CAAC,aAAa,GAAG;gBACtB,KAAK,EAAE,KAAK;gBACZ,IAAI,EAAE,CAAC;gBACP,SAAS,EAAE,IAAI;aAChB,CAAC;SACH;QAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;;YAE9E,MAAM,eAAe,GAAG,OAAO,CAAC,eAAe,CAAC,YAAY,CAAC;YAC7D,OAAO,CAAC,eAAe,CAAC,GAAG,OAAO,CAAC,eAAe,CAAC;YACnD,OAAO,CAAC,eAAe,GAAG,IAAI,CAAC;YAC/B,YAAY,CAAC,OAAO,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;YAC9C,OAAO,CAAC,aAAa,GAAG,IAAI,CAAC;SAC9B;KACF,CAAA;AAvCYkB,mCAAuB;QADnC,eAAe,CAAC,UAAU,CAAC;OACfA,+BAAuB,CAuCnC;;IC7ED,SAASC,OAAK;QACZ,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC3C,IAAI,CAAC,aAAa,EAAE,CAAC;IACvB,CAAC;IAED,SAASd,SAAO;QACd,IAAI,CAAC,UAAU,CAAC,SAAS,GAAG,SAAS,CAAC;QACtC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;QACvB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;IACvB,CAAC;IAED,SAAS,oBAAoB;QAC3B,MAAM,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC;QACnC,MAAM,QAAQ,IAAc,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;QACxD,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,OAAO,CAAC,GAAG,GAAG,EAAE;YACd,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC;SACnB;QACD,QAAQ,CAAC,YAAY,GAAG,EAAE,CAAC;IAC7B,CAAC;IAED,SAAS,kBAAkB;QACzB,MAAM,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;QACjC,MAAM,QAAQ,IAAc,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;QACxD,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,OAAO,CAAC,GAAG,GAAG,EAAE;YACd,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC;SACnB;QACD,QAAQ,CAAC,YAAY,GAAG,EAAE,CAAC;IAC7B,CAAC;IAED,SAAS,iBAAiB;QACxB,OAAO,IAAI,CAAC,cAAc,KAAU,IAAI,CAAC,cAAc,GAAG,IAAIe,gCAAwB,CAAM,IAAI,EAAE,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC;IAC9H,CAAC;AAED,aAAgB,kBAAkB,CAAC,IAAoE;QACrG,OAAO,UAAS,MAAgB;YAC9B,oBAAoB,CAACjC,oBAAY,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC,CAAC;YACtD,2BAA2B,EAAE,CAAC,MAAM,CAAC,CAAC;YACtC,MAAM,KAAK,GAAuB,MAAM,CAAC,SAAS,CAAC;YAEnD,KAAK,CAAC,UAAU,GAAG,IAAI,CAAC;YAExB,KAAK,CAAC,UAAU,GAAG,IAAI,CAAC;YACxB,KAAK,CAAC,QAAQ,GAAG,IAAI,CAAC;YACtB,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC;YACzB,KAAK,CAAC,kBAAkB,GAAG,IAAI,qBAA4B,QAAQ,GAAG,MAAM,CAAC;YAC7E,KAAK,CAAC,cAAc,GAAG,IAAI,CAAC;YAC5B,KAAK,CAAC,aAAa,GAAG,IAAI,qBAA4B,oBAAoB,GAAG,kBAAkB,CAAC;YAChG,KAAK,CAAC,KAAK,GAAGgC,OAAK,CAAC;YACpB,KAAK,CAAC,OAAO,GAAGd,SAAO,CAAC;YACxB,KAAK,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;YAE5C,KAAK,CAAC,SAAS,GAAG,KAAK,CAAC,SAAS,IAAI,KAAK,CAAC,aAAa,CAAC;YACzD,KAAK,CAAC,WAAW,GAAG,KAAK,CAAC,WAAW,IAAI,KAAK,CAAC,gBAAgB,CAAC;YAEhE,KAAK,CAAC,gBAAgB,GAAG,KAAK,CAAC,gBAAgB,IAAI,KAAK,CAAC,oBAAoB,CAAC;YAC9E,KAAK,CAAC,kBAAkB,GAAG,KAAK,CAAC,kBAAkB,IAAI,KAAK,CAAC,uBAAuB,CAAC;SACtF,CAAC;IACJ,CAAC;AAKD,AAAae,oCAAwB,GAArC,MAAa,wBAAwB;QAInC,YAAmB,GAAe,EAAS,WAA8B;YAAtD,QAAG,GAAH,GAAG,CAAY;YAAS,gBAAW,GAAX,WAAW,CAAmB;YACvE,IAAI,CAAC,YAAY,GAAG,GAAG,CAAC,WAAW,CAAC,CAAC;SACtC;QAEM,QAAQ;YACb,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;SACnC;QAEM,YAAY,CAAC,QAAgB;YAClC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,QAAQ,CAAC;SACvC;QAEM,SAAS,CAAC,UAA+B;YAC9C,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;SAChC;QAEM,WAAW,CAAC,UAA+B;YAChD,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;SACnC;KACF,CAAA;AAvBYA,oCAAwB;QADpC,cAAc,EAAE;OACJA,gCAAwB,CAuBpC;;IC1FD,MAAM,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC;AAC9B,UAAa,UAAU,GAAG,KAAK,CAAC,IAAI,CAAC;AACrC,UAAa,aAAa,GAAG,KAAK,CAAC,OAAO,CAAC;AAC3C,UAAa,SAAS,GAAG,KAAK,CAAC,GAAG,CAAC;AACnC,UAAa,WAAW,GAAG,KAAK,CAAC,KAAK,CAAC;AACvC,UAAa,YAAY,GAAG,KAAK,CAAC,MAAM,CAAC;AACzC,UAAa,aAAa,GAAG,KAAK,CAAC,OAAO,CAAC;AAC3C,UAAa,UAAU,GAAG,KAAK,CAAC,IAAI,CAAC;IAErC;IACA,SAAS,WAAW;QAClB,MAAM,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC;QACzB,IAAI,CAAC,KAAK,SAAS,EAAE;YACnB,OAAO,UAAU,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;SAC1C;QACD,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;QACxB,MAAM,QAAQ,GAAG,SAAS,CAAC,MAAM,CAAC;QAClC,IAAI,QAAQ,KAAK,CAAC,EAAE;YAClB,OAAO,GAAG,CAAC;SACZ;QACD,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,QAAQ,CAAC,MAAM,GAAG,GAAG,GAAG,QAAQ,CAAC;QACjD,IAAI,CAAC,GAAG,GAAG,CAAC;QACZ,OAAO,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE;YACtB,IAAI,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC;YAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAE,CAAC,CAAC;YAClD,CAAC,EAAE,CAAC;SACL;QACD,CAAC,CAAC,eAAe,CAAC,MAAM,EAAE,SAAS,EAAElC,sBAAc,CAAC,oBAAoB,CAAC,CAAC;QAC1E,OAAO,IAAI,CAAC,MAAM,CAAC;IACrB,CAAC;IAED;IACA,SAAS,cAAc;QACrB,MAAM,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC;QACzB,IAAI,CAAC,KAAK,SAAS,EAAE;YACnB,OAAO,aAAa,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;SAC7C;QACD,MAAM,QAAQ,GAAG,SAAS,CAAC,MAAM,CAAC;QAClC,MAAM,OAAO,GAAG,IAAI,KAAK,CAAC,QAAQ,CAAC,CAAC;QACpC,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,OAAO,CAAC,GAAG,QAAQ,EAAE;YACnB,OAAO,CAAC,CAAC,EAAE,CAAC,GAAG,CAAE,CAAC,CAAC;SACpB;QACD,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QACzC,MAAM,GAAG,GAAG,aAAa,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;QACjD,CAAC,CAAC,eAAe,CAAC,SAAS,EAAE,SAAS,EAAEA,sBAAc,CAAC,oBAAoB,CAAC,CAAC;QAC7E,OAAO,GAAG,CAAC;IACb,CAAC;IAED;IACA,SAAS,UAAU;QACjB,MAAM,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC;QACzB,IAAI,CAAC,KAAK,SAAS,EAAE;YACnB,OAAO,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAC7B;QACD,MAAM,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;QAC5B,MAAM,OAAO,GAAG,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;;QAErC,MAAM,KAAK,GAAG,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;QAClC,IAAI,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,EAAE;YACxB,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;SACjD;QACD,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACzB,CAAC,CAAC,eAAe,CAAC,KAAK,EAAE,SAAS,EAAEA,sBAAc,CAAC,oBAAoB,CAAC,CAAC;QACzE,OAAO,OAAO,CAAC;IACjB,CAAC;IAED;IACA,SAAS,YAAY;QACnB,MAAM,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC;QACzB,IAAI,CAAC,KAAK,SAAS,EAAE;YACnB,OAAO,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAC/B;QACD,MAAM,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;QAC5B,MAAM,OAAO,GAAG,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;;QAEvC,IAAI,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;YACpB,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;SACjD;QACD,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC3B,CAAC,CAAC,eAAe,CAAC,OAAO,EAAE,SAAS,EAAEA,sBAAc,CAAC,oBAAoB,CAAC,CAAC;QAC3E,OAAO,OAAO,CAAC;IACjB,CAAC;IAED;IACA,SAAS,aAAa,CAAuB,KAAa,EAAE,WAAoB;QAC9E,MAAM,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC;QACzB,IAAI,CAAC,KAAK,SAAS,EAAE;YACnB,OAAO,YAAY,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;SAC5C;QACD,MAAM,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;QAC5B,IAAI,WAAW,GAAG,CAAC,EAAE;YACnB,IAAI,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;YACjC,MAAM,EAAE,GAAG,CAAC,GAAG,WAAW,CAAC;YAC3B,OAAO,CAAC,GAAG,EAAE,EAAE;gBACb,IAAI,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;oBACpB,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;iBACjD;gBACD,CAAC,EAAE,CAAC;aACL;SACF;QACD,MAAM,QAAQ,GAAG,SAAS,CAAC,MAAM,CAAC;QAClC,IAAI,QAAQ,GAAG,CAAC,EAAE;YAChB,MAAM,SAAS,GAAG,QAAQ,GAAG,CAAC,CAAC;YAC/B,MAAM,OAAO,GAAG,IAAI,KAAK,CAAC,SAAS,CAAC,CAAC;YACrC,IAAI,CAAC,GAAG,CAAC,CAAC;YACV,OAAO,CAAC,GAAG,SAAS,EAAE;gBACpB,OAAO,CAAC,CAAC,EAAE,CAAC,GAAG,CAAE,CAAC,CAAC;aACpB;YACD,YAAY,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,EAAE,WAAW,EAAE,GAAG,OAAO,CAAC,CAAC;SAC7D;aAAM,IAAI,QAAQ,KAAK,CAAC,EAAE;YACzB,YAAY,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,EAAE,WAAW,CAAC,CAAC;SACjD;QACD,MAAM,OAAO,GAAG,YAAY,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;QACpD,CAAC,CAAC,eAAe,CAAC,QAAQ,EAAE,SAAS,EAAEA,sBAAc,CAAC,oBAAoB,CAAC,CAAC;QAC5E,OAAO,OAAO,CAAC;IACjB,CAAC;IAED;IACA,SAAS,cAAc;QACrB,MAAM,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC;QACzB,IAAI,CAAC,KAAK,SAAS,EAAE;YACnB,OAAO,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACjC;QACD,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;QACxB,MAAM,MAAM,GAAG,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC;QAC7B,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,OAAO,KAAK,KAAK,MAAM,EAAE;YACvB,MAAM,KAAK,GAAG,GAAG,GAAG,KAAK,GAAG,CAAC,CAAC;YAC9B,MAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;YAAC,MAAM,UAAU,GAAG,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;YACrE,MAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;YAAC,MAAM,UAAU,GAAG,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;YACrE,IAAI,CAAC,KAAK,CAAC,GAAG,UAAU,CAAC;YAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,UAAU,CAAC;YACzD,IAAI,CAAC,KAAK,CAAC,GAAG,UAAU,CAAC;YAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,UAAU,CAAC;YACzD,KAAK,EAAE,CAAC;SACT;QACD,CAAC,CAAC,eAAe,CAAC,SAAS,EAAE,SAAS,EAAEA,sBAAc,CAAC,oBAAoB,CAAC,CAAC;QAC7E,OAAO,IAAI,CAAC;IACd,CAAC;IAED;IACA;IACA,SAAS,WAAW,CAAuB,SAA4E;QACrH,MAAM,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC;QACzB,IAAI,CAAC,KAAK,SAAS,EAAE;YACnB,OAAO,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;SACzC;QACD,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;QACxB,IAAI,GAAG,GAAG,CAAC,EAAE;YACX,OAAO,IAAI,CAAC;SACb;QACD,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC,QAAQ,EAAE,CAAC,EAAE,GAAG,EAAE,cAAc,CAAC,CAAC;QACpD,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,OAAO,CAAC,GAAG,GAAG,EAAE;YACd,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,SAAS,EAAE;gBACzB,MAAM;aACP;YACD,CAAC,EAAE,CAAC;SACL;QACD,IAAI,SAAS,KAAK,SAAS,IAAI,OAAO,SAAS,KAAK,UAAU,0DAAyD;YACrH,SAAS,GAAG,WAAW,CAAC;SACzB;QACD,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,EAAE,SAAS,CAAC,CAAC;QAC7C,CAAC,CAAC,eAAe,CAAC,MAAM,EAAE,SAAS,EAAEA,sBAAc,CAAC,oBAAoB,CAAC,CAAC;QAC1E,OAAO,IAAI,CAAC;IACd,CAAC;IAED;IACA,SAAS,WAAW,CAAC,CAAyB,EAAE,CAAyB;QACvE,IAAI,CAAC,KAAK,CAAC,EAAE;YACX,OAAO,CAAC,CAAC;SACV;QACD,CAAC,GAAG,CAAC,KAAK,IAAI,GAAG,MAAM,GAAG,CAAC,CAAC,QAAQ,EAAE,CAAC;QACvC,CAAC,GAAG,CAAC,KAAK,IAAI,GAAG,MAAM,GAAG,CAAC,CAAC,QAAQ,EAAE,CAAC;QACvC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;IACxB,CAAC;IAED,SAAS,cAAc,CAAC,CAAyB,EAAE,CAAyB;QAC1E,IAAI,CAAC,KAAK,SAAS,EAAE;YACnB,IAAI,CAAC,KAAK,SAAS,EAAE;gBACnB,OAAO,CAAC,CAAC;aACV;iBAAM;gBACL,OAAO,CAAC,CAAC;aACV;SACF;QACD,IAAI,CAAC,KAAK,SAAS,EAAE;YACnB,OAAO,CAAC,CAAC,CAAC;SACX;QACD,OAAO,CAAC,CAAC;IACX,CAAC;IAED,SAAS,aAAa,CAAC,GAAmB,EAAE,QAAkB,EAAE,SAAiB,EAAE,OAAe,EAAE,SAA2E;QAC7K,IAAI,QAAQ,EAAE,QAAQ,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC;QAC1C,IAAI,CAAC,EAAE,CAAC,CAAC;QACT,KAAK,CAAC,GAAG,SAAS,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,EAAE,CAAC,EAAE,EAAE;YACxC,QAAQ,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;YAAC,QAAQ,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;YAC1C,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,SAAS,EAAE,CAAC,EAAE,EAAE;gBACnC,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;gBAAC,IAAI,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;gBAClC,KAAK,GAAG,SAAS,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;gBAClC,IAAI,KAAK,GAAG,CAAC,EAAE;oBACb,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC;oBAAC,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC;iBAC3C;qBAAM;oBACL,MAAM;iBACP;aACF;YACD,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ,CAAC;YAAC,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ,CAAC;SACnD;IACH,CAAC;IAED,SAAS,SAAS,CAAC,GAAmB,EAAE,QAAkB,EAAE,SAAiB,EAAE,OAAe,EAAE,SAA2E;QACzK,IAAI,UAAU,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;QAC1B,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;QACf,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;QACf,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;QAClB,IAAI,IAAI,EAAE,IAAI,CAAC;QACf,IAAI,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,SAAS,CAAC;QACtC,IAAI,QAAQ,EAAE,QAAQ,EAAE,KAAK,EAAE,WAAW,CAAC;;QAG3C,OAAO,IAAI,EAAE;YACX,IAAI,OAAO,GAAG,SAAS,IAAI,EAAE,EAAE;gBAC7B,aAAa,CAAC,GAAG,EAAE,QAAQ,EAAE,SAAS,EAAE,OAAO,EAAE,SAAS,CAAC,CAAC;gBAC5D,OAAO;aACR;YAED,UAAU,GAAG,SAAS,IAAI,CAAC,OAAO,GAAG,SAAS,KAAK,CAAC,CAAC,CAAC;YACtD,EAAE,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC;YAAO,EAAE,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC;YACpD,EAAE,GAAG,GAAG,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC;YAAK,EAAE,GAAG,QAAQ,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC;YACtD,EAAE,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC;YAAC,EAAE,GAAG,QAAQ,CAAC,UAAU,CAAC,CAAC;YAChD,GAAG,GAAG,SAAS,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;YACxB,IAAI,GAAG,GAAG,CAAC,EAAE;gBACX,IAAI,GAAG,EAAE,CAAC;gBAAC,IAAI,GAAG,EAAE,CAAC;gBACrB,EAAE,GAAG,EAAE,CAAC;gBAAG,EAAE,GAAG,EAAE,CAAC;gBACnB,EAAE,GAAG,IAAI,CAAC;gBAAC,EAAE,GAAG,IAAI,CAAC;aACtB;YACD,GAAG,GAAG,SAAS,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;YACxB,IAAI,GAAG,IAAI,CAAC,EAAE;gBACZ,IAAI,GAAG,EAAE,CAAC;gBAAC,IAAI,GAAG,EAAE,CAAC;gBACrB,EAAE,GAAG,EAAE,CAAC;gBAAG,EAAE,GAAG,EAAE,CAAC;gBACnB,EAAE,GAAG,EAAE,CAAC;gBAAG,EAAE,GAAG,EAAE,CAAC;gBACnB,EAAE,GAAG,IAAI,CAAC;gBAAC,EAAE,GAAG,IAAI,CAAC;aACtB;iBAAM;gBACL,GAAG,GAAG,SAAS,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;gBACxB,IAAI,GAAG,GAAG,CAAC,EAAE;oBACX,IAAI,GAAG,EAAE,CAAC;oBAAC,IAAI,GAAG,EAAE,CAAC;oBACrB,EAAE,GAAG,EAAE,CAAC;oBAAG,EAAE,GAAG,EAAE,CAAC;oBACnB,EAAE,GAAG,IAAI,CAAC;oBAAC,EAAE,GAAG,IAAI,CAAC;iBACtB;aACF;YACD,GAAG,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC;YAAG,QAAQ,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC;YAChD,GAAG,CAAC,OAAO,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC;YAAC,QAAQ,CAAC,OAAO,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC;YAClD,MAAM,GAAG,EAAE,CAAC;YAAM,MAAM,GAAG,EAAE,CAAC;YAC9B,MAAM,GAAG,SAAS,GAAG,CAAC,CAAC;YACvB,SAAS,GAAG,OAAO,GAAG,CAAC,CAAC;YACxB,GAAG,CAAC,UAAU,CAAC,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC;YAAC,QAAQ,CAAC,UAAU,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;YACvE,GAAG,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC;YAAU,QAAQ,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC;YAEzD,SAAS,EAAE,KAAK,CAAC,GAAG,MAAM,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,EAAE,CAAC,EAAE,EAAE;gBAClD,QAAQ,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;gBAAC,QAAQ,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;gBAC1C,KAAK,GAAG,SAAS,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;gBACpC,IAAI,KAAK,GAAG,CAAC,EAAE;oBACb,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC;oBAAG,QAAQ,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;oBACvD,GAAG,CAAC,MAAM,CAAC,GAAG,QAAQ,CAAC;oBAAC,QAAQ,CAAC,MAAM,CAAC,GAAG,QAAQ,CAAC;oBACpD,MAAM,EAAE,CAAC;iBACV;qBAAM,IAAI,KAAK,GAAG,CAAC,EAAE;oBACpB,GAAG;wBACD,SAAS,EAAE,CAAC;;wBAEZ,IAAI,SAAS,IAAI,CAAC,EAAE;4BAClB,MAAM,SAAS,CAAC;yBACjB;wBACD,WAAW,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC;wBAAU,KAAK,GAAG,SAAS,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC;qBAC/E,QAAQ,KAAK,GAAG,CAAC,EAAE;oBACpB,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC;oBAAG,QAAQ,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC;oBAC7D,GAAG,CAAC,SAAS,CAAC,GAAG,QAAQ,CAAC;oBAAC,QAAQ,CAAC,SAAS,CAAC,GAAG,QAAQ,CAAC;oBAC1D,IAAI,KAAK,GAAG,CAAC,EAAE;wBACb,QAAQ,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;wBAAM,QAAQ,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;wBAC/C,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC;wBAAG,QAAQ,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;wBACvD,GAAG,CAAC,MAAM,CAAC,GAAG,QAAQ,CAAC;wBAAC,QAAQ,CAAC,MAAM,CAAC,GAAG,QAAQ,CAAC;wBACpD,MAAM,EAAE,CAAC;qBACV;iBACF;aACF;YACD,IAAI,OAAO,GAAG,SAAS,GAAG,MAAM,GAAG,SAAS,EAAE;gBAC5C,SAAS,CAAC,GAAG,EAAE,QAAQ,EAAE,SAAS,EAAE,OAAO,EAAE,SAAS,CAAC,CAAC;gBACxD,OAAO,GAAG,MAAM,CAAC;aAClB;iBAAM;gBACL,SAAS,CAAC,GAAG,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,EAAE,SAAS,CAAC,CAAC;gBACvD,SAAS,GAAG,SAAS,CAAC;aACvB;SACF;IACH,CAAC;IAED,KAAK,MAAM,OAAO,IAAI,CAAC,WAAW,EAAE,cAAc,EAAE,UAAU,EAAE,YAAY,EAAE,aAAa,EAAE,cAAc,EAAE,WAAW,CAAC,EAAE;QACzH,MAAM,CAAC,cAAc,CAAC,OAAO,EAAE,WAAW,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,YAAY,EAAE,KAAK,EAAE,UAAU,EAAE,KAAK,EAAE,CAAC,CAAC;KACvH;AAED,aAAgB,sBAAsB;QACpC,IAAI,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,IAAI;YAAE,KAAK,CAAC,IAAI,GAAG,WAAW,CAAC;QAC/D,IAAI,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,KAAK,IAAI;YAAE,KAAK,CAAC,OAAO,GAAG,cAAc,CAAC;QACxE,IAAI,KAAK,CAAC,GAAG,CAAC,WAAW,CAAC,KAAK,IAAI;YAAE,KAAK,CAAC,GAAG,GAAG,UAAU,CAAC;QAC5D,IAAI,KAAK,CAAC,KAAK,CAAC,WAAW,CAAC,KAAK,IAAI;YAAE,KAAK,CAAC,KAAK,GAAG,YAAY,CAAC;QAClE,IAAI,KAAK,CAAC,MAAM,CAAC,WAAW,CAAC,KAAK,IAAI;YAAE,KAAK,CAAC,MAAM,GAAG,aAAa,CAAC;QACrE,IAAI,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,KAAK,IAAI;YAAE,KAAK,CAAC,OAAO,GAAG,cAAc,CAAC;QACxE,IAAI,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,IAAI;YAAE,KAAK,CAAC,IAAI,GAAG,WAAW,CAAC;IACjE,CAAC;IAED,sBAAsB,EAAE,CAAC;AAEzB,aAAgB,uBAAuB;QACrC,IAAI,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,IAAI;YAAE,KAAK,CAAC,IAAI,GAAG,UAAU,CAAC;QAC9D,IAAI,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,KAAK,IAAI;YAAE,KAAK,CAAC,OAAO,GAAG,aAAa,CAAC;QACvE,IAAI,KAAK,CAAC,GAAG,CAAC,WAAW,CAAC,KAAK,IAAI;YAAE,KAAK,CAAC,GAAG,GAAG,SAAS,CAAC;QAC3D,IAAI,KAAK,CAAC,KAAK,CAAC,WAAW,CAAC,KAAK,IAAI;YAAE,KAAK,CAAC,KAAK,GAAG,WAAW,CAAC;QACjE,IAAI,KAAK,CAAC,MAAM,CAAC,WAAW,CAAC,KAAK,IAAI;YAAE,KAAK,CAAC,MAAM,GAAG,YAAY,CAAC;QACpE,IAAI,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,KAAK,IAAI;YAAE,KAAK,CAAC,OAAO,GAAG,aAAa,CAAC;QACvE,IAAI,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,IAAI;YAAE,KAAK,CAAC,IAAI,GAAG,UAAU,CAAC;IAChE,CAAC;AAKD,AAAamC,yBAAa,GAA1B,MAAa,aAAa;QAKxB,YAAY,SAAqB,EAAE,KAAqB;YACtD,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;YAC3B,KAAK,CAAC,SAAS,GAAG,IAAI,CAAC;YACvB,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;YACxB,IAAI,CAAC,aAAa,EAAE,CAAC;SACtB;KACF,CAAA;AAXYA,yBAAa;QADzB,kBAAkB,eAAsB;OAC5BA,qBAAa,CAWzB;aAEe,gBAAgB,CAAC,SAAqB,EAAE,KAAqB;QAC3E,OAAQ,KAAK,CAAC,SAA2B,IAAI,IAAIA,qBAAa,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;IACnF,CAAC;;aCjUe,QAAQ,CAAC,MAAyB;QAChD,OAAO,UAAS,MAA+B,EAAE,GAAW;YAC1D,CAAC,MAAM,CAAC,QAAQ,KAAK,MAAM,CAAC,QAAQ,GAAG,EAAE,CAAC,EAAE,GAAG,CAAC,GAAG,MAAM,CAAC;SAC3D,CAAC;IACJ,CAAC;IAED,MAAM,OAAO,GAAG,EAAE,OAAO,KAAK,KAAK,SAAS,CAAC,CAAC;IAC9C,MAAM,wBAAwB,GAAsB,EAAE,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,KAAK,EAAE,CAAC;IAEvF;AACA,aAAgB,sBAAsB,CACpC,eAAiC,EACjC,YAA2B,EAC3B,SAAqB;IACrB;IACA,QAAkE,EAClE,YAAoB,EACpB,UAA8B;QAE9B,IAAI,UAAU,CAAC,YAAY,KAAK,KAAK,EAAE;YACrC,OAAO,YAAY,CAAC,cAAc,CAAC,QAAQ,EAAE,YAAY,CAAC,CAAC;SAC5D;QAED,IAAI,UAAU,CAAC,GAAG,EAAE;YAClB,MAAM,SAAS,GAAsB,QAAQ,CAAC,WAAW,CAAC,QAAQ;kBAC9D,QAAQ,CAAC,WAAW,CAAC,QAAQ,CAAC,YAAY,CAAC,IAAI,wBAAwB;kBACvE,wBAAwB,CAAC;YAE7B,IAAI,UAAU,CAAC,GAAG,EAAE;gBAClB,IAAI,SAAS,CAAC,QAAQ,EAAE;oBACtB,OAAO,OAAO;0BACV,YAAY,CAAC,cAAc,CAAC,QAAQ,EAAE,YAAY,CAAC;0BACnD,IAAIC,sBAAc,CAAC,SAAS,EAAE,QAAQ,EAAE,YAAY,EAAE,UAAU,EAAE,eAAe,EAAE,SAAS,CAAC,CAAC;iBACnG;gBAED,OAAO,IAAIC,4BAAoB,CAAC,QAAQ,EAAE,YAAY,EAAE,UAAU,EAAE,SAAS,CAAC,CAAC;aAChF;YAED,OAAO,OAAO;kBACV,YAAY,CAAC,cAAc,CAAC,QAAQ,EAAE,YAAY,CAAC;kBACnD,IAAID,sBAAc,CAAC,SAAS,EAAE,QAAQ,EAAE,YAAY,EAAE,UAAU,EAAE,eAAe,EAAE,SAAS,CAAC,CAAC;SACnG;QAED,MAAM7B,eAAQ,CAAC,KAAK,CAAC,EAAE,EAAE,YAAY,CAAC,CAAC;IACzC,CAAC;IAID;AAEA,AAAa8B,gCAAoB,GAAjC,MAAa,oBAAoB;QAO/B,YACS,GAAgB,EAChB,WAAmB,EAClB,UAA8B,EAC9B,SAAqB;YAHtB,QAAG,GAAH,GAAG,CAAa;YAChB,gBAAW,GAAX,WAAW,CAAQ;YAClB,eAAU,GAAV,UAAU,CAAoB;YAC9B,cAAS,GAAT,SAAS,CAAY;YAVxB,eAAU,GAAS,IAAI,CAAC;YAExB,cAAS,GAAY,KAAK,CAAC;SAS7B;QAEE,QAAQ;YACb,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;SACnC;QAEM,QAAQ,CAAC,QAAgC;YAC9C,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,QAAQ,CAAC;SACvC;QAEM,KAAK,CAAC,KAAqB;YAChC,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;YAC/B,MAAM,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC;YAEnC,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,QAAQ,EAAE,KAAK,GAAGrC,sBAAc,CAAC,oBAAoB,CAAC,CAAC;SACvF;QAEM,SAAS,CAAC,UAA+B;YAC9C,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;gBACnB,IAAI,CAAC,eAAe,EAAE,CAAC;aACxB;YACD,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;SAChC;QAEM,WAAW,CAAC,UAA+B;YAChD,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;SACnC;QAEM,eAAe;YACpB,MAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC;YACnC,MAAM,IAAI,GAAG,IAAI,CAAC;YAElB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;YACtB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;YAE/C,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,WAAW,EAAE;gBACjD,GAAG,EAAE,UAAS,QAAgC;oBAC5C,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;oBAEhC,MAAM,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC;oBAEnC,IAAI,QAAQ,KAAK,QAAQ,EAAE;wBACzB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;wBACzB,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;wBAEhC,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC;qBAC9B;iBACF;aACF,CAAC,CAAC;SACJ;KACF,CAAA;AA9DYqC,gCAAoB;QADhC,oBAAoB,CAACpC,oBAAY,CAAC,QAAQ,CAAC;OAC/BoC,4BAAoB,CA8DhC;AAEDA,gCAAoB,CAAC,SAAS,CAAC,OAAO,GAAGlC,eAAQ,CAAC,IAAI,CAAC;IAIvD;IACA;IACA;AAEA,AAAaiC,0BAAc,GAA3B,MAAa,cAAc;QAIzB,YACU,SAA4B,EAC7B,GAAgB,EAChB,WAAmB,EAClB,UAA8B,EAC9B,eAAiC,EACjC,SAAqB;YALrB,cAAS,GAAT,SAAS,CAAmB;YAC7B,QAAG,GAAH,GAAG,CAAa;YAChB,gBAAW,GAAX,WAAW,CAAQ;YAClB,eAAU,GAAV,UAAU,CAAoB;YAC9B,oBAAe,GAAf,eAAe,CAAkB;YACjC,cAAS,GAAT,SAAS,CAAY;YAE7B,IAAI,CAAC,UAAU,GAAG,IAAI,gBAAgB,CACpC,SAAS,EACT,GAAG,EACH,WAAW,EACX,UAAU,EACV,IAAI,EACJ,eAAe,EACf,SAAS,CACV,CAAC;SACH;QAEM,QAAQ;YACb,OAAO,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC;SAC9B;;QAGM,QAAQ,CAAC,QAAgC,KAAW;QAEpD,KAAK,CAAC,KAAqB;YAChC,MAAM,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC;YACvC,MAAM,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,8BAA8B,EAAE,CAAC;YAElE,IAAI,QAAQ,KAAK,QAAQ,EAAE;gBACzB,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,QAAQ,EAAE,KAAK,GAAGpC,sBAAc,CAAC,oBAAoB,CAAC,CAAC;aACvF;SACF;QAEM,SAAS,CAAC,UAA+B;YAC9C,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;YAC/B,IAAI,CAAC,UAAU,CAAC,iBAAiB,EAAE,CAAC;SACrC;QAEM,WAAW,CAAC,UAA+B;YAChD,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;YAClC,IAAI,CAAC,UAAU,CAAC,mBAAmB,EAAE,CAAC;SACvC;KACF,CAAA;AAhDYoC,0BAAc;QAD1B,oBAAoB,CAACnC,oBAAY,CAAC,QAAQ,CAAC;OAC/BmC,sBAAc,CAgD1B;AAEDA,0BAAc,CAAC,SAAS,CAAC,OAAO,GAAGjC,eAAQ,CAAC,IAAI,CAAC;IAEjD;AACA,UAAa,gBAAgB;QAO3B,YACU,SAA4B,EAC5B,QAAqB,EACrB,YAAoB,EAC5B,UAA8B,EACtB,KAAqB,EAC7B,eAAiC,EACzB,SAAqB;YANrB,cAAS,GAAT,SAAS,CAAmB;YAC5B,aAAQ,GAAR,QAAQ,CAAa;YACrB,iBAAY,GAAZ,YAAY,CAAQ;YAEpB,UAAK,GAAL,KAAK,CAAgB;YAErB,cAAS,GAAT,SAAS,CAAY;YAZxB,iBAAY,GAAY,KAAK,CAAC;YAE7B,iBAAY,GAA2C,EAAE,CAAC;YAC1D,oBAAe,GAAW,CAAC,CAAC;YAWlC,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,QAAQ,EAAE,iBAAiB,CAAC,eAAe,EAAE,IAAI,CAAC,CAAC,CAAC;YAC5E,MAAM,MAAM,GAAG,UAAU,CAAC,GAAG,CAAC;YAC9B,MAAM,IAAI,GAAG,IAAI,CAAC;YAElB,OAAO,CAAC,cAAc,CAAC,QAAQ,EAAE,YAAY,EAAE;gBAC7C,GAAG,EAAE;oBACH,IAAI,IAAI,CAAC,eAAe,GAAG,CAAC,IAAI,IAAI,CAAC,YAAY,EAAE;wBACjD,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;qBAClC;oBAED,OAAO,IAAI,CAAC,KAAK,CAAC;iBACnB;aACF,CAAC,CAAC;SACJ;QAEM,aAAa,CAAC,YAAkD;YACrE,IAAI,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,YAAY,CAAC,EAAE;gBAC5C,OAAO;aACR;YAED,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;SACtC;QAEM,iBAAiB;YACtB,IAAI,CAAC,eAAe,EAAE,CAAC;YAEvB,IAAI,IAAI,CAAC,eAAe,GAAG,CAAC,EAAE;gBAC5B,OAAO;aACR;YAED,IAAI,CAAC,8BAA8B,CAAC,IAAI,CAAC,CAAC;SAC3C;QAEM,8BAA8B,CAAC,iBAA0B,KAAK;YACnE,MAAM,mBAAmB,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI,cAAc,CAAC;YAErE,IAAI,mBAAmB,EAAE;gBACvB,IAAI,CAAC,0BAA0B,EAAE,CAAC;gBAClC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;aAC1B;YAED,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;YAE9C,IAAI,mBAAmB,EAAE;gBACvB,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;gBAC1B,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;aACxD;YAED,OAAO,IAAI,CAAC,KAAK,CAAC;SACnB;QAEM,mBAAmB;YACxB,IAAI,CAAC,eAAe,EAAE,CAAC;YAEvB,IAAI,IAAI,CAAC,eAAe,KAAK,CAAC,EAAE;gBAC9B,IAAI,CAAC,0BAA0B,EAAE,CAAC;aACnC;SACF;QAEM,YAAY;YACjB,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACzC;QAEO,0BAA0B;YAChC,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;YACzD,IAAI,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC;SAC9B;KACF;IAED,SAAS,iBAAiB,CAAC,eAAiC,EAAE,UAA4B;QACxF,OAAO;YACL,GAAG,EAAE,UAAS,QAAoB,EAAE,GAAW;gBAC7C,MAAM,KAAK,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC;gBAE5B,IAAI,GAAG,KAAK,YAAY,IAAI,OAAO,KAAK,KAAK,UAAU,IAAI,CAAC,UAAU,CAAC,YAAY,EAAE;oBACnF,OAAO,KAAK,CAAC;iBACd;;gBAGD,IAAI,QAAQ,YAAY,KAAK,EAAE;oBAC7B,UAAU,CAAC,aAAa,CAAC,eAAe,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC,CAAC;oBAErE,IAAI,GAAG,KAAK,QAAQ,EAAE;wBACpB,UAAU,CAAC,aAAa,CAAC,eAAe,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC,iBAAiB,EAAE,CAAC,CAAC;qBAC1F;iBACF;qBAAM,IAAI,QAAQ,YAAY,GAAG,EAAE;oBAClC,UAAU,CAAC,aAAa,CAAC,eAAe,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC,CAAC;oBAEnE,IAAI,GAAG,KAAK,MAAM,EAAE;wBAClB,UAAU,CAAC,aAAa,CAAC,eAAe,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC,iBAAiB,EAAE,CAAC,CAAC;qBACxF;iBACF;qBAAM,IAAI,QAAQ,YAAY,GAAG,EAAE;oBAClC,UAAU,CAAC,aAAa,CAAC,eAAe,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC,CAAC;oBAEnE,IAAI,GAAG,KAAK,MAAM,EAAE;wBAClB,OAAO,eAAe,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC,iBAAiB,EAAE,CAAC;qBACrE;iBACF;qBAAM;oBACL,UAAU,CAAC,aAAa,CAAC,eAAe,CAAC,WAAW,CAAC,QAAQ,EAAE,GAAG,CAA2B,CAAC,CAAC;iBAChG;gBAED,OAAO,YAAY,CAAC,eAAe,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC;aACzD;SACF,CAAC;IACJ,CAAC;IAED,SAAS,YAAY,CAAC,eAAiC,EAAE,UAA4B,EAAE,KAAiB;QACtG,IAAI,EAAE,KAAK,YAAY,MAAM,CAAC,EAAE;YAC9B,OAAO,KAAK,CAAC;SACd;QAED,OAAO,IAAI,KAAK,CAAC,KAAK,EAAE,iBAAiB,CAAC,eAAe,EAAE,UAAU,CAAC,CAAC,CAAC;IAC1E,CAAC;;UCzTY,aAAa,GAAGD,SAAE,CAAC,eAAe,EAAiB;SAC7D,WAAW,CAAC,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC;IAE/C;AACA,UAAa,YAAY;QAAzB;YACU,YAAO,GAAyB,EAAE,CAAC;YACnC,eAAU,GAAW,GAAG,CAAC;SAyClC;QAvCQ,cAAc,CAAC,GAAgB,EAAE,YAAoB;YAC1D,OAAO,IAAIoC,0BAAkB,CAAC,IAAI,EAAE,GAAG,EAAE,YAAY,CAAC,CAAC;SACxD;QAEM,WAAW,CAAC,QAA4B;YAC7C,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;YAE7B,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAEvB,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;gBACxB,IAAI,CAAC,kBAAkB,EAAE,CAAC;aAC3B;SACF;QAEM,cAAc,CAAC,QAA4B;YAChD,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;YAC7B,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC;SAC9C;QAEM,kBAAkB;YACvB,UAAU,CAAC,QAAQ,IAAI,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;SACtD;QAEM,KAAK;YACV,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;YAC7B,IAAI,CAAC,GAAG,OAAO,CAAC,MAAM,CAAC;YAEvB,OAAO,CAAC,EAAE,EAAE;gBACV,MAAM,OAAO,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;gBAE3B,IAAI,OAAO,CAAC,OAAO,EAAE,EAAE;oBACrB,OAAO,CAAC,KAAK,CAACtC,sBAAc,CAAC,SAAS,CAAC,CAAC;iBACzC;aACF;YAED,IAAI,OAAO,CAAC,MAAM,EAAE;gBAClB,IAAI,CAAC,kBAAkB,EAAE,CAAC;aAC3B;SACF;KACF;IAID;AAEA,AAAasC,8BAAkB,GAA/B,MAAa,kBAAkB;QAG7B,YACU,YAA0B,EAC3B,GAAgB,EAChB,WAAmB;YAFlB,iBAAY,GAAZ,YAAY,CAAc;YAC3B,QAAG,GAAH,GAAG,CAAa;YAChB,gBAAW,GAAX,WAAW,CAAQ;SAEzB;QAEI,OAAO;YACZ,OAAO,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;SACrD;QAEM,QAAQ;YACb,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;SACnC;QAEM,QAAQ,CAAC,QAAgC;YAC9C,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,QAAQ,CAAC;SACvC;QAEM,KAAK,CAAC,KAAqB;YAChC,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;YAC/B,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;YAEjC,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,QAAQ,EAAE,KAAK,GAAGtC,sBAAc,CAAC,oBAAoB,CAAC,CAAC;YAEtF,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;SAC1B;QAEM,SAAS,CAAC,UAA+B;YAC9C,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,EAAE;gBAC1B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;gBAChC,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;aACrC;YACD,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;SAChC;QAEM,WAAW,CAAC,UAA+B;YAChD,IAAI,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,EAAE;gBAC/D,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;aACxC;SACF;KACF,CAAA;AA5CYsC,8BAAkB;QAD9B,gBAAgB,EAAE;OACNA,0BAAkB,CA4C9B;;IC7FD,MAAM,kBAAkB,GAAG;QACzB,CAAC,QAAQ,GAAG,EAAE;QACd,CAAC,UAAU,GAAG,IAAI;QAClB,CAAC,OAAO,GAAG,SAAS;QACpB,CAAC,MAAM,GAAG,EAAE;QACZ,CAAC,gBAAgB,GAAG,EAAE;QACtB,CAAC,OAAO,GAAG,EAAE;QACb,CAAC,MAAM,GAAG,EAAE;QACZ,CAAC,QAAQ,GAAG,EAAE;QACd,CAAC,OAAO,GAAG,EAAE;QACb,CAAC,OAAO,GAAG,EAAE;QACb,CAAC,QAAQ,GAAG,EAAE;QACd,CAAC,UAAU,GAAG,EAAE;QAChB,CAAC,OAAO,GAAG,IAAI;QACf,CAAC,OAAO,GAAG,IAAI;QACf,CAAC,OAAO,GAAG,EAAE;QACb,CAAC,QAAQ,GAAG,EAAE;QACd,CAAC,QAAQ,GAAG,EAAE;QACd,CAAC,KAAK,GAAG,EAAE;QACX,CAAC,MAAM,GAAG,EAAE;QACZ,CAAC,MAAM,GAAG,EAAE;QACZ,CAAC,KAAK,GAAG,EAAE;QACX,CAAC,MAAM,GAAG,EAAE;KACb,CAAC;IAEF,MAAM,gBAAgB,GAAGtC,sBAAc,CAAC,YAAY,GAAGA,sBAAc,CAAC,sBAAsB,CAAC;AAM7F,AAAauC,kCAAsB,GAAnC,MAAa,sBAAsB;QAQjC,YACS,SAAqB,EACrB,GAAU,EACV,WAAmB,EACnB,OAAyB;;;YAHzB,cAAS,GAAT,SAAS,CAAY;YACrB,QAAG,GAAH,GAAG,CAAO;YACV,gBAAW,GAAX,WAAW,CAAQ;YACnB,YAAO,GAAP,OAAO,CAAkB;;YAMhC,IAAI,WAAW,KAAK,OAAO,EAAE;gBAC3B,MAAM,QAAQ,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC;gBAC7B,IAAI,CAAC,YAAY,GAAG,kBAAkB,CAAC,QAAQ,IAAI,MAAM,CAAC,CAAC;gBAC3D,IAAI,QAAQ,KAAK,MAAM,EAAE;oBACvB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,gBAAgB,CAAC;iBACpC;aACF;iBAAM;gBACL,IAAI,CAAC,YAAY,GAAG,EAAE,CAAC;aACxB;YACD,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,YAAY,GAAG,GAAG,CAAC,WAAW,CAAC,CAAC;SACtD;QAEM,QAAQ;YACb,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;SACnC;QAEM,YAAY,CAAC,QAAgC,EAAE,KAAqB;YACzE,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,QAAQ,CAAC;YACtC,IAAI,KAAK,GAAGvC,sBAAc,CAAC,QAAQ,EAAE;gBACnC,OAAO;aACR;YACD,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;SAC/D;QAEM,WAAW;YAChB,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC;YACnD,MAAM,QAAQ,GAAG,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;YACrD,IAAI,QAAQ,KAAK,QAAQ,EAAE;gBACzB,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,QAAQ,EAAE,gBAAgB,CAAC,CAAC;gBAC3D,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;aAC1B;SACF;QAEM,SAAS,CAAC,UAA+B;YAC9C,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,EAAE;gBAC1B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;gBAChC,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;aACxC;YACD,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;SAChC;QAEM,WAAW,CAAC,UAA+B;YAChD,IAAI,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,EAAE;gBAC/D,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;aACxB;SACF;QAEO,gBAAgB;YACtB,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;YACvC,IAAI,IAAI,CAAC,QAAQ,KAAK,YAAY,EAAE;gBAClC,IAAI,YAAY,KAAK,EAAE,EAAE;oBACvB,IAAI,CAAC,YAAY,CAAC,YAAY,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;oBACnD,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC;iBACnC;aACF;SACF;KACF,CAAA;AA1EYuC,kCAAsB;QADlC,cAAc,CAAC,EAAE,CAAC;OACNA,8BAAsB,CA0ElC;AAEDA,kCAAsB,CAAC,SAAS,CAAC,WAAW,GAAG,EAAE,CAAC;AAClDA,kCAAsB,CAAC,SAAS,CAAC,OAAO,GAAG,IAAI,CAAC;IAEhD,MAAM,+BAA+B,GAAGvC,sBAAc,CAAC,SAAS,GAAGA,sBAAc,CAAC,oBAAoB,CAAC;AAiBvG,AAAawC,2BAAe,GAA5B,MAAa,eAAe;QAW1B,YACS,SAAqB,EACrB,GAA0B,EAC1B,OAAyB,EACzB,eAAiC;YAHjC,cAAS,GAAT,SAAS,CAAY;YACrB,QAAG,GAAH,GAAG,CAAuB;YAC1B,YAAO,GAAP,OAAO,CAAkB;YACzB,oBAAe,GAAf,eAAe,CAAkB;SACrC;QAEE,QAAQ;YACb,OAAO,IAAI,CAAC,YAAY,CAAC;SAC1B;QAEM,YAAY,CAAC,QAAgC,EAAE,KAAqB;YACzE,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;gBACvB,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,KAAK,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,KAAK,IAAI,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,KAAK,CAAC,CAAC;gBAC9G,IAAI,IAAI,CAAC,aAAa,EAAE;oBACtB,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;iBACpC;aACF;YACD,IAAI,IAAI,CAAC,aAAa,EAAE;gBACtB,IAAI,CAAC,aAAa,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;gBAC5C,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;aAC3B;YACD,IAAI,IAAI,CAAC,GAAG,CAAC,IAAI,KAAK,UAAU,IAAI,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE;gBAC3D,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,eAAe,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;gBACrE,IAAI,CAAC,aAAa,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;aAC3C;YACD,IAAI,CAAC,kBAAkB,EAAE,CAAC;SAC3B;;QAGM,mBAAmB;YACxB,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAC1B,IAAI,CAAC,MAAM,CAAC,+BAA+B,CAAC,CAAC;SAC9C;;QAGM,YAAY,CAAC,QAAgC,EAAE,aAAqC,EAAE,KAAqB;YAChH,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAC1B,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;SACpB;QAEM,kBAAkB;YACvB,MAAM,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC;YAChC,MAAM,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC;YACzB,MAAM,YAAY,GAAG,OAAO,CAAC,cAAc,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,KAAK,CAAC;YACxF,MAAM,OAAO,GAAG,OAAO,CAAC,IAAI,KAAK,OAAO,CAAC;YACzC,MAAM,OAAO,GAAG,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAyB,EAAE,CAAyB,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;YAE1G,IAAI,OAAO,EAAE;gBACX,OAAO,CAAC,OAAO,GAAG,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC;aAClD;iBAAM,IAAI,KAAK,KAAK,IAAI,EAAE;gBACzB,OAAO,CAAC,OAAO,GAAG,IAAI,CAAC;aACxB;iBAAM,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;gBAC/B,OAAO,CAAC,OAAO,GAAG,KAAK,CAAC,SAAS,CAAC,IAAI,IAAI,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;aACjF;iBAAM;gBACL,OAAO,CAAC,OAAO,GAAG,KAAK,CAAC;aACzB;SACF;QAEM,MAAM,CAAC,KAAqB;YACjC,IAAI,KAAK,GAAGxC,sBAAc,CAAC,QAAQ,EAAE;gBACnC,OAAO;aACR;YACD,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;YAC/B,MAAM,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC;YACnC,IAAI,QAAQ,KAAK,QAAQ,EAAE;gBACzB,OAAO;aACR;YACD,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;SAC/D;QAEM,WAAW;YAChB,IAAI,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC;YAC9B,MAAM,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC;YACzB,MAAM,YAAY,GAAG,OAAO,CAAC,cAAc,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,KAAK,CAAC;YACxF,IAAI,KAAK,CAAC;YACV,MAAM,OAAO,GAAG,OAAO,CAAC,SAAS,CAAC,IAAI,cAAc,CAAC;YAErD,IAAI,OAAO,CAAC,IAAI,KAAK,UAAU,EAAE;gBAC/B,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;oBACxB,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC,IAAI,IAAI,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC,CAAC;oBAC/D,IAAI,OAAO,CAAC,OAAO,IAAI,KAAK,KAAK,CAAC,CAAC,EAAE;wBACnC,KAAK,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;qBAC1B;yBAAM,IAAI,CAAC,OAAO,CAAC,OAAO,IAAI,KAAK,KAAK,CAAC,CAAC,EAAE;wBAC3C,KAAK,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;qBACxB;;oBAED,OAAO;iBACR;gBACD,KAAK,GAAG,OAAO,CAAC,OAAO,CAAC;aACzB;iBAAM,IAAI,OAAO,CAAC,OAAO,EAAE;gBAC1B,KAAK,GAAG,YAAY,CAAC;aACtB;iBAAM;gBACL,OAAO;aACR;YACD,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC;YAClC,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;YAC1B,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC;SAC/B;QAEM,SAAS,CAAC,UAA+B;YAC9C,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,EAAE;gBAC1B,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;aACxC;YACD,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;SAChC;QAEM,WAAW,CAAC,UAA+B;YAChD,IAAI,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,EAAE;gBAC/D,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;aACxB;SACF;QAEM,MAAM;YACX,IAAI,IAAI,CAAC,aAAa,EAAE;gBACtB,IAAI,CAAC,aAAa,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;gBAC5C,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;aAC3B;YACD,IAAI,IAAI,CAAC,aAAa,EAAE;gBACtB,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;aACtC;SACF;KACF,CAAA;AArIYwC,2BAAe;QAD3B,cAAc,EAAE;OACJA,uBAAe,CAqI3B;AAEDA,2BAAe,CAAC,SAAS,CAAC,OAAO,GAAG,IAAI,CAAC;AACzCA,2BAAe,CAAC,SAAS,CAAC,eAAe,GAAG,IAAI,CAAC;IAEjD,MAAM,oBAAoB,GAAG;QAC3B,SAAS,EAAE,IAAI;QACf,OAAO,EAAE,IAAI;QACb,aAAa,EAAE,IAAI;KACpB,CAAC;IAIF,SAAS,cAAc,CAAC,CAAyB,EAAE,CAAyB;QAC1E,OAAO,CAAC,KAAK,CAAC,CAAC;IACjB,CAAC;AAoBD,AAAaC,+BAAmB,GAAhC,MAAa,mBAAmB;QAW9B,YACS,SAAqB,EACrB,GAAmB,EACnB,OAAyB,EACzB,eAAiC;YAHjC,cAAS,GAAT,SAAS,CAAY;YACrB,QAAG,GAAH,GAAG,CAAgB;YACnB,YAAO,GAAP,OAAO,CAAkB;YACzB,oBAAe,GAAf,eAAe,CAAkB;SACrC;QAEE,QAAQ;YACb,OAAO,IAAI,CAAC,YAAY,CAAC;SAC1B;QAEM,YAAY,CAAC,QAAkC,EAAE,KAAqB;YAC3E,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;YACxC,IAAI,CAAC,OAAO,IAAI,QAAQ,KAAK,IAAI,IAAI,QAAQ,KAAK,SAAS,IAAI,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE;gBAChF,MAAM,IAAI,KAAK,CAAC,8DAA8D,CAAC,CAAC;aACjF;YACD,IAAI,IAAI,CAAC,aAAa,EAAE;gBACtB,IAAI,CAAC,aAAa,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;gBAC5C,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;aAC3B;YACD,IAAI,OAAO,EAAE;gBACX,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,eAAe,CAAC,gBAAgB,CAA6B,QAAQ,CAAC,CAAC;gBACjG,IAAI,CAAC,aAAa,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;aAC3C;YACD,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAC1B,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;SACpB;;QAGM,mBAAmB,CAAC,QAAkB;;;YAG3C,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;SACnC;;QAGM,YAAY,CAAC,QAAkC,EAAE,aAAuC,EAAE,KAAqB;YACpH,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;SAChC;QAEM,MAAM,CAAC,KAAqB;YACjC,IAAI,KAAK,GAAGzC,sBAAc,CAAC,QAAQ,EAAE;gBACnC,OAAO;aACR;YACD,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;YAC/B,MAAM,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC;YACnC,IAAI,QAAQ,KAAK,QAAQ,EAAE;gBACzB,OAAO;aACR;YACD,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;SACjD;QAEM,WAAW;;YAEhB,MAAM,YAAY,GAAG,IAAI,CAAC,gBAAgB,EAAE,CAAC;YAC7C,IAAI,YAAY,EAAE;gBAChB,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC;aAC/B;SACF;QAEM,kBAAkB,CAAC,QAAmB;YAC3C,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;YACvC,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;YAC5C,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;YACrB,MAAM,OAAO,GAAG,GAAG,CAAC,OAAO,IAAI,cAAc,CAAC;YAC9C,MAAM,OAAO,GAAG,GAAG,CAAC,OAAO,CAAC;YAC5B,IAAI,CAAC,GAAG,OAAO,CAAC,MAAM,CAAC;YAEvB,OAAO,CAAC,EAAE,EAAE;gBACV,MAAM,MAAM,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;gBAC1B,MAAM,WAAW,GAAG,MAAM,CAAC,cAAc,CAAC,OAAO,CAAC,GAAG,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC;gBACjF,IAAI,OAAO,EAAE;oBACX,MAAM,CAAC,QAAQ,GAAkB,YAAa,CAAC,SAAS,CAAC,IAAI,IAAI,CAAC,CAAC,OAAO,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;oBACtG,SAAS;iBACV;gBACD,MAAM,CAAC,QAAQ,GAAG,CAAC,CAAC,OAAO,CAAC,WAAW,EAAE,YAAY,CAAC,CAAC;aACxD;SACF;QAEM,gBAAgB;;;;;;;;;;;;;;;;YAgBrB,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;YACrB,MAAM,OAAO,GAAG,GAAG,CAAC,OAAO,CAAC;YAC5B,MAAM,GAAG,GAAG,OAAO,CAAC,MAAM,CAAC;YAC3B,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;YACvC,IAAI,CAAC,GAAG,CAAC,CAAC;YAEV,IAAI,GAAG,CAAC,QAAQ,EAAE;;gBAEhB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE;;oBAEhC,OAAO,IAAI,CAAC;iBACb;;;gBAGD,IAAI,MAAsB,CAAC;gBAC3B,MAAM,OAAO,GAAG,GAAG,CAAC,OAAO,IAAI,cAAc,CAAC;;gBAE9C,MAAM,MAAM,GAAiB,EAAE,CAAC;gBAChC,OAAO,CAAC,GAAG,GAAG,EAAE;oBACd,MAAM,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;oBACpB,IAAI,MAAM,CAAC,QAAQ,EAAE;wBACnB,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,OAAO,CAAC;8BACtC,MAAM,CAAC,KAAK;8BACZ,MAAM,CAAC,KAAK,CACf,CAAC;qBACH;oBACD,EAAE,CAAC,CAAC;iBACL;;gBAED,CAAC,GAAG,CAAC,CAAC;gBACN,OAAO,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE;oBAC9B,MAAM,CAAC,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;;oBAE1B,IAAI,MAAM,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;wBACjD,YAAY,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;qBAC3B;yBAAM;wBACL,EAAE,CAAC,CAAC;qBACL;iBACF;;gBAED,CAAC,GAAG,CAAC,CAAC;gBACN,OAAO,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE;oBACxB,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;;oBAEpB,IAAI,YAAY,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;wBACvD,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;qBACtB;oBACD,EAAE,CAAC,CAAC;iBACL;;gBAED,OAAO,KAAK,CAAC;aACd;;;YAGD,IAAI,KAAK,GAA0C,IAAI,CAAC;YACxD,OAAO,CAAC,GAAG,GAAG,EAAE;gBACd,MAAM,MAAM,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;gBAC1B,IAAI,MAAM,CAAC,QAAQ,EAAE;oBACnB,KAAK,GAAG,MAAM,CAAC,cAAc,CAAC,OAAO,CAAC;0BAClC,MAAM,CAAC,KAAK;0BACZ,MAAM,CAAC,KAAK,CAAC;oBACjB,MAAM;iBACP;gBACD,EAAE,CAAC,CAAC;aACL;;YAED,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC;;YAElC,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;;YAE1B,OAAO,IAAI,CAAC;SACb;QAEM,SAAS,CAAC,UAA+B;YAC9C,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,EAAE;gBAC1B,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;aACxC;YACD,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;SAChC;QAEM,WAAW,CAAC,UAA+B;YAChD,IAAI,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,EAAE;gBAC/D,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;aACxB;SACF;QAEM,IAAI;YACT,IAAI,CAAC,YAAY,GAAG,GAAG,CAAC,kBAAkB,CACxC,IAAI,CAAC,GAAG,EACR,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,EAChC,oBAAoB,CACrB,CAAC;SACH;QAEM,MAAM;YACX,IAAI,CAAC,YAAY,CAAC,UAAU,EAAE,CAAC;YAC/B,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;YAEzB,IAAI,IAAI,CAAC,aAAa,EAAE;gBACtB,IAAI,CAAC,aAAa,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;gBAC5C,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;aAC3B;SACF;QAEM,gBAAgB;YACrB,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAC1B,MAAM,YAAY,GAAG,IAAI,CAAC,gBAAgB,EAAE,CAAC;YAC7C,IAAI,YAAY,EAAE;gBAChB,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC;aAC/B;SACF;KACF,CAAA;AAzNYyC,+BAAmB;QAD/B,cAAc,EAAE;OACJA,2BAAmB,CAyN/B;AAEDA,+BAAmB,CAAC,SAAS,CAAC,OAAO,GAAG,IAAI,CAAC;AAC7CA,+BAAmB,CAAC,SAAS,CAAC,eAAe,GAAG,IAAI,CAAC;;ICzgBrD,MAAMC,OAAK,GAAG,GAAG,CAAC,SAAS,CAAC;AAC5B,UAAa,SAAS,GAAGA,OAAK,CAAC,GAAG,CAAC;AACnC,UAAa,WAAW,GAAGA,OAAK,CAAC,KAAK,CAAC;AACvC,UAAa,YAAY,GAAGA,OAAK,CAAC,MAAM,CAAC;IAEzC;IACA;IAEA;IACA,SAAS,UAAU,CAAqB,GAA2B,EAAE,KAA6B;QAChG,MAAM,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC;QACzB,IAAI,CAAC,KAAK,SAAS,EAAE;YACnB,OAAO,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;SACzC;QACD,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC;QAC1B,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;QACjC,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC;QAC1B,IAAI,OAAO,KAAK,OAAO,EAAE;YACvB,IAAI,CAAC,GAAG,CAAC,CAAC;YACV,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,OAAO,EAAE,EAAE;gBAClC,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;oBACpB,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE;wBACtB,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;qBACpB;oBACD,OAAO,IAAI,CAAC;iBACb;gBACD,CAAC,EAAE,CAAC;aACL;YACD,OAAO,IAAI,CAAC;SACb;QACD,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;QACzB,CAAC,CAAC,eAAe,CAAC,KAAK,EAAE,SAAS,EAAE1C,sBAAc,CAAC,oBAAoB,CAAC,CAAC;QACzE,OAAO,IAAI,CAAC;IACd,CAAC;IAED;IACA,SAAS,YAAY;QACnB,MAAM,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC;QACzB,IAAI,CAAC,KAAK,SAAS,EAAE;YACnB,OAAO,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAC/B;QACD,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,IAAI,IAAI,GAAG,CAAC,EAAE;YACZ,MAAM,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;YAC5B,IAAI,CAAC,GAAG,CAAC,CAAC;YACV,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,IAAI,EAAE,EAAE;gBAC/B,IAAI,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;oBACpB,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;iBAC/C;gBACD,CAAC,EAAE,CAAC;aACL;YACD,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACvB,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;YACpB,CAAC,CAAC,eAAe,CAAC,OAAO,EAAE,SAAS,EAAEA,sBAAc,CAAC,oBAAoB,CAAC,CAAC;SAC5E;QACD,OAAO,SAAS,CAAC;IACnB,CAAC;IAED;IACA,SAAS,aAAa,CAAqB,KAA6B;QACtE,MAAM,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC;QACzB,IAAI,CAAC,KAAK,SAAS,EAAE;YACnB,OAAO,YAAY,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;SACvC;QACD,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,IAAI,IAAI,KAAK,CAAC,EAAE;YACd,OAAO,KAAK,CAAC;SACd;QACD,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,MAAM,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;QAC5B,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,IAAI,EAAE,EAAE;YAC/B,IAAI,KAAK,KAAK,KAAK,EAAE;gBACnB,IAAI,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;oBACpB,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;iBAC/C;gBACD,YAAY,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;gBAClC,OAAO,YAAY,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;aACvC;YACD,CAAC,EAAE,CAAC;SACL;QACD,CAAC,CAAC,eAAe,CAAC,QAAQ,EAAE,SAAS,EAAEA,sBAAc,CAAC,oBAAoB,CAAC,CAAC;QAC5E,OAAO,KAAK,CAAC;IACf,CAAC;IAED,KAAK,MAAM,OAAO,IAAI,CAAC,UAAU,EAAE,YAAY,EAAE,aAAa,CAAC,EAAE;QAC/D,MAAM,CAAC,cAAc,CAAC,OAAO,EAAE,WAAW,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,YAAY,EAAE,KAAK,EAAE,UAAU,EAAE,KAAK,EAAE,CAAC,CAAC;KACvH;AAED,aAAgB,oBAAoB;QAClC,IAAI0C,OAAK,CAAC,GAAG,CAAC,WAAW,CAAC,KAAK,IAAI;YAAEA,OAAK,CAAC,GAAG,GAAG,UAAU,CAAC;QAC5D,IAAIA,OAAK,CAAC,KAAK,CAAC,WAAW,CAAC,KAAK,IAAI;YAAEA,OAAK,CAAC,KAAK,GAAG,YAAY,CAAC;QAClE,IAAIA,OAAK,CAAC,MAAM,CAAC,WAAW,CAAC,KAAK,IAAI;YAAEA,OAAK,CAAC,MAAM,GAAG,aAAa,CAAC;IACvE,CAAC;IAED,oBAAoB,EAAE,CAAC;AAEvB,aAAgB,qBAAqB;QACnC,IAAIA,OAAK,CAAC,GAAG,CAAC,WAAW,CAAC,KAAK,IAAI;YAAEA,OAAK,CAAC,GAAG,GAAG,SAAS,CAAC;QAC3D,IAAIA,OAAK,CAAC,KAAK,CAAC,WAAW,CAAC,KAAK,IAAI;YAAEA,OAAK,CAAC,KAAK,GAAG,WAAW,CAAC;QACjE,IAAIA,OAAK,CAAC,MAAM,CAAC,WAAW,CAAC,KAAK,IAAI;YAAEA,OAAK,CAAC,MAAM,GAAG,YAAY,CAAC;IACtE,CAAC;AAKD,AAAaC,uBAAW,GAAxB,MAAa,WAAW;QAMtB,YAAY,SAAqB,EAAE,GAAiB;YAClD,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;YAC3B,GAAG,CAAC,SAAS,GAAG,IAAI,CAAC;YACrB,IAAI,CAAC,UAAU,GAAG,GAAG,CAAC;YACtB,IAAI,CAAC,aAAa,EAAE,CAAC;SACtB;KACF,CAAA;AAZYA,uBAAW;QADvB,kBAAkB,aAAoB;OAC1BA,mBAAW,CAYvB;aAEe,cAAc,CAAC,SAAqB,EAAE,GAAiB;QACrE,OAAQ,GAAG,CAAC,SAAyB,IAAI,IAAIA,mBAAW,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC;IAC3E,CAAC;;ICxHD,MAAMD,OAAK,GAAG,GAAG,CAAC,SAAS,CAAC;AAC5B,UAAa,SAAS,GAAGA,OAAK,CAAC,GAAG,CAAC;AACnC,UAAaE,aAAW,GAAGF,OAAK,CAAC,KAAK,CAAC;AACvC,UAAaG,cAAY,GAAGH,OAAK,CAAC,MAAM,CAAC;IAEzC;IACA;IAEA;IACA,SAAS,UAAU,CAAqB,KAA6B;QACnE,MAAM,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC;QACzB,IAAI,CAAC,KAAK,SAAS,EAAE;YACnB,OAAO,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;SACpC;QACD,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC;QAC1B,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAC5B,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC;QAC1B,IAAI,OAAO,KAAK,OAAO,EAAE;YACvB,OAAO,IAAI,CAAC;SACb;QACD,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;QACzB,CAAC,CAAC,eAAe,CAAC,KAAK,EAAE,SAAS,EAAE1C,sBAAc,CAAC,oBAAoB,CAAC,CAAC;QACzE,OAAO,IAAI,CAAC;IACd,CAAC;IAED;IACA,SAAS8C,cAAY;QACnB,MAAM,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC;QACzB,IAAI,CAAC,KAAK,SAAS,EAAE;YACnB,OAAOF,aAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAC/B;QACD,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,IAAI,IAAI,GAAG,CAAC,EAAE;YACZ,MAAM,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;YAC5B,IAAI,CAAC,GAAG,CAAC,CAAC;YACV,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,IAAI,EAAE,EAAE;gBAC/B,IAAI,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;oBACpB,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;iBAC/C;gBACD,CAAC,EAAE,CAAC;aACL;YACDA,aAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACvB,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;YACpB,CAAC,CAAC,eAAe,CAAC,OAAO,EAAE,SAAS,EAAE5C,sBAAc,CAAC,oBAAoB,CAAC,CAAC;SAC5E;QACD,OAAO,SAAS,CAAC;IACnB,CAAC;IAED;IACA,SAAS+C,eAAa,CAAqB,KAA6B;QACtE,MAAM,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC;QACzB,IAAI,CAAC,KAAK,SAAS,EAAE;YACnB,OAAOF,cAAY,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;SACvC;QACD,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,IAAI,IAAI,KAAK,CAAC,EAAE;YACd,OAAO,KAAK,CAAC;SACd;QACD,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,MAAM,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;QAC5B,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,IAAI,EAAE,EAAE;YAC/B,IAAI,KAAK,KAAK,KAAK,EAAE;gBACnB,IAAI,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;oBACpB,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;iBAC/C;gBACD,YAAY,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;gBAClC,OAAOA,cAAY,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;aACvC;YACD,CAAC,EAAE,CAAC;SACL;QACD,CAAC,CAAC,eAAe,CAAC,QAAQ,EAAE,SAAS,EAAE7C,sBAAc,CAAC,oBAAoB,CAAC,CAAC;QAC5E,OAAO,KAAK,CAAC;IACf,CAAC;IAED,KAAK,MAAM,OAAO,IAAI,CAAC,UAAU,EAAE8C,cAAY,EAAEC,eAAa,CAAC,EAAE;QAC/D,MAAM,CAAC,cAAc,CAAC,OAAO,EAAE,WAAW,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,YAAY,EAAE,KAAK,EAAE,UAAU,EAAE,KAAK,EAAE,CAAC,CAAC;KACvH;AAED,aAAgB,oBAAoB;QAClC,IAAIL,OAAK,CAAC,GAAG,CAAC,WAAW,CAAC,KAAK,IAAI;YAAEA,OAAK,CAAC,GAAG,GAAG,UAAU,CAAC;QAC5D,IAAIA,OAAK,CAAC,KAAK,CAAC,WAAW,CAAC,KAAK,IAAI;YAAEA,OAAK,CAAC,KAAK,GAAGI,cAAY,CAAC;QAClE,IAAIJ,OAAK,CAAC,MAAM,CAAC,WAAW,CAAC,KAAK,IAAI;YAAEA,OAAK,CAAC,MAAM,GAAGK,eAAa,CAAC;IACvE,CAAC;IAED,oBAAoB,EAAE,CAAC;AAEvB,aAAgB,qBAAqB;QACnC,IAAIL,OAAK,CAAC,GAAG,CAAC,WAAW,CAAC,KAAK,IAAI;YAAEA,OAAK,CAAC,GAAG,GAAG,SAAS,CAAC;QAC3D,IAAIA,OAAK,CAAC,KAAK,CAAC,WAAW,CAAC,KAAK,IAAI;YAAEA,OAAK,CAAC,KAAK,GAAGE,aAAW,CAAC;QACjE,IAAIF,OAAK,CAAC,MAAM,CAAC,WAAW,CAAC,KAAK,IAAI;YAAEA,OAAK,CAAC,MAAM,GAAGG,cAAY,CAAC;IACtE,CAAC;AAKD,AAAaG,uBAAW,GAAxB,MAAa,WAAW;QAKtB,YAAY,SAAqB,EAAE,WAAyB;YAC1D,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;YAC3B,WAAW,CAAC,SAAS,GAAG,IAAI,CAAC;YAC7B,IAAI,CAAC,UAAU,GAAG,WAAW,CAAC;YAC9B,IAAI,CAAC,aAAa,EAAE,CAAC;SACtB;KACF,CAAA;AAXYA,uBAAW;QADvB,kBAAkB,aAAoB;OAC1BA,mBAAW,CAWvB;aAEe,cAAc,CAAC,SAAqB,EAAE,WAAyB;QAC7E,OAAQ,WAAW,CAAC,SAAyB,IAAI,IAAIA,mBAAW,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;IAC3F,CAAC;;UC9GY,YAAY,GAAG9C,SAAE,CAAC,eAAe,EAAgB;SAC3D,WAAW,CAAC,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC;QACrB,sBAAsB,CAAC,IAAW,EAAE,aAAqB;YAC9D,OAAO,KAAK,CAAC;SACd;KACF,CAAC,CACH;;ICMD,MAAM+C,aAAW,GAAG,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC;AAe9C,UAAa,gBAAgB,GAAG/C,SAAE,CAAC,eAAe,EAAoB;SACnE,WAAW,CAAC,CAAC,IAAI,CAAC,CAAC,SAAS,CAACgD,uBAAe,CAAC,CAAC,CAAC;IAElD,SAAS,qBAAqB,CAAC,OAAe,EAAE,IAAY;QAC1D,IAAI,EAAE,GAAG,MAAM,CAAC,wBAAwB,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QACxD,IAAI,KAAK,GAAG,MAAM,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;QAE3C,OAAO,EAAE,KAAK,SAAS,IAAI,KAAK,KAAK,IAAI,EAAE;YACzC,EAAE,GAAG,MAAM,CAAC,wBAAwB,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;YAClD,KAAK,GAAG,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;SACtC;QAED,OAAO,EAAE,CAAC;IACZ,CAAC;AAID,AAAaA,2BAAe;IAD5B;IACA,MAAa,eAAe;QAG1B,YACU,SAAqB,EACrB,YAA2B,EAC3B,YAA2B,EAC3B,WAAyB;YAHzB,cAAS,GAAT,SAAS,CAAY;YACrB,iBAAY,GAAZ,YAAY,CAAe;YAC3B,iBAAY,GAAZ,YAAY,CAAe;YAC3B,gBAAW,GAAX,WAAW,CAAc;YAN3B,aAAQ,GAAgC,EAAE,CAAC;SAO/C;QAEG,WAAW,CAAC,GAAqD,EAAE,YAAoB;YAC5F,IAAI,GAAG,CAAC,UAAU,KAAK,IAAI,EAAE;gBAC3B,OAAO,GAAG,CAAC,YAAY,EAAE,CAAC,WAAW,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;aAC1D;YACD,IAAI,eAAe,GAAG,GAAG,CAAC,UAAU,CAAC;YACrC,IAAI,QAAQ,CAAC;YAEb,IAAI,eAAe,IAAI,YAAY,IAAI,eAAe,EAAE;gBACtD,OAAO,eAAe,CAAC,YAAY,CAAC,CAAC;aACtC;YAED,QAAQ,GAAG,IAAI,CAAC,sBAAsB,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;YAE1D,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE;gBACxB,IAAI,eAAe,KAAK,SAAS,EAAE;oBACjC,eAAe,GAAG,IAAI,CAAC,0BAA0B,CAAC,GAAG,CAAC,CAAC;iBACxD;gBAED,eAAe,CAAC,YAAY,CAAC,GAAG,QAAQ,CAAC;aAC1C;YAED,OAAO,QAAQ,CAAC;SACjB;QAEM,UAAU,CAAC,OAAkC;YAClD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;SAC7B;QAEM,WAAW,CAAC,GAAgB,EAAE,YAAoB;YACvD,IAAI,GAAG,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE;gBAC3B,MAAM,OAAO,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC;;gBAE/B,IAAI,YAAY,KAAK,aAAa,EAAE;oBAClC,OAAO,IAAItC,+BAAuB,CAAC,IAAI,CAAC,SAAS,EAAE,GAAG,EAAE,YAAY,CAAC,CAAC;iBACvE;;gBAGD,IAAI,YAAY,KAAK,OAAO,IAAI,YAAY,KAAK,OAAO,IAAI,YAAY,KAAK,KAAK;uBAC7E,YAAY,KAAK,OAAO,KAAK,OAAO,KAAK,OAAO,IAAI,OAAO,KAAK,QAAQ,CAAC;uBACzE,YAAY,KAAK,SAAS,IAAI,OAAO,KAAK,OAAO;uBACjD,YAAY,KAAK,OAAO,IAAI,OAAO,KAAK,OAAO;uBAC/C,YAAY,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE;oBACpC,OAAO,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;iBAC5C;gBAED,IAAI,qBAAqB,CAAC,IAAI,CAAC,YAAY,CAAC;uBACvC,IAAI,CAAC,WAAW,CAAC,sBAAsB,CAAC,GAAG,EAAE,YAAY,CAAC;uBAC1D,OAAO,KAAK,KAAK,IAAI,YAAY,KAAK,KAAK;uBAC3C,OAAO,KAAK,GAAG,IAAI,YAAY,KAAK,MAAM,EAC7C;oBACA,OAAO,IAAIH,6BAAqB,CAAC,IAAI,CAAC,SAAS,EAAE,GAAG,EAAE,YAAY,CAAC,CAAC;iBACrE;gBACD,OAAO,IAAIG,+BAAuB,CAAC,IAAI,CAAC,SAAS,EAAE,GAAG,EAAE,YAAY,CAAC,CAAC;aACvE;YAED,OAAO,IAAI,gBAAgB,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;SAChD;QAEM,gBAAgB,CAAC,aAA6B;YACnD,OAAO,gBAAgB,CAAC,IAAI,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;SACxD;QAEM,cAAc,CAAC,WAAyB;YAC7C,OAAO,cAAc,CAAC,IAAI,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;SACpD;QAEM,cAAc,CAAC,WAAyB;YAC7C,OAAO,cAAc,CAAC,IAAI,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;SACpD;QAEO,0BAA0B,CAAC,GAAgB;YACjD,OAAO,GAAG,CAAC,UAAU,IAAI,IAAI,CAAC,qBAAqB,CAAC,GAAG,CAAC,CAAC;SAC1D;QAEO,qBAAqB,CAAC,GAAgB;YAC5C,MAAM,KAAK,GAA2C,EAAE,CAAC;YACzD,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,GAAG,EAAE,YAAY,EAAE;gBAC7C,UAAU,EAAE,KAAK;gBACjB,YAAY,EAAE,KAAK;gBACnB,QAAQ,EAAE,KAAK;gBACf,KAAK,EAAE,KAAK;aACb,CAAC,EAAE;gBACFL,eAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;aACxB;YACD,OAAO,KAAK,CAAC;SACd;QAEO,kBAAkB,CAAC,GAAgB,EAAE,YAAoB,EAAE,UAA8B;YAC/F,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE;gBACtD,MAAM,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;gBACjC,MAAM,QAAQ,GAAG,OAAO,CAAC,WAAW,CAAC,GAAG,EAAE,YAAY,EAAE,UAAU,CAAC,CAAC;gBACpE,IAAI,QAAQ,EAAE;oBACZ,OAAO,QAAQ,CAAC;iBACjB;aACF;YACD,OAAO,IAAI,CAAC;SACb;QAEO,sBAAsB,CAAC,GAAgB,EAAE,YAAoB;YACnE,IAAI,EAAE,GAAG,YAAY,MAAM,CAAC,EAAE;gBAC5B,OAAO,IAAI,iBAAiB,CAAC,GAAG,EAAE,YAAY,CAA2B,CAAC;aAC3E;YAED,IAAI,MAAe,CAAC;YACpB,IAAI,GAAG,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE;gBAC3B,IAAI,YAAY,KAAK,OAAO,EAAE;oBAC5B,OAAO,IAAII,8BAAsB,CAAC,IAAI,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC;iBACxD;gBAED,IAAI,YAAY,KAAK,OAAO,IAAI,YAAY,KAAK,KAAK,EAAE;oBACtD,OAAO,IAAID,8BAAsB,CAAC,IAAI,CAAC,SAAS,EAAgB,GAAG,CAAC,CAAC;iBACtE;gBAED,MAAM,OAAO,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC;gBAC/B,MAAM,OAAO,GAAG,IAAI,CAAC,YAAY,CAAC,iBAAiB,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;gBACvE,IAAI,YAAY,KAAK,OAAO,IAAI,OAAO,KAAK,QAAQ,EAAE;oBACpD,OAAO,IAAI+B,2BAAmB,CAAC,IAAI,CAAC,SAAS,EAAkB,GAAG,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC;iBACpF;gBAED,IAAI,YAAY,KAAK,SAAS,IAAI,OAAO,KAAK,OAAO,EAAE;oBACrD,OAAO,IAAID,uBAAe,CAAC,IAAI,CAAC,SAAS,EAAiB,GAAG,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC;iBAC/E;gBAED,IAAI,OAAO,EAAE;oBACX,OAAO,IAAID,8BAAsB,CAAC,IAAI,CAAC,SAAS,EAAE,GAAG,EAAE,YAAY,EAAE,OAAO,CAAC,CAAC;iBAC/E;gBAED,MAAM,WAAW,GAAG,cAAc,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;gBACtD,IAAI,WAAW,EAAE;oBACf,OAAO,IAAI/B,8BAAsB,CAAC,IAAI,CAAC,SAAS,EAAgB,GAAG,EAAE,YAAY,EAAE,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;iBACpG;gBAED,IAAI,YAAY,KAAK,MAAM;uBACtB,qBAAqB,CAAC,IAAI,CAAC,YAAY,CAAC;uBACxC,IAAI,CAAC,WAAW,CAAC,sBAAsB,CAAC,GAAG,EAAE,YAAY,CAAC,EAAE;oBAC/D,OAAO,IAAIC,6BAAqB,CAAC,IAAI,CAAC,SAAS,EAAE,GAAG,EAAE,YAAY,CAAC,CAAC;iBACrE;gBACD,MAAM,GAAG,IAAI,CAAC;aACf;YAED,MAAM,GAAG,GAAGwC,aAAW,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YAClC,QAAQ,GAAG;gBACT,KAAK,gBAAgB;oBACnB,IAAI,YAAY,KAAK,QAAQ,EAAE;wBAC7B,OAAO,IAAI,CAAC,gBAAgB,CAAiB,GAAG,CAAC,CAAC,iBAAiB,EAAE,CAAC;qBACvE;oBACD,OAAO,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;gBAC7D,KAAK,cAAc;oBACjB,IAAI,YAAY,KAAK,MAAM,EAAE;wBAC3B,OAAO,IAAI,CAAC,cAAc,CAAe,GAAG,CAAC,CAAC,iBAAiB,EAAE,CAAC;qBACnE;oBACD,OAAO,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;gBAC7D,KAAK,cAAc;oBACjB,IAAI,YAAY,KAAK,MAAM,EAAE;wBAC3B,OAAO,IAAI,CAAC,cAAc,CAAe,GAAG,CAAC,CAAC,iBAAiB,EAAE,CAAC;qBACnE;oBACD,OAAO,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;aAC9D;YAED,MAAM,UAAU,GAAG,qBAAqB,CAAC,GAAG,EAAE,YAAY,CAGzD,CAAC;YAEF,IAAI,UAAU,EAAE;gBACd,IAAI,UAAU,CAAC,GAAG,IAAI,UAAU,CAAC,GAAG,EAAE;oBACpC,IAAI,UAAU,CAAC,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC,WAAW,EAAE;wBAChD,OAAO,UAAU,CAAC,GAAG,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;qBACxC;;oBAGD,MAAM,eAAe,GAAG,IAAI,CAAC,kBAAkB,CAAC,GAAG,EAAE,YAAY,EAAE,UAAU,CAAC,CAAC;oBAC/E,IAAI,eAAe,EAAE;wBACnB,OAAO,eAAe,CAAC;qBACxB;oBACD,IAAI,MAAM,EAAE;;wBAEV,OAAO,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;qBAC5D;oBAED,OAAO,sBAAsB,CAAC,IAAI,EAAE,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,SAAS,EAAE,GAAG,EAAE,YAAY,EAAE,UAAU,CAAC,CAAC;iBACvG;aACF;YACD,OAAO,IAAI7B,sBAAc,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;SAC9C;KACF,CAAA;AAnMY8B,2BAAe;QAF3B5C,aAAM,CAAC,UAAU,EAAE,aAAa,EAAE,aAAa,EAAE,YAAY,CAAC;;OAElD4C,uBAAe,CAmM3B;aAEe,qBAAqB,CAAC,SAAqB,EAAE,UAAwD;QACnH,QAAQD,aAAW,CAAC,IAAI,CAAC,UAAU,CAAC;YAClC,KAAK,gBAAgB;gBACnB,OAAO,gBAAgB,CAAC,SAAS,EAAkB,UAAU,CAAC,CAAC;YACjE,KAAK,cAAc;gBACjB,OAAO,cAAc,CAAC,SAAS,EAAgB,UAAU,CAAC,CAAC;YAC7D,KAAK,cAAc;gBACjB,OAAO,cAAc,CAAC,SAAS,EAAgB,UAAU,CAAC,CAAC;SAC9D;QACD,OAAO,IAAI,CAAC;IACd,CAAC;;AC/OYE,wCAA4B,GAAzC,MAAa,4BAA4B;QACvC,YAAoB,eAAiC;YAAjC,oBAAe,GAAf,eAAe,CAAkB;SAAI;QAElD,IAAI,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAiC,EAAE,GAAG,MAAgB;YACtG,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;gBACvB,MAAM5C,eAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;aACzB;YAED,IAAI,OAAO,CAAC,IAAI,KAAKO,mBAAW,CAAC,MAAM,IAAI,OAAO,CAAC,IAAI,KAAKA,mBAAW,CAAC,QAAQ,EAAE;gBAChF,MAAMP,eAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;aAC1B;;YAGD,MAAM,cAAc,GAA8B,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,cAAc,CAAC,CAAC;YAC3H,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE;gBAC3B,MAAMA,eAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;aAC1B;YAED,OAAO,CAAC,cAAc,GAAG,cAAc,CAAC;;YAGxC,cAAc,CAAC,eAAe,GAAG,OAAO,CAAC,cAAc,CAAC,OAAO,CAAC;;YAGhE,cAAc,CAAC,OAAO,GAAG,IAAI,eAAe,CAAC,MAAM,CAAC,CAAC;SACtD;QAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAiC;;YAEnF,OAAO,CAAC,cAAc,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;YACzC,OAAO,CAAC,cAAc,CAAC,OAAO,GAAG,OAAO,CAAC,cAAc,CAAC,eAAe,CAAC;YACxE,OAAO,CAAC,cAAc,CAAC,eAAe,GAAG,IAAI,CAAC;SAC/C;KACF,CAAA;AAjCY4C,wCAA4B;QAFxC,eAAe,CAAC,eAAe,CAAC;QAChC7C,aAAM,CAAC,gBAAgB,CAAC;OACZ6C,oCAA4B,CAiCxC;;UC3CY,IAAI;QASf,YACS,gBAAmC,EAC1C,MAAa,EACb,cAAsB,EACtB,eAAiC,EAC1B,OAAwB;YAJxB,qBAAgB,GAAhB,gBAAgB,CAAmB;YAInC,YAAO,GAAP,OAAO,CAAiB;YAb1B,cAAS,GAAe,IAAI,CAAC;YAC7B,cAAS,GAAe,IAAI,CAAC;YAE7B,WAAM,gBAAqB;YAWhC,IAAI,CAAC,cAAc,GAAG,eAAe,CAAC,WAAW,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;SAC3E;QAEM,UAAU,CAAC,IAAgB;YAChC,MAAM,eAAe,GAAG,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC;YACpD,MAAM,CAAC,MAAM,CAAC,eAAe,EAAE,IAAI,CAAC,CAAC;YACrC,MAAM,MAAM,GAAG,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAACnD,sBAAc,CAAC,YAAY,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;YAEtG,KAAK,MAAM,IAAI,IAAI,IAAI,EAAE;gBACvB,OAAO,eAAe,CAAC,IAAI,CAAC,CAAC;aAC9B;YAED,OAAO,MAAM,CAAC;SACf;QAEM,KAAK,CAAC,KAAqB,EAAE,KAAa;YAC/C,IAAI,IAAI,CAAC,MAAM,oBAAkB;gBAC/B,IAAI,IAAI,CAAC,MAAM,KAAK,KAAK,EAAE;oBACzB,OAAO;iBACR;gBAED,IAAI,CAAC,OAAO,CAAC,KAAK,GAAGA,sBAAc,CAAC,QAAQ,CAAC,CAAC;aAC/C;;YAED,IAAI,CAAC,MAAM,sBAAoB;YAE/B,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;YAEpB,MAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;YAC/C,IAAI,OAAO,CAAC,gBAAgB,CAAC,EAAE;gBAC7B,gBAAgB,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;aAC3C;YAED,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,KAAK,IAAI,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,CAAC;;YAGrE,IAAI,CAAC,MAAM,oBAAkB;YAC7B,IAAI,CAAC,MAAM,IAAI,mBAAiB;SACjC;QAEM,OAAO,CAAC,KAAqB;YAClC,IAAI,EAAE,IAAI,CAAC,MAAM,mBAAiB,EAAE;gBAClC,OAAO;aACR;;YAED,IAAI,CAAC,MAAM,yBAAsB;YAEjC,MAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;YAC/C,IAAI,SAAS,CAAC,gBAAgB,CAAC,EAAE;gBAC/B,gBAAgB,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;aACnD;YAED,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;YACnB,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;;YAG1C,IAAI,CAAC,MAAM,IAAI,EAAE,uCAAkC,CAAC;SACrD;;QAEM,eAAe,CAAC,GAAc,EAAE,YAAuB,KAAW;QAClE,YAAY,CAAC,QAAa,EAAE,aAAkB,EAAE,KAAqB,KAAW;KAExF;;UC3EY,iBAAiB,GAAGE,SAAE,CAAC,eAAe,EAAqB;SACrE,WAAW,CAAC,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,gBAAgB,CAAC,CAAC,CAAC;IAEnD;AACA,UAAa,gBAAgB;QAI3B;YACE,IAAI,CAAC,gBAAgB,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YAC5C,IAAI,CAAC,mBAAmB,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YAC/C,IAAI,CAAC,WAAW,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;SACxC;QAKM,KAAK,CAAC,UAAkB,EAAE,WAAwB;YACvD,QAAQ,WAAW;gBACjB;oBACA;wBACE,IAAI,KAAK,GAAG,IAAI,CAAC,mBAAmB,CAAC,UAAU,CAAC,CAAC;wBACjD,IAAI,KAAK,KAAK,SAAS,EAAE;4BACvB,KAAK,GAAG,IAAI,CAAC,mBAAmB,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,WAAW,CAAC,CAAC;yBACxF;wBACD,OAAO,KAAK,CAAC;qBACd;gBACD;oBACA;wBACE,IAAI,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;wBACzC,IAAI,KAAK,KAAK,SAAS,EAAE;4BACvB,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,WAAW,CAAC,CAAC;yBAChF;wBACD,OAAO,KAAK,CAAC;qBACd;gBACD;oBACA;;;wBAGE,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,KAAK,WAAW,IAAI,wEAAiF,CAAC,EAAE;4BACjI,OAAO,gBAAgB,CAAC,MAAM,CAAC;yBAChC;wBACD,IAAI,KAAK,GAAG,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;wBAC9C,IAAI,KAAK,KAAK,SAAS,EAAE;4BACvB,KAAK,GAAG,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,WAAW,CAAC,CAAC;yBACrF;wBACD,OAAO,KAAK,CAAC;qBACd;aACF;SACF;QAEM,KAAK,CAAC,WAA+E;YAC1F,MAAM,EAAE,WAAW,EAAE,gBAAgB,EAAE,mBAAmB,EAAE,GAAG,IAAI,CAAC;YACpE,KAAK,MAAM,UAAU,IAAI,WAAW,EAAE;gBACpC,MAAM,IAAI,GAAG,WAAW,CAAC,UAAU,CAAC,CAAC;gBACrC,QAAQ,IAAI,CAAC,KAAK;oBAChB;wBACE,mBAAmB,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC;wBACvC,MAAM;oBACR;wBACE,WAAW,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC;wBAC/B,MAAM;oBACR;wBACE,gBAAgB,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC;iBACvC;aACF;SACF;QAKO,SAAS,CAAC,UAAkB,EAAE,WAAwB;YAC5D,IAAI;gBACF,MAAM,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;gBACpC,MAAM,SAAS,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gBAC3B,IAAI,OAA2D,CAAC;gBAEhE,IAAI,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;oBAC5B,OAAO,GAAG,IAAI,SAAS,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,EAAEC,eAAQ,CAAC,UAAU,CAAC,CAAC;iBAC3E;qBAAM;oBACL,OAAO,GAAG,IAAI,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;iBACrC;gBAED,IAAI,KAAK,GAAG,CAAC,CAAC;gBAEd,OAAO,KAAK,GAAG,KAAK,CAAC,MAAM,EAAE;oBAC3B,MAAM,WAAW,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC;oBAEjC,IAAI,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;wBAC9B,OAAO,GAAG,IAAI,UAAU,CAAC,OAAO,EAAE,WAAW,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,EAAEA,eAAQ,CAAC,UAAU,CAAC,CAAC;qBACvF;yBAAM;wBACL,OAAO,GAAG,IAAI,YAAY,CAAC,OAAO,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;qBACnD;oBAED,KAAK,EAAE,CAAC;iBACT;gBAED,OAAO,OAAO,CAAC;aAChB;YAAC,OAAO,CAAC,EAAE;gBACV,MAAMI,eAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;aAC5B;SACF;KACF;;ICxGD;IAEA,MAAM,UAAEiB,QAAM,WAAED,SAAO,EAAE,GAAGT,mBAAW,CAAC;AAExC,UAAa,yBAAyB;QAUpC,YACS,eAAiC,EACjC,aAA4B,EAC5B,MAAsB,EACtB,cAAsB,EACtB,IAAiB,EACjB,OAAwB;YALxB,oBAAe,GAAf,eAAe,CAAkB;YACjC,kBAAa,GAAb,aAAa,CAAe;YAC5B,WAAM,GAAN,MAAM,CAAgB;YACtB,mBAAc,GAAd,cAAc,CAAQ;YACtB,SAAI,GAAJ,IAAI,CAAa;YACjB,YAAO,GAAP,OAAO,CAAiB;YAf1B,cAAS,GAAe,IAAI,CAAC;YAC7B,cAAS,GAAe,IAAI,CAAC;YAE7B,WAAM,gBAAqB;YAE3B,WAAM,GAAW,IAAI,CAAC;;;;;YAgB3B,MAAM,WAAW,GAAG,aAAa,CAAC,WAAW,CAAC;YAC9C,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;YACrD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBACpD,KAAK,CAAC,CAAC,CAAC,GAAG,IAAIsC,4BAAoB,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE,aAAa,EAAE,MAAM,EAAE,cAAc,EAAE,IAAI,EAAE,eAAe,EAAE,OAAO,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;aACrI;SACF;QAEM,KAAK,CAAC,KAAqB,EAAE,KAAa;YAC/C,IAAI,IAAI,CAAC,MAAM,oBAAkB;gBAC/B,IAAI,IAAI,CAAC,MAAM,KAAK,KAAK,EAAE;oBACzB,OAAO;iBACR;gBACD,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;aACrB;YACD,IAAI,CAAC,MAAM,oBAAkB;YAC7B,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;YAEpB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;YACzB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBAC9C,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;aAC9B;SACF;QAEM,OAAO,CAAC,KAAqB;YAClC,IAAI,EAAE,IAAI,CAAC,MAAM,mBAAiB,EAAE;gBAClC,OAAO;aACR;YACD,IAAI,CAAC,MAAM,IAAI,iBAAe;YAC9B,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;YACnB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;YACzB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBAC9C,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;aACzB;SACF;KACF;AAKD,AAAaA,gCAAoB,GAAjC,MAAa,oBAAoB;QAM/B,YACS,gBAA6B,EAC7B,aAA4B,EAC5B,MAAsB,EACtB,cAAsB,EACtB,IAAiB,EACjB,eAAiC,EACjC,OAAwB,EACxB,OAAgB;YAPhB,qBAAgB,GAAhB,gBAAgB,CAAa;YAC7B,kBAAa,GAAb,aAAa,CAAe;YAC5B,WAAM,GAAN,MAAM,CAAgB;YACtB,mBAAc,GAAd,cAAc,CAAQ;YACtB,SAAI,GAAJ,IAAI,CAAa;YACjB,oBAAe,GAAf,eAAe,CAAkB;YACjC,YAAO,GAAP,OAAO,CAAiB;YACxB,YAAO,GAAP,OAAO,CAAS;YAZlB,WAAM,gBAAqB;YAchC,IAAI,CAAC,cAAc,GAAG,eAAe,CAAC,WAAW,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;SAC3E;QAEM,YAAY,CAAC,KAAU,EAAE,KAAqB;YACnD,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,GAAGpD,sBAAc,CAAC,oBAAoB,CAAC,CAAC;SAClF;QAEM,YAAY,CAAC,QAAa,EAAE,aAAkB,EAAE,KAAqB;YAC1E,IAAI,EAAE,IAAI,CAAC,MAAM,mBAAiB,EAAE;gBAClC,OAAO;aACR;YAED,aAAa,GAAG,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE,CAAC;YAC/C,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;YACzE,IAAI,QAAQ,KAAK,aAAa,EAAE;gBAC9B,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;aACpC;YAED,IAAI,CAAC,IAAI,CAAC,IAAI,GAAGuB,SAAO,MAAM,CAAC,EAAE;gBAC/B,IAAI,CAAC,OAAO,EAAE,CAAC;gBACf,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;gBACxD,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;aACvB;SACF;QAEM,KAAK,CAAC,KAAqB,EAAE,KAAa;YAC/C,IAAI,IAAI,CAAC,MAAM,oBAAkB;gBAC/B,IAAI,IAAI,CAAC,MAAM,KAAK,KAAK,EAAE;oBACzB,OAAO;iBACR;gBACD,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;aACrB;YAED,IAAI,CAAC,MAAM,oBAAkB;YAC7B,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;YAEpB,MAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;YAC/C,IAAI,gBAAgB,CAAC,IAAI,EAAE;gBACzB,gBAAgB,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;aAC3C;;;YAID,IAAI,IAAI,CAAC,OAAO,EAAE;gBAChB,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,OAAO,CAAC,EAAE,KAAK,CAAC,CAAC;aACnF;YACD,IAAI,IAAI,CAAC,IAAI,GAAGC,QAAM,EAAE;gBACtB,gBAAgB,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;aAC9C;SACF;QAEM,OAAO,CAAC,KAAqB;YAClC,IAAI,EAAE,IAAI,CAAC,MAAM,mBAAiB,EAAE;gBAClC,OAAO;aACR;YACD,IAAI,CAAC,MAAM,IAAI,iBAAe;YAE9B,MAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;YAC/C,IAAI,gBAAgB,CAAC,MAAM,EAAE;gBAC3B,gBAAgB,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;aACnD;YAED,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;YACnB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;SACtB;KACF,CAAA;AAjFY4B,gCAAoB;QADhC,WAAW,EAAE;OACDA,4BAAoB,CAiFhC;;AC9IYC,sBAAU,GAAvB,MAAa,UAAU;QAUrB,YACS,gBAA6B,EAC7B,cAAsB,EACtB,eAAiC,EACjC,OAAwB,EACvB,cAAuB,KAAK;YAJ7B,qBAAgB,GAAhB,gBAAgB,CAAa;YAC7B,mBAAc,GAAd,cAAc,CAAQ;YACtB,oBAAe,GAAf,eAAe,CAAkB;YACjC,YAAO,GAAP,OAAO,CAAiB;YACvB,gBAAW,GAAX,WAAW,CAAiB;YAd/B,cAAS,GAAe,IAAI,CAAC;YAC7B,cAAS,GAAe,IAAI,CAAC;YAE7B,WAAM,gBAAqB;YAC3B,WAAM,GAAW,IAAI,CAAC;YAGtB,WAAM,GAAmB,IAAI,CAAC;YAQnC,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;SAC3C;QAEM,YAAY,CAAC,QAAa,EAAE,aAAkB,EAAE,KAAqB;YAC1E,IAAI,EAAE,IAAI,CAAC,MAAM,mBAAiB,EAAE;gBAClC,OAAO;aACR;YAED,IAAI,KAAK,GAAGrD,sBAAc,CAAC,oBAAoB,EAAE;gBAC/C,MAAM,EAAE,MAAM,EAAE,cAAc,EAAE,GAAG,IAAI,CAAC;gBACxC,aAAa,GAAG,MAAM,CAAC,cAAc,CAAC,CAAC;gBACvC,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;gBAC5E,IAAI,QAAQ,KAAK,aAAa,EAAE;oBAC9B,MAAM,CAAC,cAAc,CAAC,GAAG,QAAQ,CAAC;iBACnC;gBACD,OAAO;aACR;YAED,MAAMO,eAAQ,CAAC,KAAK,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;SACjC;QAEM,KAAK,CAAC,KAAqB,EAAE,KAAa;YAC/C,IAAI,IAAI,CAAC,MAAM,oBAAkB;gBAC/B,IAAI,IAAI,CAAC,MAAM,KAAK,KAAK,EAAE;oBACzB,OAAO;iBACR;gBACD,IAAI,CAAC,OAAO,CAAC,KAAK,GAAGP,sBAAc,CAAC,QAAQ,CAAC,CAAC;aAC/C;;YAED,IAAI,CAAC,MAAM,sBAAoB;YAE/B,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;YACpB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC,cAAc,GAAG,KAAK,CAAC,eAAe,CAAC;YAE9E,MAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;YAC/C,IAAI,gBAAgB,CAAC,IAAI,EAAE;gBACzB,gBAAgB,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;aAC3C;;YAED,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,GAAG,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAACA,sBAAc,CAAC,QAAQ,EAAE,KAAK,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;YAChH,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;;YAGlD,IAAI,CAAC,MAAM,oBAAkB;YAC7B,IAAI,CAAC,MAAM,IAAI,mBAAiB;SACjC;QAEM,OAAO,CAAC,KAAqB;YAClC,IAAI,EAAE,IAAI,CAAC,MAAM,mBAAiB,EAAE;gBAClC,OAAO;aACR;;YAED,IAAI,CAAC,MAAM,yBAAsB;YAEjC,MAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;YAC/C,IAAI,gBAAgB,CAAC,MAAM,EAAE;gBAC3B,gBAAgB,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;aACnD;YACD,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;YACnB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;;YAGrB,IAAI,CAAC,MAAM,IAAI,EAAE,uCAAkC,CAAC;SACrD;KACF,CAAA;AAhFYqD,sBAAU;QADtB,WAAW,EAAE;OACDA,kBAAU,CAgFtB;;UCnFY,QAAQ;QAUnB,YACS,WAAmB,EACnB,kBAAsC,EACtC,gBAAmC,EACnC,MAAa,EACb,cAAuB,EACtB,YAA2B,EAC5B,OAAwB;YANxB,gBAAW,GAAX,WAAW,CAAQ;YACnB,uBAAkB,GAAlB,kBAAkB,CAAoB;YACtC,qBAAgB,GAAhB,gBAAgB,CAAmB;YACnC,WAAM,GAAN,MAAM,CAAO;YACb,mBAAc,GAAd,cAAc,CAAS;YACtB,iBAAY,GAAZ,YAAY,CAAe;YAC5B,YAAO,GAAP,OAAO,CAAiB;YAhB1B,cAAS,GAAe,IAAI,CAAC;YAC7B,cAAS,GAAe,IAAI,CAAC;YAE7B,WAAM,gBAAqB;SAaI;QAE/B,UAAU,CAAC,KAAY;YAC5B,MAAM,eAAe,GAAG,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC;YACpD,eAAe,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC;YAElC,MAAM,MAAM,GAAG,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAACrD,sBAAc,CAAC,YAAY,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;YAEtG,OAAO,eAAe,CAAC,QAAQ,CAAC,CAAC;YAEjC,IAAI,MAAM,KAAK,IAAI,IAAI,IAAI,CAAC,cAAc,EAAE;gBAC1C,KAAK,CAAC,cAAc,EAAE,CAAC;aACxB;YAED,OAAO,MAAM,CAAC;SACf;QAEM,WAAW,CAAC,KAAY;YAC7B,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;SACxB;QAEM,KAAK,CAAC,KAAqB,EAAE,KAAa;YAC/C,IAAI,IAAI,CAAC,MAAM,oBAAkB;gBAC/B,IAAI,IAAI,CAAC,MAAM,KAAK,KAAK,EAAE;oBACzB,OAAO;iBACR;gBAED,IAAI,CAAC,OAAO,CAAC,KAAK,GAAGA,sBAAc,CAAC,QAAQ,CAAC,CAAC;aAC/C;;YAED,IAAI,CAAC,MAAM,sBAAoB;YAE/B,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;YAEpB,MAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;YAC/C,IAAI,OAAO,CAAC,gBAAgB,CAAC,EAAE;gBAC7B,gBAAgB,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;aAC3C;YAED,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,YAAY,CAAC,gBAAgB,CAC/C,IAAI,CAAC,MAAM,EACX,IAAI,CAAC,WAAW,EAChB,IAAI,EACJ,IAAI,CAAC,kBAAkB,CACxB,CAAC;;YAGF,IAAI,CAAC,MAAM,oBAAkB;YAC7B,IAAI,CAAC,MAAM,IAAI,mBAAiB;SACjC;QAEM,OAAO,CAAC,KAAqB;YAClC,IAAI,EAAE,IAAI,CAAC,MAAM,mBAAiB,EAAE;gBAClC,OAAO;aACR;;YAED,IAAI,CAAC,MAAM,yBAAsB;YAEjC,MAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;YAC/C,IAAI,SAAS,CAAC,gBAAgB,CAAC,EAAE;gBAC/B,gBAAgB,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;aACnD;YAED,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;YACnB,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;YACvB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;;YAGpB,IAAI,CAAC,MAAM,IAAI,EAAE,uCAAkC,CAAC;SACrD;;QAEM,eAAe,CAAC,GAAc,EAAE,YAAuB,KAAW;QAClE,YAAY,CAAC,QAAa,EAAE,aAAkB,EAAE,KAAqB,KAAW;KAExF;;UC7FY,GAAG;QAQd,YACS,gBAAmC,EACnC,MAAsB,EACtB,OAAwB;YAFxB,qBAAgB,GAAhB,gBAAgB,CAAmB;YACnC,WAAM,GAAN,MAAM,CAAgB;YACtB,YAAO,GAAP,OAAO,CAAiB;YAV1B,cAAS,GAAe,IAAI,CAAC;YAC7B,cAAS,GAAe,IAAI,CAAC;YAE7B,WAAM,gBAAqB;SAOI;QAE/B,KAAK,CAAC,KAAqB,EAAE,KAAa;YAC/C,IAAI,IAAI,CAAC,MAAM,oBAAkB;gBAC/B,IAAI,IAAI,CAAC,MAAM,KAAK,KAAK,EAAE;oBACzB,OAAO;iBACR;gBAED,IAAI,CAAC,OAAO,CAAC,KAAK,GAAGA,sBAAc,CAAC,QAAQ,CAAC,CAAC;aAC/C;;YAED,IAAI,CAAC,MAAM,sBAAoB;YAE/B,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;YAEpB,MAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;YAC/C,IAAI,OAAO,CAAC,gBAAgB,CAAC,EAAE;gBAC7B,gBAAgB,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;aAC3C;YAED,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;;YAG5E,IAAI,CAAC,MAAM,oBAAkB;YAC7B,IAAI,CAAC,MAAM,IAAI,mBAAiB;SACjC;QAEM,OAAO,CAAC,KAAqB;YAClC,IAAI,EAAE,IAAI,CAAC,MAAM,mBAAiB,EAAE;gBAClC,OAAO;aACR;;YAED,IAAI,CAAC,MAAM,yBAAsB;YAEjC,IAAI,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,KAAK,IAAI,CAAC,MAAM,EAAE;gBACpF,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;aACtE;YAED,MAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;YAC/C,IAAI,SAAS,CAAC,gBAAgB,CAAC,EAAE;gBAC/B,gBAAgB,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;aACnD;YAED,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;;YAGnB,IAAI,CAAC,MAAM,IAAI,EAAE,uCAAkC,CAAC;SACrD;;QAEM,eAAe,CAAC,GAAc,EAAE,YAAuB,KAAW;QAClE,YAAY,CAAC,QAAa,EAAE,aAAkB,EAAE,KAAqB,KAAW;KAExF;;ICvED;AACA,IAOA;AACA,UAAa,iBAAiB,GAAG,gBAAgB,CAAC;IAClD;AACA,aAAgB,gBAAgB,CAAC,IAAY;QAC3C,OAAO,GAAG,iBAAiB,IAAI,IAAI,EAAE,CAAC;IACxC,CAAC;IACD;AACA,aAAgB,qBAAqB,CAAC,IAAS;QAC7C,OAAO,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC;IACrC,CAAC;IAED;AACA,UAAa,mBAAmB,GAAG,kBAAkB,CAAC;IACtD;AACA,aAAgB,kBAAkB,CAAC,IAAY;QAC7C,OAAO,GAAG,mBAAmB,IAAI,IAAI,EAAE,CAAC;IAC1C,CAAC;IA8BD,MAAM,qBAAqB,GAAG,cAAc,CAAC;AAmC7C,UAAa,oBAAoB,GAAGE,SAAE,CAAC,eAAe,EAAwB,CAAC;AAsB/E,aAAgB,qBAAqB,CAAC,KAAwB;QAC5D,MAAM,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC;QACxB,OAAO,OAAO,IAAI,KAAK,QAAQ,IAAI,qBAAqB,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;IAChF,CAAC;IAkHD;AACA,UAAa,aAAa,GAAsB,MAAM,CAAC,MAAM,CAAC;QAC5D,QAAQ,EAAE,IAAI;QACd,QAAQ,EAAE,SAAS;KACpB,CAAC,CAAC;IAEH,MAAM,gBAAgB,GAAsB,MAAM,CAAC,MAAM,CAAC;QACxD,QAAQ,EAAE,KAAK;QACf,QAAQ,EAAE,SAAS;KACpB,CAAC,CAAC;IAEH;IACA;IACA;IACA,MAAM,yBAAyB;QAa7B;YACE,IAAI,CAAC,IAAI,GAAG,SAAS,CAAC;YACtB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;YACrB,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;YACf,IAAI,CAAC,KAAK,GAAG,gBAAgB,CAAC;YAC9B,IAAI,CAAC,SAAS,GAAGC,eAAQ,CAAC,WAAW,CAAC;YACtC,IAAI,CAAC,YAAY,GAAyBA,eAAQ,CAAC,UAAU,CAAC;YAC9D,IAAI,CAAC,YAAY,GAAyBA,eAAQ,CAAC,UAAU,CAAC;YAC9D,IAAI,CAAC,UAAU,GAAuBA,eAAQ,CAAC,UAAU,CAAC;YAC1D,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;YAC3B,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;YAC1B,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;SACvB;KACF;IAED,MAAM,6BAA6B,GAAG;QACpC,MAAM;QACN,UAAU;QACV,OAAO;QACP,OAAO;QACP,eAAe;QACf,eAAe;QACf,UAAU;KACX,CAAC;IAEF,MAAM,wBAAwB,GAAG;QAC/B,cAAc;QACd,cAAc;QACd,YAAY;KACb,CAAC;AAwBF,aAAgB,uBAAuB,CACrC,IAAqC,EACrC,SAAyD,EACzD,QAAgC,EAChC,KAA2B,EAC3B,KAA0C,EAC1C,SAAuD,EACvD,YAAuE,EACvE,YAA4C,EAC5C,UAAsD,EACtD,aAA8B,EAC9B,aAAkD,EAClD,QAAyB;QAEzB,MAAM,GAAG,GAAG,IAAI,yBAAyB,EAAE,CAAC;;QAG5C,MAAM,MAAM,GAAG,SAAS,CAAC,MAAM,CAAC;QAChC,QAAQ,MAAM;YACZ,KAAK,EAAE,EAAE,IAAI,QAAQ,KAAK,IAAI;gBAAE,GAAG,CAAC,QAAQ,GAAG,QAAQ,CAAC;YACxD,KAAK,EAAE,EAAE,IAAI,aAAa,KAAK,IAAI;gBAAE,GAAG,CAAC,aAAa,GAAG,aAAa,CAAC;YACvE,KAAK,EAAE,EAAE,IAAI,aAAa,KAAK,IAAI;gBAAE,GAAG,CAAC,aAAa,GAAG,aAAa,CAAC;YACvE,KAAK,CAAC,EAAE,IAAI,UAAU,KAAK,IAAI;gBAAE,GAAG,CAAC,UAAU,GAAGA,eAAQ,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;YAC/E,KAAK,CAAC,EAAE,IAAI,YAAY,KAAK,IAAI;gBAAE,GAAG,CAAC,YAAY,GAAGA,eAAQ,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;YACrF,KAAK,CAAC,EAAE,IAAI,YAAY,KAAK,IAAI;gBAAE,GAAG,CAAC,YAAY,GAA4BA,eAAQ,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;YAC9G,KAAK,CAAC,EAAE,IAAI,SAAS,KAAK,IAAI;gBAAE,GAAG,CAAC,SAAS,qBAAQ,SAAS,CAAE,CAAC;YACjE,KAAK,CAAC,EAAE,IAAI,KAAK,KAAK,IAAI;gBAAE,GAAG,CAAC,KAAK,GAAG,KAAK,KAAK,IAAI,GAAG,aAAa,GAAG,KAAK,KAAK,KAAK,GAAG,gBAAgB,qBAAQ,KAAK,CAAE,CAAC;YAC3H,KAAK,CAAC,EAAE,IAAI,KAAK,KAAK,IAAI;gBAAE,GAAG,CAAC,KAAK,GAAG,KAAK,CAAC;YAC9C,KAAK,CAAC,EAAE,IAAI,QAAQ,KAAK,IAAI;gBAAE,GAAG,CAAC,QAAQ,GAAG,QAAQ,CAAC;YACvD,KAAK,CAAC;gBACJ,IAAI,IAAI,KAAK,IAAI,EAAE;oBACjB,IAAI,IAAI,CAAC,WAAW,CAAC,EAAE;wBACrB,GAAG,CAAC,SAAS,qBAAQ,IAAI,CAAC,SAAS,CAAE,CAAC;qBACvC;oBACD,IAAI,IAAI,CAAC,eAAe,CAAC,EAAE;wBACzB,GAAG,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC;qBACxC;oBACD,IAAI,IAAI,CAAC,eAAe,CAAC,EAAE;wBACzB,GAAG,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC;qBACxC;iBACF;gBACD,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE;oBACjC,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE;wBACxB,GAAG,CAAC,IAAI,GAAG,SAAS,CAAC;qBACtB;iBACF;qBAAM,IAAI,SAAS,KAAK,IAAI,EAAE;oBAC7B,6BAA6B,CAAC,OAAO,CAAC,IAAI;wBACxC,IAAI,SAAS,CAAC,IAAI,CAAC,EAAE;4BACnB,GAAG,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC,IAAI,CAAC,CAAC;yBAC7B;qBACF,CAAC,CAAC;oBACH,wBAAwB,CAAC,OAAO,CAAC,IAAI;wBACnC,IAAI,SAAS,CAAC,IAAI,CAAC,EAAE;4BACnB,GAAG,CAAC,IAAI,CAAC,GAAGA,eAAQ,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;yBAC/C;qBACF,CAAC,CAAC;oBACH,IAAI,SAAS,CAAC,WAAW,CAAC,EAAE;wBAC1B,IAAI,GAAG,CAAC,SAAS,KAAKA,eAAQ,CAAC,WAAW,EAAE;4BAC1C,GAAG,CAAC,SAAS,qBAAQ,SAAS,CAAC,SAAS,CAAE,CAAC;yBAC5C;6BAAM;4BACL,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,EAAE,SAAS,CAAC,SAAS,CAAC,CAAC;yBACnD;qBACF;iBACF;SACJ;;QAGD,IAAI,MAAM,KAAK,CAAC,IAAI,IAAI,KAAK,IAAI,EAAE;YACjC,IAAI,OAAO,SAAS,KAAK,QAAQ,IAAI,EAAE,OAAO,IAAI,SAAS,CAAC,EAAE;gBAC5D,GAAG,CAAC,KAAK,GAAG,aAAa,CAAC;aAC3B;SACF;QAED,OAAO,GAAG,CAAC;IACb,CAAC;;aCtWe,QAAQ,CAAiE,cAAmC,EAAE,IAAa;QACzI,IAAI,MAA4B,CAAC;QAEjC,MAAM,SAAS,GAAG,SAAS,QAAQ,CAAC,OAAU,EAAE,KAAa;YAC3D,MAAM,IAAI,GAAG,OAAO,CAAC,WAAqD,CAAC;YAC3E,IAAI,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;YAC/B,IAAI,SAAS,KAAK,SAAS,EAAE;gBAC3B,SAAS,GAAG,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;aACjC;YACD,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE;gBACrB,MAAM,CAAC,SAAS,GAAGA,eAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;aAC9C;YACD,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE;gBACpB,MAAM,CAAC,QAAQ,GAAG,GAAG,KAAK,SAAS,CAAC;aACrC;YACD,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE;gBAChB,MAAM,CAAC,IAAI,GAAGW,mBAAW,CAAC,MAAM,CAAC;aAClC;YACD,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE;;;;;;gBAMxB,MAAM,CAAC,QAAQ,GAAG,KAAK,CAAC;aACzB;YACD,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,MAAM,CAAC;SACrC,CAAC;QACF,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE;;;YAGxB,MAAM,GAAG,EAAE,CAAC;YACZ,OAAO,SAAS,CAAC,cAAmB,EAAE,IAAI,CAAC,CAAC;SAC7C;aAAM,IAAI,OAAO,cAAc,KAAK,QAAQ,EAAE;;;;;YAK7C,MAAM,GAAG,EAAE,CAAC;YACZ,OAAO,SAA8B,CAAC;SACvC;;;;QAKD,MAAM,IAAI,cAAc,IAAI,EAAE,CAAyB,CAAC;QACxD,OAAO,SAA8B,CAAC;IACxC,CAAC;;aC/De,aAAa,CAAC,SAAiC,EAAE,KAAkB,EAAE,QAA+B;QAClH,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE;YACjC,OAAO,mBAAmB,CAAC,SAAS,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;SACxD;aAAM;YACL,OAAO,oBAAoB,CAAC,SAA+B,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;SAC/E;IACH,CAAC;AAED,UAAa,UAAU;QAGrB,YACmB,IAAW,EACX,YAAqC,EACrC,YAAgC;YAFhC,SAAI,GAAJ,IAAI,CAAO;YACX,iBAAY,GAAZ,YAAY,CAAyB;YACrC,iBAAY,GAAZ,YAAY,CAAoB;SAC/C;QAEJ,IAAW,UAAU;YACnB,OAAO,IAAI,CAAC,cAAc,KAAK,IAAI,CAAC,cAAc;gBAChD,uBAAuB,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,OAAO,IAAI,CAAC,IAAI,KAAK,QAAQ,EAAE,IAAI,EAAE,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC,CAAA;SACnI;QAEM,kBAAkB,CAAC,MAAwB,EAAE,IAAyB;YAC3E,OAAO,MAAM,CAAC,kBAAkB,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;SACzD;QAEM,UAAU,CAAC,MAAwB,EAAE,aAA8B;YACxE,OAAO,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,aAAa,CAAC,CAAC,MAAM,EAAE,CAAC;SAC5D;QAEM,cAAc,CAAC,MAAwB,EAAE,aAA8B;YAC5E,OAAO,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,UAAU,EAAE,aAAa,CAAC,CAAC;SAC9D;;QAGM,SAAS,CAAC,MAAa,EAAE,YAAqC,EAAE,YAAmB;YACxF,GAAG,CAAC,WAAW,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;YACnC,YAAY,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,YAAY,CAAC,CAAC;YACxC,YAAY,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,YAAY,CAAC,CAAC;SACzC;KACF;IAED,SAAS,mBAAmB,CAAC,OAAe,EAAE,KAAkB,EAAE,QAA+B;QAC/F,MAAM,YAAY,GAA0B,EAAE,CAAC;QAC/C,MAAM,eAAe,GAAG,EAAE,CAAC;QAC3B,MAAM,YAAY,GAAG,EAAE,CAAC;QACxB,MAAM,OAAO,GAAG,GAAG,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;QAC3C,IAAI,eAAe,GAAG,KAAK,CAAC;QAE5B,IAAI,KAAK,EAAE;YACT,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC;iBACf,OAAO,CAAC,EAAE;gBACT,MAAM,KAAK,GAAG,KAAK,CAAC,EAAE,CAAC,CAAC;gBAExB,IAAI,qBAAqB,CAAC,KAAK,CAAC,EAAE;oBAChC,eAAe,GAAG,IAAI,CAAC;oBACvB,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;iBAC1B;qBAAM;oBACL,GAAG,CAAC,YAAY,CAAC,OAAO,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC;iBACtC;aACF,CAAC,CAAC;SACN;QAED,IAAI,eAAe,EAAE;YACnB,GAAG,CAAC,YAAY,CAAC,OAAO,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC;YACzC,eAAe,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;SACpC;QAED,IAAI,QAAQ,EAAE;YACZ,WAAW,CAAC,OAAO,EAAE,QAAQ,EAAE,eAAe,EAAE,YAAY,CAAC,CAAC;SAC/D;QAED,OAAO,IAAI,UAAU,CAAC,OAAO,EAAE,eAAe,EAAE,YAAY,CAAC,CAAC;IAChE,CAAC;IAED,SAAS,oBAAoB,CAAC,IAAwB,EAAE,KAAkB,EAAE,QAA+B;QACzG,MAAM,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC;QACtC,MAAM,YAAY,GAA0B,EAAE,CAAC;QAC/C,MAAM,eAAe,GAAG,CAAC,YAAY,CAAC,CAAC;QACvC,MAAM,YAAY,GAAG,EAAE,CAAC;QACxB,MAAM,iBAAiB,GAAG,EAAE,CAAC;QAC7B,MAAM,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC;QAC7C,MAAM,OAAO,GAAG,GAAG,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;QAE3C,GAAG,CAAC,YAAY,CAAC,OAAO,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC;QAEzC,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;YAChC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACzB;QAED,YAAY,CAAC,IAAI,CAAC;YAChB,IAAI;YACJ,GAAG,EAAE,OAAO;YACZ,YAAY,EAAE,iBAAiB;SAChC,CAAC,CAAC;QAEH,IAAI,KAAK,EAAE;YACT,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC;iBACf,OAAO,CAAC,EAAE;gBACT,MAAM,KAAK,GAAG,KAAK,CAAC,EAAE,CAAC,CAAC;gBAExB,IAAI,qBAAqB,CAAC,KAAK,CAAC,EAAE;oBAChC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;iBAC/B;qBAAM;oBACL,MAAM,QAAQ,GAAG,SAAS,CAAC,EAAE,CAAC,CAAC;oBAE/B,IAAI,QAAQ,EAAE;wBACZ,iBAAiB,CAAC,IAAI,CAAC;4BACrB,IAAI;4BACJ,EAAE;4BACF,KAAK;yBACN,CAAC,CAAC;qBACJ;yBAAM;wBACL,iBAAiB,CAAC,IAAI,CAAC;4BACrB,IAAI;4BACJ,EAAE;4BACF,KAAK;yBACN,CAAC,CAAC;qBACJ;iBACF;aACF,CAAC,CAAC;SACN;QAED,IAAI,QAAQ,EAAE;YACZ,WAAW,CAAC,OAAO,EAAE,QAAQ,EAAE,eAAe,EAAE,YAAY,CAAC,CAAC;SAC/D;QAED,OAAO,IAAI,UAAU,CAAC,OAAO,EAAE,eAAe,EAAE,YAAY,CAAC,CAAC;IAChE,CAAC;IAED,SAAS,WAAW,CAAC,MAAa,EAAE,QAA8B,EAAE,eAAwC,EAAE,YAAmB;QAC/H,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;YACjD,MAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;YAE5B,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;gBAC/B,GAAG,CAAC,WAAW,CAAC,MAAM,EAAE,GAAG,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,CAAC;aACtD;iBAAM,IAAI,GAAG,CAAC,cAAc,CAAC,OAAO,CAAC,EAAE;gBACtC,GAAG,CAAC,WAAW,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;aAClC;iBAAM;gBACL,OAAO,CAAC,SAAS,CAAC,MAAM,EAAE,eAAe,EAAE,YAAY,CAAC,CAAC;aAC1D;SACF;IACH,CAAC;;IChJD;AACA,aAAgB,gBAAgB,CAAmC,KAAqB,EAAE,mBAA0C;QAClI,IAAI,IAAI,CAAC,MAAM,uBAAqB;YAClC,OAAO;SACR;QACD,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC;QAClC,SAAS,CAAC,WAAW,EAAE,CAAC;;QAExB,IAAI,CAAC,MAAM,wBAAsB;QACjC,KAAK,IAAId,sBAAc,CAAC,UAAU,CAAC;QAEnC,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC;QAE1B,IAAI,KAAK,0BAAuB;YAC9B,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,mBAAmB,CAAC,CAAC;SAC5C;;QAGD,IAAI,CAAC,MAAM,uBAAqB;QAChC,IAAI,CAAC,MAAM,IAAI,qBAAmB;QAElC,IAAI,KAAK,yBAAsB;YAC7B,SAAS,CAAC,eAAe,CAAwB,IAAI,CAAC,CAAC;SACxD;QACD,SAAS,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;IAC7B,CAAC;IAED;AACA,aAAgB,cAAc,CAAiC,KAAqB,EAAE,mBAA0C;QAC9H,IAAI,IAAI,CAAC,MAAM,uBAAqB;YAClC,OAAO;SACR;QACD,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC;QAClC,SAAS,CAAC,WAAW,EAAE,CAAC;;QAExB,IAAI,CAAC,MAAM,wBAAsB;QACjC,KAAK,IAAIA,sBAAc,CAAC,UAAU,CAAC;QAEnC,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC;QAC1B,mBAAmB,GAAG,IAAI,CAAC,UAAU,CAAC,0BAA0B,CAAC,mBAAmB,KAAK,SAAS,GAAG,IAAI,CAAC,KAAK,GAAG,mBAAmB,CAAC,CAAC;QAEvI,IAAI,KAAK,0BAAuB;YAC9B,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,mBAAmB,CAAC,CAAC;SAC5C;QAED,IAAI,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC;QACnC,OAAO,OAAO,KAAK,IAAI,EAAE;YACvB,OAAO,CAAC,OAAO,CAAC,KAAK,EAAE,mBAAmB,CAAC,CAAC;YAC5C,OAAO,GAAG,OAAO,CAAC,WAAW,CAAC;SAC/B;QAED,IAAI,EAAE,IAAI,CAAC,MAAM,sBAAmB,EAAE;YACpC,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;SAC9B;;QAGD,IAAI,CAAC,MAAM,uBAAqB;QAChC,IAAI,CAAC,MAAM,IAAI,qBAAmB;QAElC,IAAI,KAAK,yBAAsB;YAC7B,SAAS,CAAC,eAAe,CAAwB,IAAI,CAAC,CAAC;SACxD;QACD,SAAS,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;IAC7B,CAAC;IAED;AACA,aAAgB,WAAW,CAAwB,KAAqB,EAAE,mBAA0C;QAClH,IAAI,IAAI,CAAC,MAAM,uBAAqB;YAClC,OAAO;SACR;;QAED,IAAI,CAAC,MAAM,wBAAsB;QACjC,KAAK,IAAIA,sBAAc,CAAC,UAAU,CAAC;QAEnC,IAAI,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC;QACnC,OAAO,OAAO,KAAK,IAAI,EAAE;YACvB,OAAO,CAAC,OAAO,CAAC,KAAK,EAAE,mBAAmB,CAAC,CAAC;YAC5C,OAAO,GAAG,OAAO,CAAC,WAAW,CAAC;SAC/B;QAED,IAAI,EAAE,IAAI,CAAC,MAAM,sBAAmB,EAAE;YACpC,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;SACpC;;QAGD,IAAI,CAAC,MAAM,uBAAqB;QAChC,IAAI,CAAC,MAAM,IAAI,qBAAmB;IACpC,CAAC;IAED;AACA,aAAgB,gBAAgB,CAAmC,KAAqB;QACtF,IAAI,IAAI,CAAC,MAAM,uBAAqB;YAClC,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC;YAClC,SAAS,CAAC,WAAW,EAAE,CAAC;;YAExB,IAAI,CAAC,MAAM,yBAAsB;YACjC,KAAK,IAAIA,sBAAc,CAAC,UAAU,CAAC;YAEnC,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC;YAC1B,IAAI,KAAK,0BAAuB;gBAC9B,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;aACvB;;YAGD,IAAI,CAAC,MAAM,IAAI,EAAE,0CAAqC,CAAC;YAEvD,IAAI,KAAK,0BAAsB;gBAC7B,SAAS,CAAC,eAAe,CAAwB,IAAI,CAAC,CAAC;aACxD;YACD,SAAS,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;SAC5B;IACH,CAAC;IAED;AACA,aAAgB,cAAc,CAAiC,KAAqB;QAClF,IAAI,IAAI,CAAC,MAAM,uBAAqB;YAClC,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC;YAClC,SAAS,CAAC,WAAW,EAAE,CAAC;;YAExB,IAAI,CAAC,MAAM,yBAAsB;YACjC,KAAK,IAAIA,sBAAc,CAAC,UAAU,CAAC;YAEnC,IAAI,IAAI,CAAC,MAAM,uBAAoB;;;;gBAIjC,IAAI,CAAC,CAAC,KAAK,GAAGA,sBAAc,CAAC,mBAAmB,IAAIA,sBAAc,CAAC,mBAAmB,KAAK,KAAK,GAAGA,sBAAc,CAAC,YAAY,CAAC,EAAE;oBAC/H,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;oBAC/B,KAAK,IAAIA,sBAAc,CAAC,mBAAmB,CAAC;iBAC7C;aACF;YAED,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC;YAC1B,IAAI,KAAK,0BAAuB;gBAC9B,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;aACvB;YAED,IAAI,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC;YACnC,OAAO,OAAO,KAAK,IAAI,EAAE;gBACvB,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;gBACvB,OAAO,GAAG,OAAO,CAAC,WAAW,CAAC;aAC/B;;YAGD,IAAI,CAAC,MAAM,IAAI,EAAE,0CAAqC,CAAC;YAEvD,IAAI,KAAK,0BAAsB;gBAC7B,SAAS,CAAC,eAAe,CAAwB,IAAI,CAAC,CAAC;aACxD;YACD,SAAS,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;SAC5B;IACH,CAAC;IAED;AACA,aAAgB,WAAW,CAAwB,KAAqB;QACtE,IAAI,IAAI,CAAC,MAAM,uBAAqB;;YAElC,IAAI,CAAC,MAAM,yBAAsB;YACjC,KAAK,IAAIA,sBAAc,CAAC,UAAU,CAAC;YAEnC,IAAI,IAAI,CAAC,MAAM,uBAAoB;;;;gBAIjC,IAAI,CAAC,CAAC,KAAK,GAAGA,sBAAc,CAAC,mBAAmB,IAAIA,sBAAc,CAAC,mBAAmB,KAAK,KAAK,GAAGA,sBAAc,CAAC,YAAY,CAAC,EAAE;oBAC/H,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;oBACrC,KAAK,IAAIA,sBAAc,CAAC,mBAAmB,CAAC;iBAC7C;aACF;YAED,IAAI,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC;YACnC,OAAO,OAAO,KAAK,IAAI,EAAE;gBACvB,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;gBACvB,OAAO,GAAG,OAAO,CAAC,WAAW,CAAC;aAC/B;;YAGD,IAAI,CAAC,MAAM,IAAI,EAAE,0CAAqC,CAAC;SACxD;IACH,CAAC;IAED;AACA,aAAgB,eAAe,CAAmC,KAAqB;QACrF,KAAK,IAAIA,sBAAc,CAAC,SAAS,CAAC;QAClC,IAAI,IAAI,CAAC,MAAM,0BAAqB;YAClC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;SACrB;IACH,CAAC;IAED;AACA,aAAgB,aAAa,CAAiC,KAAqB;QACjF,KAAK,IAAIA,sBAAc,CAAC,SAAS,CAAC;QAClC,IAAI,IAAI,CAAC,MAAM,0BAAqB;YAClC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;SACrB;QAED,IAAI,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC;QACnC,OAAO,OAAO,KAAK,IAAI,EAAE;YACvB,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YACtB,OAAO,GAAG,OAAO,CAAC,WAAW,CAAC;SAC/B;IACH,CAAC;IAED;AACA,aAAgB,UAAU,CAAwB,KAAqB;QACrE,KAAK,IAAIA,sBAAc,CAAC,SAAS,CAAC;QAClC,IAAI,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC;QACnC,OAAO,OAAO,KAAK,IAAI,EAAE;YACvB,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YACtB,OAAO,GAAG,OAAO,CAAC,WAAW,CAAC;SAC/B;IACH,CAAC;IAED;AACA,aAAgB,aAAa,CAAiC,KAAqB;QACjF,IAAI,CAAC,MAAM,uBAAoB;QAC/B,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACvC,CAAC;IAED;AACA,aAAgB,eAAe,CAAiC,KAAqB;QACnF,IAAI,CAAC,MAAM,IAAI,oBAAiB;QAChC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACpC,CAAC;IAED;AACA,aAAgB,UAAU,CAAwB,KAAqB;QACrE,IAAI,CAAC,MAAM,uBAAoB;QAC/B,IAAI,CAAC,MAAM,IAAI,sBAAkB;QACjC,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IAC1C,CAAC;IAED;AACA,aAAgB,YAAY,CAAwB,KAAqB;QACvE,IAAI,CAAC,MAAM,IAAI,oBAAiB;QAChC,IAAI,CAAC,MAAM,yBAAqB;QAChC,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC;QAErB,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;YACpB,IAAI,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE;gBACrC,IAAI,CAAC,MAAM,uBAAmB;gBAC9B,OAAO,IAAI,CAAC;aACb;SACF;QACD,OAAO,KAAK,CAAC;IACf,CAAC;;ICvPD;AACA,aAAgB,cAAc,CAAmC,KAAqB,EAAE,KAAa;QACnG,KAAK,IAAIA,sBAAc,CAAC,QAAQ,CAAC;QAEjC,IAAI,IAAI,CAAC,MAAM,oBAAkB;YAC/B,IAAI,IAAI,CAAC,MAAM,KAAK,KAAK,EAAE;gBACzB,OAAO;aACR;YAED,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;SACrB;QACD,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC;QAClC,SAAS,CAAC,SAAS,EAAE,CAAC;;QAEtB,IAAI,CAAC,MAAM,sBAAoB;QAE/B,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC;QAE1B,IAAI,KAAK,qBAAmB;YAC1B,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;SAC9B;QAED,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QAEpB,IAAI,KAAK,uBAAqB;YAC5B,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;SACrB;;QAGD,IAAI,CAAC,MAAM,oBAAkB;QAC7B,IAAI,CAAC,MAAM,IAAI,mBAAiB;QAEhC,SAAS,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;IAC3B,CAAC;IAED;AACA,aAAgB,YAAY,CAAiC,KAAqB;QAChF,IAAI,IAAI,CAAC,MAAM,oBAAkB;YAC/B,OAAO;SACR;QACD,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC;QAClC,SAAS,CAAC,SAAS,EAAE,CAAC;;QAEtB,IAAI,CAAC,MAAM,sBAAoB;QAE/B,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC;QAC1B,KAAK,IAAIA,sBAAc,CAAC,QAAQ,CAAC;QAEjC,IAAI,KAAK,qBAAmB;YAC1B,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;SAC9B;QAED,IAAI,KAAK,uBAAqB;YAC5B,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;SACrB;QAED,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC;QAC1B,IAAI,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC;QACjC,OAAO,OAAO,KAAK,IAAI,EAAE;YACvB,OAAO,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;YAC5B,OAAO,GAAG,OAAO,CAAC,SAAS,CAAC;SAC7B;;QAGD,IAAI,CAAC,MAAM,oBAAkB;QAC7B,IAAI,CAAC,MAAM,IAAI,mBAAiB;QAEhC,SAAS,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;IAC3B,CAAC;IAED;AACA,aAAgB,SAAS,CAAwB,KAAqB,EAAE,KAAa;QACnF,KAAK,IAAIA,sBAAc,CAAC,QAAQ,CAAC;QAEjC,IAAI,IAAI,CAAC,MAAM,oBAAkB;YAC/B,IAAI,IAAI,CAAC,MAAM,KAAK,KAAK,EAAE;gBACzB,OAAO;aACR;YAED,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;SACrB;;QAED,IAAI,CAAC,MAAM,sBAAoB;QAE/B,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,IAAI,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC;QACjC,OAAO,OAAO,KAAK,IAAI,EAAE;YACvB,OAAO,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;YAC5B,OAAO,GAAG,OAAO,CAAC,SAAS,CAAC;SAC7B;;QAGD,IAAI,CAAC,MAAM,oBAAkB;QAC7B,IAAI,CAAC,MAAM,IAAI,mBAAiB;IAClC,CAAC;IAED;AACA,aAAgB,gBAAgB,CAAmC,KAAqB;QACtF,IAAI,IAAI,CAAC,MAAM,oBAAkB;YAC/B,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC;YAClC,SAAS,CAAC,WAAW,EAAE,CAAC;;YAExB,IAAI,CAAC,MAAM,yBAAsB;YAEjC,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC;YAC1B,KAAK,IAAIA,sBAAc,CAAC,UAAU,CAAC;YAEnC,IAAI,KAAK,yBAAqB;gBAC5B,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;aAChC;YAED,IAAI,KAAK,2BAAuB;gBAC9B,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;aACvB;;YAGD,IAAI,CAAC,MAAM,IAAI,EAAE,uCAAkC,CAAC;YAEpD,SAAS,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;SAC5B;IACH,CAAC;IAED;AACA,aAAgB,cAAc,CAAiC,KAAqB;QAClF,IAAI,IAAI,CAAC,MAAM,oBAAkB;YAC/B,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC;YAClC,SAAS,CAAC,WAAW,EAAE,CAAC;;YAExB,IAAI,CAAC,MAAM,yBAAsB;YAEjC,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC;YAC1B,KAAK,IAAIA,sBAAc,CAAC,UAAU,CAAC;YAEnC,IAAI,KAAK,yBAAqB;gBAC5B,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;aAChC;YAED,IAAI,KAAK,2BAAuB;gBAC9B,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;aACvB;YAED,IAAI,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC;YACjC,OAAO,OAAO,KAAK,IAAI,EAAE;gBACvB,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;gBACvB,OAAO,GAAG,OAAO,CAAC,SAAS,CAAC;aAC7B;;YAGD,IAAI,CAAC,MAAM,IAAI,EAAE,uCAAkC,CAAC;YAEpD,SAAS,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;SAC5B;IACH,CAAC;IAED;AACA,aAAgB,WAAW,CAAwB,KAAqB;QACtE,IAAI,IAAI,CAAC,MAAM,oBAAkB;;YAE/B,IAAI,CAAC,MAAM,yBAAsB;YAEjC,KAAK,IAAIA,sBAAc,CAAC,UAAU,CAAC;YAEnC,IAAI,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC;YACjC,OAAO,OAAO,KAAK,IAAI,EAAE;gBACvB,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;gBACvB,OAAO,GAAG,OAAO,CAAC,SAAS,CAAC;aAC7B;;YAGD,IAAI,CAAC,MAAM,IAAI,EAAE,uCAAkC,CAAC;YACpD,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;SACpB;IACH,CAAC;;ICtKD;AACA,UAAa,IAAI;QA2Bf,YACkB,UAAsB,EAC/B,KAAiB;YADR,eAAU,GAAV,UAAU,CAAY;YAC/B,UAAK,GAAL,KAAK,CAAY;YA5BnB,kBAAa,GAAe,IAAI,CAAC;YACjC,kBAAa,GAAe,IAAI,CAAC;YAEjC,cAAS,GAAe,IAAI,CAAC;YAC7B,cAAS,GAAe,IAAI,CAAC;YAE7B,oBAAe,GAAY,IAAI,CAAC;YAChC,oBAAe,GAAY,IAAI,CAAC;YAEhC,gBAAW,GAAY,IAAI,CAAC;YAC5B,gBAAW,GAAY,IAAI,CAAC;YAE5B,eAAU,GAAe,IAAI,CAAC;YAC9B,gBAAW,GAAmB,CAAC,CAAC;YAChC,iBAAY,GAAe,IAAI,CAAC;YAChC,kBAAa,GAAmB,CAAC,CAAC;YAElC,2BAAsB,GAAqB,IAAI,CAAC;YAEhD,WAAM,gBAAqB;YAC3B,WAAM,GAAW,IAAI,CAAC;YAItB,WAAM,GAAY,KAAK,CAAC;SAID;QAEvB,IAAI,CAAC,QAAyB,EAAE,KAAqB;YAC1D,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE;gBACxB,MAAMO,eAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;aAC1B;YACD,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;YACzB,MAAM,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC;YACxC,IAAI,SAAS,IAAI,SAAS,CAAC,WAAW,KAAK,QAAQ,EAAE;gBACnD,IAAI,CAAC,MAAM,IAAI,sBAAkB;aAClC;iBAAM;gBACL,IAAI,CAAC,MAAM,yBAAqB;aACjC;SACF;QAEM,SAAS,CAAC,KAAa;YAC5B,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;YACpB,IAAI,CAAC,KAAK,GAAG,UAAU,CAAC;SACzB;QAEM,OAAO,CAAC,KAAqB;YAClC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;YACnB,IAAI,IAAI,CAAC,MAAM,uBAAqB;gBAClC,OAAO,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;aAC1C;YAED,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;SAC7B;KACF;IAED;AACA,UAAa,WAAW;QAOtB,YACS,IAAY,EACX,QAAmB,EACnB,SAAqB;YAFtB,SAAI,GAAJ,IAAI,CAAQ;YACX,aAAQ,GAAR,QAAQ,CAAW;YACnB,cAAS,GAAT,SAAS,CAAY;YARxB,cAAS,GAAY,KAAK,CAAC;YAE1B,cAAS,GAAW,CAAC,CAAC,CAAC;YACvB,UAAK,GAAW,IAAI,CAAC;SAMzB;QAEG,YAAY,CAAC,IAAkB,EAAE,yBAAkC;YACxE,IAAI,IAAI,EAAE;gBACR,IAAI,IAAI,KAAK,GAAG,EAAE;oBAChB,IAAI,GAAG,WAAW,CAAC,YAAY,CAAC;iBACjC;qBAAM,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;oBACnC,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;iBAC3B;gBAED,IAAI,IAAI,CAAC,SAAS,KAAK,CAAC,CAAC,IAAI,CAAC,yBAAyB,EAAE;oBACvD,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;iBACvB;aACF;YAED,IAAI,IAAI,CAAC,SAAS,GAAG,CAAC,EAAE;gBACtB,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;aACjB;iBAAM;gBACL,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;aACnB;YAED,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;SACrC;QAEM,gBAAgB,CAAC,IAAW;YACjC,OAAO,IAAI,CAAC,KAAK,KAAK,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC;SAClE;QAEM,gBAAgB,CAAC,IAAU;YAChC,IAAI,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE;gBAC/B,IAAI,CAAC,MAAM,CAACP,sBAAc,CAAC,IAAI,CAAC,CAAC;gBACjC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACtB,OAAO,IAAI,CAAC;aACb;YAED,OAAO,KAAK,CAAC;SACd;QAEM,MAAM;YACX,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;YACzB,IAAI,IAAU,CAAC;YAEf,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;gBACtC,IAAI,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;gBACnB,IAAI,CAAC,MAAM,IAAI,oBAAgB;gBAC/B,OAAO,IAAI,CAAC;aACb;YAED,IAAI,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;YACtC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YAC3B,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;gBAChB,MAAMO,eAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;aAC1B;YACD,OAAO,IAAI,CAAC;SACb;;IAhEa,wBAAY,GAAW,MAAM,CAAC;IAmE9C,SAAS,UAAU,CAAa,KAAqB;QACnD,IAAI,IAAI,CAAC,MAAM,oBAAkB;YAC/B,OAAO;SACR;QAED,KAAK,IAAIP,sBAAc,CAAC,QAAQ,CAAC;QACjC,MAAM,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC;QAChC,IAAI,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC;QACjC,OAAO,OAAO,KAAK,IAAI,EAAE;YACvB,OAAO,CAAC,KAAK,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC;YAClC,OAAO,GAAG,OAAO,CAAC,SAAS,CAAC;SAC7B;QAED,IAAI,CAAC,MAAM,oBAAkB;IAC/B,CAAC;IAED,CAAC,CAAC,KAAY;QACZ,KAAK,CAAC,KAAK,GAAG,SAAS,CAAC;QACxB,KAAK,CAAC,OAAO,GAAG,WAAW,CAAC;QAC5B,KAAK,CAAC,OAAO,GAAG,WAAW,CAAC;QAC5B,KAAK,CAAC,OAAO,GAAG,WAAW,CAAC;QAC5B,KAAK,CAAC,MAAM,GAAG,UAAU,CAAC;QAC1B,KAAK,CAAC,MAAM,GAAG,UAAU,CAAC;QAC1B,KAAK,CAAC,QAAQ,GAAG,YAAY,CAAC;IAChC,CAAC,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;;aClIH,cAAc,CAAC,YAA4C;QACzE,OAAO,MAAM,IAAI,sBAAsB,CAAC,MAAM,CAAC,YAAY,EAAE,MAAM,CAAC,CAAC;IACvE,CAAC;AAED,UAAa,sBAAsB,GAA8D;QAC/F,IAAI,EAAE,iBAAiB;QAEvB,OAAO,CAAC,IAAY;YAClB,OAAO,GAAG,IAAI,CAAC,IAAI,IAAI,IAAI,EAAE,CAAC;SAC/B;QAED,MAAM,CAAyD,IAAO;YACpE,OAAO,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC;SAC3B;QAED,MAAM,CAA0B,YAA4C,EAAE,IAAO;YACnF,MAAM,WAAW,GAAG,OAAO,YAAY,KAAK,QAAQ,GAAG,EAAE,IAAI,EAAE,YAAY,EAAE,GAAG,YAAY,CAAC;YAC7F,MAAM,IAAI,GAAG,IAAyC,CAAC;YAEvD,IAAI,CAAC,IAAI,GAAG,sBAAsB,CAAC;YACnC,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;YAC/B,IAAI,CAAC,QAAQ,GAAG,sBAAsB,CAAC;YAEvC,OAAgC,IAAI,CAAC;SACtC;KACF,CAAC;IAEF;AACA,aAAgB,sBAAsB,CAA4B,SAAqB;QACrF,MAAM,WAAW,GAAG,sBAAsB,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QAC1E,SAAS,CAAC,QAAQ,CAACK,mBAAY,CAAC,SAAS,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC,CAAC;IAChE,CAAC;AAOD,UAAa,iBAAiB,GAAGH,SAAE,CAAC,eAAe,EAAqB,CAAC,SAAS,EAAE,CAAC;AAErF,IAAA,WAAY,gBAAgB;QAC1B,uDAAqB,CAAA;QACrB,iEAAqB,CAAA;QACrB,iEAAqB,CAAA;IACvB,CAAC,EAJWoD,wBAAgB,KAAhBA,wBAAgB,QAI3B;IA6ED;AACA,aAAgB,iBAAiB,CAAmC,eAAiC;QACnG,MAAM,IAAI,GAAG,IAAI,CAAC,WAAmC,CAAC;QAEtD,eAAe,CAAC,oBAAoB,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QAEjD,IAAI,IAAI,CAAC,MAAM,uBAAqB;YAClC,IAAI,CAAC,OAAO,EAAE,CAAC;SAChB;IACH,CAAC;IAED;AACA,aAAgB,eAAe,CAAiC,eAAiC,EAAE,IAAW,EAAE,UAAoCnD,eAAQ,CAAC,WAAW;QACtK,MAAM,IAAI,GAAG,IAAI,CAAC,WAAiC,CAAC;QACpD,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;QAErC,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QACvC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,IAAI,CAAC,UAAU,GAAG,kBAAkB,CAAC,IAAI,EAAE,IAAI,EAAE,WAAW,CAAC,CAAC;QAE9D,eAAe,CAAC,oBAAoB,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QAEjD,IAAI,IAAI,CAAC,MAAM,yBAAoB;YACjC,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC;YAEhD,IAAI,MAAM,IAAI,oBAAoB,IAAI,MAAM,EAAE;gBAC5C,MAAM,QAAQ,GAAG,MAAM,CAAC,kBAAkB,CAAC,eAAe,EAAE,IAAI,CAAC,CAAC;gBAClE,QAAQ,CAAC,MAAM,CAAC,IAAI,EAAE,IAAI,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC;aAC5C;SACF;aAAM;YACL,MAAM,QAAQ,GAAG,eAAe,CAAC,kBAAkB,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;YACvE,QAAQ,CAAC,MAAM,CAAC,IAAI,EAAE,IAAI,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC;SAC5C;QAED,IAAI,IAAI,CAAC,MAAM,uBAAqB;YAClC,IAAI,CAAC,OAAO,EAAE,CAAC;SAChB;IACH,CAAC;IAED;AACA,UAAa,oBAAoB,GAAG;QAClC,IAAI,EAAE,MAA2B;KAClC,CAAC;IAEF,SAAS,kBAAkB,CACzB,cAA8B,EAC9B,IAAwB,EACxB,UAA8B;QAE9B,IAAI,UAAU,CAAC,aAAa,IAAI,UAAU,CAAC,QAAQ,EAAE;YACnD,IAAI,UAAU,CAAC,aAAa,EAAE;gBAC5B,MAAMI,eAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;aAC1B;YAED,OAAO,IAAI,kBAAkB,CAAC,cAAc,EAAE,IAAI,EAAE,UAAU,CAAC,CAAC;SACjE;QAED,IAAI,UAAU,CAAC,aAAa,EAAE;YAC5B,OAAO,IAAI,sBAAsB,CAAC,cAAc,EAAE,IAAI,CAAC,CAAC;SACzD;QAED,OAAO,IAAI,aAAa,CAAC,cAAc,EAAE,IAAI,CAAC,CAAC;IACjD,CAAC;AAYD,UAAa,gBAAgB,GAAGL,SAAE,CAAC,eAAe,EAAoB;SACnE,WAAW,CAAC,CAAC,IAAI,CAAC,CAAC,SAAS,CAACqD,uBAAe,CAAC,CAAC,CAAC;IAElD,MAAM,mBAAmB,GAAG,SAAS,CAAC;AAItC,AAAaA,2BAAe;IAD5B;IACA,MAAa,eAAe;QAM1B,YACU,SAAqB,EACrB,SAAqB,EACrB,eAAiC,EACjC,YAA2B,EAC3B,MAAyB,EACjC,iBAAsC;YAL9B,cAAS,GAAT,SAAS,CAAY;YACrB,cAAS,GAAT,SAAS,CAAY;YACrB,oBAAe,GAAf,eAAe,CAAkB;YACjC,iBAAY,GAAZ,YAAY,CAAe;YAC3B,WAAM,GAAN,MAAM,CAAmB;YAV3B,mBAAc,GAAuC,IAAI,GAAG,EAAE,CAAC;YAC/D,kBAAa,GAAsD,IAAI,GAAG,EAAE,CAAC;YAC7E,mBAAc,GAAoE,IAAI,GAAG,EAAE,CAAC;YAWlG,IAAI,CAAC,SAAS,GAAG,iBAAiB,CAAC,MAAM,CACvC,CAAC,GAAG,EAAE,IAAI;gBACR,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;gBACtB,OAAO,GAAG,CAAC;aACZ,EACD,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CACpB,CAAC;SACH;QAEM,kBAAkB,CAAC,UAA8B,EAAE,aAAkC;YAC1F,IAAI,CAAC,UAAU,EAAE;gBACf,OAAO,IAAI,CAAC;aACb;YAED,IAAI,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;YAEhD,IAAI,CAAC,KAAK,EAAE;gBACV,KAAK,GAAG,IAAI,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC;;gBAG5C,IAAI,KAAK,CAAC,aAAa,KAAK,IAAI,IAAI,aAAa,EAAE;oBACjD,aAAa,CAAC,QAAQ,CAAiB,KAAK,CAAC,aAAa,CAAC,CAAC;iBAC7D;gBAED,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;aAC5C;YAED,OAAO,KAAK,CAAC;SACd;QAEM,cAAc,CAAC,UAA0C,EAAE,aAA8B;YAC9F,IAAI,CAAC,UAAU,EAAE;gBACf,OAAO,IAAI,CAAC;aACb;YAED,IAAI,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;YAEjD,IAAI,CAAC,OAAO,EAAE;gBACZ,MAAM,WAAW,GAAG,uBAAuB,CAAC,IAAI,EAAE,UAAU,CAAC,CAAA;gBAC7D,MAAM,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CAAC,WAAW,EAAE,aAAa,CAAC,CAAC;gBACrE,OAAO,GAAG,IAAI,WAAW,CAAC,WAAW,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;gBACtE,OAAO,CAAC,YAAY,CAAC,WAAW,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;gBAC9C,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;aAC7C;YAED,OAAO,OAAO,CAAC;SAChB;QAEM,oBAAoB,CAAC,IAA+C,EAAE,QAA2C;YACtH,IAAI,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YAE1C,IAAI,CAAC,KAAK,EAAE;gBACV,KAAK,GAAG,eAAe,CAAC,MAAM,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;gBAC/C,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;aACtC;YAED,KAAK,CAAC,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;SACzC;QAEM,cAAc,CAAC,OAAuB;YAC3C,OAAO,IAAI,QAAQ,CACjB,OAAO,EACP,IAAI,CAAC,eAAe,EACpB,IAAI,CAAC,YAAY,EACjB,IAAI,CAAC,MAAM,EACX,IAAI,CACL,CAAC;SACH;QAEO,kBAAkB,CAAC,UAA8B,EAAE,aAA8B;YACvF,aAAa,GAAG,aAAa,IAAoB,IAAI,CAAC,SAAS,CAAC;YAEhE,IAAI,UAAU,IAAI,UAAU,CAAC,QAAQ,EAAE;gBACrC,IAAI,UAAU,CAAC,KAAK,CAAC,QAAQ,EAAE;oBAC7B,MAAM,YAAY,GAAG,UAAU,CAAC,KAAK,CAAC,QAAQ,IAAI,mBAAmB,CAAC;oBACtE,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;oBAE9C,IAAI,CAAC,QAAQ,EAAE;wBACb,MAAMhD,eAAQ,CAAC,KAAK,CAAC,EAAE,EAAE,YAAY,CAAC,CAAC;qBACxC;oBAED,UAAU,GAAG,QAAQ,CAAC,OAAO,CAAsB,UAAU,EAAE,IAAI,2BAA2B,CAAiB,aAAa,CAAC,EAAE+C,wBAAgB,CAAC,SAAS,CAAC,CAAC;iBAC5J;gBAED,OAAO,IAAI,gBAAgB,CAAC,IAAI,EAAE,aAAa,EAAE,UAAU,CAAC,CAAC;aAC9D;YAED,OAAO,cAAc,CAAC;SACvB;KACF,CAAA;AAvGYC,2BAAe;QAF3BjD,aAAM,CAACkD,iBAAU,EAAE,UAAU,EAAE,gBAAgB,EAAE,aAAa,EAAE,iBAAiB,EAAEC,UAAG,CAAC,iBAAiB,CAAC,CAAC;;OAE9FF,uBAAe,CAuG3B;IACD,MAAMG,sBAAoB,GAAG,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC;IAEjD;AACA,UAAa,kBAAkB;QAG7B,YACE,cAA8B,EACvB,IAAwB,EAC/B,UAA8B;YADvB,SAAI,GAAJ,IAAI,CAAoB;YAG/B,IAAI,CAAC,UAAU,GAAG,GAAG,CAAC,YAAY,CAAC,IAAI,EAAE,UAAU,CAAC,aAAa,IAAI,oBAAoB,CAAC,CAAC;YAC3F,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;YACrC,IAAI,CAAC,UAAU,CAAC,cAAc,GAAG,cAAc,CAAC;SACjD;QAED,IAAI,QAAQ;YACV,OAAO,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC;SAC7B;QAEM,yBAAyB,CAAC,QAAoB;YACnD,GAAG,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,EAAEA,sBAAoB,CAAC,CAAC;SACnE;QAEM,0BAA0B,CAAC,yBAAgC;YAChE,OAAO,IAAI,CAAC,UAAU,CAAC;SACxB;QAEM,OAAO,CAAC,KAAoB;YACjC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAC1B,IAAI,CAAC,OAAO,GAAGvD,eAAQ,CAAC,IAAI,CAAC;SAC9B;QAEM,IAAI,CAAC,KAAoB;;;;SAI/B;KACF;IAED;AACA,UAAa,sBAAsB;QAIjC,YAAoB,cAA8B,EAAE,IAAwB;YAAxD,mBAAc,GAAd,cAAc,CAAgB;YAChD,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE;gBAC1B,IAAI,CAAC,UAAU,GAAGA,eAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;aACrD;iBAAM;gBACL,IAAI,CAAC,UAAU,GAAGA,eAAQ,CAAC,UAAU,CAAC;aACvC;YAED,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC;YAC9C,IAAI,CAAC,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;SAC3C;QAED,IAAI,QAAQ;YACV,OAAO,IAAI,CAAC,UAAU,CAAC;SACxB;QAEM,yBAAyB,CAAC,QAAoB;;SAEpD;QAEM,0BAA0B,CAAC,yBAAgC;YAChE,IAAI,CAAC,yBAAyB,EAAE;gBAC9B,MAAMI,eAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;aAC1B;YAED,OAAO,yBAAyB,CAAC;SAClC;QAEM,OAAO,CAAC,KAAoB;YACjC,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,yBAAqB;gBACjD,IAAI,CAAC,cAAc,CAAC,MAAM,IAAI,sBAAkB;gBAChD,KAAK,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aAC/B;SACF;QAEM,IAAI,CAAC,KAAoB;YAC9B,IAAI,CAAC,cAAc,CAAC,MAAM,yBAAqB;YAC/C,KAAK,CAAC,MAAM,EAAE,CAAC;SAChB;KACF;IAED;AACA,UAAa,aAAa;QAExB,YAAY,cAA8B,EAAS,IAAwB;YAAxB,SAAI,GAAJ,IAAI,CAAoB;YACzE,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;YACrC,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;SAC7C;QAED,IAAI,QAAQ;YACV,OAAOJ,eAAQ,CAAC,UAAU,CAAC;SAC5B;QAEM,yBAAyB,CAAC,QAAoB;;SAEpD;QAEM,0BAA0B,CAAC,yBAAgC;YAChE,OAAO,yBAAyB,IAAI,IAAI,CAAC,IAAI,CAAC;SAC/C;QAEM,OAAO,CAAC,KAAoB;YACjC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAC1B,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;gBACnB,IAAI,CAAC,OAAO,GAAGA,eAAQ,CAAC,IAAI,CAAC;aAC9B;SACF;QAEM,IAAI,CAAC,KAAoB;;;YAG9B,IAAI,IAAI,CAAC,SAAS,EAAE;;gBAElB,KAAK,CAAC,MAAM,EAAE,CAAC;aAChB;SACF;KACF;IAED;AACA,UAAa,eAAe;QAG1B,iBAAwB;QAEjB,OAAO,MAAM,CAAC,SAAoD,EAAE,QAA2C;YACpH,MAAM,QAAQ,GAAG,IAAI,eAAe,EAAE,CAAC;YAEvC,QAAQ,CAAC,SAAS,GAAG,SAAS,CAAC,WAAW,CAAC,SAAS,CAAC;YAErD,OAAO,QAAQ,CAAC;SACjB;QAEM,OAAO,CAAC,QAA2C,EAAE,SAAqB;YAC/E,QAAQ,CAAC,UAAU,GAAG,SAAS,CAAC;YAChC,IAAI,YAAY,IAAI,QAAQ,EAAE;gBAC5B,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;aAC1C;iBAAM;gBACL,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;aAC5B;SACF;QAEO,cAAc,CAAC,SAAqB,EAAE,QAAwB;YACpE,MAAM,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;YAE7C,SAAS,CAAC,SAAS,GAAG,IAAIwD,wBAAgB,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;YAEhE,OAAO,CAAC,cAAc,CAAC,QAAQ,EAAE,WAAW,EAAE;gBAC5C,UAAU,EAAE,KAAK;gBACjB,GAAG,EAAE;oBACH,OAAO,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,QAAQ,EAAE,CAAC;iBAC7C;aACF,CAAC,CAAC;SACJ;QAEO,WAAW,CAAC,QAA2C;YAC7D,MAAM,SAAS,GAAG,EAAE,CAAC;YACrB,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;YACjC,MAAM,eAAe,GAAG,MAAM,CAAC,mBAAmB,CAAC,SAAS,CAAC,CAAC;YAE9D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,eAAe,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBACxD,MAAM,IAAI,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC;gBAEhC,SAAS,CAAC,IAAI,CAAC,GAAG,IAAItC,gBAAQ,CAC5B,QAAQ,EACR,IAAI,EACJ,SAAS,CAAC,IAAI,CAAC,CAAC,QAAQ,CACzB,CAAC;gBAEF,kBAAkB,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;aACpC;YAED,OAAO,CAAC,cAAc,CAAC,QAAQ,EAAE,YAAY,EAAE;gBAC7C,UAAU,EAAE,KAAK;gBACjB,KAAK,EAAE,SAAS;aACjB,CAAC,CAAC;YAEH,OAAO,SAAS,CAAC;SAClB;KACF;IAED,SAAS,kBAAkB,CAAC,QAA2C,EAAE,IAAY;QACnF,OAAO,CAAC,cAAc,CAAC,QAAQ,EAAE,IAAI,EAAE;YACrC,UAAU,EAAE,IAAI;YAChB,GAAG,EAAE,cAAsB,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,QAAQ,EAAE,CAAC,EAAE;YACrE,GAAG,EAAE,UAAS,KAAc,IAAU,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,KAAK,EAAErB,sBAAc,CAAC,oBAAoB,CAAC,CAAC,EAAE;SACpH,CAAC,CAAC;IACL,CAAC;IAOD;AAEA,AAAa2D,4BAAgB,GAA7B,MAAa,gBAAgB;QAM3B,YACU,SAAqB,EACrB,aAA6D;YAD7D,cAAS,GAAT,SAAS,CAAY;YACrB,kBAAa,GAAb,aAAa,CAAgD;YAPhE,eAAU,GAAY,KAAK,CAAC;YAE3B,aAAQ,GAAqB,IAAI,CAAC;YAClC,cAAS,GAAY,KAAK,CAAC;SAK9B;QAEE,QAAQ;YACb,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;gBACnB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;gBACtB,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,yBAAyB,CAAC,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC;gBACxF,IAAI,CAAC,QAAQ,GAAG,YAAY,CAAC,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;aACtE;YAED,OAAO,IAAI,CAAC,QAAQ,CAAC;SACtB;QAEM,QAAQ,CAAC,QAAiB,KAA4B;QAEtD,KAAK,CAA6C,KAAqB;YAC5E,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,QAAQ,EAAE,SAAS,EAAE,KAAK,GAAG3D,sBAAc,CAAC,oBAAoB,CAAC,CAAC;YAC5F,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;SACzB;QAEM,SAAS,CAA6C,UAA+B;YAC1F,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;SAChC;QAEM,WAAW,CAA6C,UAA+B;YAC5F,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;SACnC;QAEO,iBAAiB;YACvB,IAAI,CAAC,QAAQ,GAAG,YAAY,CAAC,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;YAErE,IAAI,kBAAkB,IAAI,IAAI,CAAC,aAAa,EAAE;gBAC5C,IAAI,CAAC,aAAa,CAAC,gBAAgB,EAAE,CAAC;aACvC;YAED,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;YAClC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;SACxB;KACF,CAAA;AA9CY2D,4BAAgB;QAD5B,oBAAoB,CAAC1D,oBAAY,CAAC,QAAQ,CAAC;OAC/B0D,wBAAgB,CA8C5B;IAED;AACA,aAAgB,YAAY,CAAC,KAAuB;QAClD,MAAM,UAAU,GAAqB,EAAE,CAAC;QAExC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;YAC9C,MAAM,OAAO,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACzB,MAAM,SAAS,GAAG,qBAAqB,CAAC,OAAO,CAAC,CAAC;YAEjD,IAAI,SAAS,KAAK,IAAI,EAAE;gBACtB,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;aAC5B;SACF;QAED,OAAO,UAAU,CAAC;IACpB,CAAC;IAED;AACA,UAAa,2BAA2B;QACtC,YAAoB,OAAuB;YAAvB,YAAO,GAAP,OAAO,CAAgB;SAAI;QAExC,IAAI,CAAU,IAA4B,EAAE,IAAY;YAC7D,MAAM,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YAC/B,MAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,CAAU,GAAG,EAAE,KAAK,CAAC,CAAC;YAE/D,IAAI,QAAQ,KAAK,IAAI,IAAI,QAAQ,CAAC,UAAU,EAAE;gBAC5C,MAAM,OAAO,GAAG,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBAElD,IAAI,OAAO,KAAK,IAAI,EAAE;oBACpB,OAAQ,OAAO,CAAC,IAA+B,CAAC,WAAW,IAAI,IAAI,CAAC;iBACrE;aACF;YAED,OAAO,IAAI,CAAC;SACb;QAEM,MAAM,CAAgD,IAAmC,EAAE,IAAY;YAC5G,MAAM,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YAC/B,IAAI,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE;gBAChC,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAM,GAAG,CAAC,IAAI,IAAI,CAAC;aAC3C;YACD,OAAO,IAAI,CAAC;SACb;KACF;IAYD;IACA;IACA;IACA;IACA;IACA;IACA;AACA,UAAa,gBAAgB;QAI3B,YAAY,eAAiC,EAAE,mBAAmC,EAAU,kBAAsC;YAAtC,uBAAkB,GAAlB,kBAAkB,CAAoB;YAChI,IAAI,CAAC,OAAO,GAAG,mBAAmB,CAAC,SAAS,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;YAC1E,IAAI,CAAC,aAAa,GAAG,mBAAmB,CAAC,eAAe,EAAE,mBAAmB,EAAE,kBAAkB,CAAC,YAAY,CAAC,CAAC;SACjH;QAEM,MAAM,CAAC,UAAuB,EAAE,IAAY,EAAE,KAA+B;YAClF,MAAM,KAAK,GAA2B,UAAW,CAAC,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,kBAAkB,EAAE,CAAC;YACrE,UAAW,CAAC,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC;YAClE,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,UAAU,EAAE,KAAK,CAAC,WAAW,EAAE,EAAE,IAAI,CAAC,kBAAkB,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;SAClG;KACF;IAED;IACA;AACA,UAAa,cAAc,GAAc;QACvC,aAAa,EAAE,IAAI;QACnB,MAAM,CAAC,UAAuB;YACJ,UAAW,CAAC,MAAM,GAAG,YAAY,CAAC,KAAK,CAAC;YACxC,UAAW,CAAC,QAAQ,GAAG,IAAI,CAAC;SACrD;KACF,CAAC;AAMF,aAAgB,mBAAmB,CAAC,eAAiC,EAAE,mBAAmC,EAAE,YAAiC;QAC3I,MAAM,OAAO,GAAmB,mBAAmB,CAAC,WAAW,EAAE,CAAC;QAClE,MAAM,kBAAkB,GAAG,IAAI,gBAAgB,EAAE,CAAC;QAClD,MAAM,eAAe,GAAG,IAAI,gBAAgB,EAAE,CAAC;QAC/C,MAAM,mBAAmB,GAAG,IAAI,gBAAgB,EAAwB,CAAC;QACzE,MAAM,eAAe,GAAG,IAAI,mBAAmB,CAAC,eAAe,CAAC,CAAC;QACjE,MAAM,sBAAsB,GAAG,IAAI,gBAAgB,EAAmB,CAAC;QACvE,MAAM,QAAQ,GAAG,eAAe,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;QAEzD,GAAG,CAAC,uBAAuB,CAAC,OAAO,EAAE,eAAe,CAAC,CAAC;QAEtD,OAAO,CAAC,gBAAgB,CAAC,YAAY,EAAE,eAAe,CAAC,CAAC;QACxD,OAAO,CAAC,gBAAgB,CAAC,WAAW,EAAE,kBAAkB,CAAC,CAAC;QAC1D,OAAO,CAAC,gBAAgB,CAAC,oBAAoB,EAAE,mBAAmB,CAAC,CAAC;QACpE,OAAO,CAAC,gBAAgB,CAAC,eAAe,EAAE,sBAAsB,CAAC,CAAC;QAElE,IAAI,YAAY,EAAE;YAChB,OAAO,CAAC,QAAQ,CAAC,GAAG,YAAY,CAAC,CAAC;SACnC;QAED,OAAO,CAAC,MAAM,GAAG,UAAS,UAAuB,EAAE,OAAyB,EAAE,kBAAsC,EAAE,IAAY,EAAE,KAA+B;YACjK,QAAQ,CAAC,MAAM,CAAC,UAAU,EAAE,OAAO,EAAE,kBAAkB,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;SACvE,CAAC;QAEF,OAAO,CAAC,uBAAuB,GAAG,UAAS,UAAuB,EAAE,MAAa,EAAE,WAAiC,EAAE,OAAsB,EAAE,KAA+B,EAAE,QAA0B;YACvM,kBAAkB,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;YACvC,eAAe,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;YAChC,mBAAmB,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;YAEzC,IAAI,OAAO,EAAE;gBACX,eAAe,CAAC,OAAO,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;aACzC;YAED,IAAI,QAAQ,EAAE;gBACZ,sBAAsB,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;aAC1C;YAED,OAAO,OAAO,CAAC;SAChB,CAAC;QAEF,OAAO,CAAC,OAAO,GAAG;YAChB,eAAe,CAAC,OAAO,EAAE,CAAC;YAC1B,kBAAkB,CAAC,OAAO,EAAE,CAAC;YAC7B,mBAAmB,CAAC,OAAO,EAAE,CAAC;YAC9B,eAAe,CAAC,OAAO,EAAE,CAAC;YAC1B,sBAAsB,CAAC,OAAO,EAAE,CAAC;SAClC,CAAC;QAEF,OAAO,OAAO,CAAC;IACjB,CAAC;IAED;AACA,UAAa,gBAAgB;QAA7B;YACU,aAAQ,GAAM,IAAI,CAAC;SAgB5B;QAdQ,OAAO,CAAC,QAAW;YACxB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;SAC1B;QAEM,OAAO,CAAC,OAAmB,EAAE,SAAqB;YACvD,IAAI,IAAI,CAAC,QAAQ,KAAK,SAAS,EAAE;gBAC/B,MAAMpD,eAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;aAC1B;YACD,OAAO,IAAI,CAAC,QAAQ,CAAC;SACtB;QAEM,OAAO;YACZ,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;SACtB;KACF;IAED;AACA,UAAa,mBAAmB;QAI9B,YAAoB,eAAiC;YAAjC,oBAAe,GAAf,eAAe,CAAkB;SAAI;QAElD,OAAO,CAAC,OAAqB,EAAE,KAA8B;YAClE,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;YACvB,IAAI,CAAC,YAAY,GAAG,KAAK,IAAIJ,eAAQ,CAAC,WAAW,CAAC;SACnD;QAEM,OAAO,CAAC,OAAmB,EAAE,SAAyB;YAC3D,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;YAC7B,IAAI,OAAO,KAAK,SAAS,EAAE;gBACzB,MAAMI,eAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;aAC1B;YACD,IAAI,CAAC,OAAO,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE;gBACzC,MAAMA,eAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;aAC1B;YACD,MAAM,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YAC9C,IAAI,KAAK,EAAE;gBACT,OAAO,IAAI,CAAC,eAAe,CAAC,cAAc,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;aAC9D;YAED,OAAO,IAAI,CAAC,OAAO,CAAC;SACrB;QAEM,OAAO;YACZ,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;YACpB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;SAC1B;KACF;AAED,aAAgB,WAAW,CAAC,UAAsB,EAAE,QAAoB;QACtE,QAAQ,CAAC,SAAS,GAAG,UAAU,CAAC,aAAa,CAAC;QAC9C,QAAQ,CAAC,SAAS,GAAG,IAAI,CAAC;QAC1B,IAAI,UAAU,CAAC,aAAa,KAAK,IAAI,EAAE;YACrC,UAAU,CAAC,aAAa,GAAG,QAAQ,CAAC;SACrC;aAAM;YACL,UAAU,CAAC,aAAa,CAAC,SAAS,GAAG,QAAQ,CAAC;SAC/C;QACD,UAAU,CAAC,aAAa,GAAG,QAAQ,CAAC;IACtC,CAAC;AAED,aAAgB,aAAa,CAAC,UAAwB,EAAE,UAAmB;QACzE,UAAU,CAAC,WAAW,GAAG,UAAU,CAAC,eAAe,CAAC;QACpD,UAAU,CAAC,WAAW,GAAG,IAAI,CAAC;QAC9B,IAAI,UAAU,CAAC,eAAe,KAAK,IAAI,EAAE;YACvC,UAAU,CAAC,eAAe,GAAG,UAAU,CAAC;SACzC;aAAM;YACL,UAAU,CAAC,eAAe,CAAC,WAAW,GAAG,UAAU,CAAC;SACrD;QACD,UAAU,CAAC,eAAe,GAAG,UAAU,CAAC;IAC1C,CAAC;IAOD;IACA;IAEA;AACA,UAAa,QAAQ;QACnB,YACU,OAAuB,EACvB,eAAiC,EACjC,YAA2B,EAC3B,MAAyB,EACzB,eAAiC;YAJjC,YAAO,GAAP,OAAO,CAAgB;YACvB,oBAAe,GAAf,eAAe,CAAkB;YACjC,iBAAY,GAAZ,YAAY,CAAe;YAC3B,WAAM,GAAN,MAAM,CAAmB;YACzB,oBAAe,GAAf,eAAe,CAAkB;SACtC;QAEE,MAAM,CAAC,UAAuB,EAAE,OAAyB,EAAE,UAA8B,EAAE,IAAY,EAAE,KAA+B;YAC7I,MAAM,kBAAkB,GAAG,UAAU,CAAC,YAAY,CAAC;YAEnD,IAAI,OAAO,CAAC,MAAM,KAAK,kBAAkB,CAAC,MAAM,EAAE;gBAChD,IAAI,OAAO,CAAC,MAAM,GAAG,kBAAkB,CAAC,MAAM,EAAE;oBAC9C,MAAMA,eAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;iBAC1B;qBAAM;oBACL,MAAMA,eAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;iBAC1B;aACF;YACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBAChD,MAAM,YAAY,GAAG,kBAAkB,CAAC,CAAC,CAAC,CAAC;gBAC3C,MAAM,MAAM,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;gBAE1B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;oBACrD,MAAM,OAAO,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;oBAC/B,IAAY,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,UAAU,EAAE,MAAM,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;iBACjE;aACF;YAED,IAAI,IAAI,EAAE;gBACR,MAAM,qBAAqB,GAAG,UAAU,CAAC,UAAU,CAAC;gBAEpD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,qBAAqB,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;oBAC9D,MAAM,OAAO,GAAG,qBAAqB,CAAC,CAAC,CAAC,CAAC;oBACxC,IAAY,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,UAAU,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;iBAC/D;aACF;SACF;QAEM,sBAAsB,CAAC,UAAuB,EAAE,MAAa,EAAE,WAAkD,EAAE,SAAyB;YACjJ,MAAM,iBAAiB,GAAG,WAAW,CAAC,YAAY,CAAC;YAEnD,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,eAAe,EAAE,MAAM,EAAE,WAAW,CAAC,CAAC;YAE9D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,iBAAiB,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBAC1D,MAAM,OAAO,GAAG,iBAAiB,CAAC,CAAC,CAAC,CAAC;gBACrC,MAAM,WAAW,GAAG,OAAO,CAAC,IAAI,CAAC;gBAEhC,IAAY,CAAC,WAAW,CAAC,CAAC,UAAU,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;aAC5D;YAED,WAAW,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;YACnC,aAAa,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;SACtC;QAEM,uBAAqC,CAAC,UAAuB,EAAE,MAAW,EAAE,WAA+C;YAChI,MAAM,IAAI,GAAG,MAAM,CAAC,WAAW,CAAC;YAChC,GAAG,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC;YAC/B,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;YACnB,MAAM,KAAK,GAAG,WAAW,CAAC,IAAW,CAAC;YACtC,MAAM,IAAI,IAAI,KAAK,CAAC,KAAK,GAAG,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,2BAA4B,CAAkB,CAAC;YAC1G,IAAI,IAAI,CAAC,OAAO,EAAE;gBAChB,WAAW,CAAC,UAAU,EAAE,IAAI,yBAAyB,CAAC,IAAI,CAAC,eAAe,EAAE,IAAI,EAAE,IAAI,EAAE,aAAa,EAAEO,mBAAW,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;aAC3I;iBAAM;gBACL,WAAW,CAAC,UAAU,EAAE,IAAIsC,4BAAoB,CAAC,IAAI,CAAC,eAAe,EAAE,IAAI,EAAE,IAAI,EAAE,aAAa,EAAEtC,mBAAW,CAAC,MAAM,EAAE,IAAI,CAAC,eAAe,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC;aAClK;SACF;QAEM,yBAAuC,CAAC,UAAuB,EAAE,MAAW,EAAE,WAAiD;YACpI,MAAM,KAAK,GAAG,WAAW,CAAC,IAAW,CAAC;YACtC,MAAM,IAAI,IAAI,KAAK,CAAC,KAAK,GAAG,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,2BAA4B,CAAkB,CAAC;YAC1G,IAAI,IAAI,CAAC,OAAO,EAAE;gBAChB,WAAW,CAAC,UAAU,EAAE,IAAI,yBAAyB,CAAC,IAAI,CAAC,eAAe,EAAE,IAAI,EAAE,MAAM,EAAE,WAAW,CAAC,EAAE,EAAEA,mBAAW,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;aAC9I;iBAAM;gBACL,WAAW,CAAC,UAAU,EAAE,IAAIsC,4BAAoB,CAAC,IAAI,CAAC,eAAe,EAAE,IAAI,EAAE,MAAM,EAAE,WAAW,CAAC,EAAE,EAAEtC,mBAAW,CAAC,MAAM,EAAE,IAAI,CAAC,eAAe,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC;aACrK;SACF;QAEM,2BAAyC,CAAC,UAAuB,EAAE,MAAW,EAAE,WAAmD;YACxI,MAAM,KAAK,GAAG,WAAW,CAAC,IAAW,CAAC;YACtC,WAAW,CAAC,UAAU,EAAE,IAAIY,eAAO,CAAC,KAAK,CAAC,KAAK,GAAG,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,EAAE,6BAAgC,WAAW,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,WAAW,CAAC,EAAE,EAAE,WAAW,CAAC,IAAI,EAAE,IAAI,CAAC,eAAe,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;SACtN;QAEM,2BAAyC,CAAC,UAAuB,EAAE,MAAW,EAAE,WAAmD;YACxI,MAAM,KAAK,GAAG,WAAW,CAAC,IAAW,CAAC;YACtC,WAAW,CAAC,UAAU,EAAE,IAAIA,eAAO,CAAC,KAAK,CAAC,KAAK,GAAG,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,uBAAyB,EAAE,MAAM,EAAE,WAAW,CAAC,EAAE,EAAEZ,mBAAW,CAAC,MAAM,EAAE,IAAI,CAAC,eAAe,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;SAC9L;QAEM,2BAAyC,CAAC,UAAuB,EAAE,MAAW,EAAE,WAAmD;YACxI,MAAM,KAAK,GAAG,WAAW,CAAC,IAAW,CAAC;YACtC,WAAW,CAAC,UAAU,EAAE,IAAI,QAAQ,CAAC,WAAW,CAAC,EAAE,EAAE,WAAW,CAAC,QAAQ,EAAE,KAAK,CAAC,KAAK,GAAG,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,EAAE,2BAA8B,WAAW,CAAC,QAAQ,mCAAuC,CAAC,EAAE,MAAM,EAAE,WAAW,CAAC,cAAc,EAAE,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;SAC7R;QAEM,uBAAqC,CAAC,UAAuB,EAAE,MAAW,EAAE,WAA+C;YAChI,MAAM,KAAK,GAAG,WAAW,CAAC,IAAW,CAAC;YACtC,WAAW,CAAC,UAAU,EAAE,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,wBAA0B,EAAE,MAAM,EAAE,WAAW,CAAC,EAAE,EAAE,IAAI,CAAC,eAAe,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;SACxK;QAEM,sBAAoC,CAAC,UAAuB,EAAE,MAAW,EAAE,WAA8C;YAC9H,MAAM,KAAK,GAAG,WAAW,CAAC,IAAW,CAAC;YACtC,WAAW,CAAC,UAAU,EAAE,IAAI,GAAG,CAAC,KAAK,CAAC,KAAK,GAAG,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,mBAAoB,EAAE,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;SAC3H;QAEM,gCAA8C,CAAC,UAAuB,EAAE,MAAW,EAAE,WAAwD;YAClJ,MAAM,KAAK,GAAG,WAAW,CAAC,IAAW,CAAC;YACtC,WAAW,CAAC,UAAU,EAAE,IAAIY,eAAO,CAAC,KAAK,CAAC,KAAK,GAAG,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,EAAE,6BAAgCZ,mBAAW,CAAC,MAAM,CAAC,EAAQ,MAAO,CAAC,KAAK,EAAE,WAAW,CAAC,EAAE,EAAEA,mBAAW,CAAC,MAAM,EAAE,IAAI,CAAC,eAAe,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;SACvO;QAEM,uBAAqC,CAAC,UAAuB,EAAE,MAAW,EAAE,WAA+C;YAChI,MAAM,CAAC,WAAW,CAAC,EAAE,CAAC,GAAG,WAAW,CAAC,KAAK,CAAC;SAC5C;QAEM,wBAAsC,CAAC,UAAuB,EAAE,MAAW,EAAE,WAAgD;YAClI,GAAG,CAAC,YAAY,CAAC,MAAM,EAAE,WAAW,CAAC,EAAE,EAAE,WAAW,CAAC,KAAK,CAAC,CAAC;SAC7D;QAEM,0BAAwC,CAAC,UAAuB,EAAE,MAAW,EAAE,WAAkD;YACtI,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;YAC7B,MAAM,SAAS,GAAG,OAAO,CAAC,uBAAuB,CAAC,UAAU,EAAE,MAAM,EAAE,WAAW,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;YAC7G,MAAM,SAAS,GAAG,OAAO,CAAC,GAAG,CAAiB,gBAAgB,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC;YAEjF,IAAI,CAAC,sBAAsB,CAAC,UAAU,EAAE,MAAM,EAAE,WAAW,EAAE,SAAS,CAAC,CAAC;YACxE,SAAS,CAAC,OAAO,EAAE,CAAC;SACrB;QAEM,4BAA0C,CAAC,UAAuB,EAAE,MAAW,EAAE,WAAoD;YAC1I,MAAM,iBAAiB,GAAG,WAAW,CAAC,YAAY,CAAC;YACnD,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;YAE7B,MAAM,SAAS,GAAG,OAAO,CAAC,uBAAuB,CAAC,UAAU,EAAE,MAAM,EAAE,WAAW,CAAC,CAAC;YACnF,MAAM,SAAS,GAAG,OAAO,CAAC,GAAG,CAAmB,kBAAkB,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC;YACrF,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;YAEzC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,iBAAiB,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBAC1D,MAAM,OAAO,GAAG,iBAAiB,CAAC,CAAC,CAAC,CAAC;gBACpC,IAAY,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,UAAU,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;aAC7D;YAED,WAAW,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;YACnC,aAAa,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;YAErC,SAAS,CAAC,OAAO,EAAE,CAAC;SACrB;QAEM,qCAAmD,CAAC,UAAuB,EAAE,MAAW,EAAE,WAAkD,EAAE,KAA+B;YAClL,MAAM,iBAAiB,GAAG,WAAW,CAAC,YAAY,CAAC;YACnD,MAAM,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC,cAAc,CAAC,WAAW,CAAC,GAAG,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;YACnF,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;YAC7B,MAAM,SAAS,GAAG,OAAO,CAAC,uBAAuB,CAAC,UAAU,EAAE,MAAM,EAAE,WAAW,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,CAAC,uBAAuB,CAAC,MAAM,CAAC,EAAE,KAAK,CAAC,CAAC;YAE/I,MAAM,SAAS,GAAG,OAAO,CAAC,GAAG,CAAmB,kBAAkB,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC;YACrF,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;YAEzC,IAAI,WAAW,CAAC,IAAI,EAAE;gBACnB,SAAiB,CAAC,IAAI,CAAC,UAAU,CAAC,eAAe,CAAC,CAAC;aACrD;YAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,iBAAiB,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBAC1D,MAAM,OAAO,GAAG,iBAAiB,CAAC,CAAC,CAAC,CAAC;gBACpC,IAAY,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,UAAU,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;aAC7D;YAED,WAAW,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;YACnC,aAAa,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;YAErC,SAAS,CAAC,OAAO,EAAE,CAAC;SACrB;QAEM,0BAAwC,CAAC,UAAuB,EAAE,MAAW,EAAE,WAAkD;YACtI,MAAM,YAAY,GAAG,WAAW,CAAC,IAAI,CAAC;YACtC,IAAI,IAAI,CAAC,YAAY,CAAC,KAAK,SAAS,EAAE;gBACpC,MAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAkB,sBAAsB,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC,CAAC;gBACjG,IAAI,QAAQ,KAAK,IAAI,IAAI,QAAQ,KAAK,SAAS,EAAE;oBAC/C,MAAM,IAAI,KAAK,CAAC,2BAA2B,YAAY,GAAG,CAAC,CAAC;iBAC7D;gBACD,IAAI,CAAC,YAAY,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;aACrD;YACD,IAAI,CAAC,YAAY,CAAC,CAAC,UAAU,EAAE,MAAM,EAAE,WAAW,CAAC,CAAC;SACrD;QAEM,sBAAoC,CAAC,UAAuB,EAAE,MAAW,EAAE,WAA8C;YAC9H,MAAM,CAAC,MAAM,EAAE,CAAC;YAChB,MAAM,iBAAiB,GAAG,WAAW,CAAC,YAAY,CAAC;YACnD,MAAM,WAAW,GAAG,WAAW,CAAC,WAAW,CAAC;YAC5C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,iBAAiB,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBAC1D,MAAM,gBAAgB,GAAG,iBAAiB,CAAC,CAAC,CAAC,CAAC;gBAC9C,MAAM,KAAK,GAAQ,gBAAgB,CAAC,IAAI,CAAC;gBACzC,WAAW,CAAC,UAAU,EAAE,IAAIuC,kBAAU,CACpC,KAAK,CAAC,KAAK,GAAG,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,6BAAgC,EAC7E,gBAAgB,CAAC,EAAE,EACnB,IAAI,CAAC,eAAe,EACpB,IAAI,CAAC,OAAO,EACZ,WAAW,CACZ,CAAC,CAAC;aACJ;SACF;KACF;;IC1+BD;;;AAGA,aAAgB,aAAa,CAAC,YAA0C;QACtE,OAAO,MAAM,IAAI,qBAAqB,CAAC,MAAM,CAAC,YAAY,EAAE,MAAM,CAAC,CAAC;IACtE,CAAC;AAYD,aAAgB,YAAY,CAA0B,eAA4E;QAChI,MAAM,OAAO,GAAG,OAAO,eAAe,KAAK,UAAU,IAAI,CAAC,eAAe;cACrE,oBAAoB;cACpB,eAAoD,CAAC;QAEzD,SAAS,qBAAqB,CAAC,MAA4B;YACzD,MAAM,CAAC,aAAa,GAAG,OAAO,CAAC;YAC/B,OAAO,MAAM,CAAC;SACf;QAED,OAAO,OAAO,eAAe,KAAK,UAAU,GAAG,qBAAqB,CAAC,eAAe,CAAC,GAAG,qBAAqB,CAAC;IAChH,CAAC;IAID,SAAS,sBAAsB,CAA0B,MAA4B;QACnF,MAAM,CAAC,aAAa,GAAG,IAAI,CAAC;QAC5B,OAAO,MAAM,CAAC;IAChB,CAAC;AAUD,aAAgB,aAAa,CAA0B,MAA6B;QAClF,OAAO,MAAM,KAAK,SAAS,GAAG,sBAAsB,GAAG,sBAAsB,CAAI,MAAM,CAAC,CAAC;IAC3F,CAAC;AAED,UAAa,qBAAqB,GAA2B;QAC3D,IAAI,EAAE,iBAAiB;QAEvB,OAAO,EAAE,gBAAgB;QAEzB,MAAM,CAAwD,IAAO;YACnE,OAAO,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC;SAC3B;QAED,WAAW,EAAuD,qBAAqB;QAEvF,MAAM,CAA0B,YAA0C,EAAE,OAAU,IAAI;YACxF,IAAI,CAAC,YAAY,EAAE;gBACjB,MAAM9C,eAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;aAC1B;YACD,MAAM,IAAI,IAAI,IAAI,KAAK,IAAI,GAAG,MAAM,eAAe;aAAoB,GAAG,IAAI,CAAqC,CAAC;YACpH,MAAM,WAAW,GAAG,uBAAuB,CAA8B,IAAI,EAAE,YAAY,CAAC,CAAC;YAC7F,MAAM,KAAK,GAA6B,IAAI,CAAC,SAAS,CAAC;YAEvD,IAAI,CAAC,IAAI,GAAG,qBAAqB,CAAC;YAClC,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;YAC/B,IAAI,CAAC,QAAQ,GAAG,eAAe,CAAC;YAEhC,KAAK,CAAC,QAAQ,GAAG,eAAe,CAAC;YACjC,KAAK,CAAC,KAAK,GAAG,YAAY,CAAC;YAC3B,KAAK,CAAC,OAAO,GAAG,cAAc,CAAC;YAC/B,KAAK,CAAC,OAAO,GAAG,cAAc,CAAC;YAC/B,KAAK,CAAC,OAAO,GAAG,cAAc,CAAC;YAC/B,KAAK,CAAC,MAAM,GAAG,aAAa,CAAC;YAE7B,KAAK,CAAC,SAAS,GAAG,IAAI,CAAC;YACvB,KAAK,CAAC,SAAS,GAAG,IAAI,CAAC;YACvB,KAAK,CAAC,WAAW,GAAG,IAAI,CAAC;YACzB,KAAK,CAAC,WAAW,GAAG,IAAI,CAAC;YAEzB,KAAK,CAAC,sBAAsB,GAAG,IAAI,CAAC;YAEpC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC;YACpB,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;YACjB,KAAK,CAAC,MAAM,wBAAoB;YAEhC,KAAK,CAAC,aAAa,GAAG,IAAI,CAAC;YAC3B,KAAK,CAAC,aAAa,GAAG,IAAI,CAAC;YAC3B,KAAK,CAAC,eAAe,GAAG,IAAI,CAAC;YAC7B,KAAK,CAAC,eAAe,GAAG,IAAI,CAAC;YAE7B,KAAK,CAAC,MAAM,GAAG,aAAa,CAAC;YAC7B,KAAK,CAAC,QAAQ,GAAG,eAAe,CAAC;YAEjC,KAAK,CAAC,UAAU,GAAG,IAAI,CAAC;YACxB,KAAK,CAAC,YAAY,GAAG,IAAI,CAAC;YAE1B,KAAK,CAAC,UAAU,GAAG,IAAI,CAAC;YAExB,IAAI,OAAO,IAAI,KAAK,EAAE;gBACpB,KAAK,CAAC,UAAU,GAAG,IAAI,CAAC;aACzB;YAED,IAAI,SAAS,IAAI,KAAK;gBAAE,KAAK,CAAC,MAAM,uBAAqB;YACzD,IAAI,OAAO,IAAI,KAAK,EAAE;gBACpB,KAAK,CAAC,MAAM,qBAAmB;gBAC/B,KAAK,CAAC,UAAU,GAAG,IAAI,CAAC;aACzB;YAED,IAAI,WAAW,IAAI,KAAK;gBAAE,KAAK,CAAC,MAAM,2BAAuB;YAC7D,IAAI,SAAS,IAAI,KAAK,EAAE;gBACtB,KAAK,CAAC,MAAM,yBAAqB;gBACjC,KAAK,CAAC,YAAY,GAAG,IAAI,CAAC;aAC3B;YAED,IAAI,QAAQ,IAAI,KAAK;gBAAE,KAAK,CAAC,MAAM,yBAAoB;YACvD,IAAI,SAAS,IAAI,KAAK;gBAAE,KAAK,CAAC,MAAM,uBAAqB;YACzD,IAAI,WAAW,IAAI,KAAK;gBAAE,KAAK,CAAC,MAAM,0BAAuB;YAC7D,IAAI,UAAU,IAAI,KAAK,EAAE;gBACvB,KAAK,CAAC,MAAM,yBAAsB;gBAClC,KAAK,CAAC,aAAa,GAAG,IAAI,CAAC;aAC5B;YACD,IAAI,WAAW,IAAI,KAAK;gBAAE,KAAK,CAAC,MAAM,0BAAuB;YAC7D,IAAI,SAAS,IAAI,KAAK;gBAAE,KAAK,CAAC,MAAM,0BAAqB;YACzD,IAAI,UAAU,IAAI,KAAK,EAAE;gBACvB,KAAK,CAAC,MAAM,0BAAsB;gBAClC,KAAK,CAAC,aAAa,GAAG,IAAI,CAAC;aAC5B;YAED,OAA+B,IAAI,CAAC;SACrC;KACF,CAAC;IAEF;AACA,aAAgB,eAAe,CAA2B,SAAqB;QAC7E,MAAM,WAAW,GAAG,qBAAqB,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QACzE,SAAS,CAAC,QAAQ,CAACF,mBAAY,CAAC,SAAS,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC,CAAC;IAChE,CAAC;IAED;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,oEAAoE;;IC/JpE,MAAM,aAAa,GAAwB;QACzC,IAAI,EAAE,YAAY;QAClB,aAAa,EAAE,IAAI;KACpB,CAAC;IAEF,MAAM,YAAY,GAAG,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;AAO9C,AAAauD,mBAAO,GAApB,MAAa,OAAO;QAOlB,YACU,UAAuB,EAC/B,WAAkD,EAC1C,eAAiC,EACjC,WAAmC;YAHnC,eAAU,GAAV,UAAU,CAAa;YAEvB,oBAAe,GAAf,eAAe,CAAkB;YACjC,gBAAW,GAAX,WAAW,CAAwB;YAV5B,YAAO,GAA+B,IAAI,CAAC;YAC3C,cAAS,GAAY,KAAK,CAAC;YAEpC,eAAU,GAAwC,IAAI,CAAC;YACvD,gBAAW,GAA+B,IAAI,CAAC;YAQrD,IAAI,CAAC,WAAW,CAAC,cAAc,GAAG;gBAChC,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;aACxB,CAAC;YAEF,IAAI,CAAC,UAAU,GAAG,WAAW,CAAC,YAAY;iBACvC,MAAM,CAAC,CAAC,CAAM,KAAK,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;iBAChD,MAAM,CAAC,CAAC,GAAG,EAAE,IAAS;gBACrB,IAAI,IAAI,CAAC,EAAE,EAAE;oBACX,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC;iBACrB;gBAED,OAAO,GAAG,CAAC;aACZ,EAAE,EAAE,CAAC,CAAC;SACV;QAEM,OAAO,CAAC,KAAqB;YAClC,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,OAAO,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;YACtD,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;SAC9C;QAEM,SAAS,CAAC,KAAqB;YACpC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;SACnC;QAEM,SAAS,CAAC,KAAqB;YACpC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;SACnC;QAEM,SAAS,CAAC,KAAqB;YACpC,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;YACxB,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;SACnC;QAEM,OAAO,CAAC,KAAqB;YAClC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;SACjC;QAEM,cAAc,CAAC,QAAa,EAAE,aAAkB,EAAE,KAAqB;YAC5E,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,aAAa,EAAE,KAAK,CAAC,CAAC;SACvD;QAEO,gBAAgB,CAAC,OAAY,EAAE,eAAoB,EAAE,KAAqB;YAChF,IAAI,IAAI,CAAC,WAAW,KAAK,OAAO,EAAE;gBAChC,OAAO;aACR;YAED,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC;YAE3B,IAAI,OAAO,YAAY,OAAO,EAAE;gBAC9B,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,IAAI,IAAI,CAAC,WAAW,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;aACzD;iBAAM;gBACL,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;aAC5C;YAED,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;YACtB,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;SAC1C;QAEO,WAAW,CAAC,OAAgB,EAAE,KAAqB;YACzD,MAAM,IAAI,GAAG,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;YAE1C,IAAI,IAAI,EAAE;gBACR,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;gBACvC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;gBACvC,OAAO,IAAI,CAAC;aACb;YAED,OAAO,IAAI,CAAC;SACb;QAEO,cAAc,CAAC,OAAgB;YACrC,IAAI,CAAC,OAAO,EAAE;gBACZ,OAAO,IAAI,CAAC;aACb;YAED,IAAI,WAAW,IAAI,OAAO,EAAE;gBAC1B,OAAO,OAAO,CAAC;aAChB;YAED,IAAI,YAAY,IAAI,OAAO,EAAE;gBAC3B,OAAO,OAAO,CAAC,UAAU,CACvB,IAAI,CAAC,eAAe,EACpB,IAAI,CAAC,UAAU,CAAC,QAAQ,CACzB,CAAC;aACH;YAED,IAAI,QAAQ,IAAI,OAAO,EAAE;gBACvB,OAAO,OAAO,CAAC,MAAM,EAAE,CAAC;aACzB;YAED,IAAI,UAAU,IAAI,OAAO,EAAE;gBACzB,OAAO,IAAI,CAAC,eAAe,CAAC,cAAc,CACxC,OAAO,EACP,IAAI,CAAC,UAAU,CAAC,QAAQ,CACzB,CAAC,MAAM,EAAE,CAAC;aACZ;;YAGD,OAAO,aAAa,CAClB,OAAO,EACP,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,UAAU,CAAC,QAAQ,CACzB,CAAC,UAAU,CACV,IAAI,CAAC,eAAe,EACpB,IAAI,CAAC,UAAU,CAAC,QAAQ,CACzB,CAAC;SACH;KACF,CAAA;AAvHWC;QAAT,QAAQ;oDAAmD;AAClDA;QAAT,QAAQ;sDAAmC;AAFjCD,mBAAO;QAFnB,aAAa,CAAC,aAAa,CAAC;QAC5BtD,aAAM,CAAC,WAAW,EAAE,oBAAoB,EAAE,gBAAgB,EAAEF,8BAAsB,CAAC;OACvEwD,eAAO,CAwHnB;;ICzID;;;AAGA,aAAgB,eAAe,CAAC,SAAwC;QACtE,OAAO,MAAM,IAAI,uBAAuB,CAAC,MAAM,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;IACrE,CAAC;IAED;;;;;AAKA,aAAgB,kBAAkB,CAAC,SAAsE;QACvG,OAAO,MAAM,IAAI,uBAAuB,CAAC,MAAM,CAC7C,OAAO,SAAS,KAAK,QAAQ;cAC3B,EAAE,oBAAoB,EAAE,IAAI,EAAG,IAAI,EAAE,SAAS,EAAE;8BAC9C,oBAAoB,EAAE,IAAI,IAAK,SAAS,CAAE,EAC9C,MAAM,CAAC,CAAC;IACZ,CAAC;AAED,UAAa,uBAAuB,GAA8D;QAChG,IAAI,EAAE,mBAAmB;QAEzB,OAAO,EAAE,kBAAkB;QAE3B,MAAM,CAA0D,IAAO;YACrE,OAAO,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC;SAC3B;QAED,MAAM,CAA0B,YAA2C,EAAE,IAAO;YAClF,MAAM,IAAI,GAAG,IAA0C,CAAC;YACxD,MAAM,WAAW,GAAG,gCAAgC,CAAC,OAAO,YAAY,KAAK,QAAQ,GAAG,EAAE,IAAI,EAAE,YAAY,EAAE,GAAG,YAAY,EAA4B,IAAI,CAAC,CAAC;YAC/J,MAAM,KAAK,GAA+B,IAAI,CAAC,SAAS,CAAC;YAEzD,IAAI,CAAC,IAAI,GAAG,uBAAuB,CAAC;YACpC,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;YAC/B,IAAI,CAAC,QAAQ,GAAG,iBAAiB,CAAC;YAElC,KAAK,CAAC,QAAQ,GAAG,iBAAiB,CAAC;YACnC,KAAK,CAAC,KAAK,GAAG,cAAc,CAAC;YAC7B,KAAK,CAAC,OAAO,GAAG,gBAAgB,CAAC;YACjC,KAAK,CAAC,OAAO,GAAG,gBAAgB,CAAC;YACjC,KAAK,CAAC,OAAO,GAAG,gBAAgB,CAAC;YACjC,KAAK,CAAC,MAAM,GAAG,eAAe,CAAC;YAE/B,KAAK,CAAC,SAAS,GAAG,IAAI,CAAC;YACvB,KAAK,CAAC,SAAS,GAAG,IAAI,CAAC;YACvB,KAAK,CAAC,WAAW,GAAG,IAAI,CAAC;YACzB,KAAK,CAAC,WAAW,GAAG,IAAI,CAAC;YAEzB,KAAK,CAAC,sBAAsB,GAAG,IAAI,CAAC;YAEpC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC;YACpB,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;YACjB,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;YAEjB,IAAI,OAAO,IAAI,KAAK,EAAE;gBACpB,KAAK,CAAC,UAAU,GAAG,IAAI,CAAC;aACzB;YAED,IAAI,SAAS,IAAI,KAAK;gBAAE,KAAK,CAAC,MAAM,uBAAqB;YACzD,IAAI,OAAO,IAAI,KAAK,EAAE;gBACpB,KAAK,CAAC,MAAM,qBAAmB;gBAC/B,KAAK,CAAC,UAAU,GAAG,IAAI,CAAC;aACzB;YAED,IAAI,WAAW,IAAI,KAAK;gBAAE,KAAK,CAAC,MAAM,2BAAuB;YAC7D,IAAI,SAAS,IAAI,KAAK,EAAE;gBACtB,KAAK,CAAC,MAAM,yBAAqB;gBACjC,KAAK,CAAC,YAAY,GAAG,IAAI,CAAC;aAC3B;YAED,IAAI,SAAS,IAAI,KAAK;gBAAE,KAAK,CAAC,MAAM,uBAAqB;YACzD,IAAI,WAAW,IAAI,KAAK;gBAAE,KAAK,CAAC,MAAM,0BAAuB;YAC7D,IAAI,UAAU,IAAI,KAAK,EAAE;gBACvB,KAAK,CAAC,MAAM,yBAAsB;gBAClC,KAAK,CAAC,aAAa,GAAG,IAAI,CAAC;aAC5B;YACD,IAAI,WAAW,IAAI,KAAK;gBAAE,KAAK,CAAC,MAAM,0BAAuB;YAC7D,IAAI,SAAS,IAAI,KAAK;gBAAE,KAAK,CAAC,MAAM,0BAAqB;YACzD,IAAI,UAAU,IAAI,KAAK,EAAE;gBACvB,KAAK,CAAC,MAAM,0BAAsB;gBAClC,KAAK,CAAC,aAAa,GAAG,IAAI,CAAC;aAC5B;YAED,OAAiC,IAAI,CAAC;SACvC;KACF,CAAC;IAEF;AACA,aAAgB,iBAAiB,CAA6B,SAAqB;QACjF,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;QACrC,MAAM,WAAW,GAAG,uBAAuB,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QACtE,MAAM,OAAO,GAAG,WAAW,CAAC,OAAO,CAAC;QAEpC,SAAS,CAAC,QAAQ,CAACvD,mBAAY,CAAC,SAAS,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC,CAAC;QAE9D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;YAChD,MAAM,QAAQ,GAAG,uBAAuB,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;YAC7D,SAAS,CAAC,QAAQ,CAACA,mBAAY,CAAC,KAAK,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC,CAAC;SAC/D;IACH,CAAC;IAED;AACA,aAAgB,gCAAgC,CAAC,GAAyB,EAAE,IAA0B;QACpG,OAAO;YACL,IAAI,EAAE,GAAG,CAAC,IAAI;YACd,OAAO,EAAE,GAAG,CAAC,OAAO,IAAIF,eAAQ,CAAC,UAAU;YAC3C,kBAAkB,EAAE,GAAG,CAAC,kBAAkB,IAAIW,mBAAW,CAAC,MAAM;YAChE,oBAAoB,EAAE,GAAG,CAAC,oBAAoB,IAAI,KAAK;YACvD,SAAS,oBAAM,IAAI,CAAC,SAAS,EAAK,GAAG,CAAC,SAAS,CAAC;SACjD,CAAC;IACJ,CAAC;;AC/GYgD,cAAE,GAAf,MAAa,EAAE;QAQb,YACS,SAAuB,EACvB,QAAyB,EACzB,WAAmC;YAFnC,cAAS,GAAT,SAAS,CAAc;YACvB,aAAQ,GAAR,QAAQ,CAAiB;YACzB,gBAAW,GAAX,WAAW,CAAwB;YAV3B,UAAK,GAAY,KAAK,CAAC;YAEjC,gBAAW,GAAiB,IAAI,CAAC;YAEjC,WAAM,GAAU,IAAI,CAAC;YACrB,aAAQ,GAAU,IAAI,CAAC;SAKmB;QAE1C,OAAO,CAAC,KAAqB;YAClC,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;YACpC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;YACtC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;SAC9C;QAEM,SAAS,CAAC,KAAqB;YACpC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;SACnC;QAEM,SAAS,CAAC,KAAqB;YACpC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;SACnC;QAEM,SAAS,CAAC,KAAqB;YACpC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;SACnC;QAEM,OAAO,CAAC,KAAqB;YAClC,IAAI,IAAI,CAAC,MAAM,KAAK,IAAI,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;gBACtD,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;aACpB;YAED,IAAI,IAAI,CAAC,QAAQ,KAAK,IAAI,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;gBAC1D,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;aACtB;YAED,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;SACjC;QAEM,YAAY,CAAC,QAAiB,EAAE,QAAiB,EAAE,KAAqB;YAC7E,IAAI,KAAK,GAAG9D,sBAAc,CAAC,SAAS,EAAE;gBACpC,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;gBACpC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;aACvC;iBAAM;gBACL,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;aACpC;SACF;QAEM,KAAK,CAAC,KAAqB;YAChC,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;YACpC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;SACvC;;QAGM,UAAU,CAAC,KAAqB;YACrC,IAAI,IAAW,CAAC;YAEhB,IAAI,IAAI,CAAC,KAAK,EAAE;gBACd,IAAI,GAAG,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;aAC1E;iBAAM,IAAI,IAAI,CAAC,WAAW,KAAK,IAAI,EAAE;gBACpC,IAAI,GAAG,IAAI,CAAC,QAAQ,GAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,WAAW,EAAE,KAAK,CAAC,CAAC;aACjF;iBAAM;gBACL,IAAI,GAAG,IAAI,CAAC;aACb;YAED,OAAO,IAAI,CAAC;SACb;;QAGM,UAAU,CAAC,IAAW,EAAE,OAAqB,EAAE,KAAqB;YACzE,IAAI,IAAI,KAAK,IAAI,EAAE;gBACjB,IAAI,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC;aACzB;YAED,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;YAEhC,OAAO,IAAI,CAAC;SACb;KACF,CAAA;AAjFW6D;QAAT,QAAQ;6CAA+B;AAD7BC,cAAE;QAFd,kBAAkB,CAAC,IAAI,CAAC;QACxBxD,aAAM,CAAC,YAAY,EAAE,eAAe,EAAEF,8BAAsB,CAAC;OACjD0D,UAAE,CAkFd;AAMYC,gBAAI,GAAjB,MAAa,IAAI;QACf,YAAoB,OAAqB;YAArB,YAAO,GAAP,OAAO,CAAc;SAAK;QAEvC,IAAI,CAAC,UAAc;YACxB,UAAU,CAAC,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC;SACvC;KACF,CAAA;AANYA,gBAAI;QAFhB,kBAAkB,CAAC,MAAM,CAAC;QAC1BzD,aAAM,CAAC,YAAY,CAAC;OACRyD,YAAI,CAMhB;;ACxFYC,kBAAM,GAAnB,MAAa,MAAM;QAcjB,YACS,QAAyB,EACzB,UAAuB,EACvB,OAAqB;YAFrB,aAAQ,GAAR,QAAQ,CAAiB;YACzB,eAAU,GAAV,UAAU,CAAa;YACvB,YAAO,GAAP,OAAO,CAAc;YAXvB,wBAAmB,GAAU,IAAI,CAAC;YAClC,UAAK,GAAY,EAAE,CAAC;YACpB,aAAQ,GAAuB,IAAI,CAAC;YACpC,+BAA0B,GAAY,KAAK,CAAC;SAQhB;QAE5B,OAAO,CAAC,KAAqB;YAClC,IAAI,CAAC,uBAAuB,EAAE,CAAC;SAChC;QAEM,KAAK,CAAC,KAAqB;YAChC,IAAI,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC;YAC5C,OAAO,OAAO,KAAK,IAAI,EAAE;gBACvB,IAAc,OAAQ,CAAC,MAAM,KAAK,IAAI,IAAc,OAAQ,CAAC,cAAc,KAAK,OAAO,EAAE;oBACvF,IAAI,CAAC,KAAK,GAAa,OAAQ,CAAC,gBAAkC,CAAC;oBACnE,MAAM;iBACP;gBACD,OAAO,GAAG,OAAO,CAAC,SAAS,CAAC;aAC7B;YACD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;YAEvE,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;SAChC;QAEM,SAAS,CAAC,KAAqB;YACpC,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC;YACjC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBAC9C,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gBACtB,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;gBAC3B,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;aACrB;SACF;QAEM,SAAS,CAAC,KAAqB;YACpC,MAAM,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC;YACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBAC9C,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gBACtB,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;gBACpB,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;aACrB;SACF;QAEM,OAAO,CAAC,KAAqB;YAClC,IAAI,CAAC,uBAAuB,EAAE,CAAC;YAE/B,MAAM,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC;YACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBAC9C,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gBACtB,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;aACrB;SACF;;QAGM,YAAY,CAAC,QAAW,EAAE,QAAW,EAAE,KAAqB;YACjE,IAAI,CAAC,uBAAuB,EAAE,CAAC;YAC/B,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,KAAK,GAAGhE,sBAAc,CAAC,oBAAoB,CAAC,CAAC;SACtE;;QAGM,mBAAmB,CAAC,QAAyB;YAClD,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAEA,sBAAc,CAAC,SAAS,GAAGA,sBAAc,CAAC,oBAAoB,CAAC,CAAC;SAC7F;;QAGO,YAAY,CAAC,QAAyB,EAAE,KAAqB;YACnE,MAAM,EAAE,KAAK,EAAE,UAAU,EAAE,GAAG,IAAI,CAAC;YACnC,IAAI,IAAI,CAAC,MAAM,oBAAkB;gBAC/B,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC;gBACtD,MAAM,SAAS,GAAG,KAAK,CAAC,MAAM,CAAC;gBAC/B,MAAM,SAAS,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;gBACrC,IAAI,SAAS,GAAG,SAAS,EAAE;oBACzB,KAAK,CAAC,MAAM,GAAG,SAAS,CAAC;oBACzB,KAAK,IAAI,CAAC,GAAG,SAAS,EAAE,CAAC,GAAG,SAAS,EAAE,EAAE,CAAC,EAAE;wBAC1C,KAAK,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC;qBAC7B;iBACF;qBAAM,IAAI,SAAS,GAAG,SAAS,EAAE;oBAChC,UAAU,CAAC,WAAW,EAAE,CAAC;oBACzB,KAAK,IAAI,CAAC,GAAG,SAAS,EAAE,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,SAAS,EAAE,IAAI,GAAG,KAAK,CAAC,EAAE,CAAC,CAAC,EAAE;wBACzE,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;wBACpB,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;qBACrB;oBACD,UAAU,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;oBAC5B,UAAU,CAAC,WAAW,EAAE,CAAC;oBACzB,KAAK,IAAI,CAAC,GAAG,SAAS,EAAE,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,SAAS,EAAE,IAAI,GAAG,KAAK,CAAC,EAAE,CAAC,CAAC,EAAE;wBACzE,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;qBACrB;oBACD,UAAU,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;oBAC5B,KAAK,CAAC,MAAM,GAAG,SAAS,CAAC;oBACzB,IAAI,SAAS,KAAK,CAAC,EAAE;wBACnB,OAAO;qBACR;iBACF;qBAAM,IAAI,SAAS,KAAK,CAAC,EAAE;oBAC1B,OAAO;iBACR;gBAED,UAAU,CAAC,SAAS,EAAE,CAAC;gBACvB,IAAI,QAAQ,KAAK,IAAI,EAAE;oBACrB,KAAK,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC,GAAG,EAAE,CAAC,EAAE,IAAI;wBAChC,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;wBACtB,IAAI,CAAC,CAAC,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,KAAK,IAAI,EAAE;4BAC/D,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,UAAU,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC,CAAC;yBACzE;6BAAM;4BACL,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,UAAU,CAAC,MAAM,EAAE,cAAc,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;yBACjF;qBACF,CAAC,CAAC;iBACJ;qBAAM;oBACL,KAAK,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC,GAAG,EAAE,CAAC,EAAE,IAAI;wBAChC,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;wBACtB,IAAI,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE;4BACtC,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,UAAU,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC,CAAC;yBACzE;6BAAM;4BACL,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,UAAU,CAAC,MAAM,EAAE,cAAc,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;yBACjF;qBACF,CAAC,CAAC;iBACJ;gBACD,UAAU,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;aAC3B;YAED,IAAI,IAAI,CAAC,MAAM,uBAAqB;gBAClC,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC;gBAC1B,UAAU,CAAC,WAAW,EAAE,CAAC;gBACzB,IAAI,QAAQ,KAAK,IAAI,EAAE;oBACrB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBAC9C,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;wBACtB,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;wBAC3B,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;qBACrB;iBACF;qBAAM;oBACL,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBAC9C,IAAI,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;4BACrB,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;4BACtB,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;4BAC3B,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;yBACrB;qBACF;iBACF;gBACD,UAAU,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;aAC7B;SACF;QAEO,uBAAuB;YAC7B,MAAM,WAAW,GAAG,IAAI,CAAC,QAAQ,CAAC;YAClC,IAAI,IAAI,CAAC,MAAM,IAAI,oCAAgC,EAAE;gBACnD,MAAM,WAAW,GAAG,IAAI,CAAC,QAAQ,GAAG,qBAAqB,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;gBACvF,IAAI,WAAW,KAAK,WAAW,EAAE;oBAC/B,IAAI,WAAW,EAAE;wBACf,WAAW,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;qBACtC;iBACF;gBACD,IAAI,WAAW,EAAE;oBACf,WAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;iBACpC;aACF;iBAAM,IAAI,WAAW,EAAE;gBACtB,WAAW,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;aACtC;SACF;KACF,CAAA;AAxKW6D;QAAT,QAAQ;iDAAiB;AADfG,kBAAM;QAFlB1D,aAAM,CAAC,eAAe,EAAE,WAAW,EAAE,YAAY,CAAC;QAClD,kBAAkB,CAAC,QAAQ,CAAC;OAChB0D,cAAM,CAyKlB;;AChLYC,uBAAW,GAAxB,MAAa,WAAW;QAGtB,YAAoB,OAAqB,EAAE,QAAyB;YAAhD,YAAO,GAAP,OAAO,CAAc;YACvC,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;YACzC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,EAAEjE,sBAAc,CAAC,UAAU,CAAC,CAAC;SAC5D;QAEM,OAAO,CAAC,KAAqB;YAClC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;SAC5C;QAEM,SAAS,CAAC,KAAqB;YACpC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;SACjC;QAEM,SAAS,CAAC,KAAqB;YACpC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;SACjC;QAEM,SAAS,CAAC,KAAqB;YACpC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;SACjC;KACF,CAAA;AAvBYiE,uBAAW;QAFvB,kBAAkB,CAAC,aAAa,CAAC;QACjC3D,aAAM,CAAC,YAAY,EAAE,eAAe,CAAC;OACzB2D,mBAAW,CAuBvB;;ACrBYC,gBAAI,GAAjB,MAAa,IAAI;QAKf,YAAoB,OAAqB,EAAE,QAAyB;YAAhD,YAAO,GAAP,OAAO,CAAc;YAJxB,UAAK,GAAQ,IAAI,CAAC;YAE3B,gBAAW,GAAU,IAAI,CAAC;YAGhC,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;YACzC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,EAAElE,sBAAc,CAAC,UAAU,CAAC,CAAC;SAC5D;QAEM,YAAY;YACjB,IAAI,IAAI,CAAC,MAAM,oBAAkB;gBAC/B,IAAI,CAAC,SAAS,CAACA,sBAAc,CAAC,mBAAmB,CAAC,CAAC;aACpD;SACF;QAEM,OAAO,CAAC,KAAqB;YAClC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;SACvB;QAEM,SAAS,CAAC,KAAqB;YACpC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;SACjC;QAEM,SAAS,CAAC,KAAqB;YACpC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;SACjC;QAEM,SAAS,CAAC,KAAqB;YACpC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;SACjC;QAEO,SAAS,CAAC,KAAqB;YACrC,MAAM,KAAK,GAAG,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;YACxD,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;SACtC;KACF,CAAA;AAnCW6D;QAAT,QAAQ;+CAA0B;AADxBK,gBAAI;QAFhB,kBAAkB,CAAC,MAAM,CAAC;QAC1B5D,aAAM,CAAC,YAAY,EAAE,eAAe,CAAC;OACzB4D,YAAI,CAoChB;;UCvCY,OAAO;QAOlB,YAAoB,YAAwBhE,SAAE,CAAC,eAAe,EAAE;YAA5C,cAAS,GAAT,SAAS,CAAmC;YANxD,eAAU,GAAqB,EAAE,CAAC;YAClC,eAAU,GAAmB,EAAE,CAAC;YAChC,cAAS,GAAmB,EAAE,CAAC;YAC/B,cAAS,GAAY,KAAK,CAAC;YAC3B,UAAK,GAAmB,IAAI,CAAC;YAGnCG,mBAAY;iBACT,QAAQ,CAAC,OAAO,EAAE,IAAI,CAAC;iBACvB,QAAQ,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;SACjC;QAEM,QAAQ,CAAC,GAAG,MAA0D;YAC3E,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,MAAM,CAAC,CAAC;YACnC,OAAO,IAAI,CAAC;SACb;QAEM,GAAG,CAAC,MAAsB;YAC/B,MAAM,SAAS,GAAmB,MAAM,CAAC,SAAS,CAAC;YACnD,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC;YAEzB,MAAM,SAAS,GAAG;gBAChB,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC;gBAChB,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE;oBACxC,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC;oBACvB,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;oBAChC,MAAM,EAAE,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAC;oBAChD,SAAS,CAAC,QAAQ,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC;iBAC9B;gBAED,SAAS,CAAC,KAAK,CAACL,sBAAc,CAAC,aAAa,GAAGA,sBAAc,CAAC,QAAQ,CAAC,CAAC;gBACxE,SAAS,CAAC,OAAO,CAACA,sBAAc,CAAC,aAAa,EAAE,IAAI,CAAC,CAAC;aACvD,CAAC;YAEF,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YAEhC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC;gBAClB,SAAS,CAAC,OAAO,CAACA,sBAAc,CAAC,YAAY,CAAC,CAAC;gBAC/C,SAAS,CAAC,OAAO,CAACA,sBAAc,CAAC,YAAY,GAAGA,sBAAc,CAAC,UAAU,CAAC,CAAC;gBAC3E,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC;aACjB,CAAC,CAAC;YAEH,IAAI,IAAI,CAAC,SAAS,EAAE;gBAClB,SAAS,EAAE,CAAC;aACb;YAED,OAAO,IAAI,CAAC;SACb;QAEM,IAAI;YACT,OAAO,IAAI,CAAC,KAAK,CAAC;SACnB;QAEM,KAAK;YACV,KAAK,MAAM,YAAY,IAAI,IAAI,CAAC,UAAU,EAAE;gBAC1C,YAAY,EAAE,CAAC;aAChB;YACD,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;YACtB,OAAO,IAAI,CAAC;SACb;QAEM,IAAI;YACT,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;YACvB,KAAK,MAAM,WAAW,IAAI,IAAI,CAAC,SAAS,EAAE;gBACxC,WAAW,EAAE,CAAC;aACf;YACD,OAAO,IAAI,CAAC;SACb;KACF;AAEKG,mBAAQ,CAAC,MAAO,CAAC,OAAO,GAAG,OAAO,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}