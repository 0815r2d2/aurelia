{"version":3,"file":"index.umd.js","sources":["../src/observation.ts","../../../node_modules/tslib/tslib.es6.js","../src/observation/subscriber-collection.ts","../src/observation/property-observer.ts","../src/observation/property-observation.ts","../src/observation/binding-context.ts","../src/observation/signaler.ts","../src/resources/binding-behavior.ts","../src/resources/value-converter.ts","../src/binding/ast.ts","../src/binding/binding-mode.ts","../src/lifecycle.ts","../src/binding/connectable.ts","../src/binding/binding.ts","../src/binding/call.ts","../src/binding/expression-parser.ts","../src/binding/interpolation-binding.ts","../src/binding/let-binding.ts","../src/binding/listener.ts","../src/binding/ref.ts","../src/dom.interfaces.ts","../src/dom.ts","../src/observation/target-observer.ts","../src/observation/collection-observer.ts","../src/observation/array-observer.ts","../src/observation/map-observer.ts","../src/observation/set-observer.ts","../src/observation/computed-observer.ts","../src/observation/dirty-checker.ts","../src/observation/element-observation.ts","../src/observation/event-manager.ts","../src/observation/svg-analyzer.ts","../src/observation/target-accessors.ts","../src/observation/observer-locator.ts","../src/resources/binding-behaviors/attr.ts","../src/resources/binding-behaviors/binding-mode.ts","../src/resources/binding-behaviors/debounce.ts","../src/resources/binding-behaviors/self.ts","../src/resources/binding-behaviors/signals.ts","../src/resources/binding-behaviors/throttle.ts","../src/resources/binding-behaviors/update-trigger.ts","../src/definitions.ts","../src/templating/lifecycle-attach.ts","../src/templating/lifecycle-bind.ts","../src/templating/view.ts","../src/templating/lifecycle-render.ts","../src/resources/custom-attribute.ts","../src/templating/bindable.ts","../src/resources/custom-attributes/if.ts","../src/resources/custom-attributes/repeat.ts","../src/resources/custom-attributes/replaceable.ts","../src/resources/custom-attributes/with.ts","../src/resources/custom-element.ts","../src/templating/create-element.ts","../src/resources/custom-elements/compose.ts","../src/resources/value-converters/sanitize.ts","../src/aurelia.ts","../src/html-renderer.ts","../src/instructions.ts"],"sourcesContent":["import { IDisposable, IIndexable } from '@aurelia/kernel';\nimport { ILifecycle } from './lifecycle';\n\nexport enum LifecycleFlags {\n  none                      = 0b0_0000_00000000000000_000_00,\n  mustEvaluate              = 0b0_0001_00000000000000_000_00,\n  mutation                  = 0b0_0000_00000000000000_000_11,\n  isCollectionMutation      = 0b0_0000_00000000000000_000_01,\n  isInstanceMutation        = 0b0_0000_00000000000000_000_10,\n  update                    = 0b0_0000_00000000000000_111_00,\n  updateTargetObserver      = 0b0_0000_00000000000000_001_00,\n  updateTargetInstance      = 0b0_0000_00000000000000_010_00,\n  updateSourceExpression    = 0b0_0000_00000000000000_100_00,\n  from                      = 0b0_0000_11111111111111_000_00,\n  fromFlush                 = 0b0_0000_00000000000011_000_00,\n  fromAsyncFlush            = 0b0_0000_00000000000001_000_00,\n  fromSyncFlush             = 0b0_0000_00000000000010_000_00,\n  fromStartTask             = 0b0_0000_00000000000100_000_00,\n  fromStopTask              = 0b0_0000_00000000001000_000_00,\n  fromBind                  = 0b0_0000_00000000010000_000_00,\n  fromUnbind                = 0b0_0000_00000000100000_000_00,\n  fromAttach                = 0b0_0000_00000001000000_000_00,\n  fromDetach                = 0b0_0000_00000010000000_000_00,\n  fromCache                 = 0b0_0000_00000100000000_000_00,\n  fromCreate                = 0b0_0000_00001000000000_000_00,\n  fromDOMEvent              = 0b0_0000_00010000000000_000_00,\n  fromObserverSetter        = 0b0_0000_00100000000000_000_00,\n  fromBindableHandler       = 0b0_0000_01000000000000_000_00,\n  fromLifecycleTask         = 0b0_0000_10000000000000_000_00,\n  parentUnmountQueued       = 0b0_0010_00000000000000_000_00,\n  // this flag is for the synchronous flush before detach (no point in updating the\n  // DOM if it's about to be detached)\n  doNotUpdateDOM            = 0b0_0100_00000000000000_000_00,\n  isTraversingParentScope   = 0b0_1000_00000000000000_000_00,\n  // Bitmask for flags that need to be stored on a binding during $bind for mutation\n  // callbacks outside of $bind\n  persistentBindingFlags    = 0b1_0000_00000000000000_000_00,\n  allowParentScopeTraversal = 0b1_0000_00000000000000_000_00,\n}\n\nexport function stringifyLifecycleFlags(flags: LifecycleFlags): string {\n  const flagNames: string[] = [];\n\n  if (flags & LifecycleFlags.mustEvaluate) { flagNames.push('mustEvaluate'); }\n  if (flags & LifecycleFlags.isCollectionMutation) { flagNames.push('isCollectionMutation'); }\n  if (flags & LifecycleFlags.isInstanceMutation) { flagNames.push('isInstanceMutation'); }\n  if (flags & LifecycleFlags.updateTargetObserver) { flagNames.push('updateTargetObserver'); }\n  if (flags & LifecycleFlags.updateTargetInstance) { flagNames.push('updateTargetInstance'); }\n  if (flags & LifecycleFlags.updateSourceExpression) { flagNames.push('updateSourceExpression'); }\n  if (flags & LifecycleFlags.fromAsyncFlush) { flagNames.push('fromAsyncFlush'); }\n  if (flags & LifecycleFlags.fromSyncFlush) { flagNames.push('fromSyncFlush'); }\n  if (flags & LifecycleFlags.fromStartTask) { flagNames.push('fromStartTask'); }\n  if (flags & LifecycleFlags.fromStopTask) { flagNames.push('fromStopTask'); }\n  if (flags & LifecycleFlags.fromBind) { flagNames.push('fromBind'); }\n  if (flags & LifecycleFlags.fromUnbind) { flagNames.push('fromUnbind'); }\n  if (flags & LifecycleFlags.fromAttach) { flagNames.push('fromAttach'); }\n  if (flags & LifecycleFlags.fromDetach) { flagNames.push('fromDetach'); }\n  if (flags & LifecycleFlags.fromCache) { flagNames.push('fromCache'); }\n  if (flags & LifecycleFlags.fromCreate) { flagNames.push('fromCreate'); }\n  if (flags & LifecycleFlags.fromDOMEvent) { flagNames.push('fromDOMEvent'); }\n  if (flags & LifecycleFlags.fromObserverSetter) { flagNames.push('fromObserverSetter'); }\n  if (flags & LifecycleFlags.fromBindableHandler) { flagNames.push('fromBindableHandler'); }\n  if (flags & LifecycleFlags.fromLifecycleTask) { flagNames.push('fromLifecycleTask'); }\n  if (flags & LifecycleFlags.parentUnmountQueued) { flagNames.push('parentUnmountQueued'); }\n  if (flags & LifecycleFlags.doNotUpdateDOM) { flagNames.push('doNotUpdateDOM'); }\n  if (flags & LifecycleFlags.isTraversingParentScope) { flagNames.push('isTraversingParentScope'); }\n  if (flags & LifecycleFlags.allowParentScopeTraversal) { flagNames.push('allowParentScopeTraversal'); }\n\n  return flagNames.join('|');\n}\n\n/** @internal */\nexport const enum SubscriberFlags {\n  None            = 0,\n  Subscriber0     = 0b0001,\n  Subscriber1     = 0b0010,\n  Subscriber2     = 0b0100,\n  SubscribersRest = 0b1000,\n  Any             = 0b1111,\n}\n\n/**\n * Describes a type that tracks changes and can flush those changes in some way\n */\nexport interface IChangeTracker {\n  $nextFlush?: IChangeTracker;\n  hasChanges?: boolean;\n  flush(flags: LifecycleFlags): void;\n}\n\n/**\n * Basic interface to normalize getting/setting a value of any property on any object\n */\nexport interface IAccessor<TValue = unknown> {\n  getValue(): TValue;\n  setValue(newValue: TValue, flags: LifecycleFlags): void;\n}\n\n/**\n * Describes a target observer for to-view bindings (in other words, an observer without the observation).\n */\nexport interface IBindingTargetAccessor<\n  TObj = any,\n  TProp = keyof TObj,\n  TValue = unknown>\n  extends IDisposable,\n          IAccessor<TValue>,\n          IPropertyChangeTracker<TObj, TProp> { }\n\n/**\n * Describes a target observer for from-view or two-way bindings.\n */\nexport interface IBindingTargetObserver<\n  TObj = any,\n  TProp = keyof TObj,\n  TValue = unknown>\n  extends IBindingTargetAccessor<TObj, TProp, TValue>,\n          ISubscribable<MutationKind.instance>,\n          ISubscriberCollection<MutationKind.instance> {\n\n  bind?(flags: LifecycleFlags): void;\n  unbind?(flags: LifecycleFlags): void;\n}\n\nexport type AccessorOrObserver = IBindingTargetAccessor | IBindingTargetObserver;\n\n/**\n * An array of indices, where the index of an element represents the index to map FROM, and the numeric value of the element itself represents the index to map TO\n *\n * The deletedItems property contains the items (in case of an array) or keys (in case of map or set) that have been deleted.\n */\nexport type IndexMap = number[] & {\n  deletedItems?: unknown[];\n};\n\n/**\n * Mostly just a marker enum to help with typings (specifically to reduce duplication)\n */\nexport enum MutationKind {\n  instance   = 0b01,\n  collection = 0b10\n}\n\n/**\n * Describes a type that specifically tracks changes in an object property, or simply something that can have a getter and/or setter\n */\nexport interface IPropertyChangeTracker<TObj extends Object, TProp = keyof TObj, TValue = unknown> {\n  obj: TObj;\n  propertyKey?: TProp;\n  currentValue?: TValue;\n}\n\n/**\n * Describes a type that specifically tracks changes in a collection (map, set or array)\n */\nexport interface ICollectionChangeTracker<T extends Collection> extends IChangeTracker {\n  collection: T;\n  indexMap: IndexMap;\n  resetIndexMap(): void;\n}\n\n/**\n * Represents a (subscriber) function that can be called by a PropertyChangeNotifier\n */\nexport type IPropertyChangeHandler<TValue = unknown> = (newValue: TValue, previousValue: TValue, flags: LifecycleFlags) => void;\n/**\n * Represents a (observer) function that can notify subscribers of mutations on a property\n */\nexport interface IPropertyChangeNotifier extends IPropertyChangeHandler {}\n\n/**\n * Describes a (subscriber) type that has a function conforming to the IPropertyChangeHandler interface\n */\nexport interface IPropertySubscriber<TValue = unknown> { handleChange(newValue: TValue, previousValue: TValue, flags: LifecycleFlags): void; }\n\n/**\n * Represents a (subscriber) function that can be called by a CollectionChangeNotifier\n */\nexport type ICollectionChangeHandler = (origin: string, args: IArguments | null, flags?: LifecycleFlags) => void;\n/**\n * Represents a (observer) function that can notify subscribers of mutations in a collection\n */\nexport interface ICollectionChangeNotifier extends ICollectionChangeHandler {}\n\n/**\n * Represents a (subscriber) function that can be called by a BatchedCollectionChangeNotifier\n */\nexport type IBatchedCollectionChangeHandler = (indexMap: number[]) => void;\n/**\n * Represents a (observer) function that can notify subscribers of batched mutations in a collection\n */\nexport interface IBatchedCollectionChangeNotifier extends IBatchedCollectionChangeHandler {}\n\n/**\n * Describes a (subscriber) type that has a function conforming to the ICollectionChangeHandler interface\n */\nexport interface ICollectionSubscriber { handleChange(origin: string, args: IArguments | null, flags: LifecycleFlags): void; }\n/**\n * Describes a (subscriber) type that has a function conforming to the IBatchedCollectionChangeNotifier interface\n */\nexport interface IBatchedCollectionSubscriber { handleBatchedChange(indexMap: number[]): void; }\n\n/**\n * Either a property or collection subscriber\n */\nexport type Subscriber = ICollectionSubscriber | IPropertySubscriber;\n/**\n * Either a batched property or batched collection subscriber\n */\nexport type BatchedSubscriber = IBatchedCollectionSubscriber;\n\n/**\n * Helper type that translates from mutationKind enum to the correct subscriber interface\n */\nexport type MutationKindToSubscriber<T> =\n  T extends MutationKind.instance ? IPropertySubscriber :\n  T extends MutationKind.collection ? ICollectionSubscriber :\n  never;\n\n/**\n * Helper type that translates from mutationKind enum to the correct batched subscriber interface\n */\nexport type MutationKindToBatchedSubscriber<T> =\n  T extends MutationKind.collection ? IBatchedCollectionSubscriber :\n  never;\n\n/**\n * Helper type that translates from mutationKind enum to the correct notifier interface\n */\nexport type MutationKindToNotifier<T> =\n  T extends MutationKind.instance ? IPropertyChangeNotifier :\n  T extends MutationKind.collection ? ICollectionChangeNotifier :\n  never;\n\n/**\n * Helper type that translates from mutationKind enum to the correct batched notifier interface\n */\nexport type MutationKindToBatchedNotifier<T> =\n  T extends MutationKind.collection ? IBatchedCollectionChangeNotifier :\n  never;\n\nexport interface ISubscribable<T extends MutationKind> {\n  subscribe(subscriber: MutationKindToSubscriber<T>): void;\n  unsubscribe(subscriber: MutationKindToSubscriber<T>): void;\n}\n\n/**\n * A collection of property or collection subscribers\n */\nexport interface ISubscriberCollection<T extends MutationKind> extends ISubscribable<T> {\n  /** @internal */_subscriberFlags?: SubscriberFlags;\n  /** @internal */_subscriber0?: MutationKindToSubscriber<T>;\n  /** @internal */_subscriber1?: MutationKindToSubscriber<T>;\n  /** @internal */_subscriber2?: MutationKindToSubscriber<T>;\n  /** @internal */_subscribersRest?: MutationKindToSubscriber<T>[];\n\n  callSubscribers: MutationKindToNotifier<T>;\n  hasSubscribers(): boolean;\n  hasSubscriber(subscriber: MutationKindToSubscriber<T>): boolean;\n  removeSubscriber(subscriber: MutationKindToSubscriber<T>): boolean;\n  addSubscriber(subscriber: MutationKindToSubscriber<T>): boolean;\n}\n\n/**\n * A collection of batched property or collection subscribers\n */\nexport interface IBatchedSubscriberCollection<T extends MutationKind> extends IBatchedSubscribable<T> {\n  /** @internal */_batchedSubscriberFlags?: SubscriberFlags;\n  /** @internal */_batchedSubscriber0?: MutationKindToBatchedSubscriber<T>;\n  /** @internal */_batchedSubscriber1?: MutationKindToBatchedSubscriber<T>;\n  /** @internal */_batchedSubscriber2?: MutationKindToBatchedSubscriber<T>;\n  /** @internal */_batchedSubscribersRest?: MutationKindToBatchedSubscriber<T>[];\n\n  /** @internal */lifecycle?: ILifecycle;\n  callBatchedSubscribers: MutationKindToBatchedNotifier<T>;\n\n  /** @internal */flush(flags: LifecycleFlags): void;\n  hasBatchedSubscribers(): boolean;\n  hasBatchedSubscriber(subscriber: MutationKindToBatchedSubscriber<T>): boolean;\n  removeBatchedSubscriber(subscriber: MutationKindToBatchedSubscriber<T>): boolean;\n  addBatchedSubscriber(subscriber: MutationKindToBatchedSubscriber<T>): boolean;\n}\n\nexport interface IBatchedSubscribable<T extends MutationKind> {\n  subscribeBatched(subscriber: MutationKindToBatchedSubscriber<T>): void;\n  unsubscribeBatched(subscriber: MutationKindToBatchedSubscriber<T>): void;\n}\n\n/**\n * Describes a complete property observer with an accessor, change tracking fields, normal and batched subscribers\n */\nexport interface IPropertyObserver<TObj extends Object, TProp extends keyof TObj> extends\n  IDisposable,\n  IAccessor<TObj[TProp]>,\n  IPropertyChangeTracker<TObj, TProp>,\n  ISubscriberCollection<MutationKind.instance> {\n  /** @internal */observing: boolean;\n}\n\n/**\n * An any-typed property observer\n */\nexport type PropertyObserver = IPropertyObserver<any, PropertyKey>;\n\n/**\n * A collection (array, set or map)\n */\nexport type Collection = unknown[] | Set<unknown> | Map<unknown, unknown>;\ninterface IObservedCollection {\n  $observer?: CollectionObserver;\n}\n\n/**\n * An array that is being observed for mutations\n */\nexport interface IObservedArray<T = unknown> extends IObservedCollection, Array<T> { }\n/**\n * A set that is being observed for mutations\n */\nexport interface IObservedSet<T = unknown> extends IObservedCollection, Set<T> { }\n/**\n * A map that is being observed for mutations\n */\nexport interface IObservedMap<K = unknown, V = unknown> extends IObservedCollection, Map<K, V> { }\n/**\n * A collection that is being observed for mutations\n */\nexport type ObservedCollection = IObservedArray | IObservedSet | IObservedMap;\n\nexport const enum CollectionKind {\n  indexed = 0b1000,\n  keyed   = 0b0100,\n  array   = 0b1001,\n  map     = 0b0110,\n  set     = 0b0111\n}\n\nexport type LengthPropertyName<T> =\n  T extends unknown[] ? 'length' :\n  T extends Set<unknown> ? 'size' :\n  T extends Map<unknown, unknown> ? 'size' :\n  never;\n\nexport type CollectionTypeToKind<T> =\n  T extends unknown[] ? CollectionKind.array | CollectionKind.indexed :\n  T extends Set<unknown> ? CollectionKind.set | CollectionKind.keyed :\n  T extends Map<unknown, unknown> ? CollectionKind.map | CollectionKind.keyed :\n  never;\n\nexport type CollectionKindToType<T> =\n  T extends CollectionKind.array ? unknown[] :\n  T extends CollectionKind.indexed ? unknown[] :\n  T extends CollectionKind.map ? Map<unknown, unknown> :\n  T extends CollectionKind.set ? Set<unknown> :\n  T extends CollectionKind.keyed ? Set<unknown> | Map<unknown, unknown> :\n  never;\n\nexport type ObservedCollectionKindToType<T> =\n  T extends CollectionKind.array ? IObservedArray :\n  T extends CollectionKind.indexed ? IObservedArray :\n  T extends CollectionKind.map ? IObservedMap :\n  T extends CollectionKind.set ? IObservedSet :\n  T extends CollectionKind.keyed ? IObservedSet | IObservedMap :\n  never;\n\n// TODO: organize this (for now it's a quick fix for length observer, but we may actually want this\n// in every observer for alternative change tracking mechanisms)\nexport interface IPatch {\n  patch(flags: LifecycleFlags): void;\n}\n\n/**\n * An observer that tracks collection mutations and notifies subscribers (either directly or in batches)\n */\nexport interface ICollectionObserver<T extends CollectionKind> extends\n  IDisposable,\n  ICollectionChangeTracker<CollectionKindToType<T>>,\n  ISubscriberCollection<MutationKind.collection>,\n  IBatchedSubscriberCollection<MutationKind.collection> {\n    collection: ObservedCollectionKindToType<T>;\n    lengthPropertyName: LengthPropertyName<CollectionKindToType<T>>;\n    collectionKind: T;\n    lengthObserver: IBindingTargetObserver & IPatch;\n    getLengthObserver(): IBindingTargetObserver;\n}\nexport type CollectionObserver = ICollectionObserver<CollectionKind>;\n\nexport interface IBindingContext {\n  [key: string]: unknown;\n\n  readonly $synthetic?: true;\n  readonly $observers?: ObserversLookup<IOverrideContext>;\n  getObservers?(): ObserversLookup<IOverrideContext>;\n}\n\nexport interface IOverrideContext {\n  [key: string]: unknown;\n\n  readonly $synthetic?: true;\n  readonly $observers?: ObserversLookup<IOverrideContext>;\n  readonly bindingContext: IBindingContext;\n  readonly parentOverrideContext: IOverrideContext | null;\n  getObservers(): ObserversLookup<IOverrideContext>;\n}\n\nexport interface IScope {\n  readonly bindingContext: IBindingContext;\n  readonly overrideContext: IOverrideContext;\n  // parentScope is strictly internal API and mainly for replaceable template controller.\n  // NOT intended for regular scope traversal!\n  /** @internal */readonly parentScope: IScope | null;\n}\n\n// TODO: currently unused, still need to fix the observersLookup type\nexport interface IObserversLookup<TObj extends IIndexable = IIndexable, TKey extends keyof TObj =\n  Exclude<keyof TObj, '$synthetic' | '$observers' | 'bindingContext' | 'overrideContext' | 'parentOverrideContext'>> { }\n\nexport type ObserversLookup<TObj extends IIndexable = IIndexable, TKey extends keyof TObj =\n  Exclude<keyof TObj, '$synthetic' | '$observers' | 'bindingContext' | 'overrideContext' | 'parentOverrideContext'>> =\n  { [P in TKey]: PropertyObserver; } & { getOrCreate(obj: IBindingContext | IOverrideContext, key: string): PropertyObserver };\n\nexport type IObservable = IIndexable & {\n  readonly $synthetic?: false;\n  $observers?: Record<string, AccessorOrObserver>;\n};\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import {\n  IBatchedCollectionSubscriber,\n  IBatchedSubscriberCollection,\n  IndexMap,\n  IPropertySubscriber,\n  ISubscriberCollection,\n  LifecycleFlags,\n  MutationKind,\n  MutationKindToBatchedSubscriber,\n  MutationKindToSubscriber,\n  SubscriberFlags\n} from '../observation';\n\nexport function subscriberCollection<T extends MutationKind>(mutationKind: T): ClassDecorator {\n  return function(target: Function): void {\n    const proto = target.prototype as ISubscriberCollection<MutationKind.instance | MutationKind.collection>;\n\n    proto._subscriberFlags = SubscriberFlags.None;\n    proto._subscriber0 = null;\n    proto._subscriber1 = null;\n    proto._subscriber2 = null;\n    proto._subscribersRest = null;\n\n    proto.addSubscriber = addSubscriber;\n    proto.removeSubscriber = removeSubscriber;\n    proto.hasSubscriber = hasSubscriber;\n    proto.hasSubscribers = hasSubscribers;\n    proto.callSubscribers = (mutationKind === MutationKind.instance ? callPropertySubscribers : callCollectionSubscribers);\n  };\n}\n\nfunction addSubscriber<T extends MutationKind>(this: ISubscriberCollection<T>, subscriber: MutationKindToSubscriber<T>): boolean {\n  if (this.hasSubscriber(subscriber)) {\n    return false;\n  }\n  const subscriberFlags = this._subscriberFlags;\n  if (!(subscriberFlags & SubscriberFlags.Subscriber0)) {\n    this._subscriber0 = subscriber;\n    this._subscriberFlags |= SubscriberFlags.Subscriber0;\n    return true;\n  }\n  if (!(subscriberFlags & SubscriberFlags.Subscriber1)) {\n    this._subscriber1 = subscriber;\n    this._subscriberFlags |= SubscriberFlags.Subscriber1;\n    return true;\n  }\n  if (!(subscriberFlags & SubscriberFlags.Subscriber2)) {\n    this._subscriber2 = subscriber;\n    this._subscriberFlags |= SubscriberFlags.Subscriber2;\n    return true;\n  }\n  if (!(subscriberFlags & SubscriberFlags.SubscribersRest)) {\n    this._subscribersRest = [subscriber];\n    this._subscriberFlags |= SubscriberFlags.SubscribersRest;\n    return true;\n  }\n  this._subscribersRest.push(subscriber);\n  return true;\n}\n\nfunction removeSubscriber<T extends MutationKind>(this: ISubscriberCollection<T>, subscriber: IPropertySubscriber): boolean {\n  const subscriberFlags = this._subscriberFlags;\n  if ((subscriberFlags & SubscriberFlags.Subscriber0) && this._subscriber0 === subscriber) {\n    this._subscriber0 = null;\n    this._subscriberFlags &= ~SubscriberFlags.Subscriber0;\n    return true;\n  }\n  if ((subscriberFlags & SubscriberFlags.Subscriber1) && this._subscriber1 === subscriber) {\n    this._subscriber1 = null;\n    this._subscriberFlags &= ~SubscriberFlags.Subscriber1;\n    return true;\n  }\n  if ((subscriberFlags & SubscriberFlags.Subscriber2) && this._subscriber2 === subscriber) {\n    this._subscriber2 = null;\n    this._subscriberFlags &= ~SubscriberFlags.Subscriber2;\n    return true;\n  }\n  if (subscriberFlags & SubscriberFlags.SubscribersRest) {\n    const subscribers = this._subscribersRest;\n    for (let i = 0, ii = subscribers.length; i < ii; ++i) {\n      if (subscribers[i] === subscriber) {\n        subscribers.splice(i, 1);\n        if (ii === 1) {\n          this._subscriberFlags &= ~SubscriberFlags.SubscribersRest;\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction callPropertySubscribers(\n  this: ISubscriberCollection<MutationKind.instance>,\n  newValue: unknown,\n  previousValue: unknown,\n  flags: LifecycleFlags): void {\n  /**\n   * Note: change handlers may have the side-effect of adding/removing subscribers to this collection during this\n   * callSubscribers invocation, so we're caching them all before invoking any.\n   * Subscribers added during this invocation are not invoked (and they shouldn't be).\n   * Subscribers removed during this invocation will still be invoked (and they also shouldn't be,\n   * however this is accounted for via $isBound and similar flags on the subscriber objects)\n   */\n  const subscriber0 = this._subscriber0;\n  const subscriber1 = this._subscriber1;\n  const subscriber2 = this._subscriber2;\n  let subscribers = this._subscribersRest;\n  if (subscribers !== null) {\n    subscribers = subscribers.slice();\n  }\n  if (subscriber0 !== null) {\n    subscriber0.handleChange(newValue, previousValue, flags);\n  }\n  if (subscriber1 !== null) {\n    subscriber1.handleChange(newValue, previousValue, flags);\n  }\n  if (subscriber2 !== null) {\n    subscriber2.handleChange(newValue, previousValue, flags);\n  }\n  const length = subscribers && subscribers.length;\n  if (length !== undefined && length > 0) {\n    for (let i = 0; i < length; ++i) {\n      const subscriber = subscribers[i];\n      if (subscriber !== null) {\n        subscriber.handleChange(newValue, previousValue, flags);\n      }\n    }\n  }\n}\n\nfunction callCollectionSubscribers(this: ISubscriberCollection<MutationKind.collection> & Required<IBatchedSubscriberCollection<MutationKind.collection>>, origin: string, args: IArguments | null, flags: LifecycleFlags): void {\n  const subscriber0 = this._subscriber0;\n  const subscriber1 = this._subscriber1;\n  const subscriber2 = this._subscriber2;\n  let subscribers = this._subscribersRest;\n  if (subscribers !== null) {\n    subscribers = subscribers.slice();\n  }\n  if (subscriber0 !== null) {\n    subscriber0.handleChange(origin, args, flags);\n  }\n  if (subscriber1 !== null) {\n    subscriber1.handleChange(origin, args, flags);\n  }\n  if (subscriber2 !== null) {\n    subscriber2.handleChange(origin, args, flags);\n  }\n  const length = subscribers && subscribers.length;\n  if (length !== undefined && length > 0) {\n    for (let i = 0; i < length; ++i) {\n      const subscriber = subscribers[i];\n      if (subscriber !== null) {\n        subscriber.handleChange(origin, args, flags);\n      }\n    }\n  }\n  this.lifecycle.enqueueFlush(this).catch(error => { throw error; });\n}\n\nfunction hasSubscribers<T extends MutationKind>(this: ISubscriberCollection<T>): boolean {\n  return this._subscriberFlags !== SubscriberFlags.None;\n}\n\nfunction hasSubscriber<T extends MutationKind>(this: ISubscriberCollection<T>, subscriber: IPropertySubscriber): boolean {\n  // Flags here is just a perf tweak\n  // Compared to not using flags, it's a moderate speed-up when this collection does not have the subscriber;\n  // and minor slow-down when it does, and the former is more common than the latter.\n  const subscriberFlags = this._subscriberFlags;\n  if ((subscriberFlags & SubscriberFlags.Subscriber0) && this._subscriber0 === subscriber) {\n    return true;\n  }\n  if ((subscriberFlags & SubscriberFlags.Subscriber1) && this._subscriber1 === subscriber) {\n    return true;\n  }\n  if ((subscriberFlags & SubscriberFlags.Subscriber2) && this._subscriber2 === subscriber) {\n    return true;\n  }\n  if (subscriberFlags & SubscriberFlags.SubscribersRest) {\n    // no need to check length; if the flag is set, there's always at least one\n    const subscribers = this._subscribersRest;\n    for (let i = 0, ii = subscribers.length; i < ii; ++i) {\n      if (subscribers[i] === subscriber) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nexport function batchedSubscriberCollection(): ClassDecorator {\n  return function(target: Function): void {\n    const proto = target.prototype as IBatchedSubscriberCollection<MutationKind.collection>;\n\n    proto._batchedSubscriberFlags = SubscriberFlags.None;\n    proto._batchedSubscriber0 = null;\n    proto._batchedSubscriber1 = null;\n    proto._batchedSubscriber2 = null;\n    proto._batchedSubscribersRest = null;\n\n    proto.addBatchedSubscriber = addBatchedSubscriber;\n    proto.removeBatchedSubscriber = removeBatchedSubscriber;\n    proto.hasBatchedSubscriber = hasBatchedSubscriber;\n    proto.hasBatchedSubscribers = hasBatchedSubscribers;\n    proto.callBatchedSubscribers = callBatchedCollectionSubscribers;\n  };\n}\n\nfunction addBatchedSubscriber(this: IBatchedSubscriberCollection<MutationKind.collection>, subscriber: MutationKindToBatchedSubscriber<MutationKind.collection>): boolean {\n  if (this.hasBatchedSubscriber(subscriber)) {\n    return false;\n  }\n  const subscriberFlags = this._batchedSubscriberFlags;\n  if (!(subscriberFlags & SubscriberFlags.Subscriber0)) {\n    this._batchedSubscriber0 = subscriber;\n    this._batchedSubscriberFlags |= SubscriberFlags.Subscriber0;\n    return true;\n  }\n  if (!(subscriberFlags & SubscriberFlags.Subscriber1)) {\n    this._batchedSubscriber1 = subscriber;\n    this._batchedSubscriberFlags |= SubscriberFlags.Subscriber1;\n    return true;\n  }\n  if (!(subscriberFlags & SubscriberFlags.Subscriber2)) {\n    this._batchedSubscriber2 = subscriber;\n    this._batchedSubscriberFlags |= SubscriberFlags.Subscriber2;\n    return true;\n  }\n  if (!(subscriberFlags & SubscriberFlags.SubscribersRest)) {\n    this._batchedSubscribersRest = [subscriber];\n    this._batchedSubscriberFlags |= SubscriberFlags.SubscribersRest;\n    return true;\n  }\n  this._batchedSubscribersRest.push(subscriber);\n  return true;\n}\n\nfunction removeBatchedSubscriber(this: IBatchedSubscriberCollection<MutationKind.collection>, subscriber: IBatchedCollectionSubscriber): boolean {\n  const subscriberFlags = this._batchedSubscriberFlags;\n  if ((subscriberFlags & SubscriberFlags.Subscriber0) && this._batchedSubscriber0 === subscriber) {\n    this._batchedSubscriber0 = null;\n    this._batchedSubscriberFlags &= ~SubscriberFlags.Subscriber0;\n    return true;\n  }\n  if ((subscriberFlags & SubscriberFlags.Subscriber1) && this._batchedSubscriber1 === subscriber) {\n    this._batchedSubscriber1 = null;\n    this._batchedSubscriberFlags &= ~SubscriberFlags.Subscriber1;\n    return true;\n  }\n  if ((subscriberFlags & SubscriberFlags.Subscriber2) && this._batchedSubscriber2 === subscriber) {\n    this._batchedSubscriber2 = null;\n    this._batchedSubscriberFlags &= ~SubscriberFlags.Subscriber2;\n    return true;\n  }\n  if (subscriberFlags & SubscriberFlags.SubscribersRest) {\n    const subscribers = this._batchedSubscribersRest;\n    for (let i = 0, ii = subscribers.length; i < ii; ++i) {\n      if (subscribers[i] === subscriber) {\n        subscribers.splice(i, 1);\n        if (ii === 1) {\n          this._batchedSubscriberFlags &= ~SubscriberFlags.SubscribersRest;\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction callBatchedCollectionSubscribers(this: IBatchedSubscriberCollection<MutationKind.collection>, indexMap: IndexMap): void {\n  const subscriber0 = this._batchedSubscriber0;\n  const subscriber1 = this._batchedSubscriber1;\n  const subscriber2 = this._batchedSubscriber2;\n  let subscribers = this._batchedSubscribersRest;\n  if (subscribers !== null) {\n    subscribers = subscribers.slice();\n  }\n  if (subscriber0 !== null) {\n    subscriber0.handleBatchedChange(indexMap);\n  }\n  if (subscriber1 !== null) {\n    subscriber1.handleBatchedChange(indexMap);\n  }\n  if (subscriber2 !== null) {\n    subscriber2.handleBatchedChange(indexMap);\n  }\n  const length = subscribers && subscribers.length;\n  if (length !== undefined && length > 0) {\n    for (let i = 0; i < length; ++i) {\n      const subscriber = subscribers[i];\n      if (subscriber !== null) {\n        subscriber.handleBatchedChange(indexMap);\n      }\n    }\n  }\n}\n\nfunction hasBatchedSubscribers(this: IBatchedSubscriberCollection<MutationKind.collection>): boolean {\n  return this._batchedSubscriberFlags !== SubscriberFlags.None;\n}\n\nfunction hasBatchedSubscriber(this: IBatchedSubscriberCollection<MutationKind.collection>, subscriber: IBatchedCollectionSubscriber): boolean {\n  // Flags here is just a perf tweak\n  // Compared to not using flags, it's a moderate speed-up when this collection does not have the subscriber;\n  // and minor slow-down when it does, and the former is more common than the latter.\n  const subscriberFlags = this._batchedSubscriberFlags;\n  if ((subscriberFlags & SubscriberFlags.Subscriber0) && this._batchedSubscriber0 === subscriber) {\n    return true;\n  }\n  if ((subscriberFlags & SubscriberFlags.Subscriber1) && this._batchedSubscriber1 === subscriber) {\n    return true;\n  }\n  if ((subscriberFlags & SubscriberFlags.Subscriber2) && this._batchedSubscriber2 === subscriber) {\n    return true;\n  }\n  if (subscriberFlags & SubscriberFlags.SubscribersRest) {\n    // no need to check length; if the flag is set, there's always at least one\n    const subscribers = this._batchedSubscribersRest;\n    for (let i = 0, ii = subscribers.length; i < ii; ++i) {\n      if (subscribers[i] === subscriber) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n","import { Reporter } from '@aurelia/kernel';\nimport { IPropertySubscriber, LifecycleFlags, MutationKind, PropertyObserver } from '../observation';\nimport { subscriberCollection } from './subscriber-collection';\n\nconst defineProperty = Reflect.defineProperty;\n// note: we're reusing the same object for setting all descriptors, just changing some properties as needed\n//   this works, because the properties are copied by defineProperty (so changing them afterwards doesn't affect existing descriptors)\n// see also: https://tc39.github.io/ecma262/#sec-topropertydescriptor\nconst observedPropertyDescriptor: PropertyDescriptor = {\n  get: undefined,\n  set: undefined,\n  enumerable: true,\n  configurable: true\n};\n\nfunction subscribe(this: PropertyObserver, subscriber: IPropertySubscriber): void {\n  if (this.observing === false) {\n    this.observing = true;\n    const { obj, propertyKey } = this;\n    this.currentValue = obj[propertyKey];\n    observedPropertyDescriptor.get = () => this.getValue();\n    observedPropertyDescriptor.set = value => { this.setValue(value, LifecycleFlags.updateTargetInstance); };\n    if (!defineProperty(obj, propertyKey, observedPropertyDescriptor)) {\n      Reporter.write(1, propertyKey, obj);\n    }\n  }\n  this.addSubscriber(subscriber);\n}\n\nfunction dispose(this: PropertyObserver): void {\n  delete this.obj[this.propertyKey];\n  this.obj = null;\n  this.propertyKey = null;\n  this.currentValue = null;\n}\n\nexport function propertyObserver(): ClassDecorator {\n  return function(target: Function): void {\n    subscriberCollection(MutationKind.instance)(target);\n    const proto = target.prototype as PropertyObserver;\n\n    proto.observing = false;\n    proto.obj = null;\n    proto.propertyKey = null;\n    // Note: this will generate some \"false positive\" changes when setting a target undefined from a source undefined,\n    // but those aren't harmful because the changes won't be propagated through to subscribers during $bind anyway.\n    // It will, however, solve some \"false negative\" changes when the source value is undefined but the target value is not;\n    // in such cases, this.currentValue in the observer being undefined will block the change from propagating to the target.\n    // This is likely not working correctly in vCurrent either.\n    proto.currentValue = Symbol();\n\n    proto.subscribe = proto.subscribe || subscribe;\n    proto.unsubscribe = proto.unsubscribe || proto.removeSubscriber;\n\n    proto.dispose = proto.dispose || dispose;\n  };\n}\n","import { IIndexable, PLATFORM, Primitive } from '@aurelia/kernel';\nimport { IAccessor, IPropertyObserver, IPropertySubscriber, ISubscribable, LifecycleFlags, MutationKind } from '../observation';\nimport { propertyObserver } from './property-observer';\n\nconst noop = PLATFORM.noop;\n\n// note: string.length is the only property of any primitive that is not a function,\n// so we can hardwire it to that and simply return undefined for anything else\n// note#2: a modified primitive constructor prototype would not work (and really, it shouldn't..)\nexport class PrimitiveObserver implements IAccessor, ISubscribable<MutationKind.instance> {\n  public getValue: () => undefined | number;\n  // removed the error reporter here because technically any primitive property that can get, can also set,\n  // but since that never serves any purpose (e.g. setting string.length doesn't throw but doesn't change the length either),\n  // we could best just leave this as a no-op and so don't need to store the propertyName\n  public setValue: () => void;\n  public subscribe: () => void;\n  public unsubscribe: () => void;\n  public dispose: () => void;\n\n  public doNotCache: boolean = true;\n  public obj: Primitive;\n\n  constructor(obj: Primitive, propertyKey: PropertyKey) {\n    // we don't need to store propertyName because only 'length' can return a useful value\n    if (propertyKey === 'length') {\n      // deliberately not checking for typeof string as users probably still want to know via an error that their string is undefined\n      this.obj = obj;\n      this.getValue = this.getStringLength;\n    } else {\n      this.getValue = this.returnUndefined;\n    }\n  }\n\n  private getStringLength(): number {\n    return (this.obj as string).length;\n  }\n  private returnUndefined(): undefined {\n    return undefined;\n  }\n}\nPrimitiveObserver.prototype.setValue = noop;\nPrimitiveObserver.prototype.subscribe = noop;\nPrimitiveObserver.prototype.unsubscribe = noop;\nPrimitiveObserver.prototype.dispose = noop;\n\nexport interface SetterObserver extends IPropertyObserver<IIndexable, string> {}\n\n@propertyObserver()\nexport class SetterObserver implements SetterObserver {\n  public subscribe: (subscriber: IPropertySubscriber) => void;\n  public unsubscribe: (subscriber: IPropertySubscriber) => void;\n  public obj: IIndexable;\n  public propertyKey: string;\n\n  constructor(obj: IIndexable, propertyKey: string) {\n    this.obj = obj;\n    this.propertyKey = propertyKey;\n  }\n\n  public getValue(): unknown {\n    return this.currentValue;\n  }\n  public setValue(newValue: unknown, flags: LifecycleFlags): void {\n    const currentValue = this.currentValue;\n    if (currentValue !== newValue) {\n      this.currentValue = newValue;\n      if (!(flags & LifecycleFlags.fromBind)) {\n        this.callSubscribers(newValue, currentValue, flags);\n      }\n      // If subscribe() has been called, the target property descriptor is replaced by these getter/setter methods,\n      // so calling obj[propertyKey] will actually return this.currentValue.\n      // However, if subscribe() was not yet called (indicated by !this.observing), the target descriptor\n      // is unmodified and we need to explicitly set the property value.\n      // This will happen in one-time, to-view and two-way bindings during $bind, meaning that the $bind will not actually update the target value.\n      // This wasn't visible in vCurrent due to connect-queue always doing a delayed update, so in many cases it didn't matter whether $bind updated the target or not.\n      if (!this.observing) {\n        this.obj[this.propertyKey] = newValue;\n      }\n    }\n  }\n}\n\nexport interface Observer extends IPropertyObserver<IIndexable, string> {}\n\n@propertyObserver()\nexport class Observer implements Observer {\n  public obj: IIndexable;\n  public propertyKey: string;\n  public currentValue: unknown;\n\n  private callback: (newValue: unknown, oldValue: unknown) => unknown;\n\n  constructor(\n    instance: object,\n    propertyName: string,\n    callbackName: string\n  ) {\n      this.obj = instance;\n      this.propertyKey = propertyName;\n      this.currentValue = instance[propertyName];\n      this.callback = callbackName in instance\n        ? instance[callbackName].bind(instance)\n        : noop;\n  }\n\n  public getValue(): unknown {\n    return this.currentValue;\n  }\n\n  public setValue(newValue: unknown, flags: LifecycleFlags): void {\n    const currentValue = this.currentValue;\n\n    if (currentValue !== newValue) {\n      this.currentValue = newValue;\n\n      if (!(flags & LifecycleFlags.fromBind)) {\n        const coercedValue = this.callback(newValue, currentValue);\n\n        if (coercedValue !== undefined) {\n          this.currentValue = newValue = coercedValue;\n        }\n\n        this.callSubscribers(newValue, currentValue, flags);\n      }\n    }\n  }\n}\n","import { IIndexable, Reporter, StrictPrimitive, Tracer } from '@aurelia/kernel';\nimport { IBindScope } from '../lifecycle';\nimport {\n  IBindingContext,\n  IOverrideContext,\n  IScope,\n  LifecycleFlags,\n  ObservedCollection,\n  ObserversLookup,\n  PropertyObserver\n} from '../observation';\nimport { SetterObserver } from './property-observation';\n\nconst slice = Array.prototype.slice;\n\nconst enum RuntimeError {\n  UndefinedScope = 250, // trying to evaluate on something that's not a valid binding\n  NullScope = 251, // trying to evaluate on an unbound binding\n  NilOverrideContext = 252,\n  NilParentScope = 253\n}\n\n/** @internal */\nexport class InternalObserversLookup {\n  public getOrCreate(obj: IBindingContext | IOverrideContext, key: string): PropertyObserver {\n    if (Tracer.enabled) { Tracer.enter('InternalObserversLookup.getOrCreate', slice.call(arguments)); }\n    let observer = this[key];\n    if (observer === undefined) {\n      observer = this[key] = new SetterObserver(obj, key);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return observer;\n  }\n}\n\ntype BindingContextValue = ObservedCollection | StrictPrimitive | IIndexable;\n\nexport class BindingContext implements IBindingContext {\n  [key: string]: BindingContextValue;\n\n  public readonly $synthetic: true;\n\n  public $observers: ObserversLookup<IOverrideContext>;\n\n  private constructor(keyOrObj?: string | IIndexable, value?: BindingContextValue) {\n    this.$synthetic = true;\n\n    if (keyOrObj !== undefined) {\n      if (value !== undefined) {\n        // if value is defined then it's just a property and a value to initialize with\n        this[keyOrObj as string] = value;\n      } else {\n        // can either be some random object or another bindingContext to clone from\n        for (const prop in keyOrObj as IIndexable) {\n          if (keyOrObj.hasOwnProperty(prop)) {\n            this[prop] = keyOrObj[prop];\n          }\n        }\n      }\n    }\n  }\n\n  public static create(obj?: IIndexable): BindingContext;\n  public static create(key: string, value: BindingContextValue): BindingContext;\n  public static create(keyOrObj?: string | IIndexable, value?: BindingContextValue): BindingContext {\n    return new BindingContext(keyOrObj, value);\n  }\n\n  public static get(scope: IScope, name: string, ancestor: number, flags: LifecycleFlags): IBindingContext | IOverrideContext | IBindScope {\n    if (Tracer.enabled) { Tracer.enter('BindingContext.get', slice.call(arguments)); }\n    if (scope === undefined) {\n      throw Reporter.error(RuntimeError.UndefinedScope);\n    }\n    if (scope === null) {\n      throw Reporter.error(RuntimeError.NullScope);\n    }\n    let overrideContext = scope.overrideContext;\n\n    if (ancestor > 0) {\n      // jump up the required number of ancestor contexts (eg $parent.$parent requires two jumps)\n      while (ancestor > 0) {\n        if (overrideContext.parentOverrideContext === null) {\n          if (Tracer.enabled) { Tracer.leave(); }\n          return undefined;\n        }\n        ancestor--;\n        overrideContext = overrideContext.parentOverrideContext;\n      }\n\n      if (Tracer.enabled) { Tracer.leave(); }\n      return name in overrideContext ? overrideContext : overrideContext.bindingContext;\n    }\n\n    // traverse the context and it's ancestors, searching for a context that has the name.\n    while (overrideContext && !(name in overrideContext) && !(overrideContext.bindingContext && name in overrideContext.bindingContext)) {\n      overrideContext = overrideContext.parentOverrideContext;\n    }\n\n    if (overrideContext) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      // we located a context with the property.  return it.\n      return name in overrideContext ? overrideContext : overrideContext.bindingContext;\n    }\n\n    // the name wasn't found. see if parent scope traversal is allowed and if so, try that\n    if ((flags & LifecycleFlags.allowParentScopeTraversal) && scope.parentScope !== null) {\n      const result = this.get(scope.parentScope, name, ancestor, flags\n        // unset the flag; only allow one level of scope boundary traversal\n        & ~LifecycleFlags.allowParentScopeTraversal\n        // tell the scope to return null if the name could not be found\n        | LifecycleFlags.isTraversingParentScope);\n      if (result !== null) {\n        if (Tracer.enabled) { Tracer.leave(); }\n        return result;\n      }\n    }\n\n    // still nothing found. return the root binding context (or null\n    // if this is a parent scope traversal, to ensure we fall back to the\n    // correct level)\n    if (flags & LifecycleFlags.isTraversingParentScope) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return null;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return scope.bindingContext || scope.overrideContext;\n  }\n\n  public getObservers(): ObserversLookup<IOverrideContext> {\n    if (Tracer.enabled) { Tracer.enter('BindingContext.getObservers', slice.call(arguments)); }\n    let observers = this.$observers;\n    if (observers === undefined) {\n      this.$observers = observers = new InternalObserversLookup() as ObserversLookup<this>;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return observers;\n  }\n}\n\nexport class Scope implements IScope {\n  public readonly bindingContext: IBindingContext | IBindScope;\n  public readonly overrideContext: IOverrideContext;\n  // parentScope is strictly internal API and mainly for replaceable template controller.\n  // NOT intended for regular scope traversal!\n  /** @internal */public readonly parentScope: IScope | null;\n\n  private constructor(bindingContext: IBindingContext | IBindScope, overrideContext: IOverrideContext) {\n    this.bindingContext = bindingContext;\n    this.overrideContext = overrideContext;\n    this.parentScope = null;\n  }\n\n  public static create(bc: IBindingContext | IBindScope, oc: IOverrideContext | null): Scope {\n    if (Tracer.enabled) { Tracer.enter('Scope.create', slice.call(arguments)); }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return new Scope(bc, oc === null || oc === undefined ? OverrideContext.create(bc, oc) : oc);\n  }\n\n  public static fromOverride(oc: IOverrideContext): Scope {\n    if (Tracer.enabled) { Tracer.enter('Scope.fromOverride', slice.call(arguments)); }\n    if (oc === null || oc === undefined) {\n      throw Reporter.error(RuntimeError.NilOverrideContext);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return new Scope(oc.bindingContext, oc);\n  }\n\n  public static fromParent(ps: IScope | null, bc: IBindingContext | IBindScope): Scope {\n    if (Tracer.enabled) { Tracer.enter('Scope.fromParent', slice.call(arguments)); }\n    if (ps === null || ps === undefined) {\n      throw Reporter.error(RuntimeError.NilParentScope);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return new Scope(bc, OverrideContext.create(bc, ps.overrideContext));\n  }\n}\n\nexport class OverrideContext implements IOverrideContext {\n  [key: string]: ObservedCollection | StrictPrimitive | IIndexable;\n\n  public readonly $synthetic: true;\n  public readonly bindingContext: IBindingContext | IBindScope;\n  public readonly parentOverrideContext: IOverrideContext | null;\n\n  private constructor(bindingContext: IBindingContext | IBindScope, parentOverrideContext: IOverrideContext | null) {\n    this.$synthetic = true;\n    this.bindingContext = bindingContext;\n    this.parentOverrideContext = parentOverrideContext;\n  }\n\n  public static create(bc: IBindingContext | IBindScope, poc: IOverrideContext | null): OverrideContext {\n    if (Tracer.enabled) { Tracer.enter('OverrideContext.create', slice.call(arguments)); }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return new OverrideContext(bc, poc === undefined ? null : poc);\n  }\n\n  public getObservers(): ObserversLookup<IOverrideContext> {\n    if (Tracer.enabled) { Tracer.enter('OverrideContext.getObservers', slice.call(arguments)); }\n    let observers = this.$observers;\n    if (observers === undefined) {\n      this.$observers = observers = new InternalObserversLookup();\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return observers as ObserversLookup<IOverrideContext>;\n  }\n}\n","import { DI, Immutable } from '@aurelia/kernel';\nimport { IPropertySubscriber, LifecycleFlags } from '../observation';\n\ntype Signal = string;\n\nexport interface ISignaler {\n  signals: Immutable<Record<string, Set<IPropertySubscriber>>>;\n  dispatchSignal(name: Signal, flags?: LifecycleFlags): void;\n  addSignalListener(name: Signal, listener: IPropertySubscriber): void;\n  removeSignalListener(name: Signal, listener: IPropertySubscriber): void;\n}\n\nexport const ISignaler = DI.createInterface<ISignaler>().withDefault(x => x.singleton(Signaler));\n\n/** @internal */\nexport class Signaler implements ISignaler {\n  public signals: Record<string, Set<IPropertySubscriber>>;\n\n  constructor() {\n    this.signals = Object.create(null);\n  }\n\n  public dispatchSignal(name: Signal, flags?: LifecycleFlags): void {\n    const listeners = this.signals[name];\n    if (listeners === undefined) {\n      return;\n    }\n    for (const listener of listeners.keys()) {\n      listener.handleChange(undefined, undefined, flags | LifecycleFlags.updateTargetInstance);\n    }\n  }\n\n  public addSignalListener(name: Signal, listener: IPropertySubscriber): void {\n    const signals = this.signals;\n    const listeners = signals[name];\n    if (listeners === undefined) {\n      signals[name] = new Set([listener]);\n    } else {\n      listeners.add(listener);\n    }\n  }\n\n  public removeSignalListener(name: Signal, listener: IPropertySubscriber): void {\n    const listeners = this.signals[name];\n    if (listeners) {\n      listeners.delete(listener);\n    }\n  }\n}\n","import {\n  Class,\n  Constructable,\n  IContainer,\n  IResourceDefinition,\n  IResourceKind,\n  IResourceType,\n  Registration,\n  Writable\n} from '@aurelia/kernel';\nimport { IBinding } from '../binding/binding';\nimport { IScope, LifecycleFlags } from '../observation';\n\nexport interface IBindingBehavior {\n  bind(flags: LifecycleFlags, scope: IScope, binding: IBinding): void;\n  unbind(flags: LifecycleFlags, scope: IScope, binding: IBinding): void;\n}\n\nexport interface IBindingBehaviorDefinition extends IResourceDefinition { }\n\nexport interface IBindingBehaviorType extends IResourceType<IBindingBehaviorDefinition, IBindingBehavior> { }\n\nexport interface IBindingBehaviorResource extends\n  IResourceKind<IBindingBehaviorDefinition, IBindingBehavior, Class<IBindingBehavior>> {\n}\n\ntype BindingBehaviorDecorator = <TProto, TClass>(target: Class<TProto, TClass> & Partial<IBindingBehaviorType>) => Class<TProto, TClass> & IBindingBehaviorType;\n\nfunction register(this: IBindingBehaviorType, container: IContainer): void {\n  const resourceKey = BindingBehaviorResource.keyFrom(this.description.name);\n  container.register(Registration.singleton(resourceKey, this));\n}\n\nexport function bindingBehavior(name: string): BindingBehaviorDecorator;\nexport function bindingBehavior(definition: IBindingBehaviorDefinition): BindingBehaviorDecorator;\nexport function bindingBehavior(nameOrDefinition: string | IBindingBehaviorDefinition): BindingBehaviorDecorator {\n  return target => BindingBehaviorResource.define(nameOrDefinition, target);\n}\n\nfunction keyFrom(this: IBindingBehaviorResource, name: string): string {\n  return `${this.name}:${name}`;\n}\n\nfunction isType<T>(this: IBindingBehaviorResource, Type: T & Partial<IBindingBehaviorType>): Type is T & IBindingBehaviorType {\n  return Type.kind === this;\n}\n\nfunction define<T extends Constructable>(this: IBindingBehaviorResource, name: string, ctor: T): T & IBindingBehaviorType;\nfunction define<T extends Constructable>(this: IBindingBehaviorResource, ndefinition: IBindingBehaviorDefinition, ctor: T): T & IBindingBehaviorType;\nfunction define<T extends Constructable>(this: IBindingBehaviorResource, nameOrDefinition: string | IBindingBehaviorDefinition, ctor: T): T & IBindingBehaviorType {\n  const Type = ctor as T & Writable<IBindingBehaviorType>;\n  const description = typeof nameOrDefinition === 'string'\n    ? { name: nameOrDefinition }\n    : nameOrDefinition;\n\n  Type.kind = BindingBehaviorResource;\n  Type.description = description;\n  Type.register = register;\n\n  return Type;\n}\n\nexport const BindingBehaviorResource: IBindingBehaviorResource = {\n  name: 'binding-behavior',\n  keyFrom,\n  isType,\n  define\n};\n","import {\n  Class,\n  Constructable,\n  IContainer,\n  IResourceDefinition,\n  IResourceKind,\n  IResourceType,\n  Registration,\n  Writable\n} from '@aurelia/kernel';\n\nexport interface IValueConverter {\n  toView(input: unknown, ...args: unknown[]): unknown;\n  fromView?(input: unknown, ...args: unknown[]): unknown;\n}\n\nexport interface IValueConverterDefinition extends IResourceDefinition { }\n\nexport interface IValueConverterType extends IResourceType<IValueConverterDefinition, IValueConverter> { }\n\nexport interface IValueConverterResource extends\n  IResourceKind<IValueConverterDefinition, IValueConverter, Class<IValueConverter>> { }\n\ntype ValueConverterDecorator = <TProto, TClass>(target: Class<TProto, TClass> & Partial<IValueConverterType>) => Class<TProto, TClass> & IValueConverterType;\n\nfunction register(this: IValueConverterType, container: IContainer): void {\n  const resourceKey = this.kind.keyFrom(this.description.name);\n  container.register(Registration.singleton(resourceKey, this));\n}\n\nexport function valueConverter(name: string): ValueConverterDecorator;\nexport function valueConverter(definition: IValueConverterDefinition): ValueConverterDecorator;\nexport function valueConverter(nameOrDefinition: string | IValueConverterDefinition): ValueConverterDecorator {\n  return target => ValueConverterResource.define(nameOrDefinition, target);\n}\n\nfunction keyFrom(this: IValueConverterResource, name: string): string {\n  return `${this.name}:${name}`;\n}\n\nfunction isType<T>(this: IValueConverterResource, Type: T & Partial<IValueConverterType>): Type is T & IValueConverterType {\n  return Type.kind === this;\n}\n\nfunction define<T extends Constructable>(this: IValueConverterResource, name: string, ctor: T): T & IValueConverterType;\nfunction define<T extends Constructable>(this: IValueConverterResource, ndefinition: IValueConverterDefinition, ctor: T): T & IValueConverterType;\nfunction define<T extends Constructable>(this: IValueConverterResource, nameOrDefinition: string | IValueConverterDefinition, ctor: T): T & IValueConverterType {\n  const Type = ctor as T & Writable<IValueConverterType>;\n  const description = typeof nameOrDefinition === 'string'\n    ? { name: nameOrDefinition }\n    : nameOrDefinition;\n\n  Type.kind = ValueConverterResource;\n  Type.description = description;\n  Type.register = register;\n\n  return Type;\n}\n\nexport const ValueConverterResource: IValueConverterResource = {\n  name: 'value-converter',\n  keyFrom,\n  isType,\n  define\n};\n","import { IIndexable, IServiceLocator, PLATFORM, Reporter, StrictPrimitive } from '@aurelia/kernel';\nimport { IBindScope } from '../lifecycle';\nimport { Collection, IBindingContext, IOverrideContext, IScope, LifecycleFlags, ObservedCollection } from '../observation';\nimport { BindingContext } from '../observation/binding-context';\nimport { ISignaler } from '../observation/signaler';\nimport { BindingBehaviorResource } from '../resources/binding-behavior';\nimport { IValueConverter, ValueConverterResource } from '../resources/value-converter';\nimport { IBinding } from './binding';\nimport { IConnectableBinding } from './connectable';\n\nexport type IsPrimary = AccessThis | AccessScope | ArrayLiteral | ObjectLiteral | PrimitiveLiteral | Template;\nexport type IsLiteral = ArrayLiteral | ObjectLiteral | PrimitiveLiteral | Template;\nexport type IsLeftHandSide = IsPrimary | CallFunction | CallMember | CallScope | AccessMember | AccessKeyed | TaggedTemplate;\nexport type IsUnary = IsLeftHandSide | Unary;\nexport type IsBinary = IsUnary | Binary;\nexport type IsConditional = IsBinary | Conditional;\nexport type IsAssign = IsConditional | Assign;\nexport type IsValueConverter = IsAssign | ValueConverter;\nexport type IsBindingBehavior = IsValueConverter | BindingBehavior;\nexport type IsAssignable = AccessScope | AccessKeyed | AccessMember | Assign;\nexport type IsExpression = IsBindingBehavior | Interpolation;\nexport type IsExpressionOrStatement = IsExpression | ForOfStatement | BindingIdentifierOrPattern | HtmlLiteral;\nexport type Connects = AccessScope | ArrayLiteral | ObjectLiteral | Template | Unary | CallScope | AccessMember | AccessKeyed | TaggedTemplate | Binary | Conditional | ValueConverter | BindingBehavior | ForOfStatement;\nexport type Observes = AccessScope | AccessKeyed | AccessMember;\nexport type CallsFunction = CallFunction | CallScope | CallMember | TaggedTemplate;\nexport type IsResource = ValueConverter | BindingBehavior;\nexport type HasBind = BindingBehavior;\nexport type HasUnbind = ValueConverter | BindingBehavior;\nexport type HasAncestor = AccessThis | AccessScope | CallScope;\n\nexport interface IVisitor<T = unknown> {\n  visitAccessKeyed(expr: AccessKeyed): T;\n  visitAccessMember(expr: AccessMember): T;\n  visitAccessScope(expr: AccessScope): T;\n  visitAccessThis(expr: AccessThis): T;\n  visitArrayBindingPattern(expr: ArrayBindingPattern): T;\n  visitArrayLiteral(expr: ArrayLiteral): T;\n  visitAssign(expr: Assign): T;\n  visitBinary(expr: Binary): T;\n  visitBindingBehavior(expr: BindingBehavior): T;\n  visitBindingIdentifier(expr: BindingIdentifier): T;\n  visitCallFunction(expr: CallFunction): T;\n  visitCallMember(expr: CallMember): T;\n  visitCallScope(expr: CallScope): T;\n  visitConditional(expr: Conditional): T;\n  visitForOfStatement(expr: ForOfStatement): T;\n  visitHtmlLiteral(expr: HtmlLiteral): T;\n  visitInterpolation(expr: Interpolation): T;\n  visitObjectBindingPattern(expr: ObjectBindingPattern): T;\n  visitObjectLiteral(expr: ObjectLiteral): T;\n  visitPrimitiveLiteral(expr: PrimitiveLiteral): T;\n  visitTaggedTemplate(expr: TaggedTemplate): T;\n  visitTemplate(expr: Template): T;\n  visitUnary(expr: Unary): T;\n  visitValueConverter(expr: ValueConverter): T;\n}\n\nexport interface IExpression {\n  readonly $kind: ExpressionKind;\n  evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator | null): unknown;\n  connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void;\n  accept<T>(visitor: IVisitor<T>): T;\n  assign?(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator | null, value: unknown): unknown;\n  bind?(flags: LifecycleFlags, scope: IScope, binding: IBinding): void;\n  unbind?(flags: LifecycleFlags, scope: IScope, binding: IBinding): void;\n}\n\nexport const enum ExpressionKind {\n  Connects             = 0b000000000001_00000, // The expression's connect() function calls observeProperty and/or calls connect() on another expression that it wraps (all expressions except for AccessThis, PrimitiveLiteral, CallMember/Function and Assign)\n  Observes             = 0b000000000010_00000, // The expression's connect() function calls observeProperty (only AccessScope, AccessMember and AccessKeyed do this)\n  CallsFunction        = 0b000000000100_00000, // Calls a function (CallFunction, CallScope, CallMember, TaggedTemplate) -> needs a valid function object returning from its lefthandside's evaluate()\n  HasAncestor          = 0b000000001000_00000, // Has an \"ancestor\" property, meaning the expression could climb up the context (only AccessThis, AccessScope and CallScope)\n  IsPrimary            = 0b000000010000_00000, // Is a primary expression according to ES parsing rules\n  IsLeftHandSide       = 0b000000100000_00000, // Is a left-hand side expression according to ES parsing rules, includes IsPrimary\n  HasBind              = 0b000001000000_00000, // Has a bind() method (currently only BindingBehavior)\n  HasUnbind            = 0b000010000000_00000, // Has an unbind() method (currentl only BindingBehavior and ValueConverter)\n  IsAssignable         = 0b000100000000_00000, // Is an assignable expression according to ES parsing rules (only AccessScope, AccessMember, AccessKeyed ans Assign)\n  IsLiteral            = 0b001000000000_00000, // Is an Aurelia resource (ValueConverter or BindingBehavior)\n  IsResource           = 0b010000000000_00000, // Is literal expression (Primitive, Array, Object or Template)\n  IsForDeclaration     = 0b100000000000_00000, // Is a For declaration (for..of, for..in -> currently only ForOfStatement)\n  Type                 = 0b000000000000_11111, // Type mask to uniquely identify each AST class (concrete types start below)\n  // ---------------------------------------------------------------------------------------------------------------------------\n  AccessThis           = 0b000000111000_00001, //               HasAncestor\n  AccessScope          = 0b000100111011_00010, // IsAssignable  HasAncestor       Observes  Connects\n  ArrayLiteral         = 0b001000110001_00011, //                                           Connects\n  ObjectLiteral        = 0b001000110001_00100, //                                           Connects\n  PrimitiveLiteral     = 0b001000110000_00101, //\n  Template             = 0b001000110001_00110, //                                           Connects\n  Unary                = 0b000000000001_00111, //                                           Connects\n  CallScope            = 0b000000101101_01000, //               HasAncestor  CallsFunction  Connects\n  CallMember           = 0b000000100100_01001, //                            CallsFunction\n  CallFunction         = 0b000000100100_01010, //                            CallsFunction\n  AccessMember         = 0b000100100011_01011, // IsAssignable                    Observes  Connects\n  AccessKeyed          = 0b000100100011_01100, // IsAssignable                    Observes  Connects\n  TaggedTemplate       = 0b000000100101_01101, //                            CallsFunction  Connects\n  Binary               = 0b000000000001_01110, //                                           Connects\n  Conditional          = 0b000000000001_11111, //                                           Connects\n  Assign               = 0b000100000000_10000, // IsAssignable\n  ValueConverter       = 0b010010000001_10001, //                                           Connects\n  BindingBehavior      = 0b010011000001_10010, //                                           Connects\n  HtmlLiteral          = 0b000000000001_10011, //                                           Connects\n  ArrayBindingPattern  = 0b100000000000_10100, //\n  ObjectBindingPattern = 0b100000000000_10101, //\n  BindingIdentifier    = 0b100000000000_10110, //\n  ForOfStatement       = 0b000000000001_10111, //                                           Connects\n  Interpolation        = 0b000000000000_11000  //\n}\n\nexport function connects(expr: IsExpressionOrStatement): expr is Connects {\n  return (expr.$kind & ExpressionKind.Connects) === ExpressionKind.Connects;\n}\nexport function observes(expr: IsExpressionOrStatement): expr is Observes {\n  return (expr.$kind & ExpressionKind.Observes) === ExpressionKind.Observes;\n}\nexport function callsFunction(expr: IsExpressionOrStatement): expr is CallsFunction {\n  return (expr.$kind & ExpressionKind.CallsFunction) === ExpressionKind.CallsFunction;\n}\nexport function hasAncestor(expr: IsExpressionOrStatement): expr is HasAncestor {\n  return (expr.$kind & ExpressionKind.HasAncestor) === ExpressionKind.HasAncestor;\n}\nexport function isAssignable(expr: IsExpressionOrStatement): expr is IsAssignable {\n  return (expr.$kind & ExpressionKind.IsAssignable) === ExpressionKind.IsAssignable;\n}\nexport function isLeftHandSide(expr: IsExpressionOrStatement): expr is IsLeftHandSide {\n  return (expr.$kind & ExpressionKind.IsLeftHandSide) === ExpressionKind.IsLeftHandSide;\n}\nexport function isPrimary(expr: IsExpressionOrStatement): expr is IsPrimary {\n  return (expr.$kind & ExpressionKind.IsPrimary) === ExpressionKind.IsPrimary;\n}\nexport function isResource(expr: IsExpressionOrStatement): expr is IsResource {\n  return (expr.$kind & ExpressionKind.IsResource) === ExpressionKind.IsResource;\n}\nexport function hasBind(expr: IsExpressionOrStatement): expr is HasBind {\n  return (expr.$kind & ExpressionKind.HasBind) === ExpressionKind.HasBind;\n}\nexport function hasUnbind(expr: IsExpressionOrStatement): expr is HasUnbind {\n  return (expr.$kind & ExpressionKind.HasUnbind) === ExpressionKind.HasUnbind;\n}\nexport function isLiteral(expr: IsExpressionOrStatement): expr is IsLiteral {\n  return (expr.$kind & ExpressionKind.IsLiteral) === ExpressionKind.IsLiteral;\n}\nexport function arePureLiterals(expressions: ReadonlyArray<IsExpressionOrStatement> | undefined): expressions is IsLiteral[] {\n  if (expressions === undefined || expressions.length === 0) {\n    return true;\n  }\n  for (let i = 0; i < expressions.length; ++i) {\n    if (!isPureLiteral(expressions[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nexport function isPureLiteral(expr: IsExpressionOrStatement): expr is IsLiteral {\n  if (isLiteral(expr)) {\n    switch (expr.$kind) {\n      case ExpressionKind.ArrayLiteral:\n        return arePureLiterals(expr.elements);\n      case ExpressionKind.ObjectLiteral:\n        return arePureLiterals(expr.values);\n      case ExpressionKind.Template:\n        return arePureLiterals(expr.expressions);\n      case ExpressionKind.PrimitiveLiteral:\n        return true;\n    }\n  }\n  return false;\n}\n\nconst enum RuntimeError {\n  NoLocator = 202,\n  NoBehaviorFound = 203,\n  BehaviorAlreadyApplied = 204,\n  NoConverterFound = 205,\n  NoBinding = 206,\n  NotAFunction = 207,\n  UnknownOperator = 208,\n  UndefinedScope = 250, // trying to evaluate on something that's not a valid binding\n  NullScope = 251, // trying to evaluate on an unbound binding\n}\n\nexport class BindingBehavior implements IExpression {\n  public $kind: ExpressionKind.BindingBehavior;\n  public readonly expression: IsBindingBehavior;\n  public readonly name: string;\n  public readonly args: ReadonlyArray<IsAssign>;\n  public readonly behaviorKey: string;\n  private readonly expressionHasBind: boolean;\n  private readonly expressionHasUnbind: boolean;\n\n  constructor(expression: IsBindingBehavior, name: string, args: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.BindingBehavior;\n    this.expression = expression;\n    this.name = name;\n    this.args = args;\n    this.behaviorKey = BindingBehaviorResource.keyFrom(this.name);\n    this.expressionHasBind = hasBind(expression);\n    this.expressionHasUnbind = hasUnbind(expression);\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    return this.expression.evaluate(flags, scope, locator);\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, value: unknown): unknown {\n    return this.expression.assign(flags, scope, locator, value);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    this.expression.connect(flags, scope, binding);\n  }\n\n  public bind(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    if (scope === undefined) {\n      throw Reporter.error(RuntimeError.UndefinedScope, this);\n    }\n    if (scope === null) {\n      throw Reporter.error(RuntimeError.NullScope, this);\n    }\n    if (!binding) {\n      throw Reporter.error(RuntimeError.NoBinding, this);\n    }\n    const locator = binding.locator;\n    if (!locator) {\n      throw Reporter.error(RuntimeError.NoLocator, this);\n    }\n    if (this.expressionHasBind) {\n      (this.expression as BindingBehavior).bind(flags, scope, binding);\n    }\n    const behaviorKey = this.behaviorKey;\n    const behavior = locator.get<BindingBehavior>(behaviorKey);\n    if (!behavior) {\n      throw Reporter.error(RuntimeError.NoBehaviorFound, this);\n    }\n    if (binding[behaviorKey] !== undefined && binding[behaviorKey] !== null) {\n      throw Reporter.error(RuntimeError.BehaviorAlreadyApplied, this);\n    }\n    binding[behaviorKey] = behavior;\n    behavior.bind.apply(behavior, ([flags, scope, binding] as unknown[]).concat(evalList(flags, scope, locator, this.args)));\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const behaviorKey = this.behaviorKey;\n    binding[behaviorKey].unbind(flags, scope, binding);\n    binding[behaviorKey] = null;\n    if (this.expressionHasUnbind) {\n      (this.expression as BindingBehavior | ValueConverter).unbind(flags, scope, binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitBindingBehavior(this);\n  }\n}\n\nexport class ValueConverter implements IExpression {\n  public $kind: ExpressionKind.ValueConverter;\n  public readonly expression: IsValueConverter;\n  public readonly name: string;\n  public readonly args: ReadonlyArray<IsAssign>;\n  public readonly converterKey: string;\n\n  constructor(expression: IsValueConverter, name: string, args: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.ValueConverter;\n    this.expression = expression;\n    this.name = name;\n    this.args = args;\n    this.converterKey = ValueConverterResource.keyFrom(this.name);\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    if (!locator) {\n      throw Reporter.error(RuntimeError.NoLocator, this);\n    }\n    const converter = locator.get<ValueConverter & IValueConverter>(this.converterKey);\n    if (!converter) {\n      throw Reporter.error(RuntimeError.NoConverterFound, this);\n    }\n    if ('toView' in converter) {\n      const args = this.args;\n      const len = args.length;\n      const result = Array(len + 1);\n      result[0] = this.expression.evaluate(flags, scope, locator);\n      for (let i = 0; i < len; ++i) {\n        result[i + 1] = args[i].evaluate(flags, scope, locator);\n      }\n      return converter.toView.apply(converter, result);\n    }\n    return this.expression.evaluate(flags, scope, locator);\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, value: unknown): unknown {\n    if (!locator) {\n      throw Reporter.error(RuntimeError.NoLocator, this);\n    }\n    const converter = locator.get<ValueConverter & IValueConverter>(this.converterKey);\n    if (!converter) {\n      throw Reporter.error(RuntimeError.NoConverterFound, this);\n    }\n    if ('fromView' in converter) {\n      value = converter.fromView.apply(converter, [value].concat(evalList(flags, scope, locator, this.args)));\n    }\n    return this.expression.assign(flags, scope, locator, value);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    if (scope === undefined) {\n      throw Reporter.error(RuntimeError.UndefinedScope, this);\n    }\n    if (scope === null) {\n      throw Reporter.error(RuntimeError.NullScope, this);\n    }\n    if (!binding) {\n      throw Reporter.error(RuntimeError.NoBinding, this);\n    }\n    const locator = binding.locator;\n    if (!locator) {\n      throw Reporter.error(RuntimeError.NoLocator, this);\n    }\n    this.expression.connect(flags, scope, binding);\n    const args = this.args;\n    for (let i = 0, ii = args.length; i < ii; ++i) {\n      args[i].connect(flags, scope, binding);\n    }\n    const converter = locator.get(this.converterKey) as { signals?: string[] };\n    if (!converter) {\n      throw Reporter.error(RuntimeError.NoConverterFound, this);\n    }\n    const signals = converter.signals;\n    if (signals === undefined) {\n      return;\n    }\n    const signaler = locator.get(ISignaler);\n    for (let i = 0, ii = signals.length; i < ii; ++i) {\n      signaler.addSignalListener(signals[i], binding);\n    }\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const locator = binding.locator;\n    const converter = locator.get(this.converterKey) as { signals?: string[] };\n    const signals = converter.signals;\n    if (signals === undefined) {\n      return;\n    }\n    const signaler = locator.get(ISignaler);\n    for (let i = 0, ii = signals.length; i < ii; ++i) {\n      signaler.removeSignalListener(signals[i], binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitValueConverter(this);\n  }\n}\n\nexport class Assign implements IExpression {\n  public $kind: ExpressionKind.Assign;\n  public readonly target: IsAssignable;\n  public readonly value: IsAssign;\n\n  constructor(target: IsAssignable, value: IsAssign) {\n    this.$kind = ExpressionKind.Assign;\n    this.target = target;\n    this.value = value;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    return this.target.assign(flags, scope, locator, this.value.evaluate(flags, scope, locator));\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    return;\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, value: unknown): unknown {\n    this.value.assign(flags, scope, locator, value);\n    return this.target.assign(flags, scope, locator, value);\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitAssign(this);\n  }\n}\n\nexport class Conditional implements IExpression {\n  public $kind: ExpressionKind.Conditional;\n  public assign: IExpression['assign'];\n  public readonly condition: IsBinary;\n  public readonly yes: IsAssign;\n  public readonly no: IsAssign;\n\n  constructor(condition: IsBinary, yes: IsAssign, no: IsAssign) {\n    this.$kind = ExpressionKind.Conditional;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.condition = condition;\n    this.yes = yes;\n    this.no = no;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    return (!!this.condition.evaluate(flags, scope, locator))\n      ? this.yes.evaluate(flags, scope, locator)\n      : this.no.evaluate(flags, scope, locator);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const condition = this.condition;\n    if (condition.evaluate(flags, scope, null)) {\n      this.condition.connect(flags, scope, binding);\n      this.yes.connect(flags, scope, binding);\n    } else {\n      this.condition.connect(flags, scope, binding);\n      this.no.connect(flags, scope, binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitConditional(this);\n  }\n}\n\nexport class AccessThis implements IExpression {\n  public static readonly $this: AccessThis = new AccessThis(0);\n  public static readonly $parent: AccessThis = new AccessThis(1);\n  public $kind: ExpressionKind.AccessThis;\n  public assign: IExpression['assign'];\n  public connect: IExpression['connect'];\n  public readonly ancestor: number;\n\n  constructor(ancestor: number = 0) {\n    this.$kind = ExpressionKind.AccessThis;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.connect = PLATFORM.noop;\n    this.ancestor = ancestor;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): IBindingContext | undefined {\n    if (scope === undefined) {\n      throw Reporter.error(RuntimeError.UndefinedScope, this);\n    }\n    if (scope === null) {\n      throw Reporter.error(RuntimeError.NullScope, this);\n    }\n    let oc: IOverrideContext | null = scope.overrideContext;\n    let i = this.ancestor;\n    while (i-- && oc) {\n      oc = oc.parentOverrideContext;\n    }\n    return i < 1 && oc ? oc.bindingContext : undefined;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitAccessThis(this);\n  }\n}\n\nexport class AccessScope implements IExpression {\n  public $kind: ExpressionKind.AccessScope;\n  public readonly name: string;\n  public readonly ancestor: number;\n\n  constructor(name: string, ancestor: number = 0) {\n    this.$kind = ExpressionKind.AccessScope;\n    this.name = name;\n    this.ancestor = ancestor;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): IBindingContext | IBindScope | IOverrideContext {\n    const name = this.name;\n    return BindingContext.get(scope, name, this.ancestor, flags)[name];\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, value: unknown): unknown {\n    const name = this.name;\n    const context = BindingContext.get(scope, name, this.ancestor, flags);\n    return context ? (context[name] = value) : undefined;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const name = this.name;\n    const context = BindingContext.get(scope, name, this.ancestor, flags);\n    binding.observeProperty(context, name);\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitAccessScope(this);\n  }\n}\n\nexport class AccessMember implements IExpression {\n  public $kind: ExpressionKind.AccessMember;\n  public readonly object: IsLeftHandSide;\n  public readonly name: string;\n\n  constructor(object: IsLeftHandSide, name: string) {\n    this.$kind = ExpressionKind.AccessMember;\n    this.object = object;\n    this.name = name;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    const instance = this.object.evaluate(flags, scope, locator) as IIndexable;\n    return instance === null || instance === undefined ? instance : instance[this.name];\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, value: unknown): unknown {\n    let instance = this.object.evaluate(flags, scope, locator) as IIndexable;\n    if (instance === null || typeof instance !== 'object') {\n      instance = {};\n      this.object.assign(flags, scope, locator, instance);\n    }\n    instance[this.name] = value;\n    return value;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const obj = this.object.evaluate(flags, scope, null) as IIndexable;\n    this.object.connect(flags, scope, binding);\n    if (obj) {\n      binding.observeProperty(obj, this.name);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitAccessMember(this);\n  }\n}\n\nexport class AccessKeyed implements IExpression {\n  public $kind: ExpressionKind.AccessKeyed;\n  public readonly object: IsLeftHandSide;\n  public readonly key: IsAssign;\n\n  constructor(object: IsLeftHandSide, key: IsAssign) {\n    this.$kind = ExpressionKind.AccessKeyed;\n    this.object = object;\n    this.key = key;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    const instance = this.object.evaluate(flags, scope, locator) as IIndexable;\n    if (instance === null || instance === undefined) {\n      return undefined;\n    }\n    const key = this.key.evaluate(flags, scope, locator) as string;\n    // note: getKeyed and setKeyed are removed because they are identical to the default spec behavior\n    // and the runtime does this this faster\n    return instance[key];\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, value: unknown): unknown {\n    const instance = this.object.evaluate(flags, scope, locator) as IIndexable;\n    const key = this.key.evaluate(flags, scope, locator) as string;\n    return instance[key] = value;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const obj = this.object.evaluate(flags, scope, null);\n    this.object.connect(flags, scope, binding);\n    if (typeof obj === 'object' && obj !== null) {\n      this.key.connect(flags, scope, binding);\n      const key = this.key.evaluate(flags, scope, null);\n      // observe the property represented by the key as long as it's not an array indexer\n      // (note: string indexers behave the same way as numeric indexers as long as they represent numbers)\n      if (!(Array.isArray(obj) && isNumeric(key))) {\n        binding.observeProperty(obj, key as string);\n      }\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitAccessKeyed(this);\n  }\n}\n\nexport class CallScope implements IExpression {\n  public $kind: ExpressionKind.CallScope;\n  public assign: IExpression['assign'];\n  public readonly name: string;\n  public readonly args: ReadonlyArray<IsAssign>;\n  public readonly ancestor: number;\n\n  constructor(name: string, args: ReadonlyArray<IsAssign>, ancestor: number = 0) {\n    this.$kind = ExpressionKind.CallScope;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.name = name;\n    this.args = args;\n    this.ancestor = ancestor;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator | null): unknown {\n    const args = evalList(flags, scope, locator, this.args);\n    const context = BindingContext.get(scope, this.name, this.ancestor, flags);\n    const func = getFunction(flags, context, this.name);\n    if (func) {\n      return func.apply(context, args);\n    }\n    return undefined;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const args = this.args;\n    for (let i = 0, ii = args.length; i < ii; ++i) {\n      args[i].connect(flags, scope, binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitCallScope(this);\n  }\n}\n\nexport class CallMember implements IExpression {\n  public $kind: ExpressionKind.CallMember;\n  public assign: IExpression['assign'];\n  public readonly object: IsLeftHandSide;\n  public readonly name: string;\n  public readonly args: ReadonlyArray<IsAssign>;\n\n  constructor(object: IsLeftHandSide, name: string, args: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.CallMember;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.object = object;\n    this.name = name;\n    this.args = args;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    const instance = this.object.evaluate(flags, scope, locator) as IIndexable;\n    const args = evalList(flags, scope, locator, this.args);\n    const func = getFunction(flags, instance, this.name);\n    if (func) {\n      return func.apply(instance, args);\n    }\n    return undefined;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const obj = this.object.evaluate(flags, scope, null) as IIndexable;\n    this.object.connect(flags, scope, binding);\n    if (getFunction(flags & ~LifecycleFlags.mustEvaluate, obj, this.name)) {\n      const args = this.args;\n      for (let i = 0, ii = args.length; i < ii; ++i) {\n        args[i].connect(flags, scope, binding);\n      }\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitCallMember(this);\n  }\n}\n\nexport class CallFunction implements IExpression {\n  public $kind: ExpressionKind.CallFunction;\n  public assign: IExpression['assign'];\n  public readonly func: IsLeftHandSide;\n  public readonly args: ReadonlyArray<IsAssign>;\n\n  constructor(func: IsLeftHandSide, args: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.CallFunction;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.func = func;\n    this.args = args;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    const func = this.func.evaluate(flags, scope, locator);\n    if (typeof func === 'function') {\n      return func.apply(null, evalList(flags, scope, locator, this.args));\n    }\n    if (!(flags & LifecycleFlags.mustEvaluate) && (func === null || func === undefined)) {\n      return undefined;\n    }\n    throw Reporter.error(RuntimeError.NotAFunction, this);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const func = this.func.evaluate(flags, scope, null);\n    this.func.connect(flags, scope, binding);\n    if (typeof func === 'function') {\n      const args = this.args;\n      for (let i = 0, ii = args.length; i < ii; ++i) {\n        args[i].connect(flags, scope, binding);\n      }\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitCallFunction(this);\n  }\n}\n\nexport type BinaryOperator = '&&' | '||' |  '==' |  '===' |  '!=' |  '!==' |  'instanceof' |  'in' |  '+' |  '-' |  '*' |  '/' |  '%' |  '<' |  '>' |  '<=' |  '>=';\n\nexport class Binary implements IExpression {\n  public $kind: ExpressionKind.Binary;\n  public assign: IExpression['assign'];\n  public readonly operation: BinaryOperator;\n  public readonly left: IsBinary;\n  public readonly right: IsBinary;\n\n  constructor(operation: BinaryOperator, left: IsBinary, right: IsBinary) {\n    this.$kind = ExpressionKind.Binary;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.operation = operation;\n    this.left = left;\n    this.right = right;\n\n    // what we're doing here is effectively moving the large switch statement from evaluate to the constructor\n    // so that the check only needs to be done once, and evaluate (which is called many times) will have a lot less\n    // work to do; we can do this because the operation can't change after it's parsed\n    this.evaluate = this[operation] as IExpression['evaluate'];\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    throw Reporter.error(RuntimeError.UnknownOperator, this);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const left = this.left.evaluate(flags, scope, null);\n    this.left.connect(flags, scope, binding);\n    if (this.operation === '&&' && !left || this.operation === '||' && left) {\n      return;\n    }\n    this.right.connect(flags, scope, binding);\n  }\n\n  private ['&&'](f: LifecycleFlags, s: IScope, l: IServiceLocator): unknown {\n    return this.left.evaluate(f, s, l) && this.right.evaluate(f, s, l);\n  }\n  private ['||'](f: LifecycleFlags, s: IScope, l: IServiceLocator): unknown {\n    return this.left.evaluate(f, s, l) || this.right.evaluate(f, s, l);\n  }\n  private ['=='](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    // tslint:disable-next-line:triple-equals\n    return this.left.evaluate(f, s, l) == this.right.evaluate(f, s, l);\n  }\n  private ['==='](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return this.left.evaluate(f, s, l) === this.right.evaluate(f, s, l);\n  }\n  private ['!='](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    // tslint:disable-next-line:triple-equals\n    return this.left.evaluate(f, s, l) != this.right.evaluate(f, s, l);\n  }\n  private ['!=='](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return this.left.evaluate(f, s, l) !== this.right.evaluate(f, s, l);\n  }\n  private ['instanceof'](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    const right = this.right.evaluate(f, s, l);\n    if (typeof right === 'function') {\n      return this.left.evaluate(f, s, l) instanceof right;\n    }\n    return false;\n  }\n  private ['in'](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    const right = this.right.evaluate(f, s, l);\n    if (right !== null && typeof right === 'object') {\n      return this.left.evaluate(f, s, l) as string in right;\n    }\n    return false;\n  }\n  // note: autoConvertAdd (and the null check) is removed because the default spec behavior is already largely similar\n  // and where it isn't, you kind of want it to behave like the spec anyway (e.g. return NaN when adding a number to undefined)\n  // this makes bugs in user code easier to track down for end users\n  // also, skipping these checks and leaving it to the runtime is a nice little perf boost and simplifies our code\n  private ['+'](f: LifecycleFlags, s: IScope, l: IServiceLocator): number {\n    return (this.left.evaluate(f, s, l) as number) + (this.right.evaluate(f, s, l) as number);\n  }\n  private ['-'](f: LifecycleFlags, s: IScope, l: IServiceLocator): number {\n    return (this.left.evaluate(f, s, l) as number) - (this.right.evaluate(f, s, l) as number);\n  }\n  private ['*'](f: LifecycleFlags, s: IScope, l: IServiceLocator): number {\n    return (this.left.evaluate(f, s, l) as number) * (this.right.evaluate(f, s, l) as number);\n  }\n  private ['/'](f: LifecycleFlags, s: IScope, l: IServiceLocator): number {\n    return (this.left.evaluate(f, s, l) as number) / (this.right.evaluate(f, s, l) as number);\n  }\n  private ['%'](f: LifecycleFlags, s: IScope, l: IServiceLocator): number {\n    return (this.left.evaluate(f, s, l) as number) % (this.right.evaluate(f, s, l) as number);\n  }\n  private ['<'](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return (this.left.evaluate(f, s, l) as number) < (this.right.evaluate(f, s, l) as number);\n  }\n  private ['>'](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return (this.left.evaluate(f, s, l) as number) > (this.right.evaluate(f, s, l) as number);\n  }\n  private ['<='](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return (this.left.evaluate(f, s, l) as number) <= (this.right.evaluate(f, s, l) as number);\n  }\n  private ['>='](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return (this.left.evaluate(f, s, l) as number) >= (this.right.evaluate(f, s, l) as number);\n  }\n\n  // tslint:disable-next-line:member-ordering\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitBinary(this);\n  }\n}\n\nexport type UnaryOperator = 'void' | 'typeof' | '!' | '-' | '+';\n\nexport class Unary implements IExpression {\n  public $kind: ExpressionKind.Unary;\n  public assign: IExpression['assign'];\n  public readonly operation: UnaryOperator;\n  public readonly expression: IsLeftHandSide;\n\n  constructor(operation: UnaryOperator, expression: IsLeftHandSide) {\n    this.$kind = ExpressionKind.Unary;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.operation = operation;\n    this.expression = expression;\n\n    // see Binary (we're doing the same thing here)\n    this.evaluate = this[operation] as IExpression['evaluate'];\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    throw Reporter.error(RuntimeError.UnknownOperator, this);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    this.expression.connect(flags, scope, binding);\n  }\n\n  public ['void'](f: LifecycleFlags, s: IScope, l: IServiceLocator): undefined {\n    return void this.expression.evaluate(f, s, l);\n  }\n  public ['typeof'](f: LifecycleFlags, s: IScope, l: IServiceLocator): string {\n    return typeof this.expression.evaluate(f, s, l);\n  }\n  public ['!'](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return !this.expression.evaluate(f, s, l);\n  }\n  public ['-'](f: LifecycleFlags, s: IScope, l: IServiceLocator): number {\n    return -(this.expression.evaluate(f, s, l) as number);\n  }\n  public ['+'](f: LifecycleFlags, s: IScope, l: IServiceLocator): number {\n    return +(this.expression.evaluate(f, s, l) as number);\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitUnary(this);\n  }\n}\nexport class PrimitiveLiteral<TValue extends StrictPrimitive = StrictPrimitive> implements IExpression {\n  public static readonly $undefined: PrimitiveLiteral<undefined> = new PrimitiveLiteral<undefined>(undefined);\n  public static readonly $null: PrimitiveLiteral<null> = new PrimitiveLiteral<null>(null);\n  public static readonly $true: PrimitiveLiteral<true> = new PrimitiveLiteral<true>(true);\n  public static readonly $false: PrimitiveLiteral<false> = new PrimitiveLiteral<false>(false);\n  public static readonly $empty: PrimitiveLiteral<string> = new PrimitiveLiteral<''>('');\n  public $kind: ExpressionKind.PrimitiveLiteral;\n  public connect: IExpression['connect'];\n  public assign: IExpression['assign'];\n  public readonly value: TValue;\n\n  constructor(value: TValue) {\n    this.$kind = ExpressionKind.PrimitiveLiteral;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.connect = PLATFORM.noop;\n    this.value = value;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): TValue {\n    return this.value;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitPrimitiveLiteral(this);\n  }\n}\n\nexport class HtmlLiteral implements IExpression {\n  public $kind: ExpressionKind.HtmlLiteral;\n  public assign: IExpression['assign'];\n  public readonly parts: ReadonlyArray<HtmlLiteral>;\n\n  constructor(parts: ReadonlyArray<HtmlLiteral>) {\n    this.$kind = ExpressionKind.HtmlLiteral;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.parts = parts;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): string {\n    const elements = this.parts;\n    let result = '';\n    for (let i = 0, ii = elements.length; i < ii; ++i) {\n      const value = elements[i].evaluate(flags, scope, locator);\n      if (value === undefined || value === null) {\n        continue;\n      }\n      result += value;\n    }\n    return result;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    for (let i = 0, ii = this.parts.length; i < ii; ++i) {\n      this.parts[i].connect(flags, scope, binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitHtmlLiteral(this);\n  }\n}\n\nexport class ArrayLiteral implements IExpression {\n  public static readonly $empty: ArrayLiteral = new ArrayLiteral(PLATFORM.emptyArray);\n  public $kind: ExpressionKind.ArrayLiteral;\n  public assign: IExpression['assign'];\n  public readonly elements: ReadonlyArray<IsAssign>;\n\n  constructor(elements: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.ArrayLiteral;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.elements = elements;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): ReadonlyArray<unknown> {\n    const elements = this.elements;\n    const length = elements.length;\n    const result = Array(length);\n    for (let i = 0; i < length; ++i) {\n      result[i] = elements[i].evaluate(flags, scope, locator);\n    }\n    return result;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const elements = this.elements;\n    for (let i = 0, ii = elements.length; i < ii; ++i) {\n      elements[i].connect(flags, scope, binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitArrayLiteral(this);\n  }\n}\n\nexport class ObjectLiteral implements IExpression {\n  public static readonly $empty: ObjectLiteral = new ObjectLiteral(PLATFORM.emptyArray, PLATFORM.emptyArray);\n  public $kind: ExpressionKind.ObjectLiteral;\n  public assign: IExpression['assign'];\n  public readonly keys: ReadonlyArray<number | string>;\n  public readonly values: ReadonlyArray<IsAssign>;\n\n  constructor(keys: ReadonlyArray<number | string>, values: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.ObjectLiteral;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.keys = keys;\n    this.values = values;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): Record<string, unknown> {\n    const instance: Record<string, unknown> = {};\n    const keys = this.keys;\n    const values = this.values;\n    for (let i = 0, ii = keys.length; i < ii; ++i) {\n      instance[keys[i]] = values[i].evaluate(flags, scope, locator);\n    }\n    return instance;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const keys = this.keys;\n    const values = this.values;\n    for (let i = 0, ii = keys.length; i < ii; ++i) {\n      values[i].connect(flags, scope, binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitObjectLiteral(this);\n  }\n}\n\nexport class Template implements IExpression {\n  public static readonly $empty: Template = new Template(['']);\n  public $kind: ExpressionKind.Template;\n  public assign: IExpression['assign'];\n  public readonly cooked: ReadonlyArray<string>;\n  public readonly expressions: ReadonlyArray<IsAssign>;\n\n  constructor(cooked: ReadonlyArray<string>, expressions?: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.Template;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.cooked = cooked;\n    this.expressions = expressions === undefined ? PLATFORM.emptyArray : expressions;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): string {\n    const expressions = this.expressions;\n    const cooked = this.cooked;\n    let result = cooked[0];\n    for (let i = 0, ii = expressions.length; i < ii; ++i) {\n      result += expressions[i].evaluate(flags, scope, locator);\n      result += cooked[i + 1];\n    }\n    return result;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const expressions = this.expressions;\n    for (let i = 0, ii = expressions.length; i < ii; ++i) {\n      expressions[i].connect(flags, scope, binding);\n      i++;\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitTemplate(this);\n  }\n}\n\nexport class TaggedTemplate implements IExpression {\n  public $kind: ExpressionKind.TaggedTemplate;\n  public assign: IExpression['assign'];\n  public readonly cooked: ReadonlyArray<string> & { raw?: ReadonlyArray<string> };\n  public readonly func: IsLeftHandSide;\n  public readonly expressions: ReadonlyArray<IsAssign>;\n\n  constructor(cooked: ReadonlyArray<string> & { raw?: ReadonlyArray<string> }, raw: ReadonlyArray<string>, func: IsLeftHandSide, expressions?: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.TaggedTemplate;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.cooked = cooked;\n    this.cooked.raw = raw;\n    this.func = func;\n    this.expressions = expressions === undefined ? PLATFORM.emptyArray : expressions;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): string {\n    const expressions = this.expressions;\n    const len = expressions.length;\n    const results = Array(len);\n    for (let i = 0, ii = len; i < ii; ++i) {\n      results[i] = expressions[i].evaluate(flags, scope, locator);\n    }\n    const func = this.func.evaluate(flags, scope, locator);\n    if (typeof func !== 'function') {\n      throw Reporter.error(RuntimeError.NotAFunction, this);\n    }\n    return func.apply(null, [this.cooked].concat(results));\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const expressions = this.expressions;\n    for (let i = 0, ii = expressions.length; i < ii; ++i) {\n      expressions[i].connect(flags, scope, binding);\n    }\n    this.func.connect(flags, scope, binding);\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitTaggedTemplate(this);\n  }\n}\n\nexport class ArrayBindingPattern implements IExpression {\n  public $kind: ExpressionKind.ArrayBindingPattern;\n  public readonly elements: ReadonlyArray<IsAssign>;\n\n  // We'll either have elements, or keys+values, but never all 3\n  constructor(elements: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.ArrayBindingPattern;\n    this.elements = elements;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    // TODO\n    return undefined;\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, obj: IIndexable): unknown {\n    // TODO\n    return undefined;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    return;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitArrayBindingPattern(this);\n  }\n}\n\nexport class ObjectBindingPattern implements IExpression {\n  public $kind: ExpressionKind.ObjectBindingPattern;\n  public readonly keys: ReadonlyArray<string | number>;\n  public readonly values: ReadonlyArray<IsAssign>;\n\n  // We'll either have elements, or keys+values, but never all 3\n  constructor(keys: ReadonlyArray<string | number>, values: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.ObjectBindingPattern;\n    this.keys = keys;\n    this.values = values;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    // TODO\n    return undefined;\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, obj: IIndexable): unknown {\n    // TODO\n    return undefined;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    return;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitObjectBindingPattern(this);\n  }\n}\n\nexport class BindingIdentifier implements IExpression {\n  public $kind: ExpressionKind.BindingIdentifier;\n  public readonly name: string;\n\n  constructor(name: string) {\n    this.$kind = ExpressionKind.BindingIdentifier;\n    this.name = name;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator | null): string {\n    return this.name;\n  }\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    return;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitBindingIdentifier(this);\n  }\n}\n\nexport type BindingIdentifierOrPattern = BindingIdentifier | ArrayBindingPattern | ObjectBindingPattern;\n\nconst toStringTag = Object.prototype.toString;\n\n// https://tc39.github.io/ecma262/#sec-iteration-statements\n// https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements\nexport class ForOfStatement implements IExpression {\n  public $kind: ExpressionKind.ForOfStatement;\n  public assign: IExpression['assign'];\n  public readonly declaration: BindingIdentifierOrPattern;\n  public readonly iterable: IsBindingBehavior;\n\n  constructor(declaration: BindingIdentifierOrPattern, iterable: IsBindingBehavior) {\n    this.$kind = ExpressionKind.ForOfStatement;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.declaration = declaration;\n    this.iterable = iterable;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    return this.iterable.evaluate(flags, scope, locator);\n  }\n\n  public count(result: ObservedCollection | number | null | undefined): number {\n    return CountForOfStatement[toStringTag.call(result)](result);\n  }\n\n  public iterate(result: ObservedCollection | number | null | undefined, func: (arr: Collection, index: number, item: unknown) => void): void {\n    IterateForOfStatement[toStringTag.call(result)](result, func);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    this.declaration.connect(flags, scope, binding);\n    this.iterable.connect(flags, scope, binding);\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitForOfStatement(this);\n  }\n}\n\n/*\n* Note: this implementation is far simpler than the one in vCurrent and might be missing important stuff (not sure yet)\n* so while this implementation is identical to Template and we could reuse that one, we don't want to lock outselves in to potentially the wrong abstraction\n* but this class might be a candidate for removal if it turns out it does provide all we need\n*/\nexport class Interpolation implements IExpression {\n  public $kind: ExpressionKind.Interpolation;\n  public assign: IExpression['assign'];\n  public readonly parts: ReadonlyArray<string>;\n  public readonly expressions: ReadonlyArray<IsBindingBehavior>;\n  public readonly isMulti: boolean;\n  public readonly firstExpression: IsBindingBehavior;\n  constructor(parts: ReadonlyArray<string>, expressions?: ReadonlyArray<IsBindingBehavior>) {\n    this.$kind = ExpressionKind.Interpolation;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.parts = parts;\n    this.expressions = expressions === undefined ? PLATFORM.emptyArray : expressions;\n    this.isMulti = this.expressions.length > 1;\n    this.firstExpression = this.expressions[0];\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): string {\n    if (this.isMulti) {\n      const expressions = this.expressions;\n      const parts = this.parts;\n      let result = parts[0];\n      for (let i = 0, ii = expressions.length; i < ii; ++i) {\n        result += expressions[i].evaluate(flags, scope, locator);\n        result += parts[i + 1];\n      }\n      return result;\n    } else {\n      const parts = this.parts;\n      return parts[0] + this.firstExpression.evaluate(flags, scope, locator) + parts[1];\n    }\n  }\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    return;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitInterpolation(this);\n  }\n}\n\n/*\n* Note: for a property that is always the same, directly assigning it to the prototype is more efficient CPU wise\n* (gets assigned once, instead of per constructor call) as well as memory wise (stored once, instead of per instance)\n*\n* This gives us a cheap way to add some extra information to the AST for the runtime to do things more efficiently.\n*/\nBindingBehavior.prototype.$kind = ExpressionKind.BindingBehavior;\nValueConverter.prototype.$kind = ExpressionKind.ValueConverter;\nAssign.prototype.$kind = ExpressionKind.Assign;\nConditional.prototype.$kind = ExpressionKind.Conditional;\nAccessThis.prototype.$kind = ExpressionKind.AccessThis;\nAccessScope.prototype.$kind = ExpressionKind.AccessScope;\nAccessMember.prototype.$kind = ExpressionKind.AccessMember;\nAccessKeyed.prototype.$kind = ExpressionKind.AccessKeyed;\nCallScope.prototype.$kind = ExpressionKind.CallScope;\nCallMember.prototype.$kind = ExpressionKind.CallMember;\nCallFunction.prototype.$kind = ExpressionKind.CallFunction;\nBinary.prototype.$kind = ExpressionKind.Binary;\nUnary.prototype.$kind = ExpressionKind.Unary;\nPrimitiveLiteral.prototype.$kind = ExpressionKind.PrimitiveLiteral;\nHtmlLiteral.prototype.$kind = ExpressionKind.HtmlLiteral;\nArrayLiteral.prototype.$kind = ExpressionKind.ArrayLiteral;\nObjectLiteral.prototype.$kind = ExpressionKind.ObjectLiteral;\nTemplate.prototype.$kind = ExpressionKind.Template;\nTaggedTemplate.prototype.$kind = ExpressionKind.TaggedTemplate;\nArrayBindingPattern.prototype.$kind = ExpressionKind.ArrayBindingPattern;\nObjectBindingPattern.prototype.$kind = ExpressionKind.ObjectBindingPattern;\nBindingIdentifier.prototype.$kind = ExpressionKind.BindingIdentifier;\nForOfStatement.prototype.$kind = ExpressionKind.ForOfStatement;\nInterpolation.prototype.$kind = ExpressionKind.Interpolation;\n\n/// Evaluate the [list] in context of the [scope].\nfunction evalList(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator | null, list: ReadonlyArray<IExpression>): unknown[] {\n  const len = list.length;\n  const result = Array(len);\n  for (let i = 0; i < len; ++i) {\n    result[i] = list[i].evaluate(flags, scope, locator);\n  }\n  return result;\n}\n\nfunction getFunction(flags: LifecycleFlags, obj: IIndexable, name: string): Function | null {\n  const func = obj === null || obj === undefined ? null : obj[name];\n  if (typeof func === 'function') {\n    return func;\n  }\n  if (!(flags & LifecycleFlags.mustEvaluate) && (func === null || func === undefined)) {\n    return null;\n  }\n  throw Reporter.error(RuntimeError.NotAFunction, obj, name, func);\n}\n\nfunction isNumeric(value: unknown): value is number {\n  const valueType = typeof value;\n  if (valueType === 'number') return true;\n  if (valueType !== 'string') return false;\n  const len = (value as string).length;\n  if (len === 0) return false;\n  for (let i = 0; i < len; ++i) {\n    const char = (value as string).charCodeAt(i);\n    if (char < 0x30 /*0*/ || char > 0x39/*9*/) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/** @internal */\nexport const IterateForOfStatement = {\n  ['[object Array]'](result: unknown[], func: (arr: Collection, index: number, item: unknown) => void): void {\n    for (let i = 0, ii = result.length; i < ii; ++i) {\n      func(result, i, result[i]);\n    }\n  },\n  ['[object Map]'](result: Map<unknown, unknown>, func: (arr: Collection, index: number, item: unknown) => void): void {\n    const arr = Array(result.size);\n    let i = -1;\n    for (const entry of result.entries()) {\n      arr[++i] = entry;\n    }\n    IterateForOfStatement['[object Array]'](arr, func);\n  },\n  ['[object Set]'](result: Set<unknown>, func: (arr: Collection, index: number, item: unknown) => void): void {\n    const arr = Array(result.size);\n    let i = -1;\n    for (const key of result.keys()) {\n      arr[++i] = key;\n    }\n    IterateForOfStatement['[object Array]'](arr, func);\n  },\n  ['[object Number]'](result: number, func: (arr: Collection, index: number, item: unknown) => void): void {\n    const arr = Array(result);\n    for (let i = 0; i < result; ++i) {\n      arr[i] = i;\n    }\n    IterateForOfStatement['[object Array]'](arr, func);\n  },\n  ['[object Null]'](result: null, func: (arr: Collection, index: number, item: unknown) => void): void {\n    return;\n  },\n  ['[object Undefined]'](result: null, func: (arr: Collection, index: number, item: unknown) => void): void {\n    return;\n  }\n};\n\n/** @internal */\nexport const CountForOfStatement = {\n  ['[object Array]'](result: unknown[]): number { return result.length; },\n  ['[object Map]'](result: Map<unknown, unknown>): number { return result.size; },\n  ['[object Set]'](result: Set<unknown>): number { return result.size; },\n  ['[object Number]'](result: number): number { return result; },\n  ['[object Null]'](result: null): number { return 0; },\n  ['[object Undefined]'](result: null): number { return 0; }\n};\n","/*\n* Note: the oneTime binding now has a non-zero value for 2 reasons:\n*  - plays nicer with bitwise operations (more consistent code, more explicit settings)\n*  - allows for potentially having something like BindingMode.oneTime | BindingMode.fromView, where an initial value is set once to the view but updates from the view also propagate back to the view model\n*\n* Furthermore, the \"default\" mode would be for simple \".bind\" expressions to make it explicit for our logic that the default is being used.\n* This essentially adds extra information which binding could use to do smarter things and allows bindingBehaviors that add a mode instead of simply overwriting it\n*/\nexport enum BindingMode {\n  oneTime  = 0b0001,\n  toView   = 0b0010,\n  fromView = 0b0100,\n  twoWay   = 0b0110,\n  default  = 0b1000\n}\n","import {\n  DI,\n  IContainer,\n  IDisposable,\n  Immutable,\n  inject,\n  InterfaceSymbol,\n  IResolver,\n  IServiceLocator,\n  Omit,\n  PLATFORM,\n  Registration,\n  Tracer\n} from '@aurelia/kernel';\nimport { IConnectableBinding } from './binding/connectable';\nimport { ITargetedInstruction, TemplateDefinition, TemplatePartDefinitions } from './definitions';\nimport { INode, INodeSequence, IRenderLocation } from './dom.interfaces';\nimport { IChangeTracker, IScope, LifecycleFlags } from './observation';\n\nconst slice = Array.prototype.slice;\n\nexport const enum State {\n  none                  = 0b000000000000,\n  isBinding             = 0b000000000001,\n  isBound               = 0b000000000010,\n  isAttaching           = 0b000000000100,\n  isAttached            = 0b000000001000,\n  isMounted             = 0b000000010000,\n  isDetaching           = 0b000000100000,\n  isUnbinding           = 0b000001000000,\n  isCached              = 0b000010000000\n}\n\nexport const enum Hooks {\n  none                   = 0b000000000001,\n  hasCreated             = 0b000000000010,\n  hasBinding             = 0b000000000100,\n  hasBound               = 0b000000001000,\n  hasAttaching           = 0b000000010000,\n  hasAttached            = 0b000000100000,\n  hasDetaching           = 0b000001000000,\n  hasDetached            = 0b000010000000,\n  hasUnbinding           = 0b000100000000,\n  hasUnbound             = 0b001000000000,\n  hasRender              = 0b010000000000,\n  hasCaching             = 0b100000000000\n}\n\nexport interface IHooks {\n  $hooks?: Hooks;\n}\n\nexport interface IState {\n  $state?: State;\n  $lifecycle?: ILifecycle;\n}\n\nexport interface IBindables {\n  /**\n   * The Bindings, Views, CustomElements, CustomAttributes and other bindable components that belong to this instance.\n   */\n  $bindableHead?: IBindScope;\n  $bindableTail?: IBindScope;\n}\n\nexport interface IAttachables {\n\n  /**\n   * The Views, CustomElements, CustomAttributes and other attachable components that belong to this instance.\n   */\n  $attachableHead?: IAttach;\n  $attachableTail?: IAttach;\n}\n\n/**\n * An object containing the necessary information to render something for display.\n */\nexport interface IRenderable extends IBindables, IAttachables, IState {\n\n  /**\n   * The (dependency) context of this instance.\n   *\n   * Contains any dependencies required by this instance or its children.\n   */\n  readonly $context: IRenderContext;\n\n  /**\n   * The nodes that represent the visible aspect of this instance.\n   *\n   * Typically this will be a sequence of `DOM` nodes contained in a `DocumentFragment`\n   */\n  readonly $nodes: INodeSequence;\n\n  /**\n   * The binding scope that the `$bindables` of this instance will be bound to.\n   *\n   * This includes the `BindingContext` which can be either a user-defined view model instance, or a synthetic view model instantiated by a `templateController`\n   */\n  readonly $scope: IScope;\n}\n\nexport const IRenderable = DI.createInterface<IRenderable>().noDefault();\n\nexport interface IRenderContext extends IServiceLocator {\n  createChild(): IRenderContext;\n  render(renderable: IRenderable, targets: ArrayLike<INode>, templateDefinition: TemplateDefinition, host?: INode, parts?: TemplatePartDefinitions): void;\n  beginComponentOperation(renderable: IRenderable, target: INode, instruction: Immutable<ITargetedInstruction>, factory?: IViewFactory, parts?: TemplatePartDefinitions, location?: IRenderLocation, locationIsContainer?: boolean): IDisposable;\n}\n\nexport interface IView extends IBindScope, IRenderable, IAttach, IMountable {\n  readonly cache: IViewCache;\n  readonly isFree: boolean;\n  readonly location: IRenderLocation;\n\n  hold(location: IRenderLocation, flags: LifecycleFlags): void;\n  release(flags: LifecycleFlags): boolean;\n\n  lockScope(scope: IScope): void;\n}\n\nexport interface IViewCache {\n  readonly isCaching: boolean;\n  setCacheSize(size: number | '*', doNotOverrideIfAlreadySet: boolean): void;\n  canReturnToCache(view: IView): boolean;\n  tryReturnToCache(view: IView): boolean;\n}\n\nexport interface IViewFactory extends IViewCache {\n  readonly name: string;\n  create(): IView;\n}\n\nexport const IViewFactory = DI.createInterface<IViewFactory>().noDefault();\n\nexport interface ILifecycleCreated extends IHooks, IState {\n  /**\n   * Called at the end of `$hydrate`.\n   *\n   * The following key properties are now assigned and initialized (see `IRenderable` for more detail):\n   * - `this.$bindables`\n   * - `this.$attachables`\n   * - `this.$scope` (null if this is a custom attribute, or contains the view model if this is a custom element)\n   * - `this.$nodes`\n   *\n   * @description\n   * This is the second and last \"hydrate\" lifecycle hook (after `render`). It happens only once per instance (contrary to bind/attach\n   * which can happen many times per instance), though it can happen many times per type (once for each instance)\n   *\n   * This hook is called right before the `$bind` lifecycle starts, making this the last opportunity\n   * for any high-level post processing on initialized properties.\n   */\n  created?(): void;\n}\n\nexport interface ILifecycleBinding extends IHooks, IState {\n  /**\n   * Called at the start of `$bind`, before this instance and its children (if any) are bound.\n   *\n   * - `this.$isBound` is false.\n   * - `this.$scope` is initialized.\n   *\n   * @param flags Contextual information about the lifecycle, such as what triggered it.\n   * Some uses for this hook:\n   * - `flags & LifecycleFlags.fromStartTask`: the Aurelia app is starting (this is the initial bind)\n   * - `flags & LifecycleFlags.fromBind`: this is a normal `$bind` lifecycle\n   * - `flags & LifecycleFlags.updateTargetInstance`: this `$bind` was triggered by some upstream observer and is not a real `$bind` lifecycle\n   * - `flags & LifecycleFlags.fromFlush` (only occurs in conjunction with updateTargetInstance): the update was queued to a `LinkedChangeList` which is now being flushed\n   *\n   * @description\n   * This is the first \"create\" lifecycle hook of the hooks that can occur multiple times per instance,\n   * and the third lifecycle hook (after `render` and `created`) of the very first this.lifecycle.\n   */\n  binding?(flags: LifecycleFlags): void;\n}\n\nexport interface ILifecycleBound extends IHooks, IState {\n  /** @internal */$nextBound?: ILifecycleBound;\n\n  /**\n   * Called at the end of `$bind`, after this instance and its children (if any) are bound.\n   *\n   * - `$isBound` is true.\n   * - `this.$scope` is initialized.\n   *\n   * @param flags Contextual information about the lifecycle, such as what triggered it.\n   * Some uses for this hook:\n   * - `flags & LifecycleFlags.fromStartTask`: the Aurelia app is starting (this is the initial bind)\n   * - `flags & LifecycleFlags.fromBind`: this is a normal `$bind` lifecycle\n   * - `flags & LifecycleFlags.updateTargetInstance`: this `$bind` was triggered by some upstream observer and is not a real `$bind` lifecycle\n   * - `flags & LifecycleFlags.fromFlush` (only occurs in conjunction with updateTargetInstance): the update was queued to a `LinkedChangeList` which is now being flushed\n   *\n   * @description\n   * This is the second \"create\" lifecycle hook (after `binding`) of the hooks that can occur multiple times per instance,\n   * and the fourth lifecycle hook (after `render`, `created` and `binding`) of the very first this.lifecycle.\n   */\n  bound?(flags: LifecycleFlags): void;\n}\n\nexport interface ILifecycleUnbinding extends IHooks, IState {\n  /**\n   * Called at the start of `$unbind`, before this instance and its children (if any) are unbound.\n   *\n   * - `this.$isBound` is true.\n   * - `this.$scope` is still available.\n   *\n   * @param flags Contextual information about the lifecycle, such as what triggered it.\n   * Some uses for this hook:\n   * - `flags & LifecycleFlags.fromBind`: the component is just switching scope\n   * - `flags & LifecycleFlags.fromUnbind`: the component is really disposing\n   * - `flags & LifecycleFlags.fromStopTask`: the Aurelia app is stopping\n   *\n   * @description\n   * This is the fourth \"cleanup\" lifecycle hook (after `detaching`, `caching` and `detached`)\n   *\n   * Last opportunity to perform any source or target updates before the bindings are disconnected.\n   *\n   */\n  unbinding?(flags: LifecycleFlags): void;\n}\n\nexport interface ILifecycleUnbound extends IHooks, IState {\n  /** @internal */$nextUnbound?: ILifecycleUnbound;\n\n  /**\n   * Called at the end of `$unbind`, after this instance and its children (if any) are unbound.\n   *\n   * - `this.$isBound` is false at this point.\n   *\n   * - `this.$scope` may not be available anymore (unless it's a `@customElement`)\n   *\n   * @param flags Contextual information about the lifecycle, such as what triggered it.\n   * Some uses for this hook:\n   * - `flags & LifecycleFlags.fromBind`: the component is just switching scope\n   * - `flags & LifecycleFlags.fromUnbind`: the component is really disposing\n   * - `flags & LifecycleFlags.fromStopTask`: the Aurelia app is stopping\n   *\n   * @description\n   * This is the fifth (and last) \"cleanup\" lifecycle hook (after `detaching`, `caching`, `detached`\n   * and `unbinding`).\n   *\n   * The lifecycle either ends here, or starts at `$bind` again.\n   */\n  unbound?(flags: LifecycleFlags): void;\n}\n\nexport interface ILifecycleAttaching extends IHooks, IState {\n  /**\n   * Called at the start of `$attach`, before this instance and its children (if any) are attached.\n   *\n   * `$isAttached` is false.\n   *\n   * @param encapsulationSource Ask Rob.\n   * @param lifecycle Utility that encapsulates the attach sequence for a hierarchy of attachables and guarantees the correct attach order.\n   *\n   * @description\n   * This is the third \"create\" lifecycle hook (after `binding` and `bound`) of the hooks that can occur multiple times per instance,\n   * and the fifth lifecycle hook (after `render`, `created`, `binding` and `bound`) of the very first lifecycle\n   *\n   * This is the time to add any (sync or async) tasks (e.g. animations) to the lifecycle that need to happen before\n   * the nodes are added to the DOM.\n   */\n  attaching?(flags: LifecycleFlags, encapsulationSource?: INode): void;\n}\n\nexport interface ILifecycleAttached extends IHooks, IState {\n  /** @internal */$nextAttached?: ILifecycleAttached;\n\n  /**\n   * Called at the end of `$attach`, after this instance and its children (if any) are attached.\n   *\n   * - `$isAttached` is true.\n   *\n   * @description\n   * This is the fourth (and last) \"create\" lifecycle hook (after `binding`, `bound` and `attaching`) of the hooks that can occur\n   * multiple times per instance, and the sixth lifecycle hook (after `render`, `created`, `binding`, `bound` and `attaching`)\n   * of the very first lifecycle\n   *\n   * This instance and its children (if any) can be assumed\n   * to be fully initialized, bound, rendered, added to the DOM and ready for use.\n   */\n  attached?(flags: LifecycleFlags): void;\n}\n\nexport interface ILifecycleDetaching extends IHooks, IState {\n  /**\n   * Called at the start of `$detach`, before this instance and its children (if any) are detached.\n   *\n   * - `$isAttached` is true.\n   *\n   * @param lifecycle Utility that encapsulates the detach sequence for a hierarchy of attachables and guarantees the correct detach order.\n   *\n   * @description\n   * This is the first \"cleanup\" lifecycle hook.\n   *\n   * This is the time to add any (sync or async) tasks (e.g. animations) to the lifecycle that need to happen before\n   * the nodes are removed from the DOM.\n   */\n  detaching?(flags: LifecycleFlags): void;\n}\n\nexport interface ILifecycleDetached extends IHooks, IState {\n  /** @internal */$nextDetached?: ILifecycleDetached;\n\n  /**\n   * Called at the end of `$detach`, after this instance and its children (if any) are detached.\n   *\n   * - `$isAttached` is false.\n   *\n   * @description\n   * This is the third \"cleanup\" lifecycle hook (after `detaching` and `caching`).\n   *\n   * The `$nodes` are now removed from the DOM and the `View` (if possible) is returned to cache.\n   *\n   * If no `$unbind` lifecycle is queued, this is the last opportunity to make state changes before the lifecycle ends.\n   */\n  detached?(flags: LifecycleFlags): void;\n}\n\nexport interface ILifecycleCaching extends IHooks, IState {\n  /**\n   * Called during `$unmount` (which happens during `$detach`), specifically after the\n   * `$nodes` are removed from the DOM, but before the view is actually added to the cache.\n   *\n   * @description\n   * This is the second \"cleanup\" lifecycle hook.\n   *\n   * This lifecycle is invoked if and only if the `ViewFactory` that created the `View` allows the view to be cached.\n   *\n   * Usually this hook is not invoked unless you explicitly set the cache size to to something greater than zero\n   * on the resource description.\n   */\n  caching?(flags: LifecycleFlags): void;\n}\n\n/**\n * Defines optional lifecycle hooks that will be called only when they are implemented.\n */\nexport interface ILifecycleHooks extends\n  ILifecycleCreated,\n  ILifecycleBinding,\n  ILifecycleBound,\n  ILifecycleUnbinding,\n  ILifecycleUnbound,\n  ILifecycleAttaching,\n  ILifecycleAttached,\n  ILifecycleDetaching,\n  ILifecycleDetached,\n  ILifecycleCaching { }\n\nexport interface ILifecycleCache {\n  $cache(flags: LifecycleFlags): void;\n}\n\nexport interface ICachable extends ILifecycleCache { }\n\nexport interface ILifecycleAttach {\n  $attach(flags: LifecycleFlags, encapsulationSource?: INode): void;\n}\n\nexport interface ILifecycleDetach {\n  $detach(flags: LifecycleFlags): void;\n}\n\nexport interface IAttach extends ILifecycleAttach, ILifecycleDetach, ICachable {\n  /** @internal */$nextAttach: IAttach;\n  /** @internal */$prevAttach: IAttach;\n}\n\nexport interface ILifecycleMount {\n  /** @internal */$nextMount?: ILifecycleMount;\n\n  /**\n   * Add the `$nodes` of this instance to the Host or RenderLocation that this instance is holding.\n   */\n  $mount(flags: LifecycleFlags): void;\n}\n\nexport interface ILifecycleUnmount {\n  /** @internal */$nextUnmount?: ILifecycleUnmount;\n\n  /**\n   * Remove the `$nodes` of this instance from the Host or RenderLocation that this instance is holding, optionally returning them to a cache.\n   * @returns\n   * - `true` if the instance has been returned to the cache.\n   * - `false` if the cache (typically ViewFactory) did not allow the instance to be cached.\n   * - `undefined` (void) if the instance does not support caching. Functionally equivalent to `false`\n   */\n  $unmount(flags: LifecycleFlags): boolean | void;\n}\nexport interface IMountable extends ILifecycleMount, ILifecycleUnmount { }\n\nexport interface ILifecycleUnbind {\n  $state?: State;\n  $unbind(flags: LifecycleFlags): void;\n}\n\nexport interface ILifecycleUnbindAfterDetach extends ILifecycleUnbind {\n  $nextUnbindAfterDetach?: ILifecycleUnbindAfterDetach;\n}\n\nexport interface ILifecycleBind {\n  $state?: State;\n  $bind(flags: LifecycleFlags, scope?: IScope): void;\n}\n\nexport interface ILifecycleBindScope {\n  $state?: State;\n  $bind(flags: LifecycleFlags, scope: IScope): void;\n}\n\nexport interface IBind extends ILifecycleBind, ILifecycleUnbind {\n  /** @internal */$nextBind: IBindScope;\n  /** @internal */$prevBind: IBindScope;\n}\n\nexport interface IBindScope extends Omit<IBind, '$bind'>, ILifecycleBindScope { }\n\nconst marker = Object.freeze(Object.create(null));\n\n/*\n * Note: the lifecycle object ensures that certain callbacks are executed in a particular order that may\n * deviate from the order in which the component tree is walked.\n * The component tree is always walked in a top-down recursive fashion, for example:\n * {\n *   path: \"1\",\n *   children: [\n *     { path: \"1.1\", children: [\n *       { path: \"1.1.1\" },\n *       { path: \"1.1.2\" }\n *     ]},\n *     { path: \"1.2\", children: [\n *       { path: \"1.2.1\" },\n *       { path: \"1.2.2\" }\n *     ]}\n *   ]\n * }\n * The call chain would be: 1 -> 1.1 -> 1.1.1 -> 1.1.2 -> 1.2 -> 1.2.1 -> 1.2.2\n *\n * During mounting, for example, we want to mount the root component *last* (so that the DOM doesn't need to be updated\n * for each mount operation), and we want to invoke the detached callbacks in the same order that the components were mounted.\n * But all mounts need to happen before any of the detach callbacks are invoked, so we store the components in a LinkedList\n * whose execution is deferred until all the normal $attach/$detach calls have occurred.\n * In the example of attach, the call chains would look like this:\n * $attach: 1 -> 1.1 -> 1.1.1 -> 1.1.2 -> 1.2 -> 1.2.1 -> 1.2.2\n * $mount: 1.1.1 -> 1.1.2 -> 1.1 -> 1.2.1 -> 1.2.2 -> 1.2 -> 1\n * attached: 1.1.1 -> 1.1.2 -> 1.1 -> 1.2.1 -> 1.2.2 -> 1.2 -> 1\n *\n * Instead of (without the lifecycles):\n * $attach: 1, $mount: 1, detached: 1 -> $attach: 1.1, $mount: 1.1, detached: 1.1 -> etc..\n *\n * Furthermore, the lifecycle object tracks the call depth so that it will automatically run a list of operations\n * when the top-most component finishes execution, and components themselves don't need to worry about where in the\n * tree they reside.\n */\n\nexport interface IFlushLifecycle {\n  processFlushQueue(flags: LifecycleFlags): void;\n\n  /**\n   * Queue a flush() callback to be executed either on the next promise tick or on the next\n   * bind lifecycle (if during startTask) or on the next attach lifecycle.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   *\n   * This queue is primarily used by DOM target observers and collection observers.\n   */\n  enqueueFlush(requestor: IChangeTracker): Promise<void>;\n}\n\nexport interface IBindLifecycle extends IFlushLifecycle {\n  /**\n   * Open up / expand a bind batch for enqueueing `bound` callbacks.\n   *\n   * When the top-most caller calls `endBind`, the `bound` callbacks will be invoked.\n   *\n   * Each `beginBind` *must* be matched by an `endBind`.\n   */\n  beginBind(): void;\n\n  /**\n   * Add a `bound` callback to the queue, to be invoked when the current bind batch\n   * is ended via `endBind` by the top-most caller.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   */\n  enqueueBound(requestor: ILifecycleBound): void;\n\n  /**\n   * Add a `connect` callback to the queue, to be invoked *after* mounting and *before*\n   * `detached` callbacks.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   */\n  enqueueConnect(requestor: IConnectableBinding): void;\n\n  /**\n   * Close / shrink a bind batch for invoking queued `bound` callbacks.\n   * @param flags The flags that will be passed into the `bound` callbacks.\n   *\n   * Flags during bind are primarily for optimization purposes, and to control whether\n   * changes are batched or propagated synchronously.\n   * If unsure which flags to provide, it's OK to use `LifecycleFlags.none` (or simply `0`)\n   * This default will work, but is generally less efficient.\n   */\n  endBind(flags: LifecycleFlags): ILifecycleTask;\n\n  /**\n   * Open up / expand an unbind batch for enqueueing `unbound` callbacks.\n   *\n   * When the top-most caller calls `endUnbind`, the `unbound` callbacks will be invoked.\n   *\n   * Each `beginUnbind` *must* be matched by an `endUnbind`.\n   */\n  beginUnbind(): void;\n\n  /**\n   * Add an `unbound` callback to the queue, to be invoked when the current unbind batch\n   * is ended via `endUnbind` by the top-most caller.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   */\n  enqueueUnbound(requestor: ILifecycleUnbound): void;\n\n  /**\n   * Close / shrink an unbind batch for invoking queued `unbound` callbacks.\n   * @param flags The flags that will be passed into the `unbound` callbacks.\n   *\n   * Flags during unbind are primarily for optimization purposes, and to control whether\n   * changes are batched or propagated synchronously.\n   * If unsure which flags to provide, it's OK to use `LifecycleFlags.none` (or simply `0`)\n   * This default will work, but is generally less efficient.\n   */\n  endUnbind(flags: LifecycleFlags): ILifecycleTask;\n}\n\nexport interface IAttachLifecycle extends IFlushLifecycle {\n  /**\n   * Open up / expand an attach batch for enqueueing `$mount` and `attached` callbacks.\n   *\n   * When the top-most caller calls `endAttach`, the `$mount` and `attached` callbacks\n   * will be invoked (in that order).\n   *\n   * Each `beginAttach` *must* be matched by an `endAttach`.\n   */\n  beginAttach(): void;\n\n  /**\n   * Add a `$mount` callback to the queue, to be invoked when the current attach batch\n   * is ended via `endAttach` by the top-most caller.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   */\n  enqueueMount(requestor: ILifecycleMount): void;\n\n  /**\n   * Add an `attached` callback to the queue, to be invoked when the current attach batch\n   * is ended via `endAttach` by the top-most caller.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   */\n  enqueueAttached(requestor: ILifecycleAttached): void;\n\n  /**\n   * Close / shrink an attach batch for invoking queued `$mount` and `attached` callbacks.\n   * @param flags The flags that will be passed into the `$mount` and `attached` callbacks.\n   *\n   * Flags during attach are primarily for optimization purposes.\n   * If unsure which flags to provide, it's OK to use `LifecycleFlags.none` (or simply `0`)\n   * This default will work, but is generally less efficient.\n   */\n  endAttach(flags: LifecycleFlags): ILifecycleTask;\n\n  /**\n   * Open up / expand a detach batch for enqueueing `$unmount` and `detached` callbacks.\n   *\n   * When the top-most caller calls `endAttach`, the `$unmount` and `detached` callbacks\n   * will be invoked (in that order).\n   *\n   * Each `beginAttach` *must* be matched by an `endAttach`.\n   */\n  beginDetach(): void;\n\n  /**\n   * Add a `$unmount` callback to the queue, to be invoked when the current detach batch\n   * is ended via `endAttach` by the top-most caller.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   */\n  enqueueUnmount(requestor: ILifecycleUnmount): void;\n\n  /**\n   * Add a `detached` callback to the queue, to be invoked when the current detach batch\n   * is ended via `endAttach` by the top-most caller.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   */\n  enqueueDetached(requestor: ILifecycleDetached): void;\n\n  /**\n   * Add an `$unbind` callback to the queue, to be invoked when the current detach batch\n   * is ended via `endAttach` by the top-most caller. The callback is invoked after all the\n   * `$unmount` and `detached` callbacks are processed.\n   *\n   * This method is idempotent; adding the same item more than once has the same effect as\n   * adding it once.\n   */\n  enqueueUnbindAfterDetach(requestor: ILifecycleUnbind): void;\n\n  /**\n   * Close / shrink a detach batch for invoking queued `$unmount` and `detached` callbacks.\n   * @param flags The flags that will be passed into the `$unmount` and `detached` callbacks.\n   *\n   * Flags during detach are primarily for optimization purposes, and to control whether a\n   * component should be unmounted or not (the default is to only unmount root nodes).\n   * If unsure which flags to provide, it's OK to use `LifecycleFlags.none` (or simply `0`).\n   * This default will work, but is generally less efficient.\n   */\n  endDetach(flags: LifecycleFlags): ILifecycleTask;\n}\n\nexport interface ILifecycle extends IBindLifecycle, IAttachLifecycle {\n  registerTask(task: ILifecycleTask): void;\n  finishTask(task: ILifecycleTask): void;\n}\n\nexport const ILifecycle = DI.createInterface<ILifecycle>().withDefault(x => x.singleton(Lifecycle));\nexport const IFlushLifecycle = ILifecycle as InterfaceSymbol<IFlushLifecycle>;\nexport const IBindLifecycle = ILifecycle as InterfaceSymbol<IBindLifecycle>;\nexport const IAttachLifecycle = ILifecycle as InterfaceSymbol<IAttachLifecycle>;\n\n/** @internal */\nexport class Lifecycle implements ILifecycle {\n  /** @internal */public bindDepth: number;\n  /** @internal */public attachDepth: number;\n  /** @internal */public detachDepth: number;\n  /** @internal */public unbindDepth: number;\n\n  /** @internal */public flushHead: IChangeTracker;\n  /** @internal */public flushTail: IChangeTracker;\n\n  /** @internal */public connectHead: IConnectableBinding;\n  /** @internal */public connectTail: IConnectableBinding;\n\n  /** @internal */public patchHead: IConnectableBinding;\n  /** @internal */public patchTail: IConnectableBinding;\n\n  /** @internal */public boundHead: ILifecycleBound;\n  /** @internal */public boundTail: ILifecycleBound;\n\n  /** @internal */public mountHead: ILifecycleMount;\n  /** @internal */public mountTail: ILifecycleMount;\n\n  /** @internal */public attachedHead: ILifecycleAttached;\n  /** @internal */public attachedTail: ILifecycleAttached;\n\n  /** @internal */public unmountHead: ILifecycleUnmount;\n  /** @internal */public unmountTail: ILifecycleUnmount;\n\n  /** @internal */public detachedHead: ILifecycleDetached;\n  /** @internal */public detachedTail: ILifecycleDetached;\n\n  /** @internal */public unbindAfterDetachHead: ILifecycleUnbindAfterDetach;\n  /** @internal */public unbindAfterDetachTail: ILifecycleUnbindAfterDetach;\n\n  /** @internal */public unboundHead: ILifecycleUnbound;\n  /** @internal */public unboundTail: ILifecycleUnbound;\n\n  /** @internal */public flushed: Promise<void>;\n  /** @internal */public promise: Promise<void>;\n\n  /** @internal */public flushCount: number;\n  /** @internal */public connectCount: number;\n  /** @internal */public patchCount: number;\n  /** @internal */public boundCount: number;\n  /** @internal */public mountCount: number;\n  /** @internal */public attachedCount: number;\n  /** @internal */public unmountCount: number;\n  /** @internal */public detachedCount: number;\n  /** @internal */public unbindAfterDetachCount: number;\n  /** @internal */public unboundCount: number;\n\n  // These are dummy properties to make the lifecycle conform to the interfaces\n  // of the components it manages. This allows the lifecycle itself to be the first link\n  // in the chain and removes the need for an additional null check on each addition.\n  /** @internal */public $nextFlush: IChangeTracker;\n  /** @internal */public flush: IChangeTracker['flush'];\n  /** @internal */public $nextConnect: IConnectableBinding;\n  /** @internal */public connect: IConnectableBinding['connect'];\n  /** @internal */public $nextPatch: IConnectableBinding;\n  /** @internal */public patch: IConnectableBinding['patch'];\n  /** @internal */public $nextBound: ILifecycleBound;\n  /** @internal */public bound: ILifecycleBound['bound'];\n  /** @internal */public $nextMount: ILifecycleMount;\n  /** @internal */public $mount: ILifecycleMount['$mount'];\n  /** @internal */public $nextAttached: ILifecycleAttached;\n  /** @internal */public attached: ILifecycleAttached['attached'];\n  /** @internal */public $nextUnmount: ILifecycleUnmount;\n  /** @internal */public $unmount: ILifecycleUnmount['$unmount'];\n  /** @internal */public $nextDetached: ILifecycleDetached;\n  /** @internal */public detached: ILifecycleDetached['detached'];\n  /** @internal */public $nextUnbindAfterDetach: ILifecycleUnbindAfterDetach;\n  /** @internal */public $unbind: ILifecycleUnbindAfterDetach['$unbind'];\n  /** @internal */public $nextUnbound: ILifecycleUnbound;\n  /** @internal */public unbound: ILifecycleUnbound['unbound'];\n\n  /** @internal */public task: AggregateLifecycleTask | null;\n\n  constructor() {\n    this.bindDepth = 0;\n    this.attachDepth = 0;\n    this.detachDepth = 0;\n    this.unbindDepth = 0;\n\n    this.flushHead = this;\n    this.flushTail = this;\n\n    this.connectHead = this as unknown as IConnectableBinding; // this cast is safe because we know exactly which properties we'll use\n    this.connectTail = this as unknown as IConnectableBinding;\n\n    this.patchHead = this as unknown as IConnectableBinding;\n    this.patchTail = this as unknown as IConnectableBinding;\n\n    this.boundHead = this;\n    this.boundTail = this;\n\n    this.mountHead = this;\n    this.mountTail = this;\n\n    this.attachedHead = this;\n    this.attachedTail = this;\n\n    this.unmountHead = this;\n    this.unmountTail = this;\n\n    this.detachedHead = this; //LOL\n    this.detachedTail = this;\n\n    this.unbindAfterDetachHead = this;\n    this.unbindAfterDetachTail = this;\n\n    this.unboundHead = this;\n    this.unboundTail = this;\n\n    this.flushed = null;\n    this.promise = Promise.resolve();\n\n    this.flushCount = 0;\n    this.connectCount = 0;\n    this.patchCount = 0;\n    this.boundCount = 0;\n    this.mountCount = 0;\n    this.attachedCount = 0;\n    this.unmountCount = 0;\n    this.detachedCount = 0;\n    this.unbindAfterDetachCount = 0;\n    this.unboundCount = 0;\n\n    this.$nextFlush = marker;\n    this.flush = PLATFORM.noop;\n    this.$nextConnect = marker;\n    this.connect = PLATFORM.noop;\n    this.$nextPatch = marker;\n    this.patch = PLATFORM.noop;\n    this.$nextBound = marker;\n    this.bound = PLATFORM.noop;\n    this.$nextMount = marker;\n    this.$mount = PLATFORM.noop;\n    this.$nextAttached = marker;\n    this.attached = PLATFORM.noop;\n    this.$nextUnmount = marker;\n    this.$unmount = PLATFORM.noop;\n    this.$nextDetached = marker;\n    this.detached = PLATFORM.noop;\n    this.$nextUnbindAfterDetach = marker;\n    this.$unbind = PLATFORM.noop;\n    this.$nextUnbound = marker;\n    this.unbound = PLATFORM.noop;\n\n    this.task = null;\n  }\n\n  public registerTask(task: ILifecycleTask): void {\n    if (this.task === null) {\n      this.task = new AggregateLifecycleTask();\n    }\n    this.task.addTask(task);\n  }\n\n  public finishTask(task: ILifecycleTask): void {\n    if (this.task !== null) {\n      if (this.task === task) {\n        this.task = null;\n      } else {\n        this.task.removeTask(task);\n      }\n    }\n  }\n\n  public enqueueFlush(requestor: IChangeTracker): Promise<void> {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.enqueueFlush', slice.call(arguments)); }\n    // Queue a flush() callback; the depth is just for debugging / testing purposes and has\n    // no effect on execution. flush() will automatically be invoked when the promise resolves,\n    // or it can be manually invoked synchronously.\n    if (this.flushHead === this) {\n      this.flushed = this.promise.then(() => { this.processFlushQueue(LifecycleFlags.fromAsyncFlush); });\n    }\n    if (requestor.$nextFlush === null) {\n      requestor.$nextFlush = marker;\n      this.flushTail.$nextFlush = requestor;\n      this.flushTail = requestor;\n      ++this.flushCount;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return this.flushed;\n  }\n\n  public processFlushQueue(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.processFlushQueue', slice.call(arguments)); }\n    flags |= LifecycleFlags.fromSyncFlush;\n    // flush callbacks may lead to additional flush operations, so keep looping until\n    // the flush head is back to `this` (though this will typically happen in the first iteration)\n    while (this.flushCount > 0) {\n      let current = this.flushHead.$nextFlush;\n      this.flushHead = this.flushTail = this;\n      this.flushCount = 0;\n      let next: typeof current;\n      do {\n        next = current.$nextFlush;\n        current.$nextFlush = null;\n        current.flush(flags);\n        current = next;\n      } while (current !== marker);\n      // doNotUpdateDOM will cause DOM updates to be re-queued which results in an infinite loop\n      // unless we break here\n      // Note that breaking on this flag is still not the ideal solution; future improvement would\n      // be something like a separate DOM queue and a non-DOM queue, but for now this fixes the infinite\n      // loop without breaking anything (apart from the edgiest of edge cases which are not yet tested)\n      if (flags & LifecycleFlags.doNotUpdateDOM) {\n        break;\n      }\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public beginBind(): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.beginBind', slice.call(arguments)); }\n    ++this.bindDepth;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public enqueueBound(requestor: ILifecycleBound): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.enqueueBound', slice.call(arguments)); }\n    // build a standard singly linked list for bound callbacks\n    if (requestor.$nextBound === null) {\n      requestor.$nextBound = marker;\n      this.boundTail.$nextBound = requestor;\n      this.boundTail = requestor;\n      ++this.boundCount;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public enqueueConnect(requestor: IConnectableBinding): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.enqueueConnect', slice.call(arguments)); }\n    // enqueue connect and patch calls in separate lists so that they can be invoked\n    // independently from eachother\n    // TODO: see if we can eliminate/optimize some of this, because this is a relatively hot path\n    // (first get all the necessary integration tests working, then look for optimizations)\n\n    // build a standard singly linked list for connect callbacks\n    if (requestor.$nextConnect === null) {\n      requestor.$nextConnect = marker;\n      this.connectTail.$nextConnect = requestor;\n      this.connectTail = requestor;\n      ++this.connectCount;\n    }\n    // build a standard singly linked list for patch callbacks\n    if (requestor.$nextPatch === null) {\n      requestor.$nextPatch = marker;\n      this.patchTail.$nextPatch = requestor;\n      this.patchTail = requestor;\n      ++this.patchCount;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public processConnectQueue(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.processConnectQueue', slice.call(arguments)); }\n    // connects cannot lead to additional connects, so we don't need to loop here\n    if (this.connectCount > 0) {\n      this.connectCount = 0;\n      let current = this.connectHead.$nextConnect;\n      this.connectHead = this.connectTail = this as unknown as IConnectableBinding;\n      let next: typeof current;\n      do {\n        current.connect(flags);\n        next = current.$nextConnect;\n        current.$nextConnect = null;\n        current = next;\n      } while (current !== marker);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public processPatchQueue(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.processPatchQueue', slice.call(arguments)); }\n    // flush before patching, but only if this is the initial bind;\n    // no DOM is attached yet so we can safely let everything propagate\n    if (flags & LifecycleFlags.fromStartTask) {\n      this.processFlushQueue(flags | LifecycleFlags.fromSyncFlush);\n    }\n    // patch callbacks may lead to additional bind operations, so keep looping until\n    // the patch head is back to `this` (though this will typically happen in the first iteration)\n    while (this.patchCount > 0) {\n      this.patchCount = 0;\n      let current = this.patchHead.$nextPatch;\n      this.patchHead = this.patchTail = this as unknown as IConnectableBinding;\n      let next: typeof current;\n      do {\n        current.patch(flags);\n        next = current.$nextPatch;\n        current.$nextPatch = null;\n        current = next;\n      } while (current !== marker);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public endBind(flags: LifecycleFlags): ILifecycleTask {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.endBind', slice.call(arguments)); }\n    // close / shrink a bind batch\n    if (--this.bindDepth === 0) {\n      if (this.task !== null && !this.task.done) {\n        this.task.owner = this;\n        if (Tracer.enabled) { Tracer.leave(); }\n        return this.task;\n      }\n\n      this.processBindQueue(flags);\n\n      if (Tracer.enabled) { Tracer.leave(); }\n      return LifecycleTask.done;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public processBindQueue(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.processBindQueue', slice.call(arguments)); }\n    // flush before processing bound callbacks, but only if this is the initial bind;\n    // no DOM is attached yet so we can safely let everything propagate\n    if (flags & LifecycleFlags.fromStartTask) {\n      this.processFlushQueue(flags | LifecycleFlags.fromSyncFlush);\n    }\n    // bound callbacks may lead to additional bind operations, so keep looping until\n    // the bound head is back to `this` (though this will typically happen in the first iteration)\n    while (this.boundCount > 0) {\n      this.boundCount = 0;\n      let current = this.boundHead.$nextBound;\n      let next: ILifecycleBound;\n      this.boundHead = this.boundTail = this;\n      do {\n        current.bound(flags);\n        next = current.$nextBound;\n        current.$nextBound = null;\n        current = next;\n      } while (current !== marker);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public beginUnbind(): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.beginUnbind', slice.call(arguments)); }\n    // open up / expand an unbind batch; the very first caller will close it again with endUnbind\n    ++this.unbindDepth;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public enqueueUnbound(requestor: ILifecycleUnbound): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.enqueueUnbound', slice.call(arguments)); }\n    // This method is idempotent; adding the same item more than once has the same effect as\n    // adding it once.\n    // build a standard singly linked list for unbound callbacks\n    if (requestor.$nextUnbound === null) {\n      requestor.$nextUnbound = marker;\n      this.unboundTail.$nextUnbound = requestor;\n      this.unboundTail = requestor;\n      ++this.unboundCount;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public endUnbind(flags: LifecycleFlags): ILifecycleTask {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.endUnbind', slice.call(arguments)); }\n    // close / shrink an unbind batch\n    if (--this.unbindDepth === 0) {\n      if (this.task !== null && !this.task.done) {\n        this.task.owner = this;\n        if (Tracer.enabled) { Tracer.leave(); }\n        return this.task;\n      }\n\n      this.processUnbindQueue(flags);\n\n      if (Tracer.enabled) { Tracer.leave(); }\n      return LifecycleTask.done;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public processUnbindQueue(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.processUnbindQueue', slice.call(arguments)); }\n    // unbound callbacks may lead to additional unbind operations, so keep looping until\n    // the unbound head is back to `this` (though this will typically happen in the first iteration)\n    while (this.unboundCount > 0) {\n      this.unboundCount = 0;\n      let current = this.unboundHead.$nextUnbound;\n      let next: ILifecycleUnbound;\n      this.unboundHead = this.unboundTail = this;\n      do {\n        current.unbound(flags);\n        next = current.$nextUnbound;\n        current.$nextUnbound = null;\n        current = next;\n      } while (current !== marker);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public beginAttach(): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.beginAttach', slice.call(arguments)); }\n    // open up / expand an attach batch; the very first caller will close it again with endAttach\n    ++this.attachDepth;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public enqueueMount(requestor: ILifecycleMount): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.enqueueMount', slice.call(arguments)); }\n    // This method is idempotent; adding the same item more than once has the same effect as\n    // adding it once.\n    // build a standard singly linked list for mount callbacks\n    if (requestor.$nextMount === null) {\n      requestor.$nextMount = marker;\n      this.mountTail.$nextMount = requestor;\n      this.mountTail = requestor;\n      ++this.mountCount;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public enqueueAttached(requestor: ILifecycleAttached): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.enqueueAttached', slice.call(arguments)); }\n    // This method is idempotent; adding the same item more than once has the same effect as\n    // adding it once.\n    // build a standard singly linked list for attached callbacks\n    if (requestor.$nextAttached === null) {\n      requestor.$nextAttached = marker;\n      this.attachedTail.$nextAttached = requestor;\n      this.attachedTail = requestor;\n      ++this.attachedCount;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public endAttach(flags: LifecycleFlags): ILifecycleTask {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.endAttach', slice.call(arguments)); }\n    // close / shrink an attach batch\n    if (--this.attachDepth === 0) {\n      if (this.task !== null && !this.task.done) {\n        this.task.owner = this;\n        if (Tracer.enabled) { Tracer.leave(); }\n        return this.task;\n      }\n\n      this.processAttachQueue(flags);\n\n      if (Tracer.enabled) { Tracer.leave(); }\n      return LifecycleTask.done;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public processAttachQueue(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.processAttachQueue', slice.call(arguments)); }\n    // flush and patch before starting the attach lifecycle to ensure batched collection changes are propagated to repeaters\n    // and the DOM is updated\n    this.processFlushQueue(flags | LifecycleFlags.fromSyncFlush);\n    // TODO: prevent duplicate updates coming from the patch queue (or perhaps it's just not needed in its entirety?)\n    //this.processPatchQueue(flags | LifecycleFlags.fromSyncFlush);\n\n    if (this.mountCount > 0) {\n      this.mountCount = 0;\n      let currentMount = this.mountHead.$nextMount;\n      this.mountHead = this.mountTail = this;\n      let nextMount: typeof currentMount;\n\n      do {\n        currentMount.$mount(flags);\n        nextMount = currentMount.$nextMount;\n        currentMount.$nextMount = null;\n        currentMount = nextMount;\n      } while (currentMount !== marker);\n    }\n    // Connect all connect-queued bindings AFTER mounting is done, so that the DOM is visible asap,\n    // but connect BEFORE running the attached callbacks to ensure any changes made during those callbacks\n    // are still accounted for.\n    // TODO: add a flag/option to further delay connect with a RAF callback (the tradeoff would be that we'd need\n    // to run an additional patch cycle before that connect, which can be expensive and unnecessary in most real\n    // world scenarios, but can significantly speed things up with nested, highly volatile data like in dbmonster)\n    this.processConnectQueue(LifecycleFlags.mustEvaluate);\n\n    if (this.attachedCount > 0) {\n      this.attachedCount = 0;\n      let currentAttached = this.attachedHead.$nextAttached;\n      this.attachedHead = this.attachedTail = this;\n      let nextAttached: typeof currentAttached;\n\n      do {\n        currentAttached.attached(flags);\n        nextAttached = currentAttached.$nextAttached;\n        currentAttached.$nextAttached = null;\n        currentAttached = nextAttached;\n      } while (currentAttached !== marker);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public beginDetach(): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.beginDetach', slice.call(arguments)); }\n    // open up / expand a detach batch; the very first caller will close it again with endDetach\n    ++this.detachDepth;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public enqueueUnmount(requestor: ILifecycleUnmount): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.enqueueUnmount', slice.call(arguments)); }\n    // This method is idempotent; adding the same item more than once has the same effect as\n    // adding it once.\n    // build a standard singly linked list for unmount callbacks\n    if (requestor.$nextUnmount === null) {\n      requestor.$nextUnmount = marker;\n      this.unmountTail.$nextUnmount = requestor;\n      this.unmountTail = requestor;\n      ++this.unmountCount;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public enqueueDetached(requestor: ILifecycleDetached): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.enqueueDetached', slice.call(arguments)); }\n    // This method is idempotent; adding the same item more than once has the same effect as\n    // adding it once.\n    // build a standard singly linked list for detached callbacks\n    if (requestor.$nextDetached === null) {\n      requestor.$nextDetached = marker;\n      this.detachedTail.$nextDetached = requestor;\n      this.detachedTail = requestor;\n      ++this.detachedCount;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public enqueueUnbindAfterDetach(requestor: ILifecycleUnbindAfterDetach): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.enqueueUnbindAfterDetach', slice.call(arguments)); }\n    // This method is idempotent; adding the same item more than once has the same effect as\n    // adding it once.\n    // build a standard singly linked list for unbindAfterDetach callbacks\n    if (requestor.$nextUnbindAfterDetach === null) {\n      requestor.$nextUnbindAfterDetach = marker;\n      this.unbindAfterDetachTail.$nextUnbindAfterDetach = requestor;\n      this.unbindAfterDetachTail = requestor;\n      ++this.unbindAfterDetachCount;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public endDetach(flags: LifecycleFlags): ILifecycleTask {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.endDetach', slice.call(arguments)); }\n    // close / shrink a detach batch\n    if (--this.detachDepth === 0) {\n      if (this.task !== null && !this.task.done) {\n        this.task.owner = this;\n        return this.task;\n      }\n\n      this.processDetachQueue(flags);\n\n      if (Tracer.enabled) { Tracer.leave(); }\n      return LifecycleTask.done;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public processDetachQueue(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Lifecycle.processDetachQueue', slice.call(arguments)); }\n    // flush before unmounting to ensure batched collection changes propagate to the repeaters,\n    // which may lead to additional unmount operations\n    this.processFlushQueue(flags | LifecycleFlags.fromFlush | LifecycleFlags.doNotUpdateDOM);\n\n    if (this.unmountCount > 0) {\n      this.unmountCount = 0;\n      let currentUnmount = this.unmountHead.$nextUnmount;\n      this.unmountHead = this.unmountTail = this;\n      let nextUnmount: typeof currentUnmount;\n\n      do {\n        currentUnmount.$unmount(flags);\n        nextUnmount = currentUnmount.$nextUnmount;\n        currentUnmount.$nextUnmount = null;\n        currentUnmount = nextUnmount;\n      } while (currentUnmount !== marker);\n    }\n\n    if (this.detachedCount > 0) {\n      this.detachedCount = 0;\n      let currentDetached = this.detachedHead.$nextDetached;\n      this.detachedHead = this.detachedTail = this;\n      let nextDetached: typeof currentDetached;\n\n      do {\n        currentDetached.detached(flags);\n        nextDetached = currentDetached.$nextDetached;\n        currentDetached.$nextDetached = null;\n        currentDetached = nextDetached;\n      } while (currentDetached !== marker);\n    }\n\n    if (this.unbindAfterDetachCount > 0) {\n      this.beginUnbind();\n      this.unbindAfterDetachCount = 0;\n      let currentUnbind = this.unbindAfterDetachHead.$nextUnbindAfterDetach;\n      this.unbindAfterDetachHead = this.unbindAfterDetachTail = this;\n      let nextUnbind: typeof currentUnbind;\n\n      do {\n        currentUnbind.$unbind(flags);\n        nextUnbind = currentUnbind.$nextUnbindAfterDetach;\n        currentUnbind.$nextUnbindAfterDetach = null;\n        currentUnbind = nextUnbind;\n      } while (currentUnbind !== marker);\n      this.endUnbind(flags);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@inject(ILifecycle)\nexport class CompositionCoordinator {\n  public readonly $lifecycle: ILifecycle;\n\n  public onSwapComplete: () => void;\n\n  private currentView: IView;\n  private isAttached: boolean;\n  private isBound: boolean;\n  private queue: (IView | PromiseSwap)[] | null;\n  private scope: IScope;\n  private swapTask: ILifecycleTask;\n\n  constructor($lifecycle: ILifecycle) {\n    this.$lifecycle = $lifecycle;\n\n    this.onSwapComplete = PLATFORM.noop;\n\n    this.currentView = null;\n    this.isAttached = false;\n    this.isBound = false;\n    this.queue = null;\n    this.swapTask = LifecycleTask.done;\n  }\n\n  public static register(container: IContainer): IResolver<CompositionCoordinator> {\n    return Registration.transient(this, this).register(container, this);\n  }\n\n  public compose(value: IView | Promise<IView>, flags: LifecycleFlags): void {\n    if (this.swapTask.done) {\n      if (value instanceof Promise) {\n        this.enqueue(new PromiseSwap(this, value));\n        this.processNext();\n      } else {\n        this.swap(value, flags);\n      }\n    } else {\n      if (value instanceof Promise) {\n        this.enqueue(new PromiseSwap(this, value));\n      } else {\n        this.enqueue(value);\n      }\n\n      if (this.swapTask.canCancel()) {\n        this.swapTask.cancel();\n      }\n    }\n  }\n\n  public binding(flags: LifecycleFlags, scope: IScope): void {\n    this.scope = scope;\n    this.isBound = true;\n\n    if (this.currentView !== null) {\n      this.currentView.$bind(flags, scope);\n    }\n  }\n\n  public attaching(flags: LifecycleFlags): void {\n    this.isAttached = true;\n\n    if (this.currentView !== null) {\n      this.currentView.$attach(flags);\n    }\n  }\n\n  public detaching(flags: LifecycleFlags): void {\n    this.isAttached = false;\n\n    if (this.currentView !== null) {\n      this.currentView.$detach(flags);\n    }\n  }\n\n  public unbinding(flags: LifecycleFlags): void {\n    this.isBound = false;\n\n    if (this.currentView !== null) {\n      this.currentView.$unbind(flags);\n    }\n  }\n\n  public caching(flags: LifecycleFlags): void {\n    this.currentView = null;\n  }\n\n  private enqueue(view: IView | PromiseSwap): void {\n    if (this.queue === null) {\n      this.queue = [];\n    }\n\n    this.queue.push(view);\n  }\n\n  private swap(view: IView, flags: LifecycleFlags): void {\n    if (this.currentView === view) {\n      return;\n    }\n\n    const $lifecycle = this.$lifecycle;\n    const swapTask = new AggregateLifecycleTask();\n\n    let lifecycleTask: ILifecycleTask;\n    let currentView = this.currentView;\n    if (currentView === null) {\n      lifecycleTask = LifecycleTask.done;\n    } else {\n      $lifecycle.enqueueUnbindAfterDetach(currentView);\n      $lifecycle.beginDetach();\n      currentView.$detach(flags);\n      lifecycleTask = $lifecycle.endDetach(flags);\n    }\n    swapTask.addTask(lifecycleTask);\n\n    currentView = this.currentView = view;\n\n    if (currentView === null) {\n      lifecycleTask = LifecycleTask.done;\n    } else {\n      if (this.isBound) {\n        $lifecycle.beginBind();\n        currentView.$bind(flags, this.scope);\n        $lifecycle.endBind(flags);\n      }\n      if (this.isAttached) {\n        $lifecycle.beginAttach();\n        currentView.$attach(flags);\n        lifecycleTask = $lifecycle.endAttach(flags);\n      } else {\n        lifecycleTask = LifecycleTask.done;\n      }\n    }\n    swapTask.addTask(lifecycleTask);\n\n    if (swapTask.done) {\n      this.swapTask = LifecycleTask.done;\n      this.onSwapComplete();\n    } else {\n      this.swapTask = swapTask;\n      this.swapTask.wait().then(() => {\n        this.onSwapComplete();\n        this.processNext();\n      }).catch(error => { throw error; });\n    }\n  }\n\n  private processNext(): void {\n    if (this.queue !== null && this.queue.length > 0) {\n      const next = this.queue.pop();\n      this.queue.length = 0;\n\n      if (PromiseSwap.is(next)) {\n        this.swapTask = next.start();\n      } else {\n        this.swap(next, LifecycleFlags.fromLifecycleTask);\n      }\n    } else {\n      this.swapTask = LifecycleTask.done;\n    }\n  }\n}\n\nexport const LifecycleTask = {\n  done: {\n    done: true,\n    canCancel(): boolean { return false; },\n    cancel(): void { return; },\n    wait(): Promise<unknown> { return Promise.resolve(); }\n  }\n};\n\nexport interface ILifecycleTask<T = unknown> {\n  readonly done: boolean;\n  canCancel(): boolean;\n  cancel(): void;\n  wait(): Promise<T>;\n}\n\nexport class AggregateLifecycleTask implements ILifecycleTask<void> {\n  public done: boolean;\n\n  /** @internal */\n  public owner: Lifecycle;\n\n  private resolve: () => void;\n  private tasks: ILifecycleTask[];\n  private waiter: Promise<void>;\n\n  constructor() {\n    this.done = true;\n\n    this.owner = null;\n\n    this.resolve = null;\n    this.tasks = [];\n    this.waiter = null;\n  }\n\n  public addTask(task: ILifecycleTask): void {\n    if (!task.done) {\n      this.done = false;\n      this.tasks.push(task);\n      task.wait().then(() => { this.tryComplete(); }).catch(error => { throw error; });\n    }\n  }\n\n  public removeTask(task: ILifecycleTask): void {\n    if (task.done) {\n      const idx = this.tasks.indexOf(task);\n      if (idx !== -1) {\n        this.tasks.splice(idx, 1);\n      }\n    }\n    if (this.tasks.length === 0 && this.owner !== null) {\n      this.owner.finishTask(this);\n      this.owner = null;\n    }\n  }\n\n  public canCancel(): boolean {\n    if (this.done) {\n      return false;\n    }\n\n    return this.tasks.every(x => x.canCancel());\n  }\n\n  public cancel(): void {\n    if (this.canCancel()) {\n      this.tasks.forEach(x => { x.cancel(); });\n      this.done = false;\n    }\n  }\n\n  public wait(): Promise<void> {\n    if (this.waiter === null) {\n      if (this.done) {\n        this.waiter = Promise.resolve();\n      } else {\n        // tslint:disable-next-line:promise-must-complete\n        this.waiter = new Promise((resolve) => this.resolve = resolve);\n      }\n    }\n\n    return this.waiter;\n  }\n\n  private tryComplete(): void {\n    if (this.done) {\n      return;\n    }\n\n    if (this.tasks.every(x => x.done)) {\n      this.complete(true);\n    }\n  }\n\n  private complete(notCancelled: boolean): void {\n    this.done = true;\n\n    if (notCancelled && this.owner !== null) {\n      this.owner.processDetachQueue(LifecycleFlags.fromLifecycleTask);\n      this.owner.processUnbindQueue(LifecycleFlags.fromLifecycleTask);\n      this.owner.processBindQueue(LifecycleFlags.fromLifecycleTask);\n      this.owner.processAttachQueue(LifecycleFlags.fromLifecycleTask);\n    }\n    this.owner.finishTask(this);\n\n    if (this.resolve !== null) {\n      this.resolve();\n    }\n  }\n}\n\n/** @internal */\nexport class PromiseSwap implements ILifecycleTask<IView> {\n  public done: boolean;\n\n  private coordinator: CompositionCoordinator;\n  private isCancelled: boolean;\n  private promise: Promise<IView>;\n\n  constructor(coordinator: CompositionCoordinator, promise: Promise<IView>) {\n    this.coordinator = coordinator;\n    this.done = false;\n    this.isCancelled = false;\n    this.promise = promise;\n  }\n\n  public static is(object: object): object is PromiseSwap {\n    return 'start' in object;\n  }\n\n  public start(): ILifecycleTask<IView | unknown> {\n    if (this.isCancelled) {\n      return LifecycleTask.done;\n    }\n\n    this.promise = this.promise.then(x => {\n      this.onResolve(x);\n      return x;\n    });\n\n    return this;\n  }\n\n  public canCancel(): boolean {\n    return !this.done;\n  }\n\n  public cancel(): void {\n    if (this.canCancel()) {\n      this.isCancelled = true;\n    }\n  }\n\n  public wait(): Promise<IView> {\n    return this.promise;\n  }\n\n  private onResolve(value: IView): void {\n    if (this.isCancelled) {\n      return;\n    }\n\n    this.done = true;\n    this.coordinator.compose(value, LifecycleFlags.fromLifecycleTask);\n  }\n}\n\n// tslint:disable:jsdoc-format\n/**\n * A general-purpose ILifecycleTask implementation that can be placed\n * before an attached, detached, bound or unbound hook during attaching,\n * detaching, binding or unbinding, respectively.\n *\n * The provided promise will be awaited before the corresponding lifecycle\n * hook (and any hooks following it) is invoked.\n *\n * The provided callback will be invoked after the promise is resolved\n * and before the next lifecycle hook.\n *\n * Example:\n```ts\nexport class MyViewModel {\n  private $lifecycle: ILifecycle; // set before created() hook\n  private answer: number;\n\n  public binding(flags: LifecycleFlags): void {\n    // this.answer === undefined\n    this.$lifecycle.registerTask(new PromiseTask(\n      this.getAnswerAsync,\n      answer => {\n        this.answer = answer;\n      }\n    ));\n  }\n\n  public bound(flags: LifecycleFlags): void {\n    // this.answer === 42\n  }\n\n  private getAnswerAsync(): Promise<number> {\n    return Promise.resolve().then(() => 42);\n  }\n}\n```\n */\n// tslint:enable:jsdoc-format\nexport class PromiseTask<T = void> implements ILifecycleTask<T> {\n  public done: boolean;\n\n  private isCancelled: boolean;\n  private promise: Promise<T>;\n  private callback: (result?: T) => void;\n\n  constructor(promise: Promise<T>, callback: (result?: T) => void) {\n    this.done = false;\n    this.isCancelled = false;\n    this.callback = callback;\n    this.promise = promise.then(value => {\n      if (this.isCancelled === true) {\n        return;\n      }\n      this.done = true;\n      this.callback(value);\n      return value;\n    });\n  }\n\n  public canCancel(): boolean {\n    return !this.done;\n  }\n\n  public cancel(): void {\n    if (this.canCancel()) {\n      this.isCancelled = true;\n    }\n  }\n\n  public wait(): Promise<T> {\n    return this.promise;\n  }\n}\n","import { Class, IIndexable, Tracer } from '@aurelia/kernel';\nimport { IBindingTargetObserver, IPropertySubscriber, LifecycleFlags } from '../observation';\nimport { IObserverLocator } from '../observation/observer-locator';\nimport { IBinding } from './binding';\n\n// TODO: add connect-queue (or something similar) back in when everything else is working, to improve startup time\n\nconst slice = Array.prototype.slice;\n\nconst slotNames: string[] = [];\nconst versionSlotNames: string[] = [];\nlet lastSlot = -1;\nfunction ensureEnoughSlotNames(currentSlot: number): void {\n  if (currentSlot === lastSlot) {\n    lastSlot += 5;\n    const ii = slotNames.length = versionSlotNames.length = lastSlot + 1;\n    for (let i = currentSlot + 1; i < ii; ++i) {\n      slotNames[i] = `_observer${i}`;\n      versionSlotNames[i] = `_observerVersion${i}`;\n    }\n  }\n}\nensureEnoughSlotNames(-1);\n\nexport interface IPartialConnectableBinding extends IBinding, IPropertySubscriber {\n  observerLocator: IObserverLocator;\n}\n\nexport interface IConnectableBinding extends IPartialConnectableBinding {\n  $nextConnect?: IConnectableBinding;\n  $nextPatch?: IConnectableBinding;\n  observerSlots: number;\n  version: number;\n  observeProperty(obj: IIndexable, propertyName: string): void;\n  addObserver(observer: IBindingTargetObserver): void;\n  unobserve(all?: boolean): void;\n  connect(flags: LifecycleFlags): void;\n  patch(flags: LifecycleFlags): void;\n}\n\n/** @internal */\nexport function addObserver(this: IConnectableBinding, observer: IBindingTargetObserver): void {\n  // find the observer.\n  const observerSlots = this.observerSlots === undefined ? 0 : this.observerSlots;\n  let i = observerSlots;\n\n  while (i-- && this[slotNames[i]] !== observer);\n\n  // if we are not already observing, put the observer in an open slot and subscribe.\n  if (i === -1) {\n    i = 0;\n    while (this[slotNames[i]]) {\n      i++;\n    }\n    this[slotNames[i]] = observer;\n    observer.subscribe(this);\n    // increment the slot count.\n    if (i === observerSlots) {\n      this.observerSlots = i + 1;\n    }\n  }\n  // set the \"version\" when the observer was used.\n  if (this.version === undefined) {\n    this.version = 0;\n  }\n  this[versionSlotNames[i]] = this.version;\n  ensureEnoughSlotNames(i);\n}\n\n/** @internal */\nexport function observeProperty(this: IConnectableBinding, obj: IIndexable, propertyName: string): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.observeProperty`, slice.call(arguments)); }\n  const observer = this.observerLocator.getObserver(obj, propertyName) as IBindingTargetObserver;\n  /* Note: we need to cast here because we can indeed get an accessor instead of an observer,\n   *  in which case the call to observer.subscribe will throw. It's not very clean and we can solve this in 2 ways:\n   *  1. Fail earlier: only let the locator resolve observers from .getObserver, and throw if no branches are left (e.g. it would otherwise return an accessor)\n   *  2. Fail silently (without throwing): give all accessors a no-op subscribe method\n   *\n   * We'll probably want to implement some global configuration (like a \"strict\" toggle) so users can pick between enforced correctness vs. ease-of-use\n   */\n  this.addObserver(observer);\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function unobserve(this: IConnectableBinding, all?: boolean): void {\n  const slots = this.observerSlots;\n  let slotName: string;\n  let observer: IBindingTargetObserver;\n  if (all === true) {\n    for (let i = 0; i < slots; ++i) {\n      slotName = slotNames[i];\n      observer = this[slotName];\n      if (observer !== null && observer !== undefined) {\n        this[slotName] = null;\n        observer.unsubscribe(this);\n      }\n    }\n  } else {\n    const version = this.version;\n    for (let i = 0; i < slots; ++i) {\n      if (this[versionSlotNames[i]] !== version) {\n        slotName = slotNames[i];\n        observer = this[slotName];\n        if (observer !== null && observer !== undefined) {\n          this[slotName] = null;\n          observer.unsubscribe(this);\n        }\n      }\n    }\n  }\n}\n\ntype DecoratableConnectable<TProto, TClass> = Class<TProto & Partial<IConnectableBinding> & IPartialConnectableBinding, TClass>;\ntype DecoratedConnectable<TProto, TClass> = Class<TProto & IConnectableBinding, TClass>;\n\nfunction connectableDecorator<TProto, TClass>(target: DecoratableConnectable<TProto, TClass>): DecoratedConnectable<TProto, TClass> {\n  const proto = target.prototype;\n  if (!proto.hasOwnProperty('observeProperty')) proto.observeProperty = observeProperty;\n  if (!proto.hasOwnProperty('unobserve')) proto.unobserve = unobserve;\n  if (!proto.hasOwnProperty('addObserver')) proto.addObserver = addObserver;\n  return target as DecoratedConnectable<TProto, TClass>;\n}\n\nexport function connectable(): typeof connectableDecorator;\nexport function connectable<TProto, TClass>(target: DecoratableConnectable<TProto, TClass>): DecoratedConnectable<TProto, TClass>;\nexport function connectable<TProto, TClass>(target?: DecoratableConnectable<TProto, TClass>): DecoratedConnectable<TProto, TClass> | typeof connectableDecorator {\n  return target === undefined ? connectableDecorator : connectableDecorator(target);\n}\n","import { IServiceLocator, Reporter, Tracer } from '@aurelia/kernel';\nimport { INode } from '../dom.interfaces';\nimport { IBindScope, ILifecycle, State } from '../lifecycle';\nimport { AccessorOrObserver, IBindingTargetObserver, IObservable, IScope, LifecycleFlags } from '../observation';\nimport { IObserverLocator } from '../observation//observer-locator';\nimport { ExpressionKind, ForOfStatement, hasBind, hasUnbind, IsBindingBehavior } from './ast';\nimport { BindingMode } from './binding-mode';\nimport { connectable, IConnectableBinding, IPartialConnectableBinding } from './connectable';\n\nconst slice = Array.prototype.slice;\n\nexport interface IBinding extends IBindScope {\n  readonly locator: IServiceLocator;\n  readonly $scope: IScope;\n}\n\nexport type IBindingTarget = INode | IObservable; // Can be: Node | CSSStyleDeclaration | IObservable;\n\n// BindingMode is not a const enum (and therefore not inlined), so assigning them to a variable to save a member accessor is a minor perf tweak\nconst { oneTime, toView, fromView } = BindingMode;\n\n// pre-combining flags for bitwise checks is a minor perf tweak\nconst toViewOrOneTime = toView | oneTime;\n\nexport interface Binding extends IConnectableBinding {}\n\n@connectable()\nexport class Binding implements IPartialConnectableBinding {\n  public $nextBind: IBindScope;\n  public $prevBind: IBindScope;\n  public $state: State;\n  public $lifecycle: ILifecycle;\n  public $nextConnect: IConnectableBinding;\n  public $nextPatch: IConnectableBinding;\n  public $scope: IScope;\n\n  public locator: IServiceLocator;\n  public mode: BindingMode;\n  public observerLocator: IObserverLocator;\n  public sourceExpression: IsBindingBehavior | ForOfStatement;\n  public target: IBindingTarget;\n  public targetProperty: string;\n\n  public targetObserver: AccessorOrObserver;\n\n  public persistentFlags: LifecycleFlags;\n\n  constructor(sourceExpression: IsBindingBehavior | ForOfStatement, target: IBindingTarget, targetProperty: string, mode: BindingMode, observerLocator: IObserverLocator, locator: IServiceLocator) {\n    this.$nextBind = null;\n    this.$prevBind = null;\n    this.$state = State.none;\n    this.$lifecycle = locator.get(ILifecycle);\n    this.$nextConnect = null;\n    this.$nextPatch = null;\n    this.$scope = null;\n\n    this.locator = locator;\n    this.mode = mode;\n    this.observerLocator = observerLocator;\n    this.sourceExpression = sourceExpression;\n    this.target = target;\n    this.targetProperty = targetProperty;\n  }\n\n  public updateTarget(value: unknown, flags: LifecycleFlags): void {\n    flags |= this.persistentFlags;\n    this.targetObserver.setValue(value, flags | LifecycleFlags.updateTargetInstance);\n  }\n\n  public updateSource(value: unknown, flags: LifecycleFlags): void {\n    flags |= this.persistentFlags;\n    this.sourceExpression.assign(flags | LifecycleFlags.updateSourceExpression, this.$scope, this.locator, value);\n  }\n\n  public handleChange(newValue: unknown, _previousValue: unknown, flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Binding.handleChange', slice.call(arguments)); }\n    if (!(this.$state & State.isBound)) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n\n    const sourceExpression = this.sourceExpression;\n    const $scope = this.$scope;\n    const locator = this.locator;\n    flags |= this.persistentFlags;\n\n    if (flags & LifecycleFlags.updateTargetInstance) {\n      const targetObserver = this.targetObserver;\n      const mode = this.mode;\n\n      const previousValue = targetObserver.getValue();\n      // if the only observable is an AccessScope then we can assume the passed-in newValue is the correct and latest value\n      if (sourceExpression.$kind !== ExpressionKind.AccessScope || this.observerSlots > 1) {\n        newValue = sourceExpression.evaluate(flags, $scope, locator);\n      }\n      if (newValue !== previousValue) {\n        this.updateTarget(newValue, flags);\n      }\n      if ((mode & oneTime) === 0) {\n        this.version++;\n        sourceExpression.connect(flags, $scope, this);\n        this.unobserve(false);\n      }\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n\n    if (flags & LifecycleFlags.updateSourceExpression) {\n      if (newValue !== sourceExpression.evaluate(flags, $scope, locator)) {\n        this.updateSource(newValue, flags);\n      }\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n\n    throw Reporter.error(15, LifecycleFlags[flags]);\n  }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (Tracer.enabled) { Tracer.enter('Binding.$bind', slice.call(arguments)); }\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        if (Tracer.enabled) { Tracer.leave(); }\n        return;\n      }\n      this.$unbind(flags | LifecycleFlags.fromBind);\n    }\n    // add isBinding flag\n    this.$state |= State.isBinding;\n\n    // Store flags which we can only receive during $bind and need to pass on\n    // to the AST during evaluate/connect/assign\n    this.persistentFlags = flags & LifecycleFlags.persistentBindingFlags;\n\n    this.$scope = scope;\n\n    let sourceExpression = this.sourceExpression;\n    if (hasBind(sourceExpression)) {\n      sourceExpression.bind(flags, scope, this);\n    }\n\n    const mode = this.mode;\n    let targetObserver = this.targetObserver as IBindingTargetObserver;\n    if (!targetObserver) {\n      if (mode & fromView) {\n        targetObserver = this.targetObserver = this.observerLocator.getObserver(this.target, this.targetProperty) as IBindingTargetObserver;\n      } else {\n        targetObserver = this.targetObserver = this.observerLocator.getAccessor(this.target, this.targetProperty) as IBindingTargetObserver;\n      }\n    }\n    if (targetObserver.bind) {\n      targetObserver.bind(flags);\n    }\n\n    // during bind, binding behavior might have changed sourceExpression\n    sourceExpression = this.sourceExpression;\n    if (mode & toViewOrOneTime) {\n      this.updateTarget(sourceExpression.evaluate(flags, scope, this.locator), flags);\n    }\n    if (mode & toView) {\n      this.$lifecycle.enqueueConnect(this);\n    }\n    if (mode & fromView) {\n      targetObserver.subscribe(this);\n    }\n\n    // add isBound flag and remove isBinding flag\n    this.$state |= State.isBound;\n    this.$state &= ~State.isBinding;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Binding.$unbind', slice.call(arguments)); }\n    if (!(this.$state & State.isBound)) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    // clear persistent flags\n    this.persistentFlags = LifecycleFlags.none;\n\n    const sourceExpression = this.sourceExpression;\n    if (hasUnbind(sourceExpression)) {\n      sourceExpression.unbind(flags, this.$scope, this);\n    }\n    this.$scope = null;\n\n    const targetObserver = this.targetObserver as IBindingTargetObserver;\n    if (targetObserver.unbind) {\n      targetObserver.unbind(flags);\n    }\n    if (targetObserver.unsubscribe) {\n      targetObserver.unsubscribe(this);\n    }\n    this.unobserve(true);\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public connect(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Binding.connect', slice.call(arguments)); }\n    if (this.$state & State.isBound) {\n      flags |= this.persistentFlags;\n      this.sourceExpression.connect(flags | LifecycleFlags.mustEvaluate, this.$scope, this);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public patch(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Binding.patch', slice.call(arguments)); }\n    if (this.$state & State.isBound) {\n      flags |= this.persistentFlags;\n      this.updateTarget(this.sourceExpression.evaluate(flags | LifecycleFlags.mustEvaluate, this.$scope, this.locator), flags);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n","import { IServiceLocator, Tracer } from '@aurelia/kernel';\nimport { INode } from '../dom.interfaces';\nimport { IBindScope, State } from '../lifecycle';\nimport { IAccessor, IScope, LifecycleFlags } from '../observation';\nimport { IObserverLocator } from '../observation//observer-locator';\nimport { hasBind, hasUnbind, IsBindingBehavior } from './ast';\nimport { IConnectableBinding } from './connectable';\n\nconst slice = Array.prototype.slice;\n\nexport interface Call extends IConnectableBinding {}\nexport class Call {\n  public $nextBind: IBindScope;\n  public $prevBind: IBindScope;\n  public $state: State;\n  public $scope: IScope;\n\n  public locator: IServiceLocator;\n  public sourceExpression: IsBindingBehavior;\n  public targetObserver: IAccessor;\n\n  constructor(sourceExpression: IsBindingBehavior, target: INode, targetProperty: string, observerLocator: IObserverLocator, locator: IServiceLocator) {\n    this.$nextBind = null;\n    this.$prevBind = null;\n    this.$state = State.none;\n\n    this.locator = locator;\n    this.sourceExpression = sourceExpression;\n    this.targetObserver = observerLocator.getObserver(target, targetProperty);\n  }\n\n  public callSource(args: object): unknown {\n    if (Tracer.enabled) { Tracer.enter('Call.callSource', slice.call(arguments)); }\n    const overrideContext = this.$scope.overrideContext;\n    Object.assign(overrideContext, args);\n    const result = this.sourceExpression.evaluate(LifecycleFlags.mustEvaluate, this.$scope, this.locator);\n\n    for (const prop in args) {\n      delete overrideContext[prop];\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n    return result;\n  }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (Tracer.enabled) { Tracer.enter('Call.$bind', slice.call(arguments)); }\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        if (Tracer.enabled) { Tracer.leave(); }\n        return;\n      }\n\n      this.$unbind(flags | LifecycleFlags.fromBind);\n    }\n    // add isBinding flag\n    this.$state |= State.isBinding;\n\n    this.$scope = scope;\n\n    const sourceExpression = this.sourceExpression;\n    if (hasBind(sourceExpression)) {\n      sourceExpression.bind(flags, scope, this);\n    }\n\n    this.targetObserver.setValue($args => this.callSource($args), flags);\n\n    // add isBound flag and remove isBinding flag\n    this.$state |= State.isBound;\n    this.$state &= ~State.isBinding;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Call.$unbind', slice.call(arguments)); }\n    if (!(this.$state & State.isBound)) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    const sourceExpression = this.sourceExpression;\n    if (hasUnbind(sourceExpression)) {\n      sourceExpression.unbind(flags, this.$scope, this);\n    }\n\n    this.$scope = null;\n    this.targetObserver.setValue(null, flags);\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public observeProperty(obj: object, propertyName: string): void {\n    return;\n  }\n\n  public handleChange(newValue: unknown, previousValue: unknown, flags: LifecycleFlags): void {\n    return;\n  }\n}\n","import { DI, PLATFORM, Reporter } from '@aurelia/kernel';\nimport {\n  AccessMember,\n  AccessScope,\n  CallMember,\n  CallScope,\n  ExpressionKind,\n  ForOfStatement,\n  Interpolation,\n  IsBindingBehavior,\n  PrimitiveLiteral\n} from './ast';\n\ntype BindingExpression = Interpolation | ForOfStatement | IsBindingBehavior;\n\nexport interface IExpressionParser {\n  cache(expressions: Record<string, BindingExpression>): void;\n  parse(expression: string, bindingType: BindingType.ForCommand): ForOfStatement;\n  parse(expression: string, bindingType: BindingType.Interpolation): Interpolation;\n  parse(expression: string, bindingType: Exclude<BindingType, BindingType.ForCommand | BindingType.Interpolation>): IsBindingBehavior;\n  parse(expression: string, bindingType: BindingType): BindingExpression;\n}\n\nexport const IExpressionParser = DI.createInterface<IExpressionParser>()\n  .withDefault(x => x.singleton(ExpressionParser));\n\n/** @internal */\nexport class ExpressionParser implements IExpressionParser {\n  private expressionLookup: Record<string, IsBindingBehavior>;\n  private forOfLookup: Record<string, ForOfStatement>;\n  private interpolationLookup: Record<string, Interpolation>;\n\n  constructor() {\n    this.expressionLookup = Object.create(null);\n    this.forOfLookup = Object.create(null);\n    this.interpolationLookup = Object.create(null);\n  }\n\n  public parse(expression: string, bindingType: BindingType.ForCommand): ForOfStatement;\n  public parse(expression: string, bindingType: BindingType.Interpolation): Interpolation;\n  public parse(expression: string, bindingType: Exclude<BindingType, BindingType.ForCommand | BindingType.Interpolation>): IsBindingBehavior;\n  public parse(expression: string, bindingType: BindingType): BindingExpression {\n    switch (bindingType) {\n      case BindingType.Interpolation:\n      {\n        let found = this.interpolationLookup[expression];\n        if (found === undefined) {\n          found = this.interpolationLookup[expression] = this.parseCore(expression, bindingType);\n        }\n        return found;\n      }\n      case BindingType.ForCommand:\n      {\n        let found = this.forOfLookup[expression];\n        if (found === undefined) {\n          found = this.forOfLookup[expression] = this.parseCore(expression, bindingType);\n        }\n        return found;\n      }\n      default:\n      {\n        // Allow empty strings for normal bindings and those that are empty by default (such as a custom attribute without an equals sign)\n        // But don't cache it, because empty strings are always invalid for any other type of binding\n        if (expression.length === 0 && (bindingType & (BindingType.BindCommand | BindingType.OneTimeCommand | BindingType.ToViewCommand))) {\n          return PrimitiveLiteral.$empty;\n        }\n        let found = this.expressionLookup[expression];\n        if (found === undefined) {\n          found = this.expressionLookup[expression] = this.parseCore(expression, bindingType);\n        }\n        return found;\n      }\n    }\n  }\n\n  public cache(expressions: Record<string, BindingExpression>): void {\n    const { forOfLookup, expressionLookup, interpolationLookup } = this;\n    for (const expression in expressions) {\n      const expr = expressions[expression];\n      switch (expr.$kind) {\n        case ExpressionKind.Interpolation:\n          interpolationLookup[expression] = expr;\n          break;\n        case ExpressionKind.ForOfStatement:\n          forOfLookup[expression] = expr;\n          break;\n        default:\n          expressionLookup[expression] = expr;\n      }\n    }\n  }\n\n  private parseCore(expression: string, bindingType: BindingType.ForCommand): ForOfStatement;\n  private parseCore(expression: string, bindingType: BindingType.Interpolation): Interpolation;\n  private parseCore(expression: string, bindingType: Exclude<BindingType, BindingType.ForCommand | BindingType.Interpolation>): IsBindingBehavior;\n  private parseCore(expression: string, bindingType: BindingType): BindingExpression {\n    try {\n      const parts = expression.split('.');\n      const firstPart = parts[0];\n      let current: BindingExpression;\n\n      if (firstPart.endsWith('()')) {\n        current = new CallScope(firstPart.replace('()', ''), PLATFORM.emptyArray);\n      } else {\n        current = new AccessScope(parts[0]);\n      }\n\n      let index = 1;\n\n      while (index < parts.length) {\n        const currentPart = parts[index];\n\n        if (currentPart.endsWith('()')) {\n          current = new CallMember(current, currentPart.replace('()', ''), PLATFORM.emptyArray);\n        } else {\n          current = new AccessMember(current, parts[index]);\n        }\n\n        index++;\n      }\n\n      return current;\n    } catch (e) {\n      throw Reporter.error(3, e);\n    }\n  }\n}\n\nexport const enum BindingType {\n              None = 0,\n     Interpolation = 0b10000000_0000,\n        IsRef      = 0b01010000_0000,\n        IsIterator = 0b00100000_0000,\n        IsCustom   = 0b00010000_0000,\n        IsFunction = 0b00001000_0000,\n        IsEvent    = 0b00000100_0000,\n        IsProperty = 0b00000010_0000,\n        IsCommand  = 0b00000001_0000,\nIsPropertyCommand  = 0b00000011_0000,\n   IsEventCommand  = 0b00000101_0000,\nDelegationStrategyDelta =     0b0110,\n           Command =          0b1111,\n    OneTimeCommand = 0b00000011_0001,\n     ToViewCommand = 0b00000011_0010,\n   FromViewCommand = 0b00000011_0011,\n     TwoWayCommand = 0b00000011_0100,\n       BindCommand = 0b00000011_0101,\n    TriggerCommand = 0b00000101_0110,\n    CaptureCommand = 0b00000101_0111,\n   DelegateCommand = 0b00000101_1000,\n       CallCommand = 0b00001001_1001,\n    OptionsCommand = 0b00000001_1010,\n        ForCommand = 0b00100001_1011,\n     CustomCommand = 0b00010001_1100\n}\n","import { IServiceLocator } from '@aurelia/kernel';\nimport { IBindScope, State } from '../lifecycle';\nimport { IBindingTargetAccessor, IScope, LifecycleFlags } from '../observation';\nimport { IObserverLocator } from '../observation/observer-locator';\nimport { IExpression, Interpolation } from './ast';\nimport { IBinding, IBindingTarget } from './binding';\nimport { BindingMode } from './binding-mode';\nimport { connectable, IConnectableBinding, IPartialConnectableBinding } from './connectable';\n\nconst { toView, oneTime } = BindingMode;\n\nexport class MultiInterpolationBinding implements IBinding {\n  public $nextBind: IBindScope;\n  public $prevBind: IBindScope;\n  public $state: State;\n  public $scope: IScope;\n\n  public interpolation: Interpolation;\n  public observerLocator: IObserverLocator;\n  public locator: IServiceLocator;\n  public mode: BindingMode;\n  public parts: InterpolationBinding[];\n  public target: IBindingTarget;\n  public targetProperty: string;\n\n  constructor(observerLocator: IObserverLocator, interpolation: Interpolation, target: IBindingTarget, targetProperty: string, mode: BindingMode, locator: IServiceLocator) {\n    this.$nextBind = null;\n    this.$prevBind = null;\n    this.$state = State.none;\n    this.$scope = null;\n\n    this.interpolation = interpolation;\n    this.locator = locator;\n    this.mode = mode;\n    this.observerLocator = observerLocator;\n    this.target = target;\n    this.targetProperty = targetProperty;\n\n    // Note: the child expressions of an Interpolation expression are full Aurelia expressions, meaning they may include\n    // value converters and binding behaviors.\n    // Each expression represents one ${interpolation}, and for each we create a child TextBinding unless there is only one,\n    // in which case the renderer will create the TextBinding directly\n    const expressions = interpolation.expressions;\n    const parts = this.parts = Array(expressions.length);\n    for (let i = 0, ii = expressions.length; i < ii; ++i) {\n      parts[i] = new InterpolationBinding(expressions[i], interpolation, target, targetProperty, mode, observerLocator, locator, i === 0);\n    }\n  }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        return;\n      }\n      this.$unbind(flags);\n    }\n    this.$state |= State.isBound;\n    this.$scope = scope;\n\n    const parts = this.parts;\n    for (let i = 0, ii = parts.length; i < ii; ++i) {\n      parts[i].$bind(flags, scope);\n    }\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (!(this.$state & State.isBound)) {\n      return;\n    }\n    this.$state &= ~State.isBound;\n    this.$scope = null;\n    const parts = this.parts;\n    for (let i = 0, ii = parts.length; i < ii; ++i) {\n      parts[i].$unbind(flags);\n    }\n  }\n}\n\nexport interface InterpolationBinding extends IConnectableBinding {}\n\n@connectable()\nexport class InterpolationBinding implements IPartialConnectableBinding {\n  public $scope: IScope;\n  public $state: State;\n\n  public interpolation: Interpolation;\n  public isFirst: boolean;\n  public locator: IServiceLocator;\n  public mode: BindingMode;\n  public observerLocator: IObserverLocator;\n  public sourceExpression: IExpression;\n  public target: IBindingTarget;\n  public targetProperty: string;\n\n  public targetObserver: IBindingTargetAccessor;\n\n  // tslint:disable-next-line:parameters-max-number\n  constructor(sourceExpression: IExpression, interpolation: Interpolation, target: IBindingTarget, targetProperty: string, mode: BindingMode, observerLocator: IObserverLocator, locator: IServiceLocator, isFirst: boolean) {\n    this.$state = State.none;\n\n    this.interpolation = interpolation;\n    this.isFirst = isFirst;\n    this.mode = mode;\n    this.locator = locator;\n    this.observerLocator = observerLocator;\n    this.sourceExpression = sourceExpression;\n    this.target = target;\n    this.targetProperty = targetProperty;\n\n    this.targetObserver = observerLocator.getAccessor(target, targetProperty);\n  }\n\n  public updateTarget(value: unknown, flags: LifecycleFlags): void {\n    this.targetObserver.setValue(value, flags | LifecycleFlags.updateTargetInstance);\n  }\n\n  public handleChange(_newValue: unknown, _previousValue: unknown, flags: LifecycleFlags): void {\n    if (!(this.$state & State.isBound)) {\n      return;\n    }\n\n    const previousValue = this.targetObserver.getValue();\n    const newValue = this.interpolation.evaluate(flags, this.$scope, this.locator);\n    if (newValue !== previousValue) {\n      this.updateTarget(newValue, flags);\n    }\n\n    if ((this.mode & oneTime) === 0) {\n      this.version++;\n      this.sourceExpression.connect(flags, this.$scope, this);\n      this.unobserve(false);\n    }\n  }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        return;\n      }\n      this.$unbind(flags);\n    }\n\n    this.$state |= State.isBound;\n    this.$scope = scope;\n\n    const sourceExpression = this.sourceExpression;\n    if (sourceExpression.bind) {\n      sourceExpression.bind(flags, scope, this);\n    }\n\n    // since the interpolation already gets the whole value, we only need to let the first\n    // text binding do the update if there are multiple\n    if (this.isFirst) {\n      this.updateTarget(this.interpolation.evaluate(flags, scope, this.locator), flags);\n    }\n    if (this.mode & toView) {\n      sourceExpression.connect(flags, scope, this);\n    }\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (!(this.$state & State.isBound)) {\n      return;\n    }\n    this.$state &= ~State.isBound;\n\n    const sourceExpression = this.sourceExpression;\n    if (sourceExpression.unbind) {\n      sourceExpression.unbind(flags, this.$scope, this);\n    }\n\n    this.$scope = null;\n    this.unobserve(true);\n  }\n}\n","import { IIndexable, IServiceLocator, Reporter, Tracer } from '@aurelia/kernel';\nimport { IBindScope, ILifecycle, State } from '../lifecycle';\nimport { IScope, LifecycleFlags } from '../observation';\nimport { IObserverLocator } from '../observation/observer-locator';\nimport { IExpression } from './ast';\nimport { IBindingTarget } from './binding';\nimport { connectable, IConnectableBinding, IPartialConnectableBinding } from './connectable';\n\nconst slice = Array.prototype.slice;\n\nexport interface LetBinding extends IConnectableBinding {}\n\n@connectable()\nexport class LetBinding implements IPartialConnectableBinding {\n  public $nextBind: IBindScope;\n  public $prevBind: IBindScope;\n  public $state: State;\n  public $lifecycle: ILifecycle;\n  public $scope: IScope;\n\n  public locator: IServiceLocator;\n  public observerLocator: IObserverLocator;\n  public sourceExpression: IExpression;\n  public target: IBindingTarget;\n  public targetProperty: string;\n\n  private toViewModel: boolean;\n\n  constructor(sourceExpression: IExpression, targetProperty: string, observerLocator: IObserverLocator, locator: IServiceLocator, toViewModel: boolean = false) {\n    this.$nextBind = null;\n    this.$prevBind = null;\n    this.$state = State.none;\n    this.$lifecycle = locator.get(ILifecycle);\n    this.$scope = null;\n\n    this.locator = locator;\n    this.observerLocator = observerLocator;\n    this.sourceExpression = sourceExpression;\n    this.target = null;\n    this.targetProperty = targetProperty;\n\n    this.toViewModel = toViewModel;\n  }\n\n  public handleChange(_newValue: unknown, _previousValue: unknown, flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('LetBinding.handleChange', slice.call(arguments)); }\n    if (!(this.$state & State.isBound)) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n\n    if (flags & LifecycleFlags.updateTargetInstance) {\n      const { target, targetProperty } = this as {target: IIndexable; targetProperty: string};\n      const previousValue: unknown = target[targetProperty];\n      const newValue: unknown = this.sourceExpression.evaluate(flags, this.$scope, this.locator);\n      if (newValue !== previousValue) {\n        target[targetProperty] = newValue;\n      }\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n\n    throw Reporter.error(15, flags);\n  }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (Tracer.enabled) { Tracer.enter('LetBinding.$bind', slice.call(arguments)); }\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        if (Tracer.enabled) { Tracer.leave(); }\n        return;\n      }\n      this.$unbind(flags | LifecycleFlags.fromBind);\n    }\n    // add isBinding flag\n    this.$state |= State.isBinding;\n\n    this.$scope = scope;\n    this.target = (this.toViewModel ? scope.bindingContext : scope.overrideContext) as IIndexable;\n\n    const sourceExpression = this.sourceExpression;\n    if (sourceExpression.bind) {\n      sourceExpression.bind(flags, scope, this);\n    }\n    // sourceExpression might have been changed during bind\n    this.target[this.targetProperty] = this.sourceExpression.evaluate(LifecycleFlags.fromBind, scope, this.locator);\n    this.sourceExpression.connect(flags, scope, this);\n\n    // add isBound flag and remove isBinding flag\n    this.$state |= State.isBound;\n    this.$state &= ~State.isBinding;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('LetBinding.$unbind', slice.call(arguments)); }\n    if (!(this.$state & State.isBound)) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    const sourceExpression = this.sourceExpression;\n    if (sourceExpression.unbind) {\n      sourceExpression.unbind(flags, this.$scope, this);\n    }\n    this.$scope = null;\n    this.unobserve(true);\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n","import { IDisposable, IIndexable, IServiceLocator, Tracer } from '@aurelia/kernel';\nimport { IEvent, INode } from '../dom.interfaces';\nimport { IBindScope, State } from '../lifecycle';\nimport { IScope, LifecycleFlags } from '../observation';\nimport { DelegationStrategy, IEventManager } from '../observation/event-manager';\nimport { hasBind, hasUnbind, IsBindingBehavior } from './ast';\nimport { IBinding } from './binding';\nimport { IConnectableBinding } from './connectable';\n\nconst slice = Array.prototype.slice;\n\nexport interface Listener extends IConnectableBinding {}\nexport class Listener implements IBinding {\n  public $nextBind: IBindScope;\n  public $prevBind: IBindScope;\n  public $state: State;\n  public $scope: IScope;\n\n  public delegationStrategy: DelegationStrategy;\n  public locator: IServiceLocator;\n  public preventDefault: boolean;\n  public sourceExpression: IsBindingBehavior;\n  public target: INode;\n  public targetEvent: string;\n\n  private eventManager: IEventManager;\n  private handler: IDisposable;\n\n  constructor(targetEvent: string, delegationStrategy: DelegationStrategy, sourceExpression: IsBindingBehavior, target: INode, preventDefault: boolean, eventManager: IEventManager, locator: IServiceLocator) {\n    this.$nextBind = null;\n    this.$prevBind = null;\n    this.$state = State.none;\n\n    this.delegationStrategy = delegationStrategy;\n    this.locator = locator;\n    this.preventDefault = preventDefault;\n    this.sourceExpression = sourceExpression;\n    this.target = target;\n    this.targetEvent = targetEvent;\n\n    this.eventManager = eventManager;\n  }\n\n  public callSource(event: IEvent): ReturnType<IsBindingBehavior['evaluate']> {\n    if (Tracer.enabled) { Tracer.enter('Listener.callSource', slice.call(arguments)); }\n    const overrideContext = this.$scope.overrideContext;\n    overrideContext['$event'] = event;\n\n    const result = this.sourceExpression.evaluate(LifecycleFlags.mustEvaluate, this.$scope, this.locator);\n\n    delete overrideContext['$event'];\n\n    if (result !== true && this.preventDefault) {\n      event.preventDefault();\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n    return result;\n  }\n\n  public handleEvent(event: IEvent): void {\n    this.callSource(event);\n  }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (Tracer.enabled) { Tracer.enter('Listener.$bind', slice.call(arguments)); }\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        if (Tracer.enabled) { Tracer.leave(); }\n        return;\n      }\n\n      this.$unbind(flags | LifecycleFlags.fromBind);\n    }\n    // add isBinding flag\n    this.$state |= State.isBinding;\n\n    this.$scope = scope;\n\n    const sourceExpression = this.sourceExpression;\n    if (hasBind(sourceExpression)) {\n      sourceExpression.bind(flags, scope, this);\n    }\n\n    this.handler = this.eventManager.addEventListener(\n      this.target,\n      this.targetEvent,\n      this,\n      this.delegationStrategy\n    );\n\n    // add isBound flag and remove isBinding flag\n    this.$state |= State.isBound;\n    this.$state &= ~State.isBinding;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Listener.$unbind', slice.call(arguments)); }\n    if (!(this.$state & State.isBound)) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    const sourceExpression = this.sourceExpression;\n    if (hasUnbind(sourceExpression)) {\n      sourceExpression.unbind(flags, this.$scope, this);\n    }\n\n    this.$scope = null;\n    this.handler.dispose();\n    this.handler = null;\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public observeProperty(obj: IIndexable, propertyName: string): void {\n    return;\n  }\n\n  public handleChange(newValue: unknown, previousValue: unknown, flags: LifecycleFlags): void {\n    return;\n  }\n}\n","import { IIndexable, IServiceLocator, Tracer } from '@aurelia/kernel';\nimport { IBindScope, State } from '../lifecycle';\nimport { IScope, LifecycleFlags } from '../observation';\nimport { hasBind, hasUnbind, IsBindingBehavior } from './ast';\nimport { IBinding, IBindingTarget } from './binding';\nimport { IConnectableBinding } from './connectable';\n\nconst slice = Array.prototype.slice;\n\nexport interface Ref extends IConnectableBinding {}\nexport class Ref implements IBinding {\n  public $nextBind: IBindScope;\n  public $prevBind: IBindScope;\n  public $state: State;\n  public $scope: IScope;\n\n  public locator: IServiceLocator;\n  public sourceExpression: IsBindingBehavior;\n  public target: IBindingTarget;\n\n  constructor(sourceExpression: IsBindingBehavior, target: IBindingTarget, locator: IServiceLocator) {\n    this.$nextBind = null;\n    this.$prevBind = null;\n    this.$state = State.none;\n\n    this.locator = locator;\n    this.sourceExpression = sourceExpression;\n    this.target = target;\n  }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (Tracer.enabled) { Tracer.enter('Ref.$bind', slice.call(arguments)); }\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        if (Tracer.enabled) { Tracer.leave(); }\n        return;\n      }\n\n      this.$unbind(flags | LifecycleFlags.fromBind);\n    }\n    // add isBinding flag\n    this.$state |= State.isBinding;\n\n    this.$scope = scope;\n\n    const sourceExpression = this.sourceExpression;\n    if (hasBind(sourceExpression)) {\n      sourceExpression.bind(flags, scope, this);\n    }\n\n    this.sourceExpression.assign(flags, this.$scope, this.locator, this.target);\n\n    // add isBound flag and remove isBinding flag\n    this.$state |= State.isBound;\n    this.$state &= ~State.isBinding;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Ref.$unbind', slice.call(arguments)); }\n    if (!(this.$state & State.isBound)) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    if (this.sourceExpression.evaluate(flags, this.$scope, this.locator) === this.target) {\n      this.sourceExpression.assign(flags, this.$scope, this.locator, null);\n    }\n\n    const sourceExpression = this.sourceExpression;\n    if (hasUnbind(sourceExpression)) {\n      sourceExpression.unbind(flags, this.$scope, this);\n    }\n\n    this.$scope = null;\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public observeProperty(obj: IIndexable, propertyName: string): void {\n    return;\n  }\n\n  public handleChange(newValue: unknown, previousValue: unknown, flags: LifecycleFlags): void {\n    return;\n  }\n}\n","import { DI } from '@aurelia/kernel';\n\nexport const enum NodeType {\n  Element = 1,\n  Attr = 2,\n  Text = 3,\n  CDATASection = 4,\n  EntityReference = 5,\n  Entity = 6,\n  ProcessingInstruction = 7,\n  Comment = 8,\n  Document = 9,\n  DocumentType = 10,\n  DocumentFragment = 11,\n  Notation = 12\n}\n\nexport interface IEventListener {\n  // tslint:disable-next-line:callable-types\n  (evt: IEvent): void;\n}\n\nexport interface IEventListenerObject {\n  handleEvent(evt: IEvent): void;\n}\n\nexport interface IEventListenerOptions {\n  capture?: boolean;\n}\n\nexport interface IAddEventListenerOptions extends IEventListenerOptions {\n  once?: boolean;\n  passive?: boolean;\n}\n\nexport type IEventListenerOrEventListenerObject = IEventListener | IEventListenerObject;\n\nexport interface IEvent {\n  readonly target: IEventTarget | null;\n  readonly type: string;\n  composedPath(): IEventTarget[];\n  preventDefault(): void;\n  stopImmediatePropagation(): void;\n  stopPropagation(): void;\n}\n\nexport interface IEventTarget {\n  addEventListener(type: string, listener: IEventListenerOrEventListenerObject | null, options?: boolean | IAddEventListenerOptions): void;\n  dispatchEvent(event: IEvent): boolean;\n  removeEventListener(type: string, callback: IEventListenerOrEventListenerObject | null, options?: IEventListenerOptions | boolean): void;\n}\n\nexport interface IGetRootNodeOptions {\n  composed?: boolean;\n}\n\nexport interface IParentNode {\n  readonly firstElementChild: IElement | null;\n  readonly lastElementChild: IElement | null;\n  querySelector<E extends IElement = IElement>(selectors: string): E | null;\n  querySelectorAll<E extends IElement = IElement>(selectors: string): ArrayLike<E>;\n}\n\nexport interface IChildNode extends INode {\n  remove(): void;\n}\n\nexport interface INodeLike {\n  readonly childNodes: ArrayLike<INode>;\n  readonly firstChild: INode | null;\n  readonly lastChild: INode | null;\n}\n\nexport interface INode extends INodeLike, IEventTarget {\n  readonly childNodes: ArrayLike<IChildNode>;\n  readonly firstChild: IChildNode | null;\n  readonly lastChild: IChildNode | null;\n  readonly nextSibling: INode | null;\n  readonly nodeName: string;\n  readonly nodeType: NodeType;\n  readonly parentNode: INode & IParentNode | null;\n  readonly previousSibling: INode | null;\n  textContent: string | null;\n  appendChild<T extends INode>(newChild: T): T;\n  cloneNode(deep?: boolean): INode;\n  /**\n   * Returns node's shadow-including root.\n   */\n  getRootNode(options?: IGetRootNodeOptions): INode;\n  insertBefore<T extends INode>(newChild: T, refChild: INode | null): T;\n  removeChild<T extends INode>(oldChild: T): T;\n  replaceChild<T extends INode>(newChild: INode, oldChild: T): T;\n}\n\nexport interface IHTMLSlotElement extends IHTMLElement {\n  name: string;\n}\n\nexport interface ISlotable {\n  readonly assignedSlot: IHTMLSlotElement | null;\n}\n\nexport interface INamedNodeMap {\n  readonly length: number;\n  item(index: number): IAttr | null;\n  [index: number]: IAttr;\n}\n\nexport interface IDOMTokenList {\n  readonly length: number;\n  value: string;\n  add(...tokens: string[]): void;\n  contains(token: string): boolean;\n  item(index: number): string | null;\n  remove(...tokens: string[]): void;\n  replace(oldToken: string, newToken: string): void;\n  // tslint:disable-next-line:no-any\n  forEach(callbackfn: (value: string, key: number, parent: IDOMTokenList) => void, thisArg?: any): void;\n  [index: number]: string;\n}\n\nexport interface IDocumentOrShadowRoot {\n  /**\n   * Retrieves a collection of styleSheet objects representing the style sheets that correspond to each instance of a link or style object in the document.\n   */\n  readonly styleSheets: IStyleSheetList;\n}\n\nexport interface IStyleSheet {\n  readonly href: string | null;\n  readonly ownerNode: INode;\n  readonly parentStyleSheet: IStyleSheet | null;\n}\n\nexport interface IStyleSheetList {\n  readonly length: number;\n  item(index: number): IStyleSheet | null;\n  [index: number]: IStyleSheet;\n}\n\nexport type IShadowRootMode = 'open' | 'closed';\n\nexport interface IShadowRoot extends IDocumentOrShadowRoot, IDocumentFragment {\n  readonly host: IElement;\n  innerHTML: string;\n  readonly mode: IShadowRootMode;\n}\n\nexport interface IShadowRootInit {\n  delegatesFocus?: boolean;\n  mode: 'open' | 'closed';\n}\n\nexport interface IAttr extends INode {\n  readonly name: string;\n  value: string;\n}\n\nexport interface ICSSStyleDeclaration {\n  cssText: string;\n  readonly length: number;\n  getPropertyPriority(propertyName: string): string;\n  getPropertyValue(propertyName: string): string;\n  item(index: number): string;\n  removeProperty(propertyName: string): string;\n  setProperty(propertyName: string, value: string | null, priority?: string | null): void;\n  [index: number]: string;\n}\n\nexport interface IElementCSSInlineStyle {\n  readonly style: ICSSStyleDeclaration;\n}\n\nexport type IInsertPosition = 'beforebegin' | 'afterbegin' | 'beforeend' | 'afterend';\n\nexport interface IElement extends INode, INonDocumentTypeChildNode, IParentNode, IChildNode, ISlotable {\n  readonly assignedSlot: IHTMLSlotElement | null;\n  readonly attributes: INamedNodeMap;\n  readonly classList: IDOMTokenList;\n  className: string;\n  innerHTML: string;\n  outerHTML: string;\n  /**\n   * Returns element's shadow root, if any, and if shadow root's mode is \"open\", and null otherwise.\n   */\n  readonly shadowRoot: IShadowRoot | null;\n  /**\n   * Returns the value of element's slot content attribute. Can be set to change it.\n   */\n  slot: string;\n  /**\n   * Returns the HTML-uppercased qualified name.\n   */\n  readonly tagName: string;\n  attachShadow(shadowRootInitDict: IShadowRootInit): IShadowRoot;\n  getAttribute(qualifiedName: string): string | null;\n  getAttributeNS(namespace: string | null, localName: string): string | null;\n  /**\n   * Returns the qualified names of all element's attributes. Can contain duplicates.\n   */\n  getAttributeNames(): string[];\n  getAttributeNode(name: string): IAttr | null;\n  hasAttribute(qualifiedName: string): boolean;\n  hasAttributes(): boolean;\n  insertAdjacentElement(position: IInsertPosition, insertedElement: IElement): IElement | null;\n  removeAttribute(qualifiedName: string): void;\n  removeAttributeNode(attr: IAttr): IAttr;\n  setAttribute(qualifiedName: string, value: string): void;\n  setAttributeNS(namespace: string | null, qualifiedName: string, value: string): void;\n  setAttributeNode(attr: IAttr): IAttr | null;\n\n  addEventListener(type: string, listener: IEventListenerOrEventListenerObject, options?: boolean | IAddEventListenerOptions): void;\n  removeEventListener(type: string, listener: IEventListenerOrEventListenerObject, options?: boolean | IEventListenerOptions): void;\n}\n\nexport interface IHTMLElement extends IElement, IElementCSSInlineStyle {}\nexport interface ISVGElement extends IElement, IElementCSSInlineStyle {}\n\nexport interface IHTMLInputElement extends IHTMLElement {\n  value: string;\n  checked: boolean;\n  type: string;\n}\n\nexport interface IHTMLSelectElement extends IHTMLElement {\n  multiple: boolean;\n  value: string;\n  readonly options: ArrayLike<IHTMLOptionElement>;\n}\n\nexport interface IHTMLOptionElement extends IHTMLElement {\n  selected: boolean;\n  value: string;\n}\n\ninterface INonDocumentTypeChildNode {\n  readonly nextElementSibling: IElement | null;\n  readonly previousElementSibling: IElement | null;\n}\n\nexport interface IDocumentFragment extends INode, IParentNode {}\n\nexport interface IHTMLTemplateElement extends IHTMLElement {\n  readonly content: IDocumentFragment;\n}\n\nexport interface IText extends INode, INonDocumentTypeChildNode, IChildNode, ISlotable {\n  readonly wholeText: string;\n}\n\nexport interface IComment extends INode, INonDocumentTypeChildNode, IChildNode {}\n\nexport interface IMutationObserverInit {\n  attributeFilter?: string[];\n  attributeOldValue?: boolean;\n  attributes?: boolean;\n  characterData?: boolean;\n  characterDataOldValue?: boolean;\n  childList?: boolean;\n  subtree?: boolean;\n}\n\nexport type IMutationRecordType = 'attributes' | 'characterData' | 'childList';\n\ninterface IMutationRecord {\n  readonly addedNodes: ArrayLike<INode>;\n  readonly attributeName: string | null;\n  readonly attributeNamespace: string | null;\n  readonly nextSibling: INode | null;\n  readonly oldValue: string | null;\n  readonly previousSibling: INode | null;\n  readonly removedNodes: ArrayLike<INode>;\n  readonly target: INode;\n  readonly type: IMutationRecordType;\n}\n\nexport interface IMutationCallback {\n  // tslint:disable-next-line:callable-types\n  (mutations: IMutationRecord[], observer: IMutationObserver): void;\n}\n\nexport interface IMutationObserver {\n  disconnect(): void;\n  observe(target: INode, options?: IMutationObserverInit): void;\n}\n\nexport interface IDocument extends INode, IDocumentOrShadowRoot, IParentNode {\n  createComment(data: string): IComment;\n  createDocumentFragment(): IDocumentFragment;\n  createElement<T extends IHTMLElement, TTag extends string>(tagName: TTag):\n    TTag extends 'template' ? IHTMLTemplateElement :\n    TTag extends 'slot' ? IHTMLSlotElement : T;\n  createTextNode(data: string): IText;\n}\n\n// --------------------------------------------------------------------------\n// ------------------- Aurelia-specific stuff starts here -------------------\n// --------------------------------------------------------------------------\n\nexport interface IManagedEvent extends IEvent {\n  propagationStopped?: boolean;\n  // legacy\n  path?: IEventTarget[];\n  standardStopPropagation?(): void;\n  // old composedPath\n  deepPath?(): IEventTarget[];\n}\n\nexport const INode = DI.createInterface<INode>().noDefault();\n\nexport const IRenderLocation = DI.createInterface<IRenderLocation>().noDefault();\nexport interface IRenderLocation extends INode {\n  $start?: IRenderLocation;\n  $nodes?: INodeSequence | Readonly<{}>;\n}\n\n/**\n * Represents a DocumentFragment\n */\nexport interface INodeSequence extends INodeLike {\n  /**\n   * The nodes of this sequence.\n   */\n  childNodes: ReadonlyArray<INode>;\n\n  /**\n   * Find all instruction targets in this sequence.\n   */\n  findTargets(): ArrayLike<INode> | ReadonlyArray<INode>;\n\n  /**\n   * Insert this sequence as a sibling before refNode\n   */\n  insertBefore(refNode: INode): void;\n\n  /**\n   * Append this sequence as a child to parent\n   */\n  appendTo(parent: INode): void;\n\n  /**\n   * Remove this sequence from its parent.\n   */\n  remove(): void;\n}\n","import {\n  Constructable,\n  IContainer,\n  IResolver,\n  PLATFORM,\n  Reporter,\n  Tracer,\n  Writable\n} from '@aurelia/kernel';\nimport {\n  IAddEventListenerOptions,\n  IChildNode,\n  IComment,\n  IDocument,\n  IDocumentFragment,\n  IElement,\n  IEventListenerOptions,\n  IEventListenerOrEventListenerObject,\n  IEventTarget,\n  IHTMLElement,\n  IHTMLTemplateElement,\n  IMutationCallback,\n  IMutationObserver,\n  IMutationObserverInit,\n  INode,\n  INodeSequence,\n  IParentNode,\n  IRenderLocation,\n  IShadowRootInit,\n  ISVGElement,\n  IText,\n  NodeType\n} from './dom.interfaces';\n\nconst slice = Array.prototype.slice;\n\nfunction isRenderLocation(node: INode): node is IRenderLocation {\n  return node.textContent === 'au-end';\n}\n\ndeclare var document: IDocument;\ndeclare var MutationObserver: Constructable & IMutationObserver;\ndeclare var Element: IElement;\ndeclare var HTMLElement: IHTMLElement;\ndeclare var SVGElement: ISVGElement;\n\nexport const DOM = {\n  createDocumentFragment(markupOrNode?: unknown): IDocumentFragment {\n    if (markupOrNode === undefined || markupOrNode === null) {\n      return document.createDocumentFragment();\n    }\n    if (DOM.isNodeInstance(markupOrNode)) {\n      if ((markupOrNode as IHTMLTemplateElement).content !== undefined) {\n        return (markupOrNode as IHTMLTemplateElement).content;\n      }\n      const fragment = document.createDocumentFragment();\n      fragment.appendChild(markupOrNode);\n      return fragment;\n    }\n    return DOM.createTemplate(markupOrNode).content;\n  },\n  createTemplate(markup?: unknown): IHTMLTemplateElement {\n    if (markup === undefined || markup === null) {\n      return document.createElement('template');\n    }\n    const template = document.createElement('template');\n    template.innerHTML = (markup as string | object).toString();\n    return template;\n  },\n  addClass(node: IElement, className: string): void {\n    node.classList.add(className);\n  },\n  addEventListener(eventName: string, subscriber: IEventListenerOrEventListenerObject, publisher?: IEventTarget, options?: boolean | IAddEventListenerOptions): void {\n    (publisher || document).addEventListener(eventName, subscriber, options);\n  },\n  appendChild(parent: INode, child: INode): void {\n    parent.appendChild(child);\n  },\n  attachShadow(host: IElement, options: IShadowRootInit): IDocumentFragment {\n    return host.attachShadow(options);\n  },\n  cloneNode<T extends INode = INode>(node: T, deep?: boolean): T {\n    return node.cloneNode(deep !== false) as T; // use true unless the caller explicitly passes in false\n  },\n  convertToRenderLocation(node: INode): IRenderLocation {\n    if (isRenderLocation(node)) {\n      return node; // it's already a RenderLocation (converted by FragmentNodeSequence)\n    }\n    if (node.parentNode === null) {\n      throw Reporter.error(52);\n    }\n    const locationEnd = document.createComment('au-end') as IRenderLocation;\n    const locationStart = document.createComment('au-start') as IRenderLocation;\n    DOM.replaceNode(locationEnd, node);\n    DOM.insertBefore(locationStart, locationEnd);\n    locationEnd.$start = locationStart;\n    locationStart.$nodes = null;\n    return locationEnd;\n  },\n  createComment(text: string): IComment {\n    return document.createComment(text);\n  },\n  createElement: ((name: string): IElement => {\n    return document.createElement(name);\n  }) as IDocument['createElement'],\n  createNodeObserver(target: INode, callback: IMutationCallback, options: IMutationObserverInit): IMutationObserver {\n    const observer = new MutationObserver(callback);\n    observer.observe(target, options);\n    return observer;\n  },\n  createTextNode(text: string): IText {\n    return document.createTextNode(text);\n  },\n  getAttribute(node: IElement, name: string): string {\n    return node.getAttribute(name);\n  },\n  hasClass(node: IElement, className: string): boolean {\n    return node.classList.contains(className);\n  },\n  insertBefore(nodeToInsert: INode, referenceNode: INode): void {\n    referenceNode.parentNode.insertBefore(nodeToInsert, referenceNode);\n  },\n  isMarker(node: INode): node is IElement {\n    return node.nodeName === 'AU-M';\n  },\n  isCommentNodeType(node: INode): node is IComment {\n    return node.nodeType === NodeType.Comment;\n  },\n  isDocumentFragmentType(node: INode): node is IDocumentFragment {\n    return node.nodeType === NodeType.DocumentFragment;\n  },\n  isElementNodeType(node: INode): node is IElement {\n    return node.nodeType === NodeType.Element;\n  },\n  isNodeInstance(potentialNode: unknown): potentialNode is INode {\n    return (potentialNode as { nodeType?: number }).nodeType > 0;\n  },\n  isTextNodeType(node: INode): node is IText {\n    return node.nodeType === NodeType.Text;\n  },\n  migrateChildNodes(currentParent: INode, newParent: INode): void {\n    while (currentParent.firstChild) {\n      DOM.appendChild(newParent, currentParent.firstChild);\n    }\n  },\n  registerElementResolver(container: IContainer, resolver: IResolver): void {\n    container.registerResolver(INode, resolver);\n    container.registerResolver(Element, resolver);\n    container.registerResolver(HTMLElement, resolver);\n    container.registerResolver(SVGElement, resolver);\n  },\n  remove(node: INode | IChildNode): void {\n    if ((node as IChildNode).remove) {\n      (node as IChildNode).remove();\n    } else {\n      node.parentNode.removeChild(node);\n    }\n  },\n  removeAttribute(node: IElement, name: string): void {\n    node.removeAttribute(name);\n  },\n  removeClass(node: IElement, className: string): void {\n    node.classList.remove(className);\n  },\n  removeEventListener(eventName: string, subscriber: IEventListenerOrEventListenerObject, publisher?: IEventTarget, options?: boolean | IEventListenerOptions): void {\n    (publisher || document).removeEventListener(eventName, subscriber, options);\n  },\n  replaceNode(newChild: INode, oldChild: INode): void {\n    if (oldChild.parentNode) {\n      oldChild.parentNode.replaceChild(newChild, oldChild);\n    }\n  },\n  setAttribute(node: IElement, name: string, value: string): void {\n    node.setAttribute(name, value);\n  }\n};\n\n// This is an implementation of INodeSequence that represents \"no DOM\" to render.\n// It's used in various places to avoid null and to encode\n// the explicit idea of \"no view\".\nconst emptySequence: INodeSequence = {\n  firstChild: null,\n  lastChild: null,\n  childNodes: PLATFORM.emptyArray,\n  findTargets(): ReturnType<INodeSequence['findTargets']> { return PLATFORM.emptyArray; },\n  insertBefore(refNode: INode): ReturnType<INodeSequence['insertBefore']> { /*do nothing*/ },\n  appendTo(parent: INode): ReturnType<INodeSequence['appendTo']> { /*do nothing*/ },\n  remove(): ReturnType<INodeSequence['remove']> { /*do nothing*/ }\n};\n\nexport const NodeSequence = {\n  empty: emptySequence\n};\n\n/**\n * An specialized INodeSequence with optimizations for text (interpolation) bindings\n * The contract of this INodeSequence is:\n * - the previous element is an `au-m` node\n * - text is the actual text node\n */\nexport class TextNodeSequence implements INodeSequence {\n  public firstChild: IText;\n  public lastChild: IText;\n  public childNodes: IText[];\n\n  private targets: [INode];\n\n  constructor(text: IText) {\n    this.firstChild = text;\n    this.lastChild = text;\n    this.childNodes = [text];\n    this.targets = [new AuMarker(text)];\n  }\n\n  public findTargets(): ArrayLike<INode> {\n    return this.targets;\n  }\n\n  public insertBefore(refNode: INode): void {\n    refNode.parentNode.insertBefore(this.firstChild, refNode);\n  }\n\n  public appendTo(parent: INode): void {\n    parent.appendChild(this.firstChild);\n  }\n\n  public remove(): void {\n    this.firstChild.remove();\n  }\n}\n// tslint:enable:no-any\n\n// This is the most common form of INodeSequence.\n// Every custom element or template controller whose node sequence is based on an HTML template\n// has an instance of this under the hood. Anyone who wants to create a node sequence from\n// a string of markup would also receive an instance of this.\n// CompiledTemplates create instances of FragmentNodeSequence.\n/** @internal */\nexport class FragmentNodeSequence implements INodeSequence {\n  public firstChild: INode;\n  public lastChild: INode;\n  public childNodes: INode[];\n\n  private end: IRenderLocation;\n  private fragment: IDocumentFragment;\n  private start: IRenderLocation;\n  private targets: ArrayLike<INode>;\n\n  constructor(fragment: IDocumentFragment) {\n    this.fragment = fragment;\n    // tslint:disable-next-line:no-any\n    const targetNodeList = fragment.querySelectorAll('.au');\n    let i = 0;\n    let ii = targetNodeList.length;\n    const targets = this.targets = Array(ii);\n    while (i < ii) {\n      // eagerly convert all markers to IRenderLocations (otherwise the renderer\n      // will do it anyway) and store them in the target list (since the comments\n      // can't be queried)\n      const target = targetNodeList[i];\n      if (target.nodeName === 'AU-M') {\n        // note the renderer will still call this method, but it will just return the\n        // location if it sees it's already a location\n        targets[i] = DOM.convertToRenderLocation(target);\n      } else {\n        // also store non-markers for consistent ordering\n        targets[i] = target;\n      }\n      ++i;\n    }\n    const childNodeList = fragment.childNodes;\n    i = 0;\n    ii = childNodeList.length;\n    const childNodes = this.childNodes = Array(ii);\n    while (i < ii) {\n      childNodes[i] = childNodeList[i] as Writable<INode>;\n      ++i;\n    }\n\n    this.firstChild = fragment.firstChild;\n    this.lastChild = fragment.lastChild;\n\n    this.start = this.end = null;\n  }\n\n  public findTargets(): ArrayLike<INode> {\n    return this.targets;\n  }\n\n  public insertBefore(refNode: IRenderLocation): void {\n    // tslint:disable-next-line:no-any\n    refNode.parentNode.insertBefore(this.fragment, refNode);\n    // internally we could generally assume that this is an IRenderLocation,\n    // but since this is also public API we still need to double check\n    // (or horrible things might happen)\n    if (isRenderLocation(refNode)) {\n      this.end = refNode;\n      const start = this.start = refNode.$start;\n      if (start.$nodes === null) {\n        start.$nodes = this;\n      } else {\n        // if more than one NodeSequence uses the same RenderLocation, it's an child\n        // of a repeater (or something similar) and we shouldn't remove all nodes between\n        // start - end since that would always remove all items from a repeater, even\n        // when only one is removed\n        // so we set $nodes to PLATFORM.emptyObject to 1) tell other sequences that it's\n        // occupied and 2) prevent start.$nodes === this from ever evaluating to true\n        // during remove()\n        start.$nodes = PLATFORM.emptyObject;\n      }\n    }\n  }\n\n  public appendTo(parent: INode): void {\n    // tslint:disable-next-line:no-any\n    parent.appendChild(this.fragment);\n    // this can never be a RenderLocation, and if for whatever reason we moved\n    // from a RenderLocation to a host, make sure \"start\" and \"end\" are null\n    this.start = this.end = null;\n  }\n\n  public remove(): void {\n    const fragment = this.fragment;\n    if (this.start !== null && this.start.$nodes === this) {\n      // if we're between a valid \"start\" and \"end\" (e.g. if/else, containerless, or a\n      // repeater with a single item) then simply remove everything in-between (but not\n      // the comments themselves as they belong to the parent)\n      const end = this.end;\n      let next: INode;\n      let current = this.start.nextSibling;\n      while (current !== end) {\n        next = current.nextSibling;\n        // tslint:disable-next-line:no-any\n        fragment.appendChild(current);\n        current = next;\n      }\n      this.start.$nodes = null;\n      this.start = this.end = null;\n    } else {\n      // otherwise just remove from first to last child in the regular way\n      let current = this.firstChild;\n\n      if (current.parentNode !== fragment) {\n        const end = this.lastChild;\n        let next: INode;\n\n        while (current !== null) {\n          next = current.nextSibling;\n          // tslint:disable-next-line:no-any\n          fragment.appendChild(current);\n\n          if (current === end) {\n            break;\n          }\n\n          current = next;\n        }\n      }\n    }\n  }\n}\n\nexport interface INodeSequenceFactory {\n  createNodeSequence(): INodeSequence;\n}\n\nexport class NodeSequenceFactory {\n  private readonly deepClone: boolean;\n  private readonly node: INode;\n  private readonly Type: Constructable;\n\n  constructor(fragment: IDocumentFragment) {\n    const childNodes = fragment.childNodes;\n    switch (childNodes.length) {\n      case 0:\n        this.createNodeSequence = () => NodeSequence.empty;\n        return;\n      case 2:\n        const target = childNodes[0];\n        if (target.nodeName === 'AU-M' || target.nodeName === '#comment') {\n          const text = childNodes[1];\n          if (text.nodeType === NodeType.Text && text.textContent.length === 0) {\n            this.deepClone = false;\n            this.node = text;\n            this.Type = TextNodeSequence;\n            return;\n          }\n        }\n      // falls through if not returned\n      default:\n        this.deepClone = true;\n        this.node = fragment;\n        this.Type = FragmentNodeSequence;\n    }\n  }\n\n  public static createFor(markupOrNode: unknown): NodeSequenceFactory {\n    if (Tracer.enabled) { Tracer.enter('NodeSequenceFactory.createFor', slice.call(arguments)); }\n    const fragment = DOM.createDocumentFragment(markupOrNode);\n    if (Tracer.enabled) { Tracer.leave(); }\n    return new NodeSequenceFactory(fragment);\n  }\n\n  public createNodeSequence(): INodeSequence {\n    return new this.Type(this.node.cloneNode(this.deepClone));\n  }\n}\n\nexport interface AuMarker extends INode { }\n\n/** @internal */\nexport class AuMarker implements INode {\n  public get parentNode(): INode & IParentNode {\n    return this.nextSibling.parentNode;\n  }\n  public readonly nextSibling: INode;\n  public readonly previousSibling: INode;\n  public readonly content?: INode;\n  public readonly firstChild: IChildNode;\n  public readonly lastChild: IChildNode;\n  public readonly childNodes: ArrayLike<IChildNode>;\n  public readonly nodeName: 'AU-M';\n  public readonly nodeType: NodeType.Element;\n\n  public textContent: string;\n\n  constructor(next: INode) {\n    this.nextSibling = next;\n    this.textContent = '';\n  }\n  public remove(): void { /* do nothing */ }\n}\n\n(proto => {\n  proto.previousSibling = null;\n  proto.firstChild = null;\n  proto.lastChild = null;\n  proto.childNodes = PLATFORM.emptyArray;\n  proto.nodeName = 'AU-M';\n  proto.nodeType = NodeType.Element;\n})(AuMarker.prototype as Writable<AuMarker>);\n","import { Tracer } from '@aurelia/kernel';\nimport { DOM } from '../dom';\nimport { ILifecycle } from '../lifecycle';\nimport { IBindingTargetAccessor, LifecycleFlags, MutationKind } from '../observation';\nimport { subscriberCollection } from './subscriber-collection';\n\nconst slice = Array.prototype.slice;\n\ntype BindingTargetAccessor = IBindingTargetAccessor & {\n  lifecycle: ILifecycle;\n  currentFlags: LifecycleFlags;\n  oldValue?: unknown;\n  defaultValue: unknown;\n  $nextFlush?: BindingTargetAccessor;\n  flush(flags: LifecycleFlags): void;\n  setValueCore(value: unknown, flags: LifecycleFlags): void;\n};\n\nfunction setValue(this: BindingTargetAccessor, newValue: unknown, flags: LifecycleFlags): Promise<void> {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.setValue`, slice.call(arguments)); }\n  const currentValue = this.currentValue;\n  newValue = newValue === null || newValue === undefined ? this.defaultValue : newValue;\n  if (currentValue !== newValue) {\n    this.currentValue = newValue;\n    if ((flags & (LifecycleFlags.fromFlush | LifecycleFlags.fromBind)) &&\n      !((flags & LifecycleFlags.doNotUpdateDOM) && DOM.isNodeInstance(this.obj))) {\n      this.setValueCore(newValue, flags);\n    } else {\n      this.currentFlags = flags;\n      if (Tracer.enabled) { Tracer.leave(); }\n      return this.lifecycle.enqueueFlush(this);\n    }\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n  return Promise.resolve();\n}\n\nfunction flush(this: BindingTargetAccessor, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.flush`, slice.call(arguments)); }\n  if ((flags & LifecycleFlags.doNotUpdateDOM) && DOM.isNodeInstance(this.obj)) {\n    // re-queue the change so it will still propagate on flush when it's attached again\n    this.lifecycle.enqueueFlush(this).catch(error => { throw error; });\n    if (Tracer.enabled) { Tracer.leave(); }\n    return;\n  }\n  const currentValue = this.currentValue;\n  // we're doing this check because a value could be set multiple times before a flush, and the final value could be the same as the original value\n  // in which case the target doesn't need to be updated\n  if (this.oldValue !== currentValue) {\n    this.setValueCore(currentValue, this.currentFlags | flags | LifecycleFlags.updateTargetInstance);\n    this.oldValue = this.currentValue;\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\nfunction dispose(this: BindingTargetAccessor): void {\n  this.currentValue = null;\n  this.oldValue = null;\n  this.defaultValue = null;\n\n  this.obj = null;\n  this.propertyKey = '';\n}\n\nexport function targetObserver(defaultValue: unknown = null): ClassDecorator {\n  return function(target: Function): void {\n    subscriberCollection(MutationKind.instance)(target);\n    const proto = target.prototype as BindingTargetAccessor;\n\n    proto.$nextFlush = null;\n\n    proto.currentValue = defaultValue;\n    proto.oldValue = defaultValue;\n    proto.defaultValue = defaultValue;\n\n    proto.obj = null;\n    proto.propertyKey = '';\n\n    proto.setValue = proto.setValue || setValue;\n    proto.flush = proto.flush || flush;\n    proto.dispose = proto.dispose || dispose;\n  };\n}\n","import { Tracer } from '@aurelia/kernel';\nimport {\n  Collection,\n  CollectionKind,\n  CollectionObserver,\n  IBindingTargetObserver,\n  ICollectionObserver,\n  IndexMap,\n  IPatch,\n  IPropertySubscriber,\n  LifecycleFlags,\n  MutationKind\n} from '../observation';\nimport { batchedSubscriberCollection, subscriberCollection } from './subscriber-collection';\nimport { targetObserver } from './target-observer';\n\nconst slice = Array.prototype.slice;\n\nfunction flush(this: CollectionObserver): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.flush`, slice.call(arguments)); }\n  this.callBatchedSubscribers(this.indexMap);\n  if (!!this.lengthObserver) {\n    this.lengthObserver.patch(LifecycleFlags.fromFlush | LifecycleFlags.updateTargetInstance);\n  }\n  this.resetIndexMap();\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\nfunction dispose(this: CollectionObserver): void {\n  this.collection.$observer = undefined;\n  this.collection = null;\n  this.indexMap = null;\n}\n\nfunction resetIndexMapIndexed(this: ICollectionObserver<CollectionKind.indexed>): void {\n  const len = this.collection.length;\n  const indexMap: IndexMap = (this.indexMap = Array(len));\n  let i = 0;\n  while (i < len) {\n    indexMap[i] = i++;\n  }\n  indexMap.deletedItems = [];\n}\n\nfunction resetIndexMapKeyed(this: ICollectionObserver<CollectionKind.keyed>): void {\n  const len = this.collection.size;\n  const indexMap: IndexMap = (this.indexMap = Array(len));\n  let i = 0;\n  while (i < len) {\n    indexMap[i] = i++;\n  }\n  indexMap.deletedItems = [];\n}\n\nfunction getLengthObserver(this: CollectionObserver): CollectionLengthObserver {\n  return this.lengthObserver === undefined ? (this.lengthObserver = new CollectionLengthObserver(this as Collection&ICollectionObserver<CollectionKind>, this.lengthPropertyName)) : this.lengthObserver as CollectionLengthObserver;\n}\n\nexport function collectionObserver(kind: CollectionKind.array | CollectionKind.set | CollectionKind.map): ClassDecorator {\n  return function(target: Function): void {\n    subscriberCollection(MutationKind.collection)(target);\n    batchedSubscriberCollection()(target);\n    const proto = target.prototype as CollectionObserver;\n\n    proto.$nextFlush = null;\n\n    proto.collection = null;\n    proto.indexMap = null;\n    proto.hasChanges = false;\n    proto.lengthPropertyName = kind & CollectionKind.indexed ? 'length' : 'size';\n    proto.collectionKind = kind;\n    proto.resetIndexMap = kind & CollectionKind.indexed ? resetIndexMapIndexed : resetIndexMapKeyed;\n    proto.flush = flush;\n    proto.dispose = dispose;\n    proto.getLengthObserver = getLengthObserver;\n\n    proto.subscribe = proto.subscribe || proto.addSubscriber;\n    proto.unsubscribe = proto.unsubscribe || proto.removeSubscriber;\n\n    proto.subscribeBatched = proto.subscribeBatched || proto.addBatchedSubscriber;\n    proto.unsubscribeBatched = proto.unsubscribeBatched || proto.removeBatchedSubscriber;\n  };\n}\n\nexport interface CollectionLengthObserver extends IBindingTargetObserver<Collection, string> {}\n\n@targetObserver()\nexport class CollectionLengthObserver implements CollectionLengthObserver, IPatch {\n  public currentValue: number;\n  public currentFlags: LifecycleFlags;\n\n  public obj: Collection;\n  public propertyKey: 'length' | 'size';\n\n  constructor(obj: Collection, propertyKey: 'length' | 'size') {\n    this.obj = obj;\n    this.propertyKey = propertyKey;\n\n    this.currentValue = obj[propertyKey];\n  }\n\n  public getValue(): number {\n    return this.obj[this.propertyKey];\n  }\n\n  public setValueCore(newValue: number): void {\n    this.obj[this.propertyKey] = newValue;\n  }\n\n  public patch(flags: LifecycleFlags): void {\n    this.callSubscribers(this.obj[this.propertyKey], this.currentValue, flags);\n    this.currentValue = this.obj[this.propertyKey];\n  }\n\n  public subscribe(subscriber: IPropertySubscriber): void {\n    this.addSubscriber(subscriber);\n  }\n\n  public unsubscribe(subscriber: IPropertySubscriber): void {\n    this.removeSubscriber(subscriber);\n  }\n}\n","import { ILifecycle } from '../lifecycle';\nimport { CollectionKind, ICollectionObserver, IndexMap, IObservedArray, LifecycleFlags } from '../observation';\nimport { collectionObserver } from './collection-observer';\nconst proto = Array.prototype;\nexport const nativePush = proto.push; // TODO: probably want to make these internal again\nexport const nativeUnshift = proto.unshift;\nexport const nativePop = proto.pop;\nexport const nativeShift = proto.shift;\nexport const nativeSplice = proto.splice;\nexport const nativeReverse = proto.reverse;\nexport const nativeSort = proto.sort;\n\n// https://tc39.github.io/ecma262/#sec-array.prototype.push\nfunction observePush(this: IObservedArray): ReturnType<typeof nativePush> {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativePush.apply(this, arguments);\n  }\n  const len = this.length;\n  const argCount = arguments.length;\n  if (argCount === 0) {\n    return len;\n  }\n  this.length = o.indexMap.length = len + argCount;\n  let i = len;\n  while (i < this.length) {\n    this[i] = arguments[i - len];\n    o.indexMap[i] = - 2;\n    i++;\n  }\n  o.callSubscribers('push', arguments, LifecycleFlags.isCollectionMutation);\n  return this.length;\n}\n\n// https://tc39.github.io/ecma262/#sec-array.prototype.unshift\nfunction observeUnshift(this: IObservedArray): ReturnType<typeof nativeUnshift>  {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativeUnshift.apply(this, arguments);\n  }\n  const argCount = arguments.length;\n  const inserts = new Array(argCount);\n  let i = 0;\n  while (i < argCount) {\n    inserts[i++] = - 2;\n  }\n  nativeUnshift.apply(o.indexMap, inserts);\n  const len = nativeUnshift.apply(this, arguments);\n  o.callSubscribers('unshift', arguments, LifecycleFlags.isCollectionMutation);\n  return len;\n}\n\n// https://tc39.github.io/ecma262/#sec-array.prototype.pop\nfunction observePop(this: IObservedArray): ReturnType<typeof nativePop> {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativePop.call(this);\n  }\n  const indexMap = o.indexMap;\n  const element = nativePop.call(this);\n  // only mark indices as deleted if they actually existed in the original array\n  const index = indexMap.length - 1;\n  if (indexMap[index] > -1) {\n    nativePush.call(indexMap.deletedItems, element);\n  }\n  nativePop.call(indexMap);\n  o.callSubscribers('pop', arguments, LifecycleFlags.isCollectionMutation);\n  return element;\n}\n\n// https://tc39.github.io/ecma262/#sec-array.prototype.shift\nfunction observeShift(this: IObservedArray): ReturnType<typeof nativeShift> {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativeShift.call(this);\n  }\n  const indexMap = o.indexMap;\n  const element = nativeShift.call(this);\n  // only mark indices as deleted if they actually existed in the original array\n  if (indexMap[0] > -1) {\n    nativePush.call(indexMap.deletedItems, element);\n  }\n  nativeShift.call(indexMap);\n  o.callSubscribers('shift', arguments, LifecycleFlags.isCollectionMutation);\n  return element;\n}\n\n// https://tc39.github.io/ecma262/#sec-array.prototype.splice\nfunction observeSplice(this: IObservedArray, start: number, deleteCount?: number): ReturnType<typeof nativeSplice> {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativeSplice.apply(this, arguments);\n  }\n  const indexMap = o.indexMap;\n  if (deleteCount > 0) {\n    let i = isNaN(start) ? 0 : start;\n    const to = i + deleteCount;\n    while (i < to) {\n      if (indexMap[i] > -1) {\n        nativePush.call(indexMap.deletedItems, this[i]);\n      }\n      i++;\n    }\n  }\n  const argCount = arguments.length;\n  if (argCount > 2) {\n    const itemCount = argCount - 2;\n    const inserts = new Array(itemCount);\n    let i = 0;\n    while (i < itemCount) {\n      inserts[i++] = - 2;\n    }\n    nativeSplice.call(indexMap, start, deleteCount, ...inserts);\n  } else if (argCount === 2) {\n    nativeSplice.call(indexMap, start, deleteCount);\n  }\n  const deleted = nativeSplice.apply(this, arguments);\n  o.callSubscribers('splice', arguments, LifecycleFlags.isCollectionMutation);\n  return deleted;\n}\n\n// https://tc39.github.io/ecma262/#sec-array.prototype.reverse\nfunction observeReverse(this: IObservedArray): ReturnType<typeof nativeReverse> {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativeReverse.call(this);\n  }\n  const len = this.length;\n  const middle = (len / 2) | 0;\n  let lower = 0;\n  // tslint:disable:no-statements-same-line\n  while (lower !== middle) {\n    const upper = len - lower - 1;\n    const lowerValue = this[lower];  const lowerIndex = o.indexMap[lower];\n    const upperValue = this[upper];  const upperIndex = o.indexMap[upper];\n    this[lower] = upperValue;        o.indexMap[lower] = upperIndex;\n    this[upper] = lowerValue;        o.indexMap[upper] = lowerIndex;\n    lower++;\n  }\n  // tslint:enable:no-statements-same-line\n  o.callSubscribers('reverse', arguments, LifecycleFlags.isCollectionMutation);\n  return this;\n}\n\n// https://tc39.github.io/ecma262/#sec-array.prototype.sort\n// https://github.com/v8/v8/blob/master/src/js/array.js\nfunction observeSort(this: IObservedArray, compareFn?: (a: unknown, b: unknown) => number): IObservedArray {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativeSort.call(this, compareFn);\n  }\n  const len = this.length;\n  if (len < 2) {\n    return this;\n  }\n  quickSort(this, o.indexMap, 0, len, preSortCompare);\n  let i = 0;\n  while (i < len) {\n    if (this[i] === undefined) {\n      break;\n    }\n    i++;\n  }\n  if (compareFn === undefined || typeof compareFn !== 'function'/*spec says throw a TypeError, should we do that too?*/) {\n    compareFn = sortCompare;\n  }\n  quickSort(this, o.indexMap, 0, i, compareFn);\n  o.callSubscribers('sort', arguments, LifecycleFlags.isCollectionMutation);\n  return this;\n}\n\n// https://tc39.github.io/ecma262/#sec-sortcompare\nfunction sortCompare(x: unknown, y: unknown): number {\n  if (x === y) {\n    return 0;\n  }\n  x = x === null ? 'null' : (x as {}).toString();\n  y = y === null ? 'null' : (y as {}).toString();\n  return (x as {}) < (y as {}) ? -1 : 1;\n}\n\nfunction preSortCompare(x: unknown, y: unknown): number {\n  if (x === undefined) {\n    if (y === undefined) {\n      return 0;\n    } else {\n      return 1;\n    }\n  }\n  if (y === undefined) {\n    return -1;\n  }\n  return 0;\n}\n\nfunction insertionSort(arr: IObservedArray, indexMap: IndexMap, from: number, to: number, compareFn: (a: unknown, b: unknown) => number): void {\n  let velement, ielement, vtmp, itmp, order;\n  let i, j;\n  for (i = from + 1; i < to; i++) {\n    velement = arr[i];\n    ielement = indexMap[i];\n    for (j = i - 1; j >= from; j--) {\n      vtmp = arr[j];\n      itmp = indexMap[j];\n      order = compareFn(vtmp, velement);\n      if (order > 0) {\n        arr[j + 1] = vtmp;\n        indexMap[j + 1] = itmp;\n      } else {\n        break;\n      }\n    }\n    arr[j + 1] = velement;\n    indexMap[j + 1] = ielement;\n  }\n}\n\n// tslint:disable-next-line:cognitive-complexity\nfunction quickSort(arr: IObservedArray, indexMap: IndexMap, from: number, to: number, compareFn: (a: unknown, b: unknown) => number): void {\n  let thirdIndex = 0, i = 0;\n  let v0, v1, v2;\n  let i0, i1, i2;\n  let c01, c02, c12;\n  let vtmp, itmp;\n  let vpivot, ipivot, lowEnd, highStart;\n  let velement, ielement, order, vtopElement;\n\n  // tslint:disable-next-line:no-constant-condition\n  while (true) {\n    if (to - from <= 10) {\n      insertionSort(arr, indexMap, from, to, compareFn);\n      return;\n    }\n\n    // tslint:disable:no-statements-same-line\n    thirdIndex = from + ((to - from) >> 1);\n    v0 = arr[from];                i0 = indexMap[from];\n    v1 = arr[to - 1];              i1 = indexMap[to - 1];\n    v2 = arr[thirdIndex];          i2 = indexMap[thirdIndex];\n    c01 = compareFn(v0, v1);\n    if (c01 > 0) {\n      vtmp = v0;                   itmp = i0;\n      v0 = v1;                     i0 = i1;\n      v1 = vtmp;                   i1 = itmp;\n    }\n    c02 = compareFn(v0, v2);\n    if (c02 >= 0) {\n      vtmp = v0;                   itmp = i0;\n      v0 = v2;                     i0 = i2;\n      v2 = v1;                     i2 = i1;\n      v1 = vtmp;                   i1 = itmp;\n    } else {\n      c12 = compareFn(v1, v2);\n      if (c12 > 0) {\n        vtmp = v1;                 itmp = i1;\n        v1 = v2;                   i1 = i2;\n        v2 = vtmp;                 i2 = itmp;\n      }\n    }\n    arr[from] = v0;                indexMap[from] = i0;\n    arr[to - 1] = v2;              indexMap[to - 1] = i2;\n    vpivot = v1;                   ipivot = i1;\n    lowEnd = from + 1;\n    highStart = to - 1;\n    arr[thirdIndex] = arr[lowEnd]; indexMap[thirdIndex] = indexMap[lowEnd];\n    arr[lowEnd] = vpivot;          indexMap[lowEnd] = ipivot;\n\n    partition: for (i = lowEnd + 1; i < highStart; i++) {\n      velement = arr[i];           ielement = indexMap[i];\n      order = compareFn(velement, vpivot);\n      if (order < 0) {\n        arr[i] = arr[lowEnd];      indexMap[i] = indexMap[lowEnd];\n        arr[lowEnd] = velement;    indexMap[lowEnd] = ielement;\n        lowEnd++;\n      } else if (order > 0) {\n        do {\n          highStart--;\n          // tslint:disable-next-line:triple-equals\n          if (highStart == i) {\n            break partition;\n          }\n          vtopElement = arr[highStart]; order = compareFn(vtopElement, vpivot);\n        } while (order > 0);\n        arr[i] = arr[highStart];   indexMap[i] = indexMap[highStart];\n        arr[highStart] = velement; indexMap[highStart] = ielement;\n        if (order < 0) {\n          velement = arr[i];       ielement = indexMap[i];\n          arr[i] = arr[lowEnd];    indexMap[i] = indexMap[lowEnd];\n          arr[lowEnd] = velement;  indexMap[lowEnd] = ielement;\n          lowEnd++;\n        }\n      }\n    }\n    // tslint:enable:no-statements-same-line\n\n    if (to - highStart < lowEnd - from) {\n      quickSort(arr, indexMap, highStart, to, compareFn);\n      to = lowEnd;\n    } else {\n      quickSort(arr, indexMap, from, lowEnd, compareFn);\n      from = highStart;\n    }\n  }\n}\n\nfor (const observe of [observePush, observeUnshift, observePop, observeShift, observeSplice, observeReverse, observeSort]) {\n  Object.defineProperty(observe, 'observing', { value: true, writable: false, configurable: false, enumerable: false });\n}\n\nexport function enableArrayObservation(): void {\n  if (proto.push['observing'] !== true) proto.push = observePush;\n  if (proto.unshift['observing'] !== true) proto.unshift = observeUnshift;\n  if (proto.pop['observing'] !== true) proto.pop = observePop;\n  if (proto.shift['observing'] !== true) proto.shift = observeShift;\n  if (proto.splice['observing'] !== true) proto.splice = observeSplice;\n  if (proto.reverse['observing'] !== true) proto.reverse = observeReverse;\n  if (proto.sort['observing'] !== true) proto.sort = observeSort;\n}\n\nenableArrayObservation();\n\nexport function disableArrayObservation(): void {\n  if (proto.push['observing'] === true) proto.push = nativePush;\n  if (proto.unshift['observing'] === true) proto.unshift = nativeUnshift;\n  if (proto.pop['observing'] === true) proto.pop = nativePop;\n  if (proto.shift['observing'] === true) proto.shift = nativeShift;\n  if (proto.splice['observing'] === true) proto.splice = nativeSplice;\n  if (proto.reverse['observing'] === true) proto.reverse = nativeReverse;\n  if (proto.sort['observing'] === true) proto.sort = nativeSort;\n}\n\nexport interface ArrayObserver extends ICollectionObserver<CollectionKind.array> {}\n\n@collectionObserver(CollectionKind.array)\nexport class ArrayObserver implements ArrayObserver {\n  public resetIndexMap: () => void;\n\n  public collection: IObservedArray;\n\n  constructor(lifecycle: ILifecycle, array: IObservedArray) {\n    this.lifecycle = lifecycle;\n    array.$observer = this;\n    this.collection = array;\n    this.resetIndexMap();\n  }\n}\n\nexport function getArrayObserver(lifecycle: ILifecycle, array: IObservedArray): ArrayObserver {\n  return (array.$observer as ArrayObserver) || new ArrayObserver(lifecycle, array);\n}\n","import { ILifecycle } from '../lifecycle';\nimport { CollectionKind, ICollectionObserver, IObservedMap, LifecycleFlags } from '../observation';\nimport { nativePush, nativeSplice } from './array-observer';\nimport { collectionObserver } from './collection-observer';\n\nconst proto = Map.prototype;\nexport const nativeSet = proto.set; // TODO: probably want to make these internal again\nexport const nativeClear = proto.clear;\nexport const nativeDelete = proto.delete;\n\n// note: we can't really do much with Map due to the internal data structure not being accessible so we're just using the native calls\n// fortunately, map/delete/clear are easy to reconstruct for the indexMap\n\n// https://tc39.github.io/ecma262/#sec-map.prototype.map\nfunction observeSet(this: IObservedMap, key: unknown, value: unknown): ReturnType<typeof nativeSet> {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativeSet.call(this, key, value);\n  }\n  const oldSize = this.size;\n  nativeSet.call(this, key, value);\n  const newSize = this.size;\n  if (newSize === oldSize) {\n    let i = 0;\n    for (const entry of this.entries()) {\n      if (entry[0] === key) {\n        if (entry[1] !== value) {\n          o.indexMap[i] = -2;\n        }\n        return this;\n      }\n      i++;\n    }\n    return this;\n  }\n  o.indexMap[oldSize] = -2;\n  o.callSubscribers('set', arguments, LifecycleFlags.isCollectionMutation);\n  return this;\n}\n\n// https://tc39.github.io/ecma262/#sec-map.prototype.clear\nfunction observeClear(this: IObservedMap): ReturnType<typeof nativeClear>  {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativeClear.call(this);\n  }\n  const size = this.size;\n  if (size > 0) {\n    const indexMap = o.indexMap;\n    let i = 0;\n    for (const entry of this.keys()) {\n      if (indexMap[i] > -1) {\n        nativePush.call(indexMap.deletedItems, entry);\n      }\n      i++;\n    }\n    nativeClear.call(this);\n    indexMap.length = 0;\n    o.callSubscribers('clear', arguments, LifecycleFlags.isCollectionMutation);\n  }\n  return undefined;\n}\n\n// https://tc39.github.io/ecma262/#sec-map.prototype.delete\nfunction observeDelete(this: IObservedMap, value: unknown): ReturnType<typeof nativeDelete> {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativeDelete.call(this, value);\n  }\n  const size = this.size;\n  if (size === 0) {\n    return false;\n  }\n  let i = 0;\n  const indexMap = o.indexMap;\n  for (const entry of this.keys()) {\n    if (entry === value) {\n      if (indexMap[i] > -1) {\n        nativePush.call(indexMap.deletedItems, entry);\n      }\n      nativeSplice.call(indexMap, i, 1);\n      return nativeDelete.call(this, value);\n    }\n    i++;\n  }\n  o.callSubscribers('delete', arguments, LifecycleFlags.isCollectionMutation);\n  return false;\n}\n\nfor (const observe of [observeSet, observeClear, observeDelete]) {\n  Object.defineProperty(observe, 'observing', { value: true, writable: false, configurable: false, enumerable: false });\n}\n\nexport function enableMapObservation(): void {\n  if (proto.set['observing'] !== true) proto.set = observeSet;\n  if (proto.clear['observing'] !== true) proto.clear = observeClear;\n  if (proto.delete['observing'] !== true) proto.delete = observeDelete;\n}\n\nenableMapObservation();\n\nexport function disableMapObservation(): void {\n  if (proto.set['observing'] === true) proto.set = nativeSet;\n  if (proto.clear['observing'] === true) proto.clear = nativeClear;\n  if (proto.delete['observing'] === true) proto.delete = nativeDelete;\n}\n\nexport interface MapObserver extends ICollectionObserver<CollectionKind.map> {}\n\n@collectionObserver(CollectionKind.map)\nexport class MapObserver implements MapObserver {\n  public resetIndexMap: () => void;\n  public lifecycle: ILifecycle;\n\n  public collection: IObservedMap;\n\n  constructor(lifecycle: ILifecycle, map: IObservedMap) {\n    this.lifecycle = lifecycle;\n    map.$observer = this;\n    this.collection = map;\n    this.resetIndexMap();\n  }\n}\n\nexport function getMapObserver(lifecycle: ILifecycle, map: IObservedMap): MapObserver {\n  return (map.$observer as MapObserver) || new MapObserver(lifecycle, map);\n}\n","import { ILifecycle } from '../lifecycle';\nimport { CollectionKind, ICollectionObserver, IObservedSet, LifecycleFlags } from '../observation';\nimport { nativePush, nativeSplice } from './array-observer';\nimport { collectionObserver } from './collection-observer';\n\nconst proto = Set.prototype;\nexport const nativeAdd = proto.add; // TODO: probably want to make these internal again\nexport const nativeClear = proto.clear;\nexport const nativeDelete = proto.delete;\n\n// note: we can't really do much with Set due to the internal data structure not being accessible so we're just using the native calls\n// fortunately, add/delete/clear are easy to reconstruct for the indexMap\n\n// https://tc39.github.io/ecma262/#sec-set.prototype.add\nfunction observeAdd(this: IObservedSet, value: unknown): ReturnType<typeof nativeAdd> {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativeAdd.call(this, value);\n  }\n  const oldSize = this.size;\n  nativeAdd.call(this, value);\n  const newSize = this.size;\n  if (newSize === oldSize) {\n    return this;\n  }\n  o.indexMap[oldSize] = -2;\n  o.callSubscribers('add', arguments, LifecycleFlags.isCollectionMutation);\n  return this;\n}\n\n// https://tc39.github.io/ecma262/#sec-set.prototype.clear\nfunction observeClear(this: IObservedSet): ReturnType<typeof nativeClear>  {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativeClear.call(this);\n  }\n  const size = this.size;\n  if (size > 0) {\n    const indexMap = o.indexMap;\n    let i = 0;\n    for (const entry of this.keys()) {\n      if (indexMap[i] > -1) {\n        nativePush.call(indexMap.deletedItems, entry);\n      }\n      i++;\n    }\n    nativeClear.call(this);\n    indexMap.length = 0;\n    o.callSubscribers('clear', arguments, LifecycleFlags.isCollectionMutation);\n  }\n  return undefined;\n}\n\n// https://tc39.github.io/ecma262/#sec-set.prototype.delete\nfunction observeDelete(this: IObservedSet, value: unknown): ReturnType<typeof nativeDelete> {\n  const o = this.$observer;\n  if (o === undefined) {\n    return nativeDelete.call(this, value);\n  }\n  const size = this.size;\n  if (size === 0) {\n    return false;\n  }\n  let i = 0;\n  const indexMap = o.indexMap;\n  for (const entry of this.keys()) {\n    if (entry === value) {\n      if (indexMap[i] > -1) {\n        nativePush.call(indexMap.deletedItems, entry);\n      }\n      nativeSplice.call(indexMap, i, 1);\n      return nativeDelete.call(this, value);\n    }\n    i++;\n  }\n  o.callSubscribers('delete', arguments, LifecycleFlags.isCollectionMutation);\n  return false;\n}\n\nfor (const observe of [observeAdd, observeClear, observeDelete]) {\n  Object.defineProperty(observe, 'observing', { value: true, writable: false, configurable: false, enumerable: false });\n}\n\nexport function enableSetObservation(): void {\n  if (proto.add['observing'] !== true) proto.add = observeAdd;\n  if (proto.clear['observing'] !== true) proto.clear = observeClear;\n  if (proto.delete['observing'] !== true) proto.delete = observeDelete;\n}\n\nenableSetObservation();\n\nexport function disableSetObservation(): void {\n  if (proto.add['observing'] === true) proto.add = nativeAdd;\n  if (proto.clear['observing'] === true) proto.clear = nativeClear;\n  if (proto.delete['observing'] === true) proto.delete = nativeDelete;\n}\n\nexport interface SetObserver extends ICollectionObserver<CollectionKind.set> {}\n\n@collectionObserver(CollectionKind.set)\nexport class SetObserver implements SetObserver {\n  public resetIndexMap: () => void;\n\n  public collection: IObservedSet;\n\n  constructor(lifecycle: ILifecycle, observedSet: IObservedSet) {\n    this.lifecycle = lifecycle;\n    observedSet.$observer = this;\n    this.collection = observedSet;\n    this.resetIndexMap();\n  }\n}\n\nexport function getSetObserver(lifecycle: ILifecycle, observedSet: IObservedSet): SetObserver {\n  return (observedSet.$observer as SetObserver) || new SetObserver(lifecycle, observedSet);\n}\n","import { PLATFORM, Reporter } from '@aurelia/kernel';\nimport { ILifecycle } from '../lifecycle';\nimport {\n  IBindingTargetAccessor,\n  IBindingTargetObserver,\n  IObservable,\n  IPropertySubscriber,\n  ISubscribable,\n  LifecycleFlags,\n  MutationKind\n} from '../observation';\nimport { IDirtyChecker } from './dirty-checker';\nimport { IObserverLocator } from './observer-locator';\nimport { subscriberCollection } from './subscriber-collection';\n\nexport interface ComputedOverrides {\n  // Indicates that a getter doesn't need to re-calculate its dependencies after the first observation.\n  static?: boolean;\n\n  // Indicates that the getter of a getter/setter pair can change its value based on side-effects outside the setter.\n  volatile?: boolean;\n}\n\nexport type ComputedLookup = { computed?: Record<string, ComputedOverrides> };\n\nexport function computed(config: ComputedOverrides): PropertyDecorator {\n  return function(target: Object & ComputedLookup, key: string): void {\n    (target.computed || (target.computed = {}))[key] = config;\n  };\n}\n\n// tslint:disable-next-line:no-typeof-undefined\nconst noProxy = typeof Proxy === 'undefined';\nconst computedOverrideDefaults: ComputedOverrides = { static: false, volatile: false };\n\n/* @internal */\nexport function createComputedObserver(\n  observerLocator: IObserverLocator,\n  dirtyChecker: IDirtyChecker,\n  lifecycle: ILifecycle,\n  instance: IObservable & { constructor: Function & ComputedLookup },\n  propertyName: string,\n  descriptor: PropertyDescriptor): IBindingTargetAccessor {\n\n  if (descriptor.configurable === false) {\n    return dirtyChecker.createProperty(instance, propertyName);\n  }\n\n  if (descriptor.get) {\n    const overrides: ComputedOverrides = instance.constructor.computed\n      ? instance.constructor.computed[propertyName] || computedOverrideDefaults\n      : computedOverrideDefaults;\n\n    if (descriptor.set) {\n      if (overrides.volatile) {\n        return noProxy\n          ? dirtyChecker.createProperty(instance, propertyName)\n          : new GetterObserver(overrides, instance, propertyName, descriptor, observerLocator, lifecycle);\n        }\n\n      return new CustomSetterObserver(instance, propertyName, descriptor, lifecycle);\n    }\n\n    return noProxy\n      ? dirtyChecker.createProperty(instance, propertyName)\n      : new GetterObserver(overrides, instance, propertyName, descriptor, observerLocator, lifecycle);\n  }\n\n  throw Reporter.error(18, propertyName);\n}\n\nexport interface CustomSetterObserver extends IBindingTargetObserver { }\n\n// Used when the getter is dependent solely on changes that happen within the setter.\n@subscriberCollection(MutationKind.instance)\nexport class CustomSetterObserver implements CustomSetterObserver {\n  public $nextFlush: this;\n  public currentValue: unknown;\n  public dispose: () => void;\n  public observing: boolean;\n  public obj: IObservable;\n  public oldValue: unknown;\n  public propertyKey: string;\n\n  private descriptor: PropertyDescriptor;\n  private lifecycle: ILifecycle;\n\n  constructor(obj: IObservable, propertyKey: string, descriptor: PropertyDescriptor, lifecycle: ILifecycle) {\n    this.$nextFlush = null;\n\n    this.obj = obj;\n    this.observing = false;\n    this.propertyKey = propertyKey;\n\n    this.descriptor = descriptor;\n    this.lifecycle = lifecycle;\n  }\n\n  public getValue(): unknown {\n    return this.obj[this.propertyKey];\n  }\n\n  public setValue(newValue: unknown): void {\n    this.obj[this.propertyKey] = newValue;\n  }\n\n  public flush(flags: LifecycleFlags): void {\n    const oldValue = this.oldValue;\n    const newValue = this.currentValue;\n\n    this.callSubscribers(newValue, oldValue, flags | LifecycleFlags.updateTargetInstance);\n  }\n\n  public subscribe(subscriber: IPropertySubscriber): void {\n    if (!this.observing) {\n      this.convertProperty();\n    }\n    this.addSubscriber(subscriber);\n  }\n\n  public unsubscribe(subscriber: IPropertySubscriber): void {\n    this.removeSubscriber(subscriber);\n  }\n\n  public convertProperty(): void {\n    const setter = this.descriptor.set;\n    const that = this;\n\n    this.observing = true;\n    this.currentValue = this.obj[this.propertyKey];\n\n    Reflect.defineProperty(this.obj, this.propertyKey, {\n      set: function(newValue: unknown): void {\n        setter.call(that.obj, newValue);\n\n        const oldValue = that.currentValue;\n\n        if (oldValue !== newValue) {\n          that.oldValue = oldValue;\n          that.lifecycle.enqueueFlush(that).catch(error => { throw error; });\n\n          that.currentValue = newValue;\n        }\n      }\n    });\n  }\n}\n\nCustomSetterObserver.prototype.dispose = PLATFORM.noop;\n\nexport interface GetterObserver extends IBindingTargetObserver { }\n\n// Used when there is no setter, and the getter is dependent on other properties of the object;\n// Used when there is a setter but the value of the getter can change based on properties set outside of the setter.\n/** @internal */\n@subscriberCollection(MutationKind.instance)\nexport class GetterObserver implements GetterObserver {\n  public dispose: () => void;\n  public obj: IObservable;\n  public propertyKey: string;\n\n  private controller: GetterController;\n\n  constructor(overrides: ComputedOverrides, obj: IObservable, propertyKey: string, descriptor: PropertyDescriptor, observerLocator: IObserverLocator, lifecycle: ILifecycle) {\n    this.obj = obj;\n    this.propertyKey = propertyKey;\n\n    this.controller = new GetterController(overrides, obj, propertyKey, descriptor, this, observerLocator, lifecycle);\n  }\n\n  public getValue(): unknown {\n    return this.controller.value;\n  }\n\n  public setValue(newValue: unknown): void {\n    return;\n  }\n\n  public flush(flags: LifecycleFlags): void {\n    const oldValue = this.controller.value;\n    const newValue = this.controller.getValueAndCollectDependencies();\n\n    if (oldValue !== newValue) {\n      this.callSubscribers(newValue, oldValue, flags | LifecycleFlags.updateTargetInstance);\n    }\n  }\n\n  public subscribe(subscriber: IPropertySubscriber): void {\n    this.addSubscriber(subscriber);\n    this.controller.onSubscriberAdded();\n  }\n\n  public unsubscribe(subscriber: IPropertySubscriber): void {\n    this.removeSubscriber(subscriber);\n    this.controller.onSubscriberRemoved();\n  }\n}\n\nGetterObserver.prototype.dispose = PLATFORM.noop;\n\n/** @internal */\nexport class GetterController {\n  public value: unknown;\n  public isCollecting: boolean;\n\n  private dependencies: ISubscribable<MutationKind.instance>[];\n  private instance: IObservable;\n  private lifecycle: ILifecycle;\n  private overrides: ComputedOverrides;\n  private owner: GetterObserver;\n  private propertyName: string;\n  private subscriberCount: number;\n\n  constructor(overrides: ComputedOverrides, instance: IObservable, propertyName: string, descriptor: PropertyDescriptor, owner: GetterObserver, observerLocator: IObserverLocator, lifecycle: ILifecycle) {\n    this.isCollecting = false;\n\n    this.dependencies = [];\n    this.instance = instance;\n    this.lifecycle = lifecycle;\n    this.overrides = overrides;\n    this.owner = owner;\n    this.propertyName = propertyName;\n    this.subscriberCount = 0;\n\n    const proxy = new Proxy(instance, createGetterTraps(observerLocator, this));\n    const getter = descriptor.get;\n    const ctrl = this;\n\n    Reflect.defineProperty(instance, propertyName, {\n      get: function(): unknown {\n        if (ctrl.subscriberCount < 1 || ctrl.isCollecting) {\n          ctrl.value = getter.apply(proxy);\n        }\n\n        return ctrl.value;\n      }\n    });\n  }\n\n  public addDependency(subscribable: ISubscribable<MutationKind.instance>): void {\n    if (this.dependencies.includes(subscribable)) {\n      return;\n    }\n\n    this.dependencies.push(subscribable);\n  }\n\n  public onSubscriberAdded(): void {\n    this.subscriberCount++;\n\n    if (this.subscriberCount > 1) {\n      return;\n    }\n\n    this.getValueAndCollectDependencies(true);\n  }\n\n  public getValueAndCollectDependencies(requireCollect: boolean = false): unknown {\n    const dynamicDependencies = !this.overrides.static || requireCollect;\n\n    if (dynamicDependencies) {\n      this.unsubscribeAllDependencies();\n      this.isCollecting = true;\n    }\n\n    this.value = this.instance[this.propertyName]; // triggers observer collection\n\n    if (dynamicDependencies) {\n      this.isCollecting = false;\n      this.dependencies.forEach(x => { x.subscribe(this); });\n    }\n\n    return this.value;\n  }\n\n  public onSubscriberRemoved(): void {\n    this.subscriberCount--;\n\n    if (this.subscriberCount === 0) {\n      this.unsubscribeAllDependencies();\n    }\n  }\n\n  public handleChange(): void {\n    this.lifecycle.enqueueFlush(this.owner).catch(error => { throw error; });\n  }\n\n  private unsubscribeAllDependencies(): void {\n    this.dependencies.forEach(x => { x.unsubscribe(this); });\n    this.dependencies.length = 0;\n  }\n}\n\nfunction createGetterTraps(observerLocator: IObserverLocator, controller: GetterController): ReturnType<typeof proxyOrValue> {\n  return {\n    get: function(instance: object, key: string): unknown {\n      const value = instance[key];\n\n      if (key === '$observers' || typeof value === 'function' || !controller.isCollecting) {\n        return value;\n      }\n\n      // TODO: fix this\n      if (instance instanceof Array) {\n        controller.addDependency(observerLocator.getArrayObserver(instance));\n\n        if (key === 'length') {\n          controller.addDependency(observerLocator.getArrayObserver(instance).getLengthObserver());\n        }\n      } else if (instance instanceof Map) {\n        controller.addDependency(observerLocator.getMapObserver(instance));\n\n        if (key === 'size') {\n          controller.addDependency(observerLocator.getMapObserver(instance).getLengthObserver());\n        }\n      } else if (instance instanceof Set) {\n        controller.addDependency(observerLocator.getSetObserver(instance));\n\n        if (key === 'size') {\n          return observerLocator.getSetObserver(instance).getLengthObserver();\n        }\n      } else {\n        controller.addDependency(observerLocator.getObserver(instance, key) as IBindingTargetObserver);\n      }\n\n      return proxyOrValue(observerLocator, controller, value);\n    }\n  };\n}\n\nfunction proxyOrValue(observerLocator: IObserverLocator, controller: GetterController, value: object): ProxyHandler<object> {\n  if (!(value instanceof Object)) {\n    return value;\n  }\n\n  return new Proxy(value, createGetterTraps(observerLocator, controller));\n}\n","import { DI } from '@aurelia/kernel';\nimport { IBindingTargetAccessor, IBindingTargetObserver, IObservable, IPropertySubscriber, LifecycleFlags } from '../observation';\nimport { propertyObserver } from './property-observer';\n\nexport interface IDirtyChecker {\n  createProperty(obj: IObservable, propertyName: string): IBindingTargetAccessor;\n}\n\nexport const IDirtyChecker = DI.createInterface<IDirtyChecker>()\n  .withDefault(x => x.singleton(DirtyChecker));\n\n/** @internal */\nexport class DirtyChecker {\n  private checkDelay: number;\n  private tracked: DirtyCheckProperty[];\n\n  public constructor() {\n    this.checkDelay = 120;\n    this.tracked = [];\n  }\n\n  public createProperty(obj: IObservable, propertyName: string): DirtyCheckProperty {\n    return new DirtyCheckProperty(this, obj, propertyName);\n  }\n\n  public addProperty(property: DirtyCheckProperty): void {\n    const tracked = this.tracked;\n\n    tracked.push(property);\n\n    if (tracked.length === 1) {\n      this.scheduleDirtyCheck();\n    }\n  }\n\n  public removeProperty(property: DirtyCheckProperty): void {\n    const tracked = this.tracked;\n    tracked.splice(tracked.indexOf(property), 1);\n  }\n\n  public scheduleDirtyCheck(): void {\n    setTimeout(() => { this.check(); }, this.checkDelay);\n  }\n\n  public check(): void {\n    const tracked = this.tracked;\n    let i = tracked.length;\n\n    while (i--) {\n      const current = tracked[i];\n\n      if (current.isDirty()) {\n        current.flush(LifecycleFlags.fromFlush);\n      }\n    }\n\n    if (tracked.length) {\n      this.scheduleDirtyCheck();\n    }\n  }\n}\n\nexport interface DirtyCheckProperty extends IBindingTargetObserver { }\n\n/** @internal */\n@propertyObserver()\nexport class DirtyCheckProperty implements DirtyCheckProperty {\n  public obj: IObservable;\n  public oldValue: unknown;\n  public propertyKey: string;\n\n  private dirtyChecker: DirtyChecker;\n\n  constructor(dirtyChecker: DirtyChecker, obj: IObservable, propertyKey: string) {\n    this.obj = obj;\n    this.propertyKey = propertyKey;\n\n    this.dirtyChecker = dirtyChecker;\n  }\n\n  public isDirty(): boolean {\n    return this.oldValue !== this.obj[this.propertyKey];\n  }\n\n  public getValue(): unknown {\n    return this.obj[this.propertyKey];\n  }\n\n  public setValue(newValue: unknown): void {\n    this.obj[this.propertyKey] = newValue;\n  }\n\n  public flush(flags: LifecycleFlags): void {\n    const oldValue = this.oldValue;\n    const newValue = this.getValue();\n\n    this.callSubscribers(newValue, oldValue, flags | LifecycleFlags.updateTargetInstance);\n\n    this.oldValue = newValue;\n  }\n\n  public subscribe(subscriber: IPropertySubscriber): void {\n    if (!this.hasSubscribers()) {\n      this.oldValue = this.getValue();\n      this.dirtyChecker.addProperty(this);\n    }\n    this.addSubscriber(subscriber);\n  }\n\n  public unsubscribe(subscriber: IPropertySubscriber): void {\n    if (this.removeSubscriber(subscriber) && !this.hasSubscribers()) {\n      this.dirtyChecker.removeProperty(this);\n    }\n  }\n}\n","import { DOM } from '../dom';\nimport { IHTMLInputElement, IHTMLOptionElement, IHTMLSelectElement, IMutationObserver, INode } from '../dom.interfaces';\nimport { ILifecycle } from '../lifecycle';\nimport {\n  CollectionKind,\n  IBatchedCollectionSubscriber,\n  IBindingTargetObserver,\n  ICollectionObserver,\n  IndexMap,\n  IPropertySubscriber,\n  LifecycleFlags,\n  ObserversLookup\n} from '../observation';\nimport { IEventSubscriber } from './event-manager';\nimport { IObserverLocator } from './observer-locator';\nimport { SetterObserver } from './property-observation';\nimport { targetObserver } from './target-observer';\n\nconst inputValueDefaults = {\n  ['button']: '',\n  ['checkbox']: 'on',\n  ['color']: '#000000',\n  ['date']: '',\n  ['datetime-local']: '',\n  ['email']: '',\n  ['file']: '',\n  ['hidden']: '',\n  ['image']: '',\n  ['month']: '',\n  ['number']: '',\n  ['password']: '',\n  ['radio']: 'on',\n  ['range']: '50',\n  ['reset']: '',\n  ['search']: '',\n  ['submit']: '',\n  ['tel']: '',\n  ['text']: '',\n  ['time']: '',\n  ['url']: '',\n  ['week']: ''\n};\n\nconst handleEventFlags = LifecycleFlags.fromDOMEvent | LifecycleFlags.updateSourceExpression;\n\nexport interface ValueAttributeObserver extends\n  IBindingTargetObserver<INode, string> { }\n\n@targetObserver('')\nexport class ValueAttributeObserver implements ValueAttributeObserver {\n  public currentFlags: LifecycleFlags;\n  public currentValue: unknown;\n  public defaultValue: unknown;\n  public oldValue: unknown;\n  public flush: () => void;\n  public handler: IEventSubscriber;\n  public lifecycle: ILifecycle;\n  public obj: INode;\n  public propertyKey: string;\n\n  constructor(lifecycle: ILifecycle, obj: INode, propertyKey: string, handler: IEventSubscriber) {\n    this.handler = handler;\n    this.lifecycle = lifecycle;\n    this.obj = obj;\n    this.propertyKey = propertyKey;\n\n    // note: input.files can be assigned and this was fixed in Firefox 57:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1384030\n\n    // input.value (for type='file') however, can only be assigned an empty string\n    if (propertyKey === 'value') {\n      const nodeType = obj['type'];\n      this.defaultValue = inputValueDefaults[nodeType || 'text'];\n      if (nodeType === 'file') {\n        this.flush = this.flushFileChanges;\n      }\n    } else {\n      this.defaultValue = '';\n    }\n    this.oldValue = this.currentValue = obj[propertyKey];\n  }\n\n  public getValue(): unknown {\n    return this.obj[this.propertyKey];\n  }\n\n  public setValueCore(newValue: unknown, flags: LifecycleFlags): void {\n    this.obj[this.propertyKey] = newValue;\n    if (flags & LifecycleFlags.fromBind) {\n      return;\n    }\n    this.callSubscribers(this.currentValue, this.oldValue, flags);\n  }\n\n  public handleEvent(): void {\n    const oldValue = this.oldValue = this.currentValue;\n    const newValue = this.currentValue = this.getValue();\n    if (oldValue !== newValue) {\n      this.callSubscribers(newValue, oldValue, handleEventFlags);\n      this.oldValue = newValue;\n    }\n  }\n\n  public subscribe(subscriber: IPropertySubscriber): void {\n    if (!this.hasSubscribers()) {\n      this.oldValue = this.getValue();\n      this.handler.subscribe(this.obj, this);\n    }\n    this.addSubscriber(subscriber);\n  }\n\n  public unsubscribe(subscriber: IPropertySubscriber): void {\n    if (this.removeSubscriber(subscriber) && !this.hasSubscribers()) {\n      this.handler.dispose();\n    }\n  }\n\n  private flushFileChanges(): void {\n    const currentValue = this.currentValue;\n    if (this.oldValue !== currentValue && currentValue === '') {\n      this.setValueCore(currentValue, this.currentFlags);\n      this.oldValue = this.currentValue;\n    }\n  }\n}\n\nValueAttributeObserver.prototype.propertyKey = '';\nValueAttributeObserver.prototype.handler = null;\n\nconst defaultHandleBatchedChangeFlags = LifecycleFlags.fromFlush | LifecycleFlags.updateTargetInstance;\n\nexport interface IInputElement extends IHTMLInputElement {\n  matcher?: typeof defaultMatcher;\n  model?: unknown;\n  $observers?: ObserversLookup & {\n    model?: SetterObserver;\n    value?: ValueAttributeObserver;\n  };\n}\n\nexport interface CheckedObserver extends\n  IBindingTargetObserver<IInputElement, string>,\n  IBatchedCollectionSubscriber,\n  IPropertySubscriber { }\n\n@targetObserver()\nexport class CheckedObserver implements CheckedObserver {\n  public currentFlags: LifecycleFlags;\n  public currentValue: unknown;\n  public defaultValue: unknown;\n  public flush: () => void;\n  public handler: IEventSubscriber;\n  public lifecycle: ILifecycle;\n  public obj: IInputElement;\n  public observerLocator: IObserverLocator;\n  public oldValue: unknown;\n\n  private arrayObserver: ICollectionObserver<CollectionKind.array>;\n  private valueObserver: ValueAttributeObserver | SetterObserver;\n\n  constructor(lifecycle: ILifecycle, obj: IInputElement, handler: IEventSubscriber, observerLocator: IObserverLocator) {\n    this.handler = handler;\n    this.lifecycle = lifecycle;\n    this.obj = obj;\n    this.observerLocator = observerLocator;\n  }\n\n  public getValue(): unknown {\n    return this.currentValue;\n  }\n\n  public setValueCore(newValue: unknown, flags: LifecycleFlags): void {\n    if (!this.valueObserver) {\n      this.valueObserver = this.obj['$observers'] && (this.obj['$observers'].model || this.obj['$observers'].value);\n      if (this.valueObserver) {\n        this.valueObserver.subscribe(this);\n      }\n    }\n    if (this.arrayObserver) {\n      this.arrayObserver.unsubscribeBatched(this);\n      this.arrayObserver = null;\n    }\n    if (this.obj.type === 'checkbox' && Array.isArray(newValue)) {\n      this.arrayObserver = this.observerLocator.getArrayObserver(newValue);\n      this.arrayObserver.subscribeBatched(this);\n    }\n    this.synchronizeElement();\n  }\n\n  // handleBatchedCollectionChange (todo: rename to make this explicit?)\n  public handleBatchedChange(): void {\n    this.synchronizeElement();\n    this.notify(defaultHandleBatchedChangeFlags);\n  }\n\n  // handlePropertyChange (todo: rename normal subscribe methods in target observers to batched, since that's what they really are)\n  public handleChange(newValue: unknown, previousValue: unknown, flags: LifecycleFlags): void {\n    this.synchronizeElement();\n    this.notify(flags);\n  }\n\n  public synchronizeElement(): void {\n    const value = this.currentValue;\n    const element = this.obj;\n    const elementValue = element.hasOwnProperty('model') ? element['model'] : element.value;\n    const isRadio = element.type === 'radio';\n    const matcher = element['matcher'] || ((a: unknown, b: unknown) => a === b);\n\n    if (isRadio) {\n      element.checked = !!matcher(value, elementValue);\n    } else if (value === true) {\n      element.checked = true;\n    } else if (Array.isArray(value)) {\n      element.checked = value.findIndex(item => !!matcher(item, elementValue)) !== -1;\n    } else {\n      element.checked = false;\n    }\n  }\n\n  public notify(flags: LifecycleFlags): void {\n    if (flags & LifecycleFlags.fromBind) {\n      return;\n    }\n    const oldValue = this.oldValue;\n    const newValue = this.currentValue;\n    if (newValue === oldValue) {\n      return;\n    }\n    this.callSubscribers(this.currentValue, this.oldValue, flags);\n  }\n\n  public handleEvent(): void {\n    let value = this.currentValue;\n    const element = this.obj;\n    const elementValue = element.hasOwnProperty('model') ? element['model'] : element.value;\n    let index;\n    const matcher = element['matcher'] || defaultMatcher;\n\n    if (element.type === 'checkbox') {\n      if (Array.isArray(value)) {\n        index = value.findIndex(item => !!matcher(item, elementValue));\n        if (element.checked && index === -1) {\n          value.push(elementValue);\n        } else if (!element.checked && index !== -1) {\n          value.splice(index, 1);\n        }\n        // when existing value is array, do not invoke callback as only the array element has changed\n        return;\n      }\n      value = element.checked;\n    } else if (element.checked) {\n      value = elementValue;\n    } else {\n      return;\n    }\n    this.oldValue = this.currentValue;\n    this.currentValue = value;\n    this.notify(handleEventFlags);\n  }\n\n  public subscribe(subscriber: IPropertySubscriber): void {\n    if (!this.hasSubscribers()) {\n      this.handler.subscribe(this.obj, this);\n    }\n    this.addSubscriber(subscriber);\n  }\n\n  public unsubscribe(subscriber: IPropertySubscriber): void {\n    if (this.removeSubscriber(subscriber) && !this.hasSubscribers()) {\n      this.handler.dispose();\n    }\n  }\n\n  public unbind(): void {\n    if (this.arrayObserver) {\n      this.arrayObserver.unsubscribeBatched(this);\n      this.arrayObserver = null;\n    }\n    if (this.valueObserver) {\n      this.valueObserver.unsubscribe(this);\n    }\n  }\n}\n\nCheckedObserver.prototype.handler = null;\nCheckedObserver.prototype.observerLocator = null;\n\nconst childObserverOptions = {\n  childList: true,\n  subtree: true,\n  characterData: true\n};\n\nfunction defaultMatcher(a: unknown, b: unknown): boolean {\n  return a === b;\n}\n\nexport interface ISelectElement extends IHTMLSelectElement {\n  options: ArrayLike<IOptionElement>;\n  matcher?: typeof defaultMatcher;\n}\nexport interface IOptionElement extends IHTMLOptionElement {\n  model?: unknown;\n}\n\nexport interface SelectValueObserver extends\n  IBindingTargetObserver<ISelectElement, string>,\n  IBatchedCollectionSubscriber,\n  IPropertySubscriber { }\n\n@targetObserver()\nexport class SelectValueObserver implements SelectValueObserver {\n  public currentValue: unknown;\n  public currentFlags: LifecycleFlags;\n  public oldValue: unknown;\n  public defaultValue: unknown;\n\n  public flush: () => void;\n\n  private arrayObserver: ICollectionObserver<CollectionKind.array>;\n  private nodeObserver: IMutationObserver;\n\n  constructor(\n    public lifecycle: ILifecycle,\n    public obj: ISelectElement,\n    public handler: IEventSubscriber,\n    public observerLocator: IObserverLocator\n  ) { }\n\n  public getValue(): unknown {\n    return this.currentValue;\n  }\n\n  public setValueCore(newValue: unknown, flags: LifecycleFlags): void {\n    const isArray = Array.isArray(newValue);\n    if (!isArray && newValue !== null && newValue !== undefined && this.obj.multiple) {\n      throw new Error('Only null or Array instances can be bound to a multi-select.');\n    }\n    if (this.arrayObserver) {\n      this.arrayObserver.unsubscribeBatched(this);\n      this.arrayObserver = null;\n    }\n    if (isArray) {\n      this.arrayObserver = this.observerLocator.getArrayObserver(newValue as unknown[]);\n      this.arrayObserver.subscribeBatched(this);\n    }\n    this.synchronizeOptions();\n    this.notify(flags);\n  }\n\n  // called when the array mutated (items sorted/added/removed, etc)\n  public handleBatchedChange(indexMap: number[]): void {\n    // we don't need to go through the normal setValue logic and can directly call synchronizeOptions here,\n    // because the change already waited one tick (batched) and there's no point in calling notify when the instance didn't change\n    this.synchronizeOptions(indexMap);\n  }\n\n  // called when a different value was assigned\n  public handleChange(newValue: unknown, previousValue: unknown, flags: LifecycleFlags): void {\n    this.setValue(newValue, flags);\n  }\n\n  public notify(flags: LifecycleFlags): void {\n    if (flags & LifecycleFlags.fromBind) {\n      return;\n    }\n    const oldValue = this.oldValue;\n    const newValue = this.currentValue;\n    if (newValue === oldValue) {\n      return;\n    }\n    this.callSubscribers(newValue, oldValue, flags);\n  }\n\n  public handleEvent(): void {\n    // \"from-view\" changes are always synchronous now, so immediately sync the value and notify subscribers\n    const shouldNotify = this.synchronizeValue();\n    if (shouldNotify) {\n      this.notify(handleEventFlags);\n    }\n  }\n\n  public synchronizeOptions(indexMap?: IndexMap): void {\n    const currentValue = this.currentValue;\n    const isArray = Array.isArray(currentValue);\n    const obj = this.obj;\n    const matcher = obj.matcher || defaultMatcher;\n    const options = obj.options;\n    let i = options.length;\n\n    while (i--) {\n      const option = options[i];\n      const optionValue = option.hasOwnProperty('model') ? option.model : option.value;\n      if (isArray) {\n        option.selected = (currentValue as unknown[]).findIndex(item => !!matcher(optionValue, item)) !== -1;\n        continue;\n      }\n      option.selected = !!matcher(optionValue, currentValue);\n    }\n  }\n\n  public synchronizeValue(): boolean {\n    // Spec for synchronizing value from `SelectObserver` to `<select/>`\n    // When synchronizing value to observed <select/> element, do the following steps:\n    // A. If `<select/>` is multiple\n    //    1. Check if current value, called `currentValue` is an array\n    //      a. If not an array, return true to signal value has changed\n    //      b. If is an array:\n    //        i. gather all current selected <option/>, in to array called `values`\n    //        ii. loop through the `currentValue` array and remove items that are nolonger selected based on matcher\n    //        iii. loop through the `values` array and add items that are selected based on matcher\n    //        iv. Return false to signal value hasn't changed\n    // B. If the select is single\n    //    1. Let `value` equal the first selected option, if no option selected, then `value` is `null`\n    //    2. assign `this.currentValue` to `this.oldValue`\n    //    3. assign `value` to `this.currentValue`\n    //    4. return `true` to signal value has changed\n    const obj = this.obj;\n    const options = obj.options;\n    const len = options.length;\n    const currentValue = this.currentValue;\n    let i = 0;\n\n    if (obj.multiple) {\n      // A.\n      if (!Array.isArray(currentValue)) {\n        // A.1.a\n        return true;\n      }\n      // A.1.b\n      // multi select\n      let option: IOptionElement;\n      const matcher = obj.matcher || defaultMatcher;\n      // A.1.b.i\n      const values: unknown[] = [];\n      while (i < len) {\n        option = options[i];\n        if (option.selected) {\n          values.push(option.hasOwnProperty('model')\n            ? option.model\n            : option.value\n          );\n        }\n        ++i;\n      }\n      // A.1.b.ii\n      i = 0;\n      while (i < currentValue.length) {\n        const a = currentValue[i];\n        // Todo: remove arrow fn\n        if (values.findIndex(b => !!matcher(a, b)) === -1) {\n          currentValue.splice(i, 1);\n        } else {\n          ++i;\n        }\n      }\n      // A.1.b.iii\n      i = 0;\n      while (i < values.length) {\n        const a = values[i];\n        // Todo: remove arrow fn\n        if (currentValue.findIndex(b => !!matcher(a, b)) === -1) {\n          currentValue.push(a);\n        }\n        ++i;\n      }\n      // A.1.b.iv\n      return false;\n    }\n    // B. single select\n    // B.1\n    let value: unknown = null;\n    while (i < len) {\n      const option = options[i];\n      if (option.selected) {\n        value = option.hasOwnProperty('model')\n          ? option.model\n          : option.value;\n        break;\n      }\n      ++i;\n    }\n    // B.2\n    this.oldValue = this.currentValue;\n    // B.3\n    this.currentValue = value;\n    // B.4\n    return true;\n  }\n\n  public subscribe(subscriber: IPropertySubscriber): void {\n    if (!this.hasSubscribers()) {\n      this.handler.subscribe(this.obj, this);\n    }\n    this.addSubscriber(subscriber);\n  }\n\n  public unsubscribe(subscriber: IPropertySubscriber): void {\n    if (this.removeSubscriber(subscriber) && !this.hasSubscribers()) {\n      this.handler.dispose();\n    }\n  }\n\n  public bind(): void {\n    this.nodeObserver = DOM.createNodeObserver(\n      this.obj,\n      this.handleNodeChange.bind(this),\n      childObserverOptions\n    );\n  }\n\n  public unbind(): void {\n    this.nodeObserver.disconnect();\n    this.nodeObserver = null;\n\n    if (this.arrayObserver) {\n      this.arrayObserver.unsubscribeBatched(this);\n      this.arrayObserver = null;\n    }\n  }\n\n  public handleNodeChange(): void {\n    this.synchronizeOptions();\n    const shouldNotify = this.synchronizeValue();\n    if (shouldNotify) {\n      this.notify(handleEventFlags);\n    }\n  }\n}\n\nSelectValueObserver.prototype.handler = null;\nSelectValueObserver.prototype.observerLocator = null;\n","import { DI, IDisposable } from '@aurelia/kernel';\nimport { DOM } from '../dom';\nimport { IEventListenerOrEventListenerObject, IEventTarget, IManagedEvent, INode } from '../dom.interfaces';\n\n//Note: path and deepPath are designed to handle v0 and v1 shadow dom specs respectively\n/** @internal */\nexport function findOriginalEventTarget(event: IManagedEvent): IEventTarget {\n  return (event.composedPath && event.composedPath()[0]) || (event.deepPath && event.deepPath()[0]) || (event.path && event.path[0]) || event.target;\n}\n\nfunction stopPropagation(this: IManagedEvent): void {\n  this.standardStopPropagation();\n  this.propagationStopped = true;\n}\n\nfunction handleCapturedEvent(event: IManagedEvent): void {\n  event.propagationStopped = false;\n  let target: IEventTargetWithLookups = findOriginalEventTarget(event) as IEventTarget & IEventTargetWithLookups;\n  const orderedCallbacks = [];\n  /**\n   * During capturing phase, event 'bubbles' down from parent. Needs to reorder callback from root down to target\n   */\n  while (target) {\n    if (target.capturedCallbacks) {\n      const callback = target.capturedCallbacks[event.type];\n      if (callback) {\n        if (event.stopPropagation !== stopPropagation) {\n          event.standardStopPropagation = event.stopPropagation;\n          event.stopPropagation = stopPropagation;\n        }\n        orderedCallbacks.push(callback);\n      }\n    }\n    target = target.parentNode;\n  }\n\n  for (let i = orderedCallbacks.length - 1; i >= 0 && !event.propagationStopped; i--) {\n    const orderedCallback = orderedCallbacks[i];\n    if ('handleEvent' in orderedCallback) {\n      orderedCallback.handleEvent(event);\n    } else {\n      orderedCallback(event);\n    }\n  }\n}\n\nfunction handleDelegatedEvent(event: IManagedEvent): void {\n  event.propagationStopped = false;\n  let target: IEventTargetWithLookups = findOriginalEventTarget(event) as IEventTarget & IEventTargetWithLookups;\n  while (target && !event.propagationStopped) {\n    if (target.delegatedCallbacks) {\n      const callback = target.delegatedCallbacks[event.type];\n      if (callback) {\n        if (event.stopPropagation !== stopPropagation) {\n          event.standardStopPropagation = event.stopPropagation;\n          event.stopPropagation = stopPropagation;\n        }\n        if ('handleEvent' in callback) {\n          callback.handleEvent(event);\n        } else {\n          callback(event);\n        }\n      }\n    }\n    target = target.parentNode;\n  }\n}\n\nexport class ListenerTracker {\n  private capture: boolean;\n  private count: number;\n  private eventName: string;\n  private listener: IEventListenerOrEventListenerObject;\n\n  constructor(eventName: string, listener: IEventListenerOrEventListenerObject, capture: boolean) {\n    this.capture = capture;\n    this.count = 0;\n    this.eventName = eventName;\n    this.listener = listener;\n  }\n\n  public increment(): void {\n    this.count++;\n    if (this.count === 1) {\n      DOM.addEventListener(this.eventName, this.listener, null, this.capture);\n    }\n  }\n\n  public decrement(): void {\n    this.count--;\n    if (this.count === 0) {\n      DOM.removeEventListener(this.eventName, this.listener, null, this.capture);\n    }\n  }\n}\n\n/**\n * Enable dispose() pattern for `delegate` & `capture` commands\n */\nexport class DelegateOrCaptureSubscription {\n  constructor(\n    public entry: ListenerTracker,\n    public lookup: Record<string, IEventListenerOrEventListenerObject>,\n    public targetEvent: string,\n    callback: IEventListenerOrEventListenerObject\n  ) {\n    lookup[targetEvent] = callback;\n  }\n\n  public dispose(): void {\n    this.entry.decrement();\n    this.lookup[this.targetEvent] = null;\n  }\n}\n\n/**\n * Enable dispose() pattern for addEventListener for `trigger`\n */\nexport class TriggerSubscription {\n  constructor(\n    public target: INode,\n    public targetEvent: string,\n    public callback: IEventListenerOrEventListenerObject\n  ) {\n    DOM.addEventListener(targetEvent, callback, target);\n  }\n\n  public dispose(): void {\n    DOM.removeEventListener(this.targetEvent, this.callback, this.target);\n  }\n}\n\nexport interface  IEventTargetWithLookups extends INode {\n  delegatedCallbacks?: Record<string, IEventListenerOrEventListenerObject>;\n  capturedCallbacks?: Record<string, IEventListenerOrEventListenerObject>;\n}\n\nexport enum DelegationStrategy {\n  none = 0,\n  capturing = 1,\n  bubbling = 2\n}\n\nexport interface IElementConfiguration {\n  tagName: string;\n  properties: Record<string, string[]>;\n}\n\nexport interface IEventSubscriber extends IDisposable {\n  subscribe(node: INode, callbackOrListener: IEventListenerOrEventListenerObject): void;\n}\n\nexport class EventSubscriber implements IEventSubscriber {\n  private target: INode;\n  private handler: IEventListenerOrEventListenerObject;\n\n  constructor(private readonly events: string[]) {\n    this.events = events;\n    this.target = null;\n    this.handler = null;\n  }\n\n  public subscribe(node: INode, callbackOrListener: IEventListenerOrEventListenerObject): void {\n    this.target = node;\n    this.handler = callbackOrListener;\n\n    const add = DOM.addEventListener;\n    const events = this.events;\n\n    for (let i = 0, ii = events.length; ii > i; ++i) {\n      add(events[i], callbackOrListener, node);\n    }\n  }\n\n  public dispose(): void {\n    const node = this.target;\n    const callbackOrListener = this.handler;\n    const events = this.events;\n    const remove = DOM.removeEventListener;\n\n    for (let i = 0, ii = events.length; ii > i; ++i) {\n      remove(events[i], callbackOrListener, node);\n    }\n\n    this.target = this.handler = null;\n  }\n}\n\nexport type EventSubscription = DelegateOrCaptureSubscription | TriggerSubscription;\n\nexport interface IEventManager {\n  registerElementConfiguration(config: IElementConfiguration): void;\n  getElementHandler(target: INode, propertyName: string): IEventSubscriber | null;\n  addEventListener(target: INode, targetEvent: string, callbackOrListener: IEventListenerOrEventListenerObject, delegate: DelegationStrategy): IDisposable;\n}\n\nexport const IEventManager = DI.createInterface<IEventManager>()\n  .withDefault(x => x.singleton(EventManager));\n\n/** @internal */\nexport class EventManager implements IEventManager {\n  public elementHandlerLookup: Record<string, Record<string, string[]>> = {};\n  public delegatedHandlers: Record<string, ListenerTracker> = {};\n  public capturedHandlers: Record<string, ListenerTracker> = {};\n\n  constructor() {\n    this.registerElementConfiguration({\n      tagName: 'INPUT',\n      properties: {\n        value: ['change', 'input'],\n        checked: ['change', 'input'],\n        files: ['change', 'input']\n      }\n    });\n    this.registerElementConfiguration({\n      tagName: 'TEXTAREA',\n      properties: {\n        value: ['change', 'input']\n      }\n    });\n    this.registerElementConfiguration({\n      tagName: 'SELECT',\n      properties: {\n        value: ['change']\n      }\n    });\n    this.registerElementConfiguration({\n      tagName: 'content editable',\n      properties: {\n        value: ['change', 'input', 'blur', 'keyup', 'paste']\n      }\n    });\n    this.registerElementConfiguration({\n      tagName: 'scrollable element',\n      properties: {\n        scrollTop: ['scroll'],\n        scrollLeft: ['scroll']\n      }\n    });\n  }\n\n  public registerElementConfiguration(config: IElementConfiguration): void {\n    const properties = config.properties;\n    const lookup: Record<string, string[]> = this.elementHandlerLookup[config.tagName] = {};\n\n    for (const propertyName in properties) {\n      if (properties.hasOwnProperty(propertyName)) {\n        lookup[propertyName] = properties[propertyName];\n      }\n    }\n  }\n\n  public getElementHandler(target: INode, propertyName: string): IEventSubscriber | null {\n    const tagName = target['tagName'];\n    const lookup = this.elementHandlerLookup;\n\n    if (tagName) {\n      if (lookup[tagName] && lookup[tagName][propertyName]) {\n        return new EventSubscriber(lookup[tagName][propertyName]);\n      }\n      if (propertyName === 'textContent' || propertyName === 'innerHTML') {\n        return new EventSubscriber(lookup['content editable'].value);\n      }\n      if (propertyName === 'scrollTop' || propertyName === 'scrollLeft') {\n        return new EventSubscriber(lookup['scrollable element'][propertyName]);\n      }\n    }\n    return null;\n  }\n\n  public addEventListener(\n    target: IEventTargetWithLookups,\n    targetEvent: string,\n    callbackOrListener: IEventListenerOrEventListenerObject,\n    strategy: DelegationStrategy\n  ): EventSubscription {\n    let delegatedHandlers: Record<string, ListenerTracker> | undefined;\n    let capturedHandlers: Record<string, ListenerTracker> | undefined;\n    let handlerEntry: ListenerTracker | undefined;\n\n    if (strategy === DelegationStrategy.bubbling) {\n      delegatedHandlers = this.delegatedHandlers;\n      handlerEntry = delegatedHandlers[targetEvent] || (delegatedHandlers[targetEvent] = new ListenerTracker(targetEvent, handleDelegatedEvent, false));\n      handlerEntry.increment();\n      const delegatedCallbacks = target.delegatedCallbacks || (target.delegatedCallbacks = {});\n      return new DelegateOrCaptureSubscription(handlerEntry, delegatedCallbacks, targetEvent, callbackOrListener);\n    }\n    if (strategy === DelegationStrategy.capturing) {\n      capturedHandlers = this.capturedHandlers;\n      handlerEntry = capturedHandlers[targetEvent] || (capturedHandlers[targetEvent] = new ListenerTracker(targetEvent, handleCapturedEvent, true));\n      handlerEntry.increment();\n      const capturedCallbacks = target.capturedCallbacks || (target.capturedCallbacks = {});\n      return new DelegateOrCaptureSubscription(handlerEntry, capturedCallbacks, targetEvent, callbackOrListener);\n    }\n    return new TriggerSubscription(target, targetEvent, callbackOrListener);\n  }\n}\n","import { DI } from '@aurelia/kernel';\nimport { INode } from '../dom.interfaces';\n\nexport interface ISVGAnalyzer {\n  isStandardSvgAttribute(node: INode, attributeName: string): boolean;\n}\n\nexport const ISVGAnalyzer = DI.createInterface<ISVGAnalyzer>()\n  .withDefault(x => x.singleton(class {\n    public isStandardSvgAttribute(node: INode, attributeName: string): boolean {\n      return false;\n    }\n  })\n);\n","import { IIndexable } from '@aurelia/kernel';\nimport { DOM } from '../dom';\nimport { IElement, IHTMLElement, INode } from '../dom.interfaces';\nimport { ILifecycle } from '../lifecycle';\nimport { IBindingTargetAccessor } from '../observation';\nimport { targetObserver } from './target-observer';\n\nconst xlinkAttributeNS = 'http://www.w3.org/1999/xlink';\n\nexport interface XLinkAttributeAccessor extends IBindingTargetAccessor<IHTMLElement, string, string> {}\n\n@targetObserver('')\nexport class XLinkAttributeAccessor implements XLinkAttributeAccessor {\n  public attributeName: string;\n  public currentValue: string;\n  public defaultValue: string;\n  public lifecycle: ILifecycle;\n  public obj: IHTMLElement;\n  public oldValue: string;\n  public propertyKey: string;\n\n  // xlink namespaced attributes require getAttributeNS/setAttributeNS\n  // (even though the NS version doesn't work for other namespaces\n  // in html5 documents)\n\n  // Using very HTML-specific code here since this isn't likely to get\n  // called unless operating against a real HTML element.\n\n  constructor(lifecycle: ILifecycle, obj: IHTMLElement, propertyKey: string, attributeName: string) {\n    this.attributeName = attributeName;\n    this.lifecycle = lifecycle;\n    this.obj = obj;\n    this.oldValue = this.currentValue = this.getValue();\n    this.propertyKey = propertyKey;\n  }\n\n  public getValue(): string {\n    return this.obj.getAttributeNS(xlinkAttributeNS, this.attributeName);\n  }\n\n  public setValueCore(newValue: string): void {\n    this.obj.setAttributeNS(xlinkAttributeNS, this.attributeName, newValue);\n  }\n}\n\nXLinkAttributeAccessor.prototype.attributeName = '';\n\nexport interface DataAttributeAccessor extends IBindingTargetAccessor<INode, string, string> {}\n\n@targetObserver()\nexport class DataAttributeAccessor implements DataAttributeAccessor {\n  public currentValue: string;\n  public defaultValue: string;\n  public lifecycle: ILifecycle;\n  public obj: IElement;\n  public oldValue: string;\n  public propertyKey: string;\n\n  constructor(lifecycle: ILifecycle, obj: IElement, propertyKey: string) {\n    this.lifecycle = lifecycle;\n    this.obj = obj;\n    this.oldValue = this.currentValue = this.getValue();\n    this.propertyKey = propertyKey;\n  }\n\n  public getValue(): string {\n    return DOM.getAttribute(this.obj, this.propertyKey);\n  }\n\n  public setValueCore(newValue: string): void {\n    if (newValue === null) {\n      DOM.removeAttribute(this.obj, this.propertyKey);\n    } else {\n      DOM.setAttribute(this.obj, this.propertyKey, newValue);\n    }\n  }\n}\n\nexport interface StyleAttributeAccessor extends IBindingTargetAccessor<IHTMLElement, 'style', string | Record<string, string>> {}\n\n@targetObserver()\nexport class StyleAttributeAccessor implements StyleAttributeAccessor {\n  public currentValue: string | Record<string, string>;\n  public defaultValue: string | Record<string, string>;\n  public lifecycle: ILifecycle;\n  public obj: IHTMLElement;\n  public oldValue: string | Record<string, string>;\n  public propertyKey: 'style';\n  public styles: object;\n  public version: number;\n\n  constructor(lifecycle: ILifecycle, obj: IHTMLElement) {\n    this.lifecycle = lifecycle;\n    this.obj = obj;\n    this.oldValue = this.currentValue = obj.style.cssText;\n  }\n\n  public getValue(): string {\n    return this.obj.style.cssText;\n  }\n\n  public _setProperty(style: string, value: string): void {\n    let priority = '';\n\n    if (value !== null && value !== undefined && typeof value.indexOf === 'function' && value.indexOf('!important') !== -1) {\n      priority = 'important';\n      value = value.replace('!important', '');\n    }\n\n    this.obj.style.setProperty(style, value, priority);\n  }\n\n  public setValueCore(newValue: string | Record<string, string>): void {\n    const styles = this.styles || {};\n    let style;\n    let version = this.version;\n\n    if (newValue !== null) {\n      if (newValue instanceof Object) {\n        let value;\n        for (style in (newValue as Object)) {\n          if (newValue.hasOwnProperty(style)) {\n            value = newValue[style];\n            style = style.replace(/([A-Z])/g, m => `-${m.toLowerCase()}`);\n            styles[style] = version;\n            this._setProperty(style, value);\n          }\n        }\n      } else if ((newValue as string).length) {\n        const rx = /\\s*([\\w\\-]+)\\s*:\\s*((?:(?:[\\w\\-]+\\(\\s*(?:\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'|[\\w\\-]+\\(\\s*(?:[^\"](?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'|[^\\)]*)\\),?|[^\\)]*)\\),?|\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'|[^;]*),?\\s*)+);?/g;\n        let pair;\n        while ((pair = rx.exec(newValue)) !== null) {\n          style = pair[1];\n          if (!style) { continue; }\n\n          styles[style] = version;\n          this._setProperty(style, pair[2]);\n        }\n      }\n    }\n\n    this.styles = styles;\n    this.version += 1;\n    if (version === 0) {\n      return;\n    }\n\n    version -= 1;\n    for (style in styles) {\n      if (!styles.hasOwnProperty(style) || styles[style] !== version) {\n        continue;\n      }\n      this.obj.style.removeProperty(style);\n    }\n  }\n}\n\nStyleAttributeAccessor.prototype.styles = null;\nStyleAttributeAccessor.prototype.version = 0;\nStyleAttributeAccessor.prototype.propertyKey = 'style';\n\nexport interface ClassAttributeAccessor extends IBindingTargetAccessor<INode, string, string> {}\n\n@targetObserver('')\nexport class ClassAttributeAccessor implements ClassAttributeAccessor {\n  public currentValue: string;\n  public defaultValue: string;\n  public doNotCache: true;\n  public lifecycle: ILifecycle;\n  public nameIndex: object;\n  public obj: IElement;\n  public oldValue: string;\n  public version: number;\n\n  constructor(lifecycle: ILifecycle, obj: IElement) {\n    this.lifecycle = lifecycle;\n    this.obj = obj;\n  }\n\n  public getValue(): string {\n    return this.currentValue;\n  }\n\n  public setValueCore(newValue: string): void {\n    const nameIndex = this.nameIndex || {};\n    let version = this.version;\n    let names;\n    let name;\n\n    // Add the classes, tracking the version at which they were added.\n    if (newValue.length) {\n      const node = this.obj;\n      names = newValue.split(/\\s+/);\n      for (let i = 0, length = names.length; i < length; i++) {\n        name = names[i];\n        if (!name.length) {\n          continue;\n        }\n        nameIndex[name] = version;\n        DOM.addClass(node, name);\n      }\n    }\n\n    // Update state variables.\n    this.nameIndex = nameIndex;\n    this.version += 1;\n\n    // First call to setValue?  We're done.\n    if (version === 0) {\n      return;\n    }\n\n    // Remove classes from previous version.\n    version -= 1;\n    for (name in nameIndex) {\n      if (!nameIndex.hasOwnProperty(name) || nameIndex[name] !== version) {\n        continue;\n      }\n\n      // TODO: this has the side-effect that classes already present which are added again,\n      // will be removed if they're not present in the next update.\n      // Better would be do have some configurability for this behavior, allowing the user to\n      // decide whether initial classes always need to be kept, always removed, or something in between\n      DOM.removeClass(this.obj, name);\n    }\n  }\n}\n\nClassAttributeAccessor.prototype.doNotCache = true;\nClassAttributeAccessor.prototype.version = 0;\nClassAttributeAccessor.prototype.nameIndex = null;\n\nexport interface ElementPropertyAccessor extends IBindingTargetAccessor<object, string> {}\n\n@targetObserver('')\nexport class ElementPropertyAccessor implements ElementPropertyAccessor {\n  public lifecycle: ILifecycle;\n  public obj: object;\n  public propertyKey: string;\n\n  constructor(lifecycle: ILifecycle, obj: object, propertyKey: string) {\n    this.lifecycle = lifecycle;\n    this.obj = obj;\n    this.propertyKey = propertyKey;\n  }\n\n  public getValue(): unknown {\n    return this.obj[this.propertyKey];\n  }\n\n  public setValueCore(value: unknown): void {\n    this.obj[this.propertyKey] = value;\n  }\n}\n\nexport interface PropertyAccessor extends IBindingTargetAccessor<IIndexable, string> {}\n\nexport class PropertyAccessor implements PropertyAccessor {\n  public obj: IIndexable;\n  public propertyKey: string;\n\n  constructor(obj: IIndexable, propertyKey: string) {\n    this.obj = obj;\n    this.propertyKey = propertyKey;\n  }\n\n  public getValue(): unknown {\n    return this.obj[this.propertyKey];\n  }\n\n  public setValue(value: unknown): void {\n    this.obj[this.propertyKey] = value;\n  }\n}\n","import { DI, inject, Reporter } from '@aurelia/kernel';\nimport { DOM } from '../dom';\nimport { IElement, IHTMLElement } from '../dom.interfaces';\nimport { ILifecycle } from '../lifecycle';\nimport {\n  AccessorOrObserver,\n  CollectionKind,\n  CollectionObserver,\n  IBindingContext,\n  IBindingTargetAccessor,\n  IBindingTargetObserver,\n  ICollectionObserver,\n  IObservable,\n  IObservedArray,\n  IObservedMap,\n  IObservedSet,\n  IOverrideContext\n} from '../observation';\nimport { getArrayObserver } from './array-observer';\nimport { createComputedObserver } from './computed-observer';\nimport { IDirtyChecker } from './dirty-checker';\nimport { CheckedObserver, IInputElement, ISelectElement, SelectValueObserver, ValueAttributeObserver } from './element-observation';\nimport { IEventManager } from './event-manager';\nimport { getMapObserver } from './map-observer';\nimport { PrimitiveObserver, SetterObserver } from './property-observation';\nimport { getSetObserver } from './set-observer';\nimport { ISVGAnalyzer } from './svg-analyzer';\nimport {\n  ClassAttributeAccessor,\n  DataAttributeAccessor,\n  ElementPropertyAccessor,\n  PropertyAccessor,\n  StyleAttributeAccessor,\n  XLinkAttributeAccessor\n} from './target-accessors';\n\nconst toStringTag = Object.prototype.toString;\n\nexport interface IObjectObservationAdapter {\n  getObserver(object: IObservable, propertyName: string, descriptor: PropertyDescriptor): IBindingTargetObserver;\n}\n\nexport interface IObserverLocator {\n  getObserver(obj: IObservable, propertyName: string): AccessorOrObserver;\n  getAccessor(obj: IObservable, propertyName: string): IBindingTargetAccessor;\n  addAdapter(adapter: IObjectObservationAdapter): void;\n  getArrayObserver(observedArray: unknown[]): ICollectionObserver<CollectionKind.array>;\n  getMapObserver(observedMap: Map<unknown, unknown>): ICollectionObserver<CollectionKind.map>;\n  getSetObserver(observedSet: Set<unknown>): ICollectionObserver<CollectionKind.set>;\n}\n\nexport const IObserverLocator = DI.createInterface<IObserverLocator>()\n  .withDefault(x => x.singleton(ObserverLocator));\n\nfunction getPropertyDescriptor(subject: object, name: string): PropertyDescriptor {\n  let pd = Object.getOwnPropertyDescriptor(subject, name);\n  let proto = Object.getPrototypeOf(subject);\n\n  while (pd === undefined && proto !== null) {\n    pd = Object.getOwnPropertyDescriptor(proto, name);\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return pd;\n}\n\n@inject(ILifecycle, IEventManager, IDirtyChecker, ISVGAnalyzer)\n/** @internal */\nexport class ObserverLocator implements IObserverLocator {\n  private adapters: IObjectObservationAdapter[];\n  private dirtyChecker: IDirtyChecker;\n  private eventManager: IEventManager;\n  private lifecycle: ILifecycle;\n  private svgAnalyzer: ISVGAnalyzer;\n\n  constructor(lifecycle: ILifecycle, eventManager: IEventManager, dirtyChecker: IDirtyChecker, svgAnalyzer: ISVGAnalyzer) {\n    this.adapters = [];\n    this.dirtyChecker = dirtyChecker;\n    this.eventManager = eventManager;\n    this.lifecycle = lifecycle;\n    this.svgAnalyzer = svgAnalyzer;\n  }\n\n  public getObserver(obj: IObservable | IBindingContext | IOverrideContext, propertyName: string): AccessorOrObserver {\n    if (obj.$synthetic === true) {\n      return obj.getObservers().getOrCreate(obj, propertyName);\n    }\n    let observersLookup = obj.$observers;\n    let observer;\n\n    if (observersLookup && propertyName in observersLookup) {\n      return observersLookup[propertyName];\n    }\n\n    observer = this.createPropertyObserver(obj, propertyName);\n\n    if (!observer.doNotCache) {\n      if (observersLookup === undefined) {\n        observersLookup = this.getOrCreateObserversLookup(obj);\n      }\n\n      observersLookup[propertyName] = observer;\n    }\n\n    return observer;\n  }\n\n  public addAdapter(adapter: IObjectObservationAdapter): void {\n    this.adapters.push(adapter);\n  }\n\n  public getAccessor(obj: IObservable, propertyName: string): IBindingTargetAccessor {\n    if (DOM.isNodeInstance(obj)) {\n      const tagName = obj['tagName'];\n      // this check comes first for hot path optimization\n      if (propertyName === 'textContent') {\n        return new ElementPropertyAccessor(this.lifecycle, obj, propertyName);\n      }\n\n      // TODO: optimize and make pluggable\n      if (propertyName === 'class' || propertyName === 'style' || propertyName === 'css'\n        || propertyName === 'value' && (tagName === 'INPUT' || tagName === 'SELECT')\n        || propertyName === 'checked' && tagName === 'INPUT'\n        || propertyName === 'model' && tagName === 'INPUT'\n        || /^xlink:.+$/.exec(propertyName)) {\n        return this.getObserver(obj, propertyName);\n      }\n\n      if (/^\\w+:|^data-|^aria-/.test(propertyName)\n        || this.svgAnalyzer.isStandardSvgAttribute(obj, propertyName)\n        || tagName === 'IMG' && propertyName === 'src'\n        || tagName === 'A' && propertyName === 'href'\n      ) {\n        return new DataAttributeAccessor(this.lifecycle, obj as IElement, propertyName);\n      }\n      return new ElementPropertyAccessor(this.lifecycle, obj, propertyName);\n    }\n\n    return new PropertyAccessor(obj, propertyName);\n  }\n\n  public getArrayObserver(observedArray: IObservedArray): ICollectionObserver<CollectionKind.array> {\n    return getArrayObserver(this.lifecycle, observedArray);\n  }\n\n  public getMapObserver(observedMap: IObservedMap): ICollectionObserver<CollectionKind.map>  {\n    return getMapObserver(this.lifecycle, observedMap);\n  }\n\n  public getSetObserver(observedSet: IObservedSet): ICollectionObserver<CollectionKind.set>  {\n    return getSetObserver(this.lifecycle, observedSet);\n  }\n\n  private getOrCreateObserversLookup(obj: IObservable): Record<string, AccessorOrObserver | IBindingTargetObserver> {\n    return obj.$observers || this.createObserversLookup(obj);\n  }\n\n  private createObserversLookup(obj: IObservable): Record<string, IBindingTargetObserver> {\n    const value: Record<string, IBindingTargetObserver> = {};\n    if (!Reflect.defineProperty(obj, '$observers', {\n      enumerable: false,\n      configurable: false,\n      writable: false,\n      value: value\n    })) {\n      Reporter.write(0, obj);\n    }\n    return value;\n  }\n\n  private getAdapterObserver(obj: IObservable, propertyName: string, descriptor: PropertyDescriptor): IBindingTargetObserver | null {\n    for (let i = 0, ii = this.adapters.length; i < ii; i++) {\n      const adapter = this.adapters[i];\n      const observer = adapter.getObserver(obj, propertyName, descriptor);\n      if (observer) {\n        return observer;\n      }\n    }\n    return null;\n  }\n\n  // TODO: Reduce complexity (currently at 37)\n  private createPropertyObserver(obj: IObservable, propertyName: string): AccessorOrObserver {\n    if (!(obj instanceof Object)) {\n      return new PrimitiveObserver(obj, propertyName) as IBindingTargetAccessor;\n    }\n\n    let isNode: boolean;\n    if (DOM.isNodeInstance(obj)) {\n      if (propertyName === 'class') {\n        return new ClassAttributeAccessor(this.lifecycle, obj as IElement);\n      }\n\n      if (propertyName === 'style' || propertyName === 'css') {\n        return new StyleAttributeAccessor(this.lifecycle, obj as IHTMLElement);\n      }\n\n      const tagName = obj['tagName'];\n      const handler = this.eventManager.getElementHandler(obj, propertyName);\n      if (propertyName === 'value' && tagName === 'SELECT') {\n        return new SelectValueObserver(this.lifecycle, obj as ISelectElement, handler, this);\n      }\n\n      if (propertyName === 'checked' && tagName === 'INPUT') {\n        return new CheckedObserver(this.lifecycle, obj as IInputElement, handler, this);\n      }\n\n      if (handler) {\n        return new ValueAttributeObserver(this.lifecycle, obj, propertyName, handler);\n      }\n\n      const xlinkResult = /^xlink:(.+)$/.exec(propertyName);\n      if (xlinkResult) {\n        return new XLinkAttributeAccessor(this.lifecycle, obj as IHTMLElement, propertyName, xlinkResult[1]);\n      }\n\n      if (propertyName === 'role'\n        || /^\\w+:|^data-|^aria-/.test(propertyName)\n        || this.svgAnalyzer.isStandardSvgAttribute(obj, propertyName)) {\n        return new DataAttributeAccessor(this.lifecycle, obj as IElement, propertyName);\n      }\n      isNode = true;\n    }\n\n    const tag = toStringTag.call(obj);\n    switch (tag) {\n      case '[object Array]':\n        if (propertyName === 'length') {\n          return this.getArrayObserver(obj as IObservedArray).getLengthObserver();\n        }\n        return this.dirtyChecker.createProperty(obj, propertyName);\n      case '[object Map]':\n        if (propertyName === 'size') {\n          return this.getMapObserver(obj as IObservedMap).getLengthObserver();\n        }\n        return this.dirtyChecker.createProperty(obj, propertyName);\n      case '[object Set]':\n        if (propertyName === 'size') {\n          return this.getSetObserver(obj as IObservedSet).getLengthObserver();\n        }\n        return this.dirtyChecker.createProperty(obj, propertyName);\n    }\n\n    const descriptor = getPropertyDescriptor(obj, propertyName) as PropertyDescriptor & {\n      get: PropertyDescriptor['get'] & { getObserver(obj: IObservable): IBindingTargetObserver };\n    };\n\n    if (descriptor && (descriptor.get || descriptor.set)) {\n      if (descriptor.get && descriptor.get.getObserver) {\n        return descriptor.get.getObserver(obj);\n      }\n\n      // attempt to use an adapter before resorting to dirty checking.\n      const adapterObserver = this.getAdapterObserver(obj, propertyName, descriptor);\n      if (adapterObserver) {\n        return adapterObserver;\n      }\n      if (isNode) {\n        // TODO: use MutationObserver\n        return this.dirtyChecker.createProperty(obj, propertyName);\n      }\n\n      return createComputedObserver(this, this.dirtyChecker, this.lifecycle, obj, propertyName, descriptor);\n    }\n    return new SetterObserver(obj, propertyName);\n  }\n}\n\nexport function getCollectionObserver(lifecycle: ILifecycle, collection: IObservedMap | IObservedSet | IObservedArray): CollectionObserver {\n  switch (toStringTag.call(collection)) {\n    case '[object Array]':\n      return getArrayObserver(lifecycle, collection as IObservedArray);\n    case '[object Map]':\n      return getMapObserver(lifecycle, collection as IObservedMap);\n    case '[object Set]':\n      return getSetObserver(lifecycle, collection as IObservedSet);\n  }\n  return null;\n}\n","import { IRegistry } from '@aurelia/kernel';\nimport { Binding } from '../../binding/binding';\nimport { IElement } from '../../dom.interfaces';\nimport { ILifecycle } from '../../lifecycle';\nimport { IScope, LifecycleFlags } from '../../observation';\nimport { DataAttributeAccessor } from '../../observation/target-accessors';\nimport { bindingBehavior } from '../binding-behavior';\n\n@bindingBehavior('attr')\nexport class AttrBindingBehavior {\n  public static register: IRegistry['register'];\n\n  public bind(flags: LifecycleFlags, scope: IScope, binding: Binding): void {\n    binding.targetObserver = new DataAttributeAccessor(binding.locator.get(ILifecycle), binding.target as IElement, binding.targetProperty);\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: Binding): void {\n    return;\n  }\n}\n","import { IRegistry } from '@aurelia/kernel';\nimport { Binding } from '../../binding/binding';\nimport { BindingMode } from '../../binding/binding-mode';\nimport { IScope, LifecycleFlags } from '../../observation';\nimport { bindingBehavior } from '../binding-behavior';\n\nconst { oneTime, toView, fromView, twoWay } = BindingMode;\n\nexport type WithMode = { mode: BindingMode; originalMode?: BindingMode };\n\nexport abstract class BindingModeBehavior {\n  private mode: BindingMode;\n\n  constructor(mode: BindingMode) {\n    this.mode = mode;\n  }\n\n  public bind(flags: LifecycleFlags, scope: IScope, binding: Binding & WithMode): void {\n    binding.originalMode = binding.mode;\n    binding.mode = this.mode;\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: Binding & WithMode): void {\n    binding.mode = binding.originalMode;\n    binding.originalMode = null;\n  }\n}\n\n@bindingBehavior('oneTime')\nexport class OneTimeBindingBehavior extends BindingModeBehavior {\n  public static register: IRegistry['register'];\n\n  constructor() {\n    super(oneTime);\n  }\n}\n\n@bindingBehavior('toView')\nexport class ToViewBindingBehavior extends BindingModeBehavior {\n  public static register: IRegistry['register'];\n\n  constructor() {\n    super(toView);\n  }\n}\n\n@bindingBehavior('fromView')\nexport class FromViewBindingBehavior extends BindingModeBehavior {\n  public static register: IRegistry['register'];\n\n  constructor() {\n    super(fromView);\n  }\n}\n\n@bindingBehavior('twoWay')\nexport class TwoWayBindingBehavior extends BindingModeBehavior {\n  public static register: IRegistry['register'];\n\n  constructor() {\n    super(twoWay);\n  }\n}\n","import { IRegistry, IWindow } from '@aurelia/kernel';\nimport { Binding, IBinding } from '../../binding/binding';\nimport { BindingMode } from '../../binding/binding-mode';\nimport { IScope, LifecycleFlags } from '../../observation';\nimport { bindingBehavior } from '../binding-behavior';\n\n// defaults to nodejs setTimeout/clearTimeout type otherwise\ndeclare var setTimeout: IWindow['setTimeout'];\ndeclare var clearTimeout: IWindow['clearTimeout'];\n\nexport type DebounceableBinding = IBinding & {\n  debouncedMethod: ((newValue: unknown, oldValue: unknown, flags: LifecycleFlags) => void) & { originalName: string };\n  debounceState: {\n    callContextToDebounce: LifecycleFlags;\n    delay: number;\n    timeoutId: number;\n    oldValue: unknown;\n  };\n};\n\nconst unset = {};\n\n/** @internal */\nexport function debounceCallSource(this: DebounceableBinding, newValue: unknown, oldValue: unknown, flags: LifecycleFlags): void {\n  const state = this.debounceState;\n  clearTimeout(state.timeoutId);\n  state.timeoutId = setTimeout(() => { this.debouncedMethod(newValue, oldValue, flags); }, state.delay);\n}\n\n/** @internal */\nexport function debounceCall(this: DebounceableBinding, newValue: unknown, oldValue: unknown, flags: LifecycleFlags): void {\n  const state = this.debounceState;\n  clearTimeout(state.timeoutId);\n  if (!(flags & state.callContextToDebounce)) {\n    state.oldValue = unset;\n    this.debouncedMethod(newValue, oldValue, flags);\n    return;\n  }\n  if (state.oldValue === unset) {\n    state.oldValue = oldValue;\n  }\n  // To disambiguate between \"number\" and \"NodeJS.Timer\" we cast it to an unknown, so we can subsequently cast it to number.\n  const timeoutId: unknown = setTimeout(\n    () => {\n      const ov = state.oldValue;\n      state.oldValue = unset;\n      this.debouncedMethod(newValue, ov, flags);\n    },\n    state.delay\n  );\n  state.timeoutId = timeoutId as number;\n}\n\nconst fromView = BindingMode.fromView;\n\n@bindingBehavior('debounce')\nexport class DebounceBindingBehavior {\n  public static register: IRegistry['register'];\n\n  public bind(flags: LifecycleFlags, scope: IScope, binding: DebounceableBinding, delay: number = 200): void {\n    let methodToDebounce;\n    let callContextToDebounce;\n    let debouncer;\n\n    if (binding instanceof Binding) {\n      methodToDebounce = 'handleChange';\n      debouncer = debounceCall;\n      callContextToDebounce = binding.mode & fromView ? LifecycleFlags.updateSourceExpression : LifecycleFlags.updateTargetInstance;\n    } else {\n      methodToDebounce = 'callSource';\n      debouncer = debounceCallSource;\n      callContextToDebounce = LifecycleFlags.updateTargetInstance;\n    }\n\n    // stash the original method and it's name.\n    // note: a generic name like \"originalMethod\" is not used to avoid collisions\n    // with other binding behavior types.\n    binding.debouncedMethod = binding[methodToDebounce];\n    binding.debouncedMethod.originalName = methodToDebounce;\n\n    // replace the original method with the debouncing version.\n    binding[methodToDebounce] = debouncer;\n\n    // create the debounce state.\n    binding.debounceState = {\n      callContextToDebounce,\n      delay,\n      timeoutId: 0,\n      oldValue: unset\n    };\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: DebounceableBinding): void {\n    // restore the state of the binding.\n    const methodToRestore = binding.debouncedMethod.originalName;\n    binding[methodToRestore] = binding.debouncedMethod;\n    binding.debouncedMethod = null;\n    clearTimeout(binding.debounceState.timeoutId);\n    binding.debounceState = null;\n  }\n}\n","import { IRegistry, Reporter } from '@aurelia/kernel';\nimport { Listener } from '../../binding/listener';\nimport { IEvent, INode } from '../../dom.interfaces';\nimport { IScope, LifecycleFlags } from '../../observation';\nimport { findOriginalEventTarget } from '../../observation/event-manager';\nimport { bindingBehavior } from '../binding-behavior';\n\n/** @internal */\nexport function handleSelfEvent(this: SelfableBinding, event: IEvent): ReturnType<Listener['callSource']> {\n  const target = findOriginalEventTarget(event) as unknown as INode;\n\n  if (this.target !== target) {\n    return;\n  }\n\n  return this.selfEventCallSource(event);\n}\n\nexport type SelfableBinding = Listener & {\n  selfEventCallSource: Listener['callSource'];\n};\n\n@bindingBehavior('self')\nexport class SelfBindingBehavior {\n  public static register: IRegistry['register'];\n\n  public bind(flags: LifecycleFlags, scope: IScope, binding: SelfableBinding): void {\n    if (!binding.callSource || !binding.targetEvent) {\n      throw Reporter.error(8);\n    }\n\n    binding.selfEventCallSource = binding.callSource;\n    binding.callSource = handleSelfEvent;\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: SelfableBinding): void {\n    binding.callSource = binding.selfEventCallSource;\n    binding.selfEventCallSource = null;\n  }\n}\n","import { inject, IRegistry, Reporter } from '@aurelia/kernel';\nimport { Binding } from '../../binding/binding';\nimport { IScope, LifecycleFlags } from '../../observation';\nimport { ISignaler } from '../../observation/signaler';\nimport { bindingBehavior } from '../binding-behavior';\n\nexport type SignalableBinding = Binding & {\n  signal: string | string[];\n};\n\n@bindingBehavior('signal')\n@inject(ISignaler)\nexport class SignalBindingBehavior {\n  public static register: IRegistry['register'];\n\n  private signaler: ISignaler;\n\n  constructor(signaler: ISignaler) {\n    this.signaler = signaler;\n  }\n\n  public bind(flags: LifecycleFlags, scope: IScope, binding: SignalableBinding, ...args: string[]): void {\n    if (!binding.updateTarget) {\n      throw Reporter.error(11);\n    }\n\n    if (arguments.length === 4) {\n      const name = args[0];\n      this.signaler.addSignalListener(name, binding);\n      binding.signal = name;\n    } else if (arguments.length > 4) {\n      const names = Array.prototype.slice.call(arguments, 3);\n      let i = names.length;\n\n      while (i--) {\n        const name = names[i];\n        this.signaler.addSignalListener(name, binding);\n      }\n\n      binding.signal = names;\n    } else {\n      throw Reporter.error(12);\n    }\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: SignalableBinding): void {\n    const name = binding.signal;\n    binding.signal = null;\n\n    if (Array.isArray(name)) {\n      const names = name;\n      let i = names.length;\n\n      while (i--) {\n        this.signaler.removeSignalListener(names[i], binding);\n      }\n    } else {\n      this.signaler.removeSignalListener(name, binding);\n    }\n  }\n}\n","import { IRegistry, IWindow } from '@aurelia/kernel';\nimport { Binding, IBinding } from '../../binding/binding';\nimport { BindingMode } from '../../binding/binding-mode';\nimport { IScope, LifecycleFlags } from '../../observation';\nimport { bindingBehavior } from '../binding-behavior';\n\n// defaults to nodejs setTimeout/clearTimeout type otherwise\ndeclare var setTimeout: IWindow['setTimeout'];\ndeclare var clearTimeout: IWindow['clearTimeout'];\n\nexport type ThrottleableBinding = IBinding & {\n  throttledMethod: ((value: unknown) => unknown) & { originalName: string };\n  throttleState: {\n    delay: number;\n    timeoutId: number;\n    last: number;\n    newValue?: unknown;\n  };\n};\n\n/** @internal */\nexport function throttle(this: ThrottleableBinding, newValue: unknown): void {\n  const state = this.throttleState;\n  const elapsed = +new Date() - state.last;\n\n  if (elapsed >= state.delay) {\n    clearTimeout(state.timeoutId);\n    state.timeoutId = -1;\n    state.last = +new Date();\n    this.throttledMethod(newValue);\n    return;\n  }\n\n  state.newValue = newValue;\n\n  if (state.timeoutId === -1) {\n    // To disambiguate between \"number\" and \"NodeJS.Timer\" we cast it to an unknown, so we can subsequently cast it to number.\n    const timeoutId: unknown = setTimeout(\n      () => {\n        state.timeoutId = -1;\n        state.last = +new Date();\n        this.throttledMethod(state.newValue);\n      },\n      state.delay - elapsed\n    );\n    state.timeoutId = timeoutId as number;\n  }\n}\n\n@bindingBehavior('throttle')\nexport class ThrottleBindingBehavior {\n  public static register: IRegistry['register'];\n\n  public bind(flags: LifecycleFlags, scope: IScope, binding: ThrottleableBinding, delay: number = 200): void {\n    let methodToThrottle: string;\n\n    if (binding instanceof Binding) {\n      if (binding.mode === BindingMode.twoWay) {\n        methodToThrottle = 'updateSource';\n      } else {\n        methodToThrottle = 'updateTarget';\n      }\n    } else {\n      methodToThrottle = 'callSource';\n    }\n\n    // stash the original method and it's name.\n    // note: a generic name like \"originalMethod\" is not used to avoid collisions\n    // with other binding behavior types.\n    binding.throttledMethod = binding[methodToThrottle];\n    binding.throttledMethod.originalName = methodToThrottle;\n\n    // replace the original method with the throttling version.\n    binding[methodToThrottle] = throttle;\n\n    // create the throttle state.\n    binding.throttleState = {\n      delay: delay,\n      last: 0,\n      timeoutId: -1\n    };\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: ThrottleableBinding): void {\n    // restore the state of the binding.\n    const methodToRestore = binding.throttledMethod.originalName;\n    binding[methodToRestore] = binding.throttledMethod;\n    binding.throttledMethod = null;\n    clearTimeout(binding.throttleState.timeoutId);\n    binding.throttleState = null;\n  }\n}\n","import { inject, IRegistry, Reporter } from '@aurelia/kernel';\nimport { Binding } from '../../binding/binding';\nimport { BindingMode } from '../../binding/binding-mode';\nimport { IScope, LifecycleFlags } from '../../observation';\nimport { CheckedObserver, SelectValueObserver, ValueAttributeObserver } from '../../observation/element-observation';\nimport { EventSubscriber, IEventSubscriber } from '../../observation/event-manager';\nimport { IObserverLocator } from '../../observation/observer-locator';\nimport { bindingBehavior } from '../binding-behavior';\n\nexport type UpdateTriggerableObserver = ((ValueAttributeObserver & Required<ValueAttributeObserver>) | (CheckedObserver & Required<CheckedObserver>) | (SelectValueObserver & Required<SelectValueObserver>)) & {\n  originalHandler?: IEventSubscriber;\n};\n\nexport type UpdateTriggerableBinding = Binding & {\n  targetObserver: UpdateTriggerableObserver;\n};\n\n@bindingBehavior('updateTrigger')\n@inject(IObserverLocator)\nexport class UpdateTriggerBindingBehavior {\n  public static register: IRegistry['register'];\n\n  private observerLocator: IObserverLocator;\n\n  constructor(observerLocator: IObserverLocator) {\n    this.observerLocator = observerLocator;\n  }\n\n  public bind(flags: LifecycleFlags, scope: IScope, binding: UpdateTriggerableBinding, ...events: string[]): void {\n    if (events.length === 0) {\n      throw Reporter.error(9);\n    }\n\n    if (binding.mode !== BindingMode.twoWay && binding.mode !== BindingMode.fromView) {\n      throw Reporter.error(10);\n    }\n\n    // ensure the binding's target observer has been set.\n    const targetObserver = this.observerLocator.getObserver(binding.target, binding.targetProperty) as UpdateTriggerableObserver;\n    if (!targetObserver.handler) {\n      throw Reporter.error(10);\n    }\n\n    binding.targetObserver = targetObserver;\n\n    // stash the original element subscribe function.\n    targetObserver.originalHandler = binding.targetObserver.handler;\n\n    // replace the element subscribe function with one that uses the correct events.\n    targetObserver.handler = new EventSubscriber(events);\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: UpdateTriggerableBinding): void {\n    // restore the state of the binding.\n    binding.targetObserver.handler.dispose();\n    binding.targetObserver.handler = binding.targetObserver.originalHandler;\n    binding.targetObserver.originalHandler = null;\n  }\n}\n","import {\n  DI,\n  Immutable,\n  IRegistry,\n  IResourceDefinition,\n  Omit,\n  PLATFORM,\n  ResourceDescription,\n  ResourcePartDescription\n} from '@aurelia/kernel';\nimport { ForOfStatement, Interpolation, IsBindingBehavior } from './binding/ast';\nimport { BindingMode } from './binding/binding-mode';\nimport { IShadowRootInit } from './dom.interfaces';\nimport { DelegationStrategy } from './observation/event-manager';\nimport { CustomElementConstructor, ICustomElement } from './resources/custom-element';\nimport { ICustomElementHost } from './templating/lifecycle-render';\n\n/** @internal */\nexport const customElementName = 'custom-element';\n/** @internal */\nexport function customElementKey(name: string): string {\n  return `${customElementName}:${name}`;\n}\n/** @internal */\nexport function customElementBehavior(node: ICustomElementHost): ICustomElement | null {\n  return node.$customElement === undefined ? null : node.$customElement;\n}\n\n/** @internal */\nexport const customAttributeName = 'custom-attribute';\n/** @internal */\nexport function customAttributeKey(name: string): string {\n  return `${customAttributeName}:${name}`;\n}\n\nexport type BindableSource = Omit<IBindableDescription, 'property'>;\n\nexport interface IBindableDescription {\n  mode?: BindingMode;\n  callback?: string;\n  attribute?: string;\n  property?: string;\n}\n\nexport const enum TargetedInstructionType {\n  textBinding = 'a',\n  interpolation = 'b',\n  propertyBinding = 'c',\n  iteratorBinding = 'd',\n  listenerBinding = 'e',\n  callBinding = 'f',\n  refBinding = 'g',\n  stylePropertyBinding = 'h',\n  setProperty = 'i',\n  setAttribute = 'j',\n  hydrateElement = 'k',\n  hydrateAttribute = 'l',\n  hydrateTemplateController = 'm',\n  hydrateLetElement = 'n',\n  letBinding = 'o'\n}\n\nconst instructionTypeValues = 'abcdefghijklmno';\n\nexport interface IBuildInstruction {\n  required: boolean;\n  compiler?: string;\n}\n\nexport interface ITemplateDefinition extends IResourceDefinition {\n  cache?: '*' | number;\n  template?: unknown;\n  instructions?: TargetedInstruction[][];\n  dependencies?: IRegistry[];\n  build?: IBuildInstruction;\n  surrogates?: TargetedInstruction[];\n  bindables?: Record<string, IBindableDescription>;\n  containerless?: boolean;\n  shadowOptions?: IShadowRootInit;\n  hasSlots?: boolean;\n}\n\nexport type TemplateDefinition = ResourceDescription<ITemplateDefinition>;\n\nexport type TemplatePartDefinitions = Record<string, ResourcePartDescription<ITemplateDefinition>>;\nexport type BindableDefinitions = Record<string, Immutable<IBindableDescription>>;\n\nexport interface IAttributeDefinition extends IResourceDefinition {\n  defaultBindingMode?: BindingMode;\n  aliases?: string[];\n  isTemplateController?: boolean;\n  hasDynamicOptions?: boolean;\n  bindables?: Record<string, IBindableDescription>;\n}\n\nexport type AttributeDefinition = Immutable<Required<IAttributeDefinition>> | null;\n\nexport const ITargetedInstruction = DI.createInterface<ITargetedInstruction>();\nexport interface ITargetedInstruction {\n  type: TargetedInstructionType;\n}\n\nexport type NodeInstruction =\n  ITextBindingInstruction |\n  IHydrateElementInstruction |\n  IHydrateTemplateController |\n  IHydrateLetElementInstruction;\n\nexport type AttributeInstruction =\n  IInterpolationInstruction |\n  IPropertyBindingInstruction |\n  IIteratorBindingInstruction |\n  IListenerBindingInstruction |\n  ICallBindingInstruction |\n  IRefBindingInstruction |\n  IStylePropertyBindingInstruction |\n  ISetPropertyInstruction |\n  ISetAttributeInstruction |\n  ILetBindingInstruction |\n  IHydrateAttributeInstruction;\n\nexport type TargetedInstruction = NodeInstruction | AttributeInstruction;\n\n// TODO: further improve specificity and integrate with the definitions;\nexport type InstructionRow = [TargetedInstruction, ...AttributeInstruction[]];\n\nexport function isTargetedInstruction(value: unknown): value is TargetedInstruction {\n  const type = (value as { type?: string }).type;\n  return typeof type === 'string' && instructionTypeValues.indexOf(type) !== -1;\n}\n\nexport interface ITextBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.textBinding;\n  from: string | Interpolation;\n}\n\nexport interface IInterpolationInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.interpolation;\n  from: string | Interpolation;\n  to: string;\n}\n\nexport interface IInterpolationInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.interpolation;\n  from: string | Interpolation;\n  to: string;\n}\n\nexport interface IPropertyBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.propertyBinding;\n  mode: BindingMode;\n  from: string | IsBindingBehavior;\n  to: string;\n  oneTime?: boolean;\n}\n\nexport interface IIteratorBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.iteratorBinding;\n  from: string | ForOfStatement;\n  to: string;\n}\n\nexport interface IListenerBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.listenerBinding;\n  from: string | IsBindingBehavior;\n  to: string;\n  strategy: DelegationStrategy;\n  preventDefault: boolean;\n}\n\nexport interface ICallBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.callBinding;\n  from: string | IsBindingBehavior;\n  to: string;\n}\n\nexport interface IRefBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.refBinding;\n  from: string | IsBindingBehavior;\n}\n\nexport interface IStylePropertyBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.stylePropertyBinding;\n  from: string | IsBindingBehavior;\n  to: string;\n}\n\nexport interface ISetPropertyInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.setProperty;\n  value: unknown;\n  to: string;\n}\n\nexport interface ISetAttributeInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.setAttribute;\n  value: string;\n  to: string;\n}\n\nexport interface IHydrateElementInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.hydrateElement;\n  res: string;\n  instructions: TargetedInstruction[];\n  parts?: Record<string, ITemplateDefinition>;\n}\n\nexport interface IHydrateAttributeInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.hydrateAttribute;\n  res: string;\n  instructions: TargetedInstruction[];\n}\n\nexport interface IHydrateTemplateController extends ITargetedInstruction {\n  type: TargetedInstructionType.hydrateTemplateController;\n  res: string;\n  instructions: TargetedInstruction[];\n  def: ITemplateDefinition;\n  link?: boolean;\n}\n\nexport interface IHydrateLetElementInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.hydrateLetElement;\n  instructions: ILetBindingInstruction[];\n  toViewModel: boolean;\n}\n\nexport interface ILetBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.letBinding;\n  from: string | IsBindingBehavior | Interpolation;\n  to: string;\n}\n\n/** @internal */\nexport const buildRequired: IBuildInstruction = Object.freeze({\n  required: true,\n  compiler: 'default'\n});\n\nconst buildNotRequired: IBuildInstruction = Object.freeze({\n  required: false,\n  compiler: 'default'\n});\n\n// Note: this is a little perf thing; having one predefined class with the properties always\n// assigned in the same order ensures the browser can keep reusing the same generated hidden\n// class\nclass DefaultTemplateDefinition implements Required<ITemplateDefinition> {\n  public name: ITemplateDefinition['name'];\n  public cache: ITemplateDefinition['cache'];\n  public template: ITemplateDefinition['template'];\n  public instructions: ITemplateDefinition['instructions'];\n  public dependencies: ITemplateDefinition['dependencies'];\n  public build: ITemplateDefinition['build'];\n  public surrogates: ITemplateDefinition['surrogates'];\n  public bindables: ITemplateDefinition['bindables'];\n  public containerless: ITemplateDefinition['containerless'];\n  public shadowOptions: ITemplateDefinition['shadowOptions'];\n  public hasSlots: ITemplateDefinition['hasSlots'];\n\n  constructor() {\n    this.name = 'unnamed';\n    this.template = null;\n    this.cache = 0;\n    this.build = buildNotRequired;\n    this.bindables = PLATFORM.emptyObject;\n    this.instructions = PLATFORM.emptyArray as this['instructions'];\n    this.dependencies = PLATFORM.emptyArray as this['dependencies'];\n    this.surrogates = PLATFORM.emptyArray as this['surrogates'];\n    this.containerless = false;\n    this.shadowOptions = null;\n    this.hasSlots = false;\n  }\n}\n\nconst templateDefinitionAssignables = [\n  'name',\n  'template',\n  'cache',\n  'build',\n  'containerless',\n  'shadowOptions',\n  'hasSlots'\n];\n\nconst templateDefinitionArrays = [\n  'instructions',\n  'dependencies',\n  'surrogates'\n];\n\nexport function buildTemplateDefinition(\n  ctor: CustomElementConstructor,\n  name: string): TemplateDefinition;\nexport function buildTemplateDefinition(\n  ctor: null,\n  def: Immutable<ITemplateDefinition>): TemplateDefinition;\nexport function buildTemplateDefinition(\n  ctor: CustomElementConstructor | null,\n  nameOrDef: string | Immutable<ITemplateDefinition>): TemplateDefinition;\n// tslint:disable-next-line:parameters-max-number\nexport function buildTemplateDefinition(\n  ctor: CustomElementConstructor | null,\n  name: string | null,\n  template: unknown,\n  cache?: number | '*' | null,\n  build?: IBuildInstruction | boolean | null,\n  bindables?: Record<string, IBindableDescription> | null,\n  instructions?: ReadonlyArray<ReadonlyArray<TargetedInstruction>> | null,\n  dependencies?: ReadonlyArray<unknown> | null,\n  surrogates?: ReadonlyArray<TargetedInstruction> | null,\n  containerless?: boolean | null,\n  shadowOptions?: { mode: 'open' | 'closed' } | null,\n  hasSlots?: boolean | null): TemplateDefinition;\n  // tslint:disable-next-line:parameters-max-number // TODO: Reduce complexity (currently at 64)\nexport function buildTemplateDefinition(\n  ctor: CustomElementConstructor | null,\n  nameOrDef: string | Immutable<ITemplateDefinition> | null,\n  template?: unknown | null,\n  cache?: number | '*' | null,\n  build?: IBuildInstruction | boolean | null,\n  bindables?: Record<string, IBindableDescription> | null,\n  instructions?: ReadonlyArray<ReadonlyArray<TargetedInstruction>> | null,\n  dependencies?: ReadonlyArray<IRegistry> | null,\n  surrogates?: ReadonlyArray<TargetedInstruction> | null,\n  containerless?: boolean | null,\n  shadowOptions?: { mode: 'open' | 'closed' } | null,\n  hasSlots?: boolean | null): TemplateDefinition {\n\n  const def = new DefaultTemplateDefinition();\n\n  // all cases fall through intentionally\n  const argLen = arguments.length;\n  switch (argLen) {\n    case 12: if (hasSlots !== null) def.hasSlots = hasSlots;\n    case 11: if (shadowOptions !== null) def.shadowOptions = shadowOptions;\n    case 10: if (containerless !== null) def.containerless = containerless;\n    case 9: if (surrogates !== null) def.surrogates = PLATFORM.toArray(surrogates);\n    case 8: if (dependencies !== null) def.dependencies = PLATFORM.toArray(dependencies);\n    case 7: if (instructions !== null) def.instructions = PLATFORM.toArray(instructions) as TargetedInstruction[][];\n    case 6: if (bindables !== null) def.bindables = { ...bindables };\n    case 5: if (build !== null) def.build = build === true ? buildRequired : build === false ? buildNotRequired : { ...build };\n    case 4: if (cache !== null) def.cache = cache;\n    case 3: if (template !== null) def.template = template;\n    case 2:\n      if (ctor !== null) {\n        if (ctor['bindables']) {\n          def.bindables = { ...ctor.bindables };\n        }\n        if (ctor['containerless']) {\n          def.containerless = ctor.containerless;\n        }\n        if (ctor['shadowOptions']) {\n          def.shadowOptions = ctor.shadowOptions;\n        }\n      }\n      if (typeof nameOrDef === 'string') {\n        if (nameOrDef.length > 0) {\n          def.name = nameOrDef;\n        }\n      } else if (nameOrDef !== null) {\n        templateDefinitionAssignables.forEach(prop => {\n          if (nameOrDef[prop]) {\n            def[prop] = nameOrDef[prop];\n          }\n        });\n        templateDefinitionArrays.forEach(prop => {\n          if (nameOrDef[prop]) {\n            def[prop] = PLATFORM.toArray(nameOrDef[prop]);\n          }\n        });\n        if (nameOrDef['bindables']) {\n          if (def.bindables === PLATFORM.emptyObject) {\n            def.bindables = { ...nameOrDef.bindables };\n          } else {\n            Object.assign(def.bindables, nameOrDef.bindables);\n          }\n        }\n      }\n  }\n\n  // special handling for invocations that quack like a @customElement decorator\n  if (argLen === 2 && ctor !== null && (typeof nameOrDef === 'string' || !('build' in nameOrDef))) {\n    def.build = buildRequired;\n  }\n\n  return def;\n}\n","import { Tracer, Writable } from '@aurelia/kernel';\nimport { INode } from '../dom.interfaces';\nimport { Hooks, IView, State } from '../lifecycle';\nimport { LifecycleFlags } from '../observation';\nimport { ICustomAttribute } from '../resources/custom-attribute';\nimport { ICustomElement } from '../resources/custom-element';\n\nconst slice = Array.prototype.slice;\n\n/** @internal */\n// tslint:disable-next-line:no-ignored-initial-value\nexport function $attachAttribute(this: Writable<ICustomAttribute>, flags: LifecycleFlags, encapsulationSource?: INode): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$attachAttribute`, slice.call(arguments)); }\n  if (this.$state & State.isAttached) {\n    if (Tracer.enabled) { Tracer.leave(); }\n    return;\n  }\n  const lifecycle = this.$lifecycle;\n  lifecycle.beginAttach();\n  // add isAttaching flag\n  this.$state |= State.isAttaching;\n  flags |= LifecycleFlags.fromAttach;\n\n  const hooks = this.$hooks;\n\n  if (hooks & Hooks.hasAttaching) {\n    this.attaching(flags, encapsulationSource);\n  }\n\n  // add isAttached flag, remove isAttaching flag\n  this.$state |= State.isAttached;\n  this.$state &= ~State.isAttaching;\n\n  if (hooks & Hooks.hasAttached) {\n    lifecycle.enqueueAttached(this as Required<typeof this>);\n  }\n  lifecycle.endAttach(flags);\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\n// tslint:disable-next-line:no-ignored-initial-value\nexport function $attachElement(this: Writable<ICustomElement>, flags: LifecycleFlags, encapsulationSource?: INode): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$attachElement`, slice.call(arguments)); }\n  if (this.$state & State.isAttached) {\n    if (Tracer.enabled) { Tracer.leave(); }\n    return;\n  }\n  const lifecycle = this.$lifecycle;\n  lifecycle.beginAttach();\n  // add isAttaching flag\n  this.$state |= State.isAttaching;\n  flags |= LifecycleFlags.fromAttach;\n\n  const hooks = this.$hooks;\n  encapsulationSource = this.$projector.provideEncapsulationSource(encapsulationSource === undefined ? this.$host : encapsulationSource);\n\n  if (hooks & Hooks.hasAttaching) {\n    this.attaching(flags, encapsulationSource);\n  }\n\n  let current = this.$attachableHead;\n  while (current !== null) {\n    current.$attach(flags, encapsulationSource);\n    current = current.$nextAttach;\n  }\n\n  lifecycle.enqueueMount(this);\n\n  // add isAttached flag, remove isAttaching flag\n  this.$state |= State.isAttached;\n  this.$state &= ~State.isAttaching;\n\n  if (hooks & Hooks.hasAttached) {\n    lifecycle.enqueueAttached(this as Required<typeof this>);\n  }\n  lifecycle.endAttach(flags);\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $attachView(this: Writable<IView>, flags: LifecycleFlags, encapsulationSource?: INode): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$attachView`, slice.call(arguments)); }\n  if (this.$state & State.isAttached) {\n    if (Tracer.enabled) { Tracer.leave(); }\n    return;\n  }\n  // add isAttaching flag\n  this.$state |= State.isAttaching;\n  flags |= LifecycleFlags.fromAttach;\n\n  let current = this.$attachableHead;\n  while (current !== null) {\n    current.$attach(flags, encapsulationSource);\n    current = current.$nextAttach;\n  }\n\n  this.$lifecycle.enqueueMount(this);\n\n  // add isAttached flag, remove isAttaching flag\n  this.$state |= State.isAttached;\n  this.$state &= ~State.isAttaching;\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\n// tslint:disable-next-line:no-ignored-initial-value\nexport function $detachAttribute(this: Writable<ICustomAttribute>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$detachAttribute`, slice.call(arguments)); }\n  if (this.$state & State.isAttached) {\n    const lifecycle = this.$lifecycle;\n    lifecycle.beginDetach();\n    // add isDetaching flag\n    this.$state |= State.isDetaching;\n    flags |= LifecycleFlags.fromDetach;\n\n    const hooks = this.$hooks;\n    if (hooks & Hooks.hasDetaching) {\n      this.detaching(flags);\n    }\n\n    // remove isAttached and isDetaching flags\n    this.$state &= ~(State.isAttached | State.isDetaching);\n\n    if (hooks & Hooks.hasDetached) {\n      lifecycle.enqueueDetached(this as Required<typeof this>);\n    }\n    lifecycle.endDetach(flags);\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\n// tslint:disable-next-line:no-ignored-initial-value\nexport function $detachElement(this: Writable<ICustomElement>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$detachElement`, slice.call(arguments)); }\n  if (this.$state & State.isAttached) {\n    const lifecycle = this.$lifecycle;\n    lifecycle.beginDetach();\n    // add isDetaching flag\n    this.$state |= State.isDetaching;\n    flags |= LifecycleFlags.fromDetach;\n\n    // Only unmount if either:\n    // - No parent view/element is queued for unmount yet, or\n    // - Aurelia is stopping (in which case all nodes need to return to their fragments for a clean mount on next start)\n    if (((flags & LifecycleFlags.parentUnmountQueued) ^ LifecycleFlags.parentUnmountQueued) | (flags & LifecycleFlags.fromStopTask)) {\n      lifecycle.enqueueUnmount(this);\n      flags |= LifecycleFlags.parentUnmountQueued;\n    }\n\n    const hooks = this.$hooks;\n    if (hooks & Hooks.hasDetaching) {\n      this.detaching(flags);\n    }\n\n    let current = this.$attachableTail;\n    while (current !== null) {\n      current.$detach(flags);\n      current = current.$prevAttach;\n    }\n\n    // remove isAttached and isDetaching flags\n    this.$state &= ~(State.isAttached | State.isDetaching);\n\n    if (hooks & Hooks.hasDetached) {\n      lifecycle.enqueueDetached(this as Required<typeof this>);\n    }\n    lifecycle.endDetach(flags);\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $detachView(this: Writable<IView>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$detachView`, slice.call(arguments)); }\n  if (this.$state & State.isAttached) {\n    // add isDetaching flag\n    this.$state |= State.isDetaching;\n    flags |= LifecycleFlags.fromDetach;\n\n    // Only unmount if either:\n    // - No parent view/element is queued for unmount yet, or\n    // - Aurelia is stopping (in which case all nodes need to return to their fragments for a clean mount on next start)\n    if (((flags & LifecycleFlags.parentUnmountQueued) ^ LifecycleFlags.parentUnmountQueued) | (flags & LifecycleFlags.fromStopTask)) {\n      this.$lifecycle.enqueueUnmount(this);\n      flags |= LifecycleFlags.parentUnmountQueued;\n    }\n\n    let current = this.$attachableTail;\n    while (current !== null) {\n      current.$detach(flags);\n      current = current.$prevAttach;\n    }\n\n    // remove isAttached and isDetaching flags\n    this.$state &= ~(State.isAttached | State.isDetaching);\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $cacheAttribute(this: Writable<ICustomAttribute>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$cacheAttribute`, slice.call(arguments)); }\n  flags |= LifecycleFlags.fromCache;\n  if (this.$hooks & Hooks.hasCaching) {\n    this.caching(flags);\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $cacheElement(this: Writable<ICustomElement>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$cacheElement`, slice.call(arguments)); }\n  flags |= LifecycleFlags.fromCache;\n  if (this.$hooks & Hooks.hasCaching) {\n    this.caching(flags);\n  }\n\n  let current = this.$attachableTail;\n  while (current !== null) {\n    current.$cache(flags);\n    current = current.$prevAttach;\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $cacheView(this: Writable<IView>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$cacheView`, slice.call(arguments)); }\n  flags |= LifecycleFlags.fromCache;\n  let current = this.$attachableTail;\n  while (current !== null) {\n    current.$cache(flags);\n    current = current.$prevAttach;\n  }\n}\n\n/** @internal */\nexport function $mountElement(this: Writable<ICustomElement>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$mountElement`, slice.call(arguments)); }\n  if (!(this.$state & State.isMounted)) {\n    this.$state |= State.isMounted;\n    this.$projector.project(this.$nodes);\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $unmountElement(this: Writable<ICustomElement>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$unmountElement`, slice.call(arguments)); }\n  if (this.$state & State.isMounted) {\n    this.$state &= ~State.isMounted;\n    this.$projector.take(this.$nodes);\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $mountView(this: Writable<IView>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$mountView`, slice.call(arguments)); }\n  if (!(this.$state & State.isMounted)) {\n    this.$state |= State.isMounted;\n    this.$nodes.insertBefore(this.location);\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $unmountView(this: Writable<IView>, flags: LifecycleFlags): boolean {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$unmountView`, slice.call(arguments)); }\n  if (this.$state & State.isMounted) {\n    this.$state &= ~State.isMounted;\n    this.$nodes.remove();\n\n    if (this.isFree) {\n      this.isFree = false;\n      if (this.cache.tryReturnToCache(this)) {\n        this.$state |= State.isCached;\n        if (Tracer.enabled) { Tracer.leave(); }\n        return true;\n      }\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return false;\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n  return false;\n}\n","import { Tracer, Writable } from '@aurelia/kernel';\nimport { Hooks, IView, State } from '../lifecycle';\nimport { IScope, LifecycleFlags } from '../observation';\nimport { ICustomAttribute } from '../resources/custom-attribute';\nimport { ICustomElement } from '../resources/custom-element';\n\nconst slice = Array.prototype.slice;\n\n/** @internal */\nexport function $bindAttribute(this: Writable<ICustomAttribute>, flags: LifecycleFlags, scope: IScope): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$bindAttribute`, slice.call(arguments)); }\n  flags |= LifecycleFlags.fromBind;\n\n  if (this.$state & State.isBound) {\n    if (this.$scope === scope) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n\n    this.$unbind(flags);\n  }\n  const lifecycle = this.$lifecycle;\n  lifecycle.beginBind();\n  // add isBinding flag\n  this.$state |= State.isBinding;\n\n  const hooks = this.$hooks;\n\n  if (hooks & Hooks.hasBound) {\n    lifecycle.enqueueBound(this);\n  }\n\n  this.$scope = scope;\n\n  if (hooks & Hooks.hasBinding) {\n    this.binding(flags);\n  }\n\n  // add isBound flag and remove isBinding flag\n  this.$state |= State.isBound;\n  this.$state &= ~State.isBinding;\n\n  lifecycle.endBind(flags);\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $bindElement(this: Writable<ICustomElement>, flags: LifecycleFlags, parentScope: IScope | null): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$bindElement`, slice.call(arguments)); }\n  if (this.$state & State.isBound) {\n    if (Tracer.enabled) { Tracer.leave(); }\n    return;\n  }\n  const scope = this.$scope;\n  (scope as Writable<IScope>).parentScope = parentScope;\n\n  const lifecycle = this.$lifecycle;\n  lifecycle.beginBind();\n  // add isBinding flag\n  this.$state |= State.isBinding;\n\n  const hooks = this.$hooks;\n  flags |= LifecycleFlags.fromBind;\n\n  if (hooks & Hooks.hasBound) {\n    lifecycle.enqueueBound(this);\n  }\n\n  if (hooks & Hooks.hasBinding) {\n    this.binding(flags);\n  }\n\n  let current = this.$bindableHead;\n  while (current !== null) {\n    current.$bind(flags, scope);\n    current = current.$nextBind;\n  }\n\n  // add isBound flag and remove isBinding flag\n  this.$state |= State.isBound;\n  this.$state &= ~State.isBinding;\n\n  lifecycle.endBind(flags);\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $bindView(this: Writable<IView>, flags: LifecycleFlags, scope: IScope): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$bindView`, slice.call(arguments)); }\n  flags |= LifecycleFlags.fromBind;\n\n  if (this.$state & State.isBound) {\n    if (this.$scope === scope) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n\n    this.$unbind(flags);\n  }\n  // add isBinding flag\n  this.$state |= State.isBinding;\n\n  this.$scope = scope;\n  let current = this.$bindableHead;\n  while (current !== null) {\n    current.$bind(flags, scope);\n    current = current.$nextBind;\n  }\n\n  // add isBound flag and remove isBinding flag\n  this.$state |= State.isBound;\n  this.$state &= ~State.isBinding;\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $unbindAttribute(this: Writable<ICustomAttribute>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$unbindAttribute`, slice.call(arguments)); }\n  if (this.$state & State.isBound) {\n    const lifecycle = this.$lifecycle;\n    lifecycle.beginUnbind();\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    const hooks = this.$hooks;\n    flags |= LifecycleFlags.fromUnbind;\n\n    if (hooks & Hooks.hasUnbound) {\n      lifecycle.enqueueUnbound(this);\n    }\n\n    if (hooks & Hooks.hasUnbinding) {\n      this.unbinding(flags);\n    }\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n\n    lifecycle.endUnbind(flags);\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $unbindElement(this: Writable<ICustomElement>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$unbindElement`, slice.call(arguments)); }\n  if (this.$state & State.isBound) {\n    const lifecycle = this.$lifecycle;\n    lifecycle.beginUnbind();\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    const hooks = this.$hooks;\n    flags |= LifecycleFlags.fromUnbind;\n\n    if (hooks & Hooks.hasUnbound) {\n      lifecycle.enqueueUnbound(this);\n    }\n\n    if (hooks & Hooks.hasUnbinding) {\n      this.unbinding(flags);\n    }\n\n    let current = this.$bindableTail;\n    while (current !== null) {\n      current.$unbind(flags);\n      current = current.$prevBind;\n    }\n\n    (this.$scope as Writable<IScope>).parentScope = null;\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n\n    lifecycle.endUnbind(flags);\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $unbindView(this: Writable<IView>, flags: LifecycleFlags): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$unbindView`, slice.call(arguments)); }\n  if (this.$state & State.isBound) {\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    flags |= LifecycleFlags.fromUnbind;\n\n    let current = this.$bindableTail;\n    while (current !== null) {\n      current.$unbind(flags);\n      current = current.$prevBind;\n    }\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n    this.$scope = null;\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n","import { Reporter, Tracer } from '@aurelia/kernel';\nimport { INodeSequence, IRenderLocation } from '../dom.interfaces';\nimport {\n  IAttach,\n  IBindScope,\n  ILifecycle,\n  ILifecycleUnbind,\n  IMountable,\n  IRenderContext,\n  IView,\n  IViewCache,\n  IViewFactory,\n  State\n} from '../lifecycle';\nimport { IScope, LifecycleFlags } from '../observation';\nimport { $attachView, $cacheView, $detachView, $mountView, $unmountView } from './lifecycle-attach';\nimport { $bindView, $unbindView } from './lifecycle-bind';\nimport { ITemplate } from './lifecycle-render';\n\nconst slice = Array.prototype.slice;\n\n/** @internal */\nexport interface View extends IView {}\n\n/** @internal */\nexport class View implements IView {\n  public $bindableHead: IBindScope;\n  public $bindableTail: IBindScope;\n\n  public $nextBind: IBindScope;\n  public $prevBind: IBindScope;\n\n  public $attachableHead: IAttach;\n  public $attachableTail: IAttach;\n\n  public $nextAttach: IAttach;\n  public $prevAttach: IAttach;\n\n  public $nextMount: IMountable;\n  public $nextUnmount: IMountable;\n\n  public $nextUnbindAfterDetach: ILifecycleUnbind;\n\n  public $state: State;\n  public $scope: IScope;\n  public $nodes: INodeSequence;\n  public $context: IRenderContext;\n  public cache: IViewCache;\n  public location: IRenderLocation;\n  public isFree: boolean;\n\n  public readonly $lifecycle: ILifecycle;\n\n  constructor($lifecycle: ILifecycle, cache: IViewCache) {\n    this.$bindableHead = null;\n    this.$bindableTail = null;\n\n    this.$nextBind = null;\n    this.$prevBind = null;\n\n    this.$attachableHead = null;\n    this.$attachableTail = null;\n\n    this.$nextAttach = null;\n    this.$prevAttach = null;\n\n    this.$nextMount = null;\n    this.$nextUnmount = null;\n\n    this.$nextUnbindAfterDetach = null;\n\n    this.$state = State.none;\n    this.$scope = null;\n    this.isFree = false;\n\n    this.$lifecycle = $lifecycle;\n    this.cache = cache;\n  }\n\n  public hold(location: IRenderLocation, flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('View.hold', slice.call(arguments)); }\n    if (!location.parentNode) { // unmet invariant: location must be a child of some other node\n      throw Reporter.error(60); // TODO: organize error codes\n    }\n    this.location = location;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public lockScope(scope: IScope): void {\n    if (Tracer.enabled) { Tracer.enter('View.lockScope', slice.call(arguments)); }\n    this.$scope = scope;\n    this.$bind = lockedBind;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public release(flags: LifecycleFlags): boolean {\n    if (Tracer.enabled) { Tracer.enter('View.release', slice.call(arguments)); }\n    this.isFree = true;\n    if (this.$state & State.isAttached) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return this.cache.canReturnToCache(this);\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n    return !!this.$unmount(flags);\n  }\n}\n\n/** @internal */\nexport class ViewFactory implements IViewFactory {\n  public static maxCacheSize: number = 0xFFFF;\n\n  public isCaching: boolean;\n  public name: string;\n\n  private cache: View[];\n  private cacheSize: number;\n  private lifecycle: ILifecycle;\n  private template: ITemplate;\n\n  constructor(name: string, template: ITemplate, lifecycle: ILifecycle) {\n    this.isCaching = false;\n\n    this.cacheSize = -1;\n    this.cache = null;\n    this.lifecycle = lifecycle;\n    this.name = name;\n    this.template = template;\n  }\n\n  public setCacheSize(size: number | '*', doNotOverrideIfAlreadySet: boolean): void {\n    if (size) {\n      if (size === '*') {\n        size = ViewFactory.maxCacheSize;\n      } else if (typeof size === 'string') {\n        size = parseInt(size, 10);\n      }\n\n      if (this.cacheSize === -1 || !doNotOverrideIfAlreadySet) {\n        this.cacheSize = size;\n      }\n    }\n\n    if (this.cacheSize > 0) {\n      this.cache = [];\n    } else {\n      this.cache = null;\n    }\n\n    this.isCaching = this.cacheSize > 0;\n  }\n\n  public canReturnToCache(view: IView): boolean {\n    return this.cache !== null && this.cache.length < this.cacheSize;\n  }\n\n  public tryReturnToCache(view: View): boolean {\n    if (this.canReturnToCache(view)) {\n      view.$cache(LifecycleFlags.none);\n      this.cache.push(view);\n      return true;\n    }\n\n    return false;\n  }\n\n  public create(): IView {\n    const cache = this.cache;\n    let view: View;\n\n    if (cache !== null && cache.length > 0) {\n      view = cache.pop() as View;\n      view.$state &= ~State.isCached;\n      return view;\n    }\n\n    view = new View(this.lifecycle, this);\n    this.template.render(view);\n    if (!view.$nodes) {\n      throw Reporter.error(90);\n    }\n    return view;\n  }\n}\n\nfunction lockedBind(this: View, flags: LifecycleFlags): void {\n  if (this.$state & State.isBound) {\n    if (Tracer.enabled) { Tracer.leave(); }\n    return;\n  }\n\n  flags |= LifecycleFlags.fromBind;\n  const lockedScope = this.$scope;\n  let current = this.$bindableHead;\n  while (current !== null) {\n    current.$bind(flags, lockedScope);\n    current = current.$nextBind;\n  }\n\n  this.$state |= State.isBound;\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n((proto: IView): void => {\n  proto.$bind = $bindView;\n  proto.$unbind = $unbindView;\n  proto.$attach = $attachView;\n  proto.$detach = $detachView;\n  proto.$cache = $cacheView;\n  proto.$mount = $mountView;\n  proto.$unmount = $unmountView;\n})(View.prototype);\n","import {\n  all,\n  Class,\n  DI,\n  IContainer,\n  IDisposable,\n  IIndexable,\n  Immutable,\n  ImmutableArray,\n  inject,\n  IRegistry,\n  IResolver,\n  IResourceDescriptions,\n  PLATFORM,\n  Registration,\n  Reporter,\n  RuntimeCompilationResources,\n  Tracer,\n  Writable\n} from '@aurelia/kernel';\nimport {\n  BindableDefinitions,\n  buildTemplateDefinition,\n  customElementBehavior,\n  IHydrateElementInstruction,\n  ITargetedInstruction,\n  ITemplateDefinition,\n  TemplateDefinition,\n  TemplatePartDefinitions\n} from '../definitions';\nimport { DOM, INodeSequenceFactory, NodeSequence, NodeSequenceFactory } from '../dom';\nimport { IElement, INode, INodeSequence, IRenderLocation } from '../dom.interfaces';\nimport { Hooks, ILifecycle, IRenderable, IRenderContext, IViewFactory } from '../lifecycle';\nimport { IAccessor, IPropertySubscriber, ISubscribable, ISubscriberCollection, LifecycleFlags, MutationKind } from '../observation';\nimport { Scope } from '../observation/binding-context';\nimport { Observer } from '../observation/property-observation';\nimport { subscriberCollection } from '../observation/subscriber-collection';\nimport { ICustomAttribute, ICustomAttributeType } from '../resources/custom-attribute';\nimport { ICustomElement, ICustomElementType } from '../resources/custom-element';\nimport { ViewFactory } from './view';\n\nconst slice = Array.prototype.slice;\n\nexport interface ITemplateCompiler {\n  readonly name: string;\n  compile(definition: ITemplateDefinition, resources: IResourceDescriptions, viewCompileFlags?: ViewCompileFlags): TemplateDefinition;\n}\n\nexport const ITemplateCompiler = DI.createInterface<ITemplateCompiler>().noDefault();\n\nexport enum ViewCompileFlags {\n  none        = 0b0_001,\n  surrogate   = 0b0_010,\n  shadowDOM   = 0b0_100,\n}\n\nexport type IElementHydrationOptions = { parts?: Record<string, TemplateDefinition> };\n\nexport interface ICustomElementHost extends IRenderLocation {\n  $customElement?: ICustomElement;\n}\n\nexport interface IElementProjector {\n  readonly host: ICustomElementHost;\n  readonly children: ArrayLike<ICustomElementHost>;\n\n  provideEncapsulationSource(parentEncapsulationSource: ICustomElementHost): ICustomElementHost;\n  project(nodes: INodeSequence): void;\n  take(nodes: INodeSequence): void;\n\n  subscribeToChildrenChange(callback: () => void): void;\n}\n\nexport interface IElementTemplateProvider {\n  getElementTemplate(renderingEngine: IRenderingEngine, customElementType: ICustomElementType): ITemplate;\n}\n\nexport interface ILifecycleRender {\n  /**\n   * Only applies to `@customElement`. This hook is not invoked for `@customAttribute`s\n   *\n   * Called during `$hydrate`, after `this.$scope` and `this.$projector` are set.\n   *\n   * If this hook is implemented, it will be used instead of `renderingEngine.getElementTemplate`.\n   * This allows you to completely override the default rendering behavior.\n   *\n   * It is the responsibility of the implementer to:\n   * - Populate `this.$bindables` with any Bindings, child Views, custom elements and custom attributes\n   * - Populate `this.$attachables` with any child Views, custom elements and custom attributes\n   * - Populate `this.$nodes` with the nodes that need to be appended to the host\n   * - Populate `this.$context` with the RenderContext / Container scoped to this instance\n   *\n   * @param host The DOM node that declares this custom element\n   * @param parts Replaceable parts, if any\n   *\n   * @returns Either an implementation of `IElementTemplateProvider`, or void\n   *\n   * @description\n   * This is the first \"hydrate\" lifecycle hook. It happens only once per instance (contrary to bind/attach\n   * which can happen many times per instance), though it can happen many times per type (once for each instance)\n   */\n  render?(host: INode, parts: Record<string, TemplateDefinition>): IElementTemplateProvider | void;\n}\n\n/** @internal */\nexport function $hydrateAttribute(this: Writable<ICustomAttribute>, renderingEngine: IRenderingEngine): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$hydrateAttribute`, slice.call(arguments)); }\n  const Type = this.constructor as ICustomAttributeType;\n\n  renderingEngine.applyRuntimeBehavior(Type, this);\n\n  if (this.$hooks & Hooks.hasCreated) {\n    this.created();\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function $hydrateElement(this: Writable<ICustomElement>, renderingEngine: IRenderingEngine, host: INode, options: IElementHydrationOptions = PLATFORM.emptyObject): void {\n  if (Tracer.enabled) { Tracer.enter(`${this['constructor'].name}.$hydrateElement`, slice.call(arguments)); }\n  const Type = this.constructor as ICustomElementType;\n  const description = Type.description;\n\n  this.$scope = Scope.create(this, null);\n  this.$host = host;\n  this.$projector = determineProjector(this, host, description);\n\n  renderingEngine.applyRuntimeBehavior(Type, this);\n\n  if (this.$hooks & Hooks.hasRender) {\n    const result = this.render(host, options.parts);\n\n    if (result && 'getElementTemplate' in result) {\n      const template = result.getElementTemplate(renderingEngine, Type);\n      template.render(this, host, options.parts);\n    }\n  } else {\n    const template = renderingEngine.getElementTemplate(description, Type);\n    template.render(this, host, options.parts);\n  }\n\n  if (this.$hooks & Hooks.hasCreated) {\n    this.created();\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport const defaultShadowOptions = {\n  mode: 'open' as 'open' | 'closed'\n};\n\nfunction determineProjector(\n  $customElement: ICustomElement,\n  host: ICustomElementHost,\n  definition: TemplateDefinition\n): IElementProjector {\n  if (definition.shadowOptions || definition.hasSlots) {\n    if (definition.containerless) {\n      throw Reporter.error(21);\n    }\n\n    return new ShadowDOMProjector($customElement, host, definition);\n  }\n\n  if (definition.containerless) {\n    return new ContainerlessProjector($customElement, host);\n  }\n\n  return new HostProjector($customElement, host);\n}\n\nexport interface IRenderingEngine {\n  getElementTemplate(definition: TemplateDefinition, componentType?: ICustomElementType): ITemplate;\n  getViewFactory(source: Immutable<ITemplateDefinition>, parentContext?: IRenderContext): IViewFactory;\n\n  applyRuntimeBehavior(Type: ICustomAttributeType, instance: ICustomAttribute): void;\n  applyRuntimeBehavior(Type: ICustomElementType, instance: ICustomElement): void;\n}\n\nexport const IRenderingEngine = DI.createInterface<IRenderingEngine>()\n  .withDefault(x => x.singleton(RenderingEngine));\n\nconst defaultCompilerName = 'default';\n\n@inject(IContainer, ILifecycle, all(ITemplateCompiler))\n/** @internal */\nexport class RenderingEngine implements IRenderingEngine {\n  private behaviorLookup: Map<ICustomElementType | ICustomAttributeType, RuntimeBehavior>;\n  private compilers: Record<string, ITemplateCompiler>;\n  private container: IContainer;\n  private factoryLookup: Map<Immutable<ITemplateDefinition>, IViewFactory>;\n  private lifecycle: ILifecycle;\n  private templateLookup: Map<TemplateDefinition, ITemplate>;\n\n  constructor(container: IContainer, lifecycle: ILifecycle, templateCompilers: ITemplateCompiler[]) {\n    this.behaviorLookup = new Map();\n    this.container = container;\n    this.factoryLookup = new Map();\n    this.lifecycle = lifecycle;\n    this.templateLookup = new Map();\n\n    this.compilers = templateCompilers.reduce(\n      (acc, item) => {\n        acc[item.name] = item;\n        return acc;\n      },\n      Object.create(null)\n    );\n  }\n\n  public getElementTemplate(definition: TemplateDefinition, componentType?: ICustomElementType): ITemplate {\n    if (!definition) {\n      return null;\n    }\n\n    let found = this.templateLookup.get(definition);\n\n    if (!found) {\n      found = this.templateFromSource(definition);\n\n      //If the element has a view, support Recursive Components by adding self to own view template container.\n      if (found.renderContext !== null && componentType) {\n        componentType.register(found.renderContext as ExposedContext);\n      }\n\n      this.templateLookup.set(definition, found);\n    }\n\n    return found;\n  }\n\n  public getViewFactory(definition: Immutable<ITemplateDefinition>, parentContext?: IRenderContext): IViewFactory {\n    if (!definition) {\n      return null;\n    }\n\n    let factory = this.factoryLookup.get(definition);\n\n    if (!factory) {\n      const validSource = buildTemplateDefinition(null, definition);\n      const template = this.templateFromSource(validSource, parentContext);\n      factory = new ViewFactory(validSource.name, template, this.lifecycle);\n      factory.setCacheSize(validSource.cache, true);\n      this.factoryLookup.set(definition, factory);\n    }\n\n    return factory;\n  }\n\n  public applyRuntimeBehavior(Type: ICustomAttributeType | ICustomElementType, instance: ICustomAttribute | ICustomElement): void {\n    let found = this.behaviorLookup.get(Type);\n\n    if (!found) {\n      found = RuntimeBehavior.create(Type, instance);\n      this.behaviorLookup.set(Type, found);\n    }\n\n    found.applyTo(instance, this.lifecycle);\n  }\n\n  private templateFromSource(definition: TemplateDefinition, parentContext?: IRenderContext): ITemplate {\n    parentContext = parentContext || this.container as ExposedContext;\n\n    if (definition && definition.template) {\n      if (definition.build.required) {\n        const compilerName = definition.build.compiler || defaultCompilerName;\n        const compiler = this.compilers[compilerName];\n\n        if (!compiler) {\n          throw Reporter.error(20, compilerName);\n        }\n\n        definition = compiler.compile(definition as ITemplateDefinition, new RuntimeCompilationResources(parentContext as ExposedContext), ViewCompileFlags.surrogate);\n      }\n\n      return new CompiledTemplate(this, parentContext, definition);\n    }\n\n    return noViewTemplate;\n  }\n}\nconst childObserverOptions = { childList: true };\n\n/** @internal */\nexport class ShadowDOMProjector implements IElementProjector {\n  public host: ICustomElementHost;\n  public shadowRoot: ICustomElementHost;\n\n  constructor($customElement: ICustomElement, host: ICustomElementHost, definition: TemplateDefinition) {\n    this.host = host;\n\n    this.shadowRoot = DOM.attachShadow(this.host as IElement, definition.shadowOptions || defaultShadowOptions);\n    this.host.$customElement = $customElement;\n    this.shadowRoot.$customElement = $customElement;\n  }\n\n  get children(): ArrayLike<INode> {\n    return this.host.childNodes;\n  }\n\n  public subscribeToChildrenChange(callback: () => void): void {\n    DOM.createNodeObserver(this.host, callback, childObserverOptions);\n  }\n\n  public provideEncapsulationSource(parentEncapsulationSource: INode): INode {\n    return this.shadowRoot;\n  }\n\n  public project(nodes: INodeSequence): void {\n    if (Tracer.enabled) { Tracer.enter('ShadowDOMProjector.project', slice.call(arguments)); }\n    nodes.appendTo(this.host);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public take(nodes: INodeSequence): void {\n    if (Tracer.enabled) { Tracer.enter('ShadowDOMProjector.take', slice.call(arguments)); }\n    nodes.remove();\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n/** @internal */\nexport class ContainerlessProjector implements IElementProjector {\n  public host: ICustomElementHost;\n\n  private childNodes: ArrayLike<INode>;\n\n  constructor($customElement: ICustomElement, host: ICustomElementHost) {\n    if (host.childNodes.length) {\n      this.childNodes = PLATFORM.toArray(host.childNodes);\n    } else {\n      this.childNodes = PLATFORM.emptyArray;\n    }\n\n    this.host = DOM.convertToRenderLocation(host);\n    this.host.$customElement = $customElement;\n  }\n\n  get children(): ArrayLike<INode> {\n    return this.childNodes;\n  }\n\n  public subscribeToChildrenChange(callback: () => void): void {\n    // Do nothing since this scenario will never have children.\n  }\n\n  public provideEncapsulationSource(parentEncapsulationSource: INode): INode {\n    if (!parentEncapsulationSource) {\n      throw Reporter.error(22);\n    }\n\n    return parentEncapsulationSource;\n  }\n\n  public project(nodes: INodeSequence): void {\n    if (Tracer.enabled) { Tracer.enter('ContainerlessProjector.project', slice.call(arguments)); }\n    nodes.insertBefore(this.host);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public take(nodes: INodeSequence): void {\n    if (Tracer.enabled) { Tracer.enter('ContainerlessProjector.take', slice.call(arguments)); }\n    nodes.remove();\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n/** @internal */\nexport class HostProjector implements IElementProjector {\n  public host: ICustomElementHost;\n\n  constructor($customElement: ICustomElement, host: ICustomElementHost) {\n    this.host = host;\n\n    this.host.$customElement = $customElement;\n  }\n\n  get children(): ArrayLike<INode> {\n    return PLATFORM.emptyArray;\n  }\n\n  public subscribeToChildrenChange(callback: () => void): void {\n    // Do nothing since this scenario will never have children.\n  }\n\n  public provideEncapsulationSource(parentEncapsulationSource: INode): INode {\n    return parentEncapsulationSource || this.host;\n  }\n\n  public project(nodes: INodeSequence): void {\n    if (Tracer.enabled) { Tracer.enter('HostProjector.project', slice.call(arguments)); }\n    nodes.appendTo(this.host);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public take(nodes: INodeSequence): void {\n    if (Tracer.enabled) { Tracer.enter('HostProjector.take', slice.call(arguments)); }\n    nodes.remove();\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n/** @internal */\nexport class RuntimeBehavior {\n  public bindables: BindableDefinitions;\n\n  private constructor() {}\n\n  public static create(Component: ICustomElementType | ICustomAttributeType, instance: ICustomAttribute | ICustomElement): RuntimeBehavior {\n    const behavior = new RuntimeBehavior();\n\n    behavior.bindables = Component.description.bindables;\n\n    return behavior;\n  }\n\n  public applyTo(instance: ICustomAttribute | ICustomElement, lifecycle: ILifecycle): void {\n    instance.$lifecycle = lifecycle;\n    if ('$projector' in instance) {\n      this.applyToElement(lifecycle, instance);\n    } else {\n      this.applyToCore(instance);\n    }\n  }\n\n  private applyToElement(lifecycle: ILifecycle, instance: ICustomElement): void {\n    const observers = this.applyToCore(instance);\n\n    observers.$children = new ChildrenObserver(lifecycle, instance);\n\n    Reflect.defineProperty(instance, '$children', {\n      enumerable: false,\n      get: function(): unknown {\n        return this['$observers'].$children.getValue();\n      }\n    });\n  }\n\n  private applyToCore(instance: ICustomAttribute | ICustomElement): IIndexable {\n    const observers = {};\n    const bindables = this.bindables;\n    const observableNames = Object.getOwnPropertyNames(bindables);\n\n    for (let i = 0, ii = observableNames.length; i < ii; ++i) {\n      const name = observableNames[i];\n\n      observers[name] = new Observer(\n        instance,\n        name,\n        bindables[name].callback\n      );\n\n      createGetterSetter(instance, name);\n    }\n\n    Reflect.defineProperty(instance, '$observers', {\n      enumerable: false,\n      value: observers\n    });\n\n    return observers;\n  }\n}\n\nfunction createGetterSetter(instance: ICustomAttribute | ICustomElement, name: string): void {\n  Reflect.defineProperty(instance, name, {\n    enumerable: true,\n    get: function(): unknown { return this['$observers'][name].getValue(); },\n    set: function(value: unknown): void { this['$observers'][name].setValue(value, LifecycleFlags.updateTargetInstance); }\n  });\n}\n\nexport interface IChildrenObserver extends\n  IAccessor,\n  ISubscribable<MutationKind.instance>,\n  ISubscriberCollection<MutationKind.instance> { }\n\n/** @internal */\n@subscriberCollection(MutationKind.instance)\nexport class ChildrenObserver implements Partial<IChildrenObserver> {\n  public hasChanges: boolean;\n\n  private children: ICustomElement[];\n  private customElement: ICustomElement & { $childrenChanged?(): void };\n  private lifecycle: ILifecycle;\n  private observing: boolean;\n\n  constructor(lifecycle: ILifecycle, customElement: ICustomElement & { $childrenChanged?(): void }) {\n    this.hasChanges = false;\n\n    this.children = null;\n    this.customElement = customElement;\n    this.lifecycle = lifecycle;\n    this.observing = false;\n  }\n\n  public getValue(): ICustomElement[] {\n    if (!this.observing) {\n      this.observing = true;\n      this.customElement.$projector.subscribeToChildrenChange(() => { this.onChildrenChanged(); });\n      this.children = findElements(this.customElement.$projector.children);\n    }\n\n    return this.children;\n  }\n\n  public setValue(newValue: unknown): void { /* do nothing */ }\n\n  public flush(this: ChildrenObserver & IChildrenObserver, flags: LifecycleFlags): void {\n    this.callSubscribers(this.children, undefined, flags | LifecycleFlags.updateTargetInstance);\n    this.hasChanges = false;\n  }\n\n  public subscribe(this: ChildrenObserver & IChildrenObserver, subscriber: IPropertySubscriber): void {\n    this.addSubscriber(subscriber);\n  }\n\n  public unsubscribe(this: ChildrenObserver & IChildrenObserver, subscriber: IPropertySubscriber): void {\n    this.removeSubscriber(subscriber);\n  }\n\n  private onChildrenChanged(): void {\n    this.children = findElements(this.customElement.$projector.children);\n\n    if ('$childrenChanged' in this.customElement) {\n      this.customElement.$childrenChanged();\n    }\n\n    this.lifecycle.enqueueFlush(this).catch(error => { throw error; });\n    this.hasChanges = true;\n  }\n}\n\n/** @internal */\nexport function findElements(nodes: ArrayLike<INode>): ICustomElement[] {\n  const components: ICustomElement[] = [];\n\n  for (let i = 0, ii = nodes.length; i < ii; ++i) {\n    const current = nodes[i];\n    const component = customElementBehavior(current);\n\n    if (component !== null) {\n      components.push(component);\n    }\n  }\n\n  return components;\n}\n\n// The basic template abstraction that allows consumers to create\n// instances of an INodeSequence on-demand. Templates are contextual in that they are, in the very least,\n// part of a particular application, with application-level resources, but they also may have their\n// own scoped resources or be part of another view (via a template controller) which provides a\n// context for the template.\nexport interface ITemplate {\n  readonly renderContext: IRenderContext;\n  render(renderable: IRenderable, host?: INode, parts?: Immutable<Pick<IHydrateElementInstruction, 'parts'>>): void;\n}\n\n// This is the main implementation of ITemplate.\n// It is used to create instances of IView based on a compiled TemplateDefinition.\n// TemplateDefinitions are hand-coded today, but will ultimately be the output of the\n// TemplateCompiler either through a JIT or AOT process.\n// Essentially, CompiledTemplate wraps up the small bit of code that is needed to take a TemplateDefinition\n// and create instances of it on demand.\n/** @internal */\nexport class CompiledTemplate implements ITemplate {\n  public readonly factory: INodeSequenceFactory;\n  public readonly renderContext: IRenderContext;\n\n  private templateDefinition: TemplateDefinition;\n\n  constructor(renderingEngine: IRenderingEngine, parentRenderContext: IRenderContext, templateDefinition: TemplateDefinition) {\n    this.templateDefinition = templateDefinition;\n\n    this.factory = NodeSequenceFactory.createFor(this.templateDefinition.template);\n    this.renderContext = createRenderContext(renderingEngine, parentRenderContext, this.templateDefinition.dependencies);\n  }\n\n  public render(renderable: IRenderable, host?: INode, parts?: TemplatePartDefinitions): void {\n    const nodes = (renderable as Writable<IRenderable>).$nodes = this.factory.createNodeSequence();\n    (renderable as Writable<IRenderable>).$context = this.renderContext;\n    this.renderContext.render(renderable, nodes.findTargets(), this.templateDefinition, host, parts);\n  }\n}\n\n// This is an implementation of ITemplate that always returns a node sequence representing \"no DOM\" to render.\n/** @internal */\nexport const noViewTemplate: ITemplate = {\n  renderContext: null,\n  render(renderable: IRenderable): void {\n    (renderable as Writable<IRenderable>).$nodes = NodeSequence.empty;\n    (renderable as Writable<IRenderable>).$context = null;\n  }\n};\n\n/** @internal */\nexport type ExposedContext = IRenderContext & IDisposable & IContainer;\n\nexport function createRenderContext(renderingEngine: IRenderingEngine, parentRenderContext: IRenderContext, dependencies: ImmutableArray<IRegistry>): IRenderContext {\n  const context = parentRenderContext.createChild() as ExposedContext;\n  const renderableProvider = new InstanceProvider();\n  const elementProvider = new InstanceProvider();\n  const instructionProvider = new InstanceProvider<ITargetedInstruction>();\n  const factoryProvider = new ViewFactoryProvider(renderingEngine);\n  const renderLocationProvider = new InstanceProvider<IRenderLocation>();\n  const renderer = context.get(IRenderer);\n\n  DOM.registerElementResolver(context, elementProvider);\n\n  context.registerResolver(IViewFactory, factoryProvider);\n  context.registerResolver(IRenderable, renderableProvider);\n  context.registerResolver(ITargetedInstruction, instructionProvider);\n  context.registerResolver(IRenderLocation, renderLocationProvider);\n\n  if (dependencies) {\n    context.register(...dependencies);\n  }\n\n  context.render = function(this: IRenderContext, renderable: IRenderable, targets: ArrayLike<INode>, templateDefinition: TemplateDefinition, host?: INode, parts?: TemplatePartDefinitions): void {\n    renderer.render(this, renderable, targets, templateDefinition, host, parts);\n  };\n\n  context.beginComponentOperation = function(renderable: IRenderable, target: INode, instruction: ITargetedInstruction, factory?: IViewFactory, parts?: TemplatePartDefinitions, location?: IRenderLocation): IDisposable {\n    renderableProvider.prepare(renderable);\n    elementProvider.prepare(target);\n    instructionProvider.prepare(instruction);\n\n    if (factory) {\n      factoryProvider.prepare(factory, parts);\n    }\n\n    if (location) {\n      renderLocationProvider.prepare(location);\n    }\n\n    return context;\n  };\n\n  context.dispose = function(): void {\n    factoryProvider.dispose();\n    renderableProvider.dispose();\n    instructionProvider.dispose();\n    elementProvider.dispose();\n    renderLocationProvider.dispose();\n  };\n\n  return context;\n}\n\n/** @internal */\nexport class InstanceProvider<T> implements IResolver {\n  private instance: T | null;\n\n  constructor() {\n    this.instance = null;\n  }\n\n  public prepare(instance: T): void {\n    this.instance = instance;\n  }\n\n  public resolve(handler: IContainer, requestor: IContainer): T | null {\n    if (this.instance === undefined) { // unmet precondition: call prepare\n      throw Reporter.error(50); // TODO: organize error codes\n    }\n    return this.instance;\n  }\n\n  public dispose(): void {\n    this.instance = null;\n  }\n}\n\n/** @internal */\nexport class ViewFactoryProvider implements IResolver {\n  private factory: IViewFactory | null;\n  private renderingEngine: IRenderingEngine;\n  private replacements: TemplatePartDefinitions;\n\n  constructor(renderingEngine: IRenderingEngine) {\n    this.renderingEngine = renderingEngine;\n  }\n\n  public prepare(factory: IViewFactory, parts: TemplatePartDefinitions): void {\n    this.factory = factory;\n    this.replacements = parts || PLATFORM.emptyObject;\n  }\n\n  public resolve(handler: IContainer, requestor: ExposedContext): IViewFactory {\n    const factory = this.factory;\n    if (factory === undefined || factory === null) { // unmet precondition: call prepare\n      throw Reporter.error(50); // TODO: organize error codes\n    }\n    if (!factory.name || !factory.name.length) { // unmet invariant: factory must have a name\n      throw Reporter.error(51); // TODO: organize error codes\n    }\n    const found = this.replacements[factory.name];\n    if (found) {\n      return this.renderingEngine.getViewFactory(found, requestor);\n    }\n\n    return factory;\n  }\n\n  public dispose(): void {\n    this.factory = null;\n    this.replacements = PLATFORM.emptyObject;\n  }\n}\n\nexport interface IRenderer {\n  instructionRenderers: Record<string, IInstructionRenderer>;\n  render(context: IRenderContext, renderable: IRenderable, targets: ArrayLike<INode>, templateDefinition: TemplateDefinition, host?: INode, parts?: TemplatePartDefinitions): void;\n}\n\nexport const IRenderer = DI.createInterface<IRenderer>().withDefault(x => x.singleton(Renderer));\n\nexport interface IInstructionTypeClassifier<TType extends string = string> {\n  instructionType: TType;\n}\n\nexport interface IInstructionRenderer<TType extends string = string> extends Partial<IInstructionTypeClassifier<TType>> {\n  render(context: IRenderContext, renderable: IRenderable, target: unknown, instruction: ITargetedInstruction, ...rest: unknown[]): void;\n}\n\nexport const IInstructionRenderer = DI.createInterface<IInstructionRenderer>().noDefault();\n\ntype DecoratableInstructionRenderer<TType extends string, TProto, TClass> = Class<TProto & Partial<IInstructionTypeClassifier<TType> & Pick<IInstructionRenderer, 'render'>>, TClass> & Partial<IRegistry>;\ntype DecoratedInstructionRenderer<TType extends string, TProto, TClass> =  Class<TProto & IInstructionTypeClassifier<TType> & Pick<IInstructionRenderer, 'render'>, TClass> & IRegistry;\n\ntype InstructionRendererDecorator<TType extends string> = <TProto, TClass>(target: DecoratableInstructionRenderer<TType, TProto, TClass>) => DecoratedInstructionRenderer<TType, TProto, TClass>;\n\nexport function instructionRenderer<TType extends string>(instructionType: TType): InstructionRendererDecorator<TType> {\n  return function decorator<TProto, TClass>(target: DecoratableInstructionRenderer<TType, TProto, TClass>): DecoratedInstructionRenderer<TType, TProto, TClass> {\n    // wrap the constructor to set the instructionType to the instance (for better performance than when set on the prototype)\n    const decoratedTarget = function(...args: unknown[]): TProto {\n      const instance = new target(...args);\n      instance.instructionType = instructionType;\n      return instance;\n    } as unknown as DecoratedInstructionRenderer<TType, TProto, TClass>;\n    // make sure we register the decorated constructor with DI\n    decoratedTarget.register = function register(container: IContainer): IResolver {\n      return Registration.singleton(IInstructionRenderer, decoratedTarget).register(container, IInstructionRenderer);\n    };\n    // copy over any static properties such as inject (set by preceding decorators)\n    // also copy the name, to be less confusing to users (so they can still use constructor.name for whatever reason)\n    // the length (number of ctor arguments) is copied for the same reason\n    const ownProperties = Object.getOwnPropertyDescriptors(target);\n    Object.keys(ownProperties).filter(prop => prop !== 'prototype').forEach(prop => {\n      Reflect.defineProperty(decoratedTarget, prop, ownProperties[prop]);\n    });\n    return decoratedTarget;\n  };\n}\n\n/* @internal */\n@inject(all(IInstructionRenderer))\nexport class Renderer implements IRenderer {\n  public instructionRenderers: Record<string, IInstructionRenderer>;\n\n  constructor(instructionRenderers: IInstructionRenderer[]) {\n    const record = this.instructionRenderers = {};\n    instructionRenderers.forEach(item => {\n      record[item.instructionType] = item;\n    });\n  }\n\n  public render(context: IRenderContext, renderable: IRenderable, targets: ArrayLike<INode>, definition: TemplateDefinition, host?: INode, parts?: TemplatePartDefinitions): void {\n    if (Tracer.enabled) { Tracer.enter('Renderer.render', slice.call(arguments)); }\n    const targetInstructions = definition.instructions;\n    const instructionRenderers = this.instructionRenderers;\n\n    if (targets.length !== targetInstructions.length) {\n      if (targets.length > targetInstructions.length) {\n        throw Reporter.error(30);\n      } else {\n        throw Reporter.error(31);\n      }\n    }\n    for (let i = 0, ii = targets.length; i < ii; ++i) {\n      const instructions = targetInstructions[i];\n      const target = targets[i];\n\n      for (let j = 0, jj = instructions.length; j < jj; ++j) {\n        const current = instructions[j];\n        instructionRenderers[current.type].render(context, renderable, target, current, parts);\n      }\n    }\n\n    if (host) {\n      const surrogateInstructions = definition.surrogates;\n\n      for (let i = 0, ii = surrogateInstructions.length; i < ii; ++i) {\n        const current = surrogateInstructions[i];\n        instructionRenderers[current.type].render(context, renderable, host, current, parts);\n      }\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n","import {\n  Class,\n  Constructable,\n  IContainer,\n  Immutable,\n  IResourceKind,\n  IResourceType,\n  Omit,\n  PLATFORM,\n  Registration,\n  ResourceDescription,\n  Writable\n} from '@aurelia/kernel';\nimport { BindingMode } from '../binding/binding-mode';\nimport {\n  customAttributeKey,\n  customAttributeName,\n  IAttributeDefinition\n} from '../definitions';\nimport {\n  Hooks,\n  IAttach,\n  IBindScope,\n  ILifecycleHooks,\n  ILifecycleUnbindAfterDetach,\n  IRenderable\n} from '../lifecycle';\nimport { IChangeTracker } from '../observation';\nimport {\n  $attachAttribute,\n  $cacheAttribute,\n  $detachAttribute\n} from '../templating/lifecycle-attach';\nimport {\n  $bindAttribute,\n  $unbindAttribute\n} from '../templating/lifecycle-bind';\nimport {\n  $hydrateAttribute,\n  IRenderingEngine\n} from '../templating/lifecycle-render';\n\ntype CustomAttributeStaticProperties = Pick<Immutable<Required<IAttributeDefinition>>, 'bindables'>;\n\nexport type CustomAttributeConstructor = Constructable & CustomAttributeStaticProperties;\n\nexport interface ICustomAttributeType extends\n  IResourceType<IAttributeDefinition, ICustomAttribute>,\n  CustomAttributeStaticProperties { }\n\nexport interface ICustomAttribute extends\n  Partial<IChangeTracker>,\n  ILifecycleHooks,\n  IBindScope,\n  ILifecycleUnbindAfterDetach,\n  IAttach,\n  IRenderable {\n\n  $hydrate(renderingEngine: IRenderingEngine): void;\n}\n\nexport interface ICustomAttributeResource extends\n  IResourceKind<IAttributeDefinition, ICustomAttribute, Class<ICustomAttribute> & CustomAttributeStaticProperties> {\n}\n\n/** @internal */\nexport function registerAttribute(this: ICustomAttributeType, container: IContainer): void {\n  const description = this.description;\n  const resourceKey = this.kind.keyFrom(description.name);\n  const aliases = description.aliases;\n\n  container.register(Registration.transient(resourceKey, this));\n\n  for (let i = 0, ii = aliases.length; i < ii; ++i) {\n    const aliasKey = this.kind.keyFrom(aliases[i]);\n    container.register(Registration.alias(resourceKey, aliasKey));\n  }\n}\n\n/**\n * Decorator: Indicates that the decorated class is a custom attribute.\n */\nexport function customAttribute(name: string): CustomAttributeDecorator;\nexport function customAttribute(definition: IAttributeDefinition): CustomAttributeDecorator;\nexport function customAttribute(nameOrDefinition: string | IAttributeDefinition): CustomAttributeDecorator {\n  return target => CustomAttributeResource.define(nameOrDefinition, target);\n}\n\n/**\n * Decorator: Applied to custom attributes. Indicates that whatever element the\n * attribute is placed on should be converted into a template and that this\n * attribute controls the instantiation of the template.\n */\nexport function templateController(name: string): CustomAttributeDecorator;\nexport function templateController(definition: IAttributeDefinition): CustomAttributeDecorator;\nexport function templateController(nameOrDefinition: string | Omit<IAttributeDefinition, 'isTemplateController'>): CustomAttributeDecorator {\n  return target => CustomAttributeResource.define(\n    typeof nameOrDefinition === 'string'\n    ? { isTemplateController: true , name: nameOrDefinition }\n    : { isTemplateController: true, ...nameOrDefinition },\n    target);\n}\n\ntype HasDynamicOptions = Pick<IAttributeDefinition, 'hasDynamicOptions'>;\n\nfunction dynamicOptionsDecorator<T extends Constructable>(target: T & HasDynamicOptions): T & Required<HasDynamicOptions> {\n  target.hasDynamicOptions = true;\n  return target as T & Required<HasDynamicOptions>;\n}\n\n/**\n * Decorator: Indicates that the custom attributes has dynamic options.\n */\nexport function dynamicOptions(): typeof dynamicOptionsDecorator;\n/**\n * Decorator: Indicates that the custom attributes has dynamic options.\n */\nexport function dynamicOptions<T extends Constructable>(target: T & HasDynamicOptions): T & Required<HasDynamicOptions>;\nexport function dynamicOptions<T extends Constructable>(target?: T & HasDynamicOptions): T & Required<HasDynamicOptions> | typeof dynamicOptionsDecorator {\n  return target === undefined ? dynamicOptionsDecorator : dynamicOptionsDecorator<T>(target);\n}\n\nfunction isType<T>(this: ICustomAttributeResource, Type: T & Partial<ICustomAttributeType>): Type is T & ICustomAttributeType {\n  return Type.kind === this;\n}\n\nfunction define<T extends Constructable>(this: ICustomAttributeResource, name: string, ctor: T): T & ICustomAttributeType;\nfunction define<T extends Constructable>(this: ICustomAttributeResource, definition: IAttributeDefinition, ctor: T): T & ICustomAttributeType;\nfunction define<T extends Constructable>(this: ICustomAttributeResource, nameOrDefinition: string | IAttributeDefinition, ctor: T): T & ICustomAttributeType {\n  const Type = ctor as T & Writable<ICustomAttributeType>;\n  const description = createCustomAttributeDescription(typeof nameOrDefinition === 'string' ? { name: nameOrDefinition } : nameOrDefinition, Type as T & ICustomAttributeType);\n  const proto: Writable<ICustomAttribute> = Type.prototype;\n\n  Type.kind = CustomAttributeResource;\n  Type.description = description;\n  Type.register = registerAttribute;\n\n  proto.$hydrate = $hydrateAttribute;\n  proto.$bind = $bindAttribute;\n  proto.$attach = $attachAttribute;\n  proto.$detach = $detachAttribute;\n  proto.$unbind = $unbindAttribute;\n  proto.$cache = $cacheAttribute;\n\n  proto.$prevBind = null;\n  proto.$nextBind = null;\n  proto.$prevAttach = null;\n  proto.$nextAttach = null;\n\n  proto.$nextUnbindAfterDetach = null;\n\n  proto.$scope = null;\n  proto.$hooks = 0;\n  proto.$state = 0;\n\n  if ('flush' in proto) {\n    proto.$nextFlush = null;\n  }\n\n  if ('binding' in proto) proto.$hooks |= Hooks.hasBinding;\n  if ('bound' in proto) {\n    proto.$hooks |= Hooks.hasBound;\n    proto.$nextBound = null;\n  }\n\n  if ('unbinding' in proto) proto.$hooks |= Hooks.hasUnbinding;\n  if ('unbound' in proto) {\n    proto.$hooks |= Hooks.hasUnbound;\n    proto.$nextUnbound = null;\n  }\n\n  if ('created' in proto) proto.$hooks |= Hooks.hasCreated;\n  if ('attaching' in proto) proto.$hooks |= Hooks.hasAttaching;\n  if ('attached' in proto) {\n    proto.$hooks |= Hooks.hasAttached;\n    proto.$nextAttached = null;\n  }\n  if ('detaching' in proto) proto.$hooks |= Hooks.hasDetaching;\n  if ('caching' in proto) proto.$hooks |= Hooks.hasCaching;\n  if ('detached' in proto) {\n    proto.$hooks |= Hooks.hasDetached;\n    proto.$nextDetached = null;\n  }\n\n  return Type as ICustomAttributeType & T;\n}\n\nexport const CustomAttributeResource: ICustomAttributeResource = {\n  name: customAttributeName,\n  keyFrom: customAttributeKey,\n  isType,\n  define\n};\n\n/** @internal */\nexport function createCustomAttributeDescription(def: IAttributeDefinition, Type: ICustomAttributeType): ResourceDescription<IAttributeDefinition> {\n  const aliases = def. aliases;\n  const defaultBindingMode = def.defaultBindingMode;\n  return {\n    name: def.name,\n    aliases: aliases === undefined || aliases === null ? PLATFORM.emptyArray : aliases,\n    defaultBindingMode: defaultBindingMode === undefined || defaultBindingMode === null ? BindingMode.toView : defaultBindingMode,\n    hasDynamicOptions: def.hasDynamicOptions === undefined ? false : def.hasDynamicOptions,\n    isTemplateController: def.isTemplateController === undefined ? false : def.isTemplateController,\n    bindables: {...Type.bindables, ...def.bindables}\n  };\n}\n\nexport type CustomAttributeDecorator = <T extends Constructable>(target: T) => T & ICustomAttributeType;\n","import { Constructable, PLATFORM } from '@aurelia/kernel';\nimport { BindingMode } from '../binding/binding-mode';\nimport { BindableSource, IBindableDescription } from '../definitions';\n\ntype WithBindables = { bindables: Record<string, IBindableDescription> };\ntype BindableDecorator = <T extends InstanceType<Constructable & Partial<WithBindables>>>\n  (target: T, prop: string) => void;\n\n/**\n * Decorator: Specifies custom behavior for a bindable property.\n * @param config The overrides\n */\nexport function bindable(config?: BindableSource): BindableDecorator;\n/**\n * Decorator: Specifies a bindable property on a class.\n * @param prop The property name\n */\nexport function bindable(prop: string): ClassDecorator;\n/**\n * Decorator: Specifies a bindable property on a class.\n * @param target The class\n * @param prop The property name\n */\nexport function bindable<T extends InstanceType<Constructable & Partial<WithBindables>>>(target: T, prop: string): void;\nexport function bindable<T extends InstanceType<Constructable & Partial<WithBindables>>>(configOrTarget?: BindableSource | T, prop?: string): void | BindableDecorator | ClassDecorator {\n  let config: IBindableDescription;\n\n  const decorator = function decorate($target: T, $prop: string): void {\n    const Type = $target.constructor as Constructable & Partial<WithBindables>;\n    let bindables = Type.bindables;\n    if (bindables === undefined) {\n      bindables = Type.bindables = {};\n    }\n    if (!config.attribute) {\n      config.attribute = PLATFORM.kebabCase($prop);\n    }\n    if (!config.callback) {\n      config.callback = `${$prop}Changed`;\n    }\n    if (config.mode === undefined) {\n      config.mode = BindingMode.toView;\n    }\n    if (arguments.length > 1) {\n      // Non invocation:\n      // - @bindable\n      // Invocation with or w/o opts:\n      // - @bindable()\n      // - @bindable({...opts})\n      config.property = $prop;\n    }\n    bindables[config.property] = config;\n  };\n  if (arguments.length > 1) {\n    // Non invocation:\n    // - @bindable\n    config = {};\n    decorator(configOrTarget as T, prop);\n    return;\n  } else if (typeof configOrTarget === 'string') {\n    // ClassDecorator\n    // - @bindable('bar')\n    // Direct call:\n    // - @bindable('bar')(Foo)\n    config = {};\n    return decorator as BindableDecorator;\n  }\n\n  // Invocation with or w/o opts:\n  // - @bindable()\n  // - @bindable({...opts})\n  config = (configOrTarget || {}) as IBindableDescription;\n  return decorator as BindableDecorator;\n}\n","import { inject, IRegistry } from '@aurelia/kernel';\nimport { IRenderLocation } from '../../dom.interfaces';\nimport { CompositionCoordinator, IView, IViewFactory } from '../../lifecycle';\nimport { LifecycleFlags } from '../../observation';\nimport { bindable } from '../../templating/bindable';\nimport { ICustomAttribute, templateController } from '../custom-attribute';\n\nexport interface If extends ICustomAttribute {}\n@templateController('if')\n@inject(IViewFactory, IRenderLocation, CompositionCoordinator)\nexport class If {\n  public static register: IRegistry['register'];\n\n  @bindable public value: boolean;\n\n  public elseFactory: IViewFactory | null;\n  public elseView: IView | null;\n  public ifFactory: IViewFactory;\n  public ifView: IView | null;\n  public location: IRenderLocation;\n  public coordinator: CompositionCoordinator;\n\n  constructor(ifFactory: IViewFactory, location: IRenderLocation, coordinator: CompositionCoordinator) {\n    this.value = false;\n\n    this.coordinator = coordinator;\n    this.elseFactory = null;\n    this.elseView = null;\n    this.ifFactory = ifFactory;\n    this.ifView = null;\n    this.location = location;\n  }\n\n  public binding(flags: LifecycleFlags): void {\n    const view = this.updateView(flags);\n    this.coordinator.compose(view, flags);\n    this.coordinator.binding(flags, this.$scope);\n  }\n\n  public attaching(flags: LifecycleFlags): void {\n    this.coordinator.attaching(flags);\n  }\n\n  public detaching(flags: LifecycleFlags): void {\n    this.coordinator.detaching(flags);\n  }\n\n  public unbinding(flags: LifecycleFlags): void {\n    this.coordinator.unbinding(flags);\n  }\n\n  public caching(flags: LifecycleFlags): void {\n    if (this.ifView !== null && this.ifView.release(flags)) {\n      this.ifView = null;\n    }\n\n    if (this.elseView !== null && this.elseView.release(flags)) {\n      this.elseView = null;\n    }\n\n    this.coordinator.caching(flags);\n  }\n\n  public valueChanged(newValue: boolean, oldValue: boolean, flags: LifecycleFlags): void {\n    if (flags & LifecycleFlags.fromFlush) {\n      const view = this.updateView(flags);\n      this.coordinator.compose(view, flags);\n    } else {\n      this.$lifecycle.enqueueFlush(this).catch(error => { throw error; });\n    }\n  }\n\n  public flush(flags: LifecycleFlags): void {\n    const view = this.updateView(flags);\n    this.coordinator.compose(view, flags);\n  }\n\n  /** @internal */\n  public updateView(flags: LifecycleFlags): IView | null {\n    let view: IView | null;\n\n    if (this.value) {\n      view = this.ifView = this.ensureView(this.ifView, this.ifFactory, flags);\n    } else if (this.elseFactory !== null) {\n      view = this.elseView  = this.ensureView(this.elseView, this.elseFactory, flags);\n    } else {\n      view = null;\n    }\n\n    return view;\n  }\n\n  /** @internal */\n  public ensureView(view: IView | null, factory: IViewFactory, flags: LifecycleFlags): IView {\n    if (view === null) {\n      view = factory.create();\n    }\n\n    view.hold(this.location, flags);\n\n    return view;\n  }\n}\n\nexport interface Else extends ICustomAttribute {}\n\n@templateController('else')\n@inject(IViewFactory)\nexport class Else {\n  public static register: IRegistry['register'];\n\n  private factory: IViewFactory;\n\n  constructor(factory: IViewFactory) {\n    this.factory = factory;\n  }\n\n  public link(ifBehavior: If): void {\n    ifBehavior.elseFactory = this.factory;\n  }\n}\n","import { IIndexable, inject, IRegistry } from '@aurelia/kernel';\nimport { ForOfStatement } from '../../binding/ast';\nimport { Binding } from '../../binding/binding';\nimport { IRenderLocation } from '../../dom.interfaces';\nimport { IBindScope, IRenderable, IView, IViewFactory, State } from '../../lifecycle';\nimport { CollectionObserver, IBatchedCollectionSubscriber, IObservedArray, IScope, LifecycleFlags, ObservedCollection } from '../../observation';\nimport { BindingContext, Scope } from '../../observation/binding-context';\nimport { getCollectionObserver } from '../../observation/observer-locator';\nimport { SetterObserver } from '../../observation/property-observation';\nimport { bindable } from '../../templating/bindable';\nimport { ICustomAttribute, templateController } from '../custom-attribute';\n\nexport interface Repeat<T extends ObservedCollection> extends ICustomAttribute, IBatchedCollectionSubscriber {}\n\n@inject(IRenderLocation, IRenderable, IViewFactory)\n@templateController('repeat')\nexport class Repeat<T extends ObservedCollection = IObservedArray> {\n  public static register: IRegistry['register'];\n\n  @bindable public items: T;\n\n  public $scope: IScope;\n  public $observers: { items: SetterObserver };\n\n  public forOf: ForOfStatement;\n  public hasPendingInstanceMutation: boolean;\n  public local: string;\n  public location: IRenderLocation;\n  public observer: CollectionObserver | null;\n  public renderable: IRenderable;\n  public factory: IViewFactory;\n  public views: IView[];\n\n  constructor(location: IRenderLocation, renderable: IRenderable, factory: IViewFactory) {\n    this.factory = factory;\n    this.hasPendingInstanceMutation = false;\n    this.location = location;\n    this.observer = null;\n    this.renderable = renderable;\n    this.views = [];\n  }\n\n  public binding(flags: LifecycleFlags): void {\n    this.checkCollectionObserver();\n  }\n\n  public bound(flags: LifecycleFlags): void {\n    let current = this.renderable.$bindableHead;\n    while (current !== null) {\n      if ((current as Binding).target === this && (current as Binding).targetProperty === 'items') {\n        this.forOf = (current as Binding).sourceExpression as ForOfStatement;\n        break;\n      }\n      current = (current as IBindScope).$nextBind;\n    }\n    this.local = this.forOf.declaration.evaluate(flags, this.$scope, null) as string;\n\n    this.processViews(null, flags);\n  }\n\n  public attaching(flags: LifecycleFlags): void {\n    const { views, location } = this;\n    for (let i = 0, ii = views.length; i < ii; ++i) {\n      const view = views[i];\n      view.hold(location, flags);\n      view.$attach(flags);\n    }\n  }\n\n  public detaching(flags: LifecycleFlags): void {\n    const { views } = this;\n    for (let i = 0, ii = views.length; i < ii; ++i) {\n      const view = views[i];\n      view.$detach(flags);\n      view.release(flags);\n    }\n  }\n\n  public unbound(flags: LifecycleFlags): void {\n    this.checkCollectionObserver();\n\n    const { views } = this;\n    for (let i = 0, ii = views.length; i < ii; ++i) {\n      const view = views[i];\n      view.$unbind(flags);\n    }\n  }\n\n  // called by SetterObserver (sync)\n  public itemsChanged(newValue: T, oldValue: T, flags: LifecycleFlags): void {\n    this.checkCollectionObserver();\n    this.processViews(null, flags | LifecycleFlags.updateTargetInstance);\n  }\n\n  // called by a CollectionObserver (async)\n  public handleBatchedChange(indexMap: number[] | null): void {\n    this.processViews(indexMap, LifecycleFlags.fromFlush | LifecycleFlags.updateTargetInstance);\n  }\n\n  // if the indexMap === null, it is an instance mutation, otherwise it's an items mutation\n  // TODO: Reduce complexity (currently at 46)\n  private processViews(indexMap: number[] | null, flags: LifecycleFlags): void {\n    const { views, $lifecycle } = this;\n    if (this.$state & State.isBound) {\n      const { local, $scope, factory, forOf, items } = this;\n      const oldLength = views.length;\n      const newLength = forOf.count(items);\n      if (oldLength < newLength) {\n        views.length = newLength;\n        for (let i = oldLength; i < newLength; ++i) {\n          views[i] = factory.create();\n        }\n      } else if (newLength < oldLength) {\n        $lifecycle.beginDetach();\n        for (let i = newLength, view = views[i]; i < oldLength; view = views[++i]) {\n          view.release(flags);\n          view.$detach(flags);\n        }\n        $lifecycle.endDetach(flags);\n        $lifecycle.beginUnbind();\n        for (let i = newLength, view = views[i]; i < oldLength; view = views[++i]) {\n          view.$unbind(flags);\n        }\n        $lifecycle.endUnbind(flags);\n        views.length = newLength;\n        if (newLength === 0) {\n          return;\n        }\n      } else if (newLength === 0) {\n        return;\n      }\n\n      $lifecycle.beginBind();\n      if (indexMap === null) {\n        forOf.iterate(items, (arr, i, item: (string | number | boolean | ObservedCollection | IIndexable)) => {\n          const view = views[i];\n          if (!!view.$scope && view.$scope.bindingContext[local] === item) {\n            view.$bind(flags, Scope.fromParent($scope, view.$scope.bindingContext));\n          } else {\n            view.$bind(flags, Scope.fromParent($scope, BindingContext.create(local, item)));\n          }\n        });\n      } else {\n        forOf.iterate(items, (arr, i, item: (string | number | boolean | ObservedCollection | IIndexable)) => {\n          const view = views[i];\n          if (indexMap[i] === i && !!view.$scope) {\n            view.$bind(flags, Scope.fromParent($scope, view.$scope.bindingContext));\n          } else {\n            view.$bind(flags, Scope.fromParent($scope, BindingContext.create(local, item)));\n          }\n        });\n      }\n      $lifecycle.endBind(flags);\n    }\n\n    if (this.$state & State.isAttached) {\n      const { location } = this;\n      $lifecycle.beginAttach();\n      if (indexMap === null) {\n        for (let i = 0, ii = views.length; i < ii; ++i) {\n          const view = views[i];\n          view.hold(location, flags);\n          view.$attach(flags);\n        }\n      } else {\n        for (let i = 0, ii = views.length; i < ii; ++i) {\n          if (indexMap[i] !== i) {\n            const view = views[i];\n            view.hold(location, flags);\n            view.$attach(flags);\n          }\n        }\n      }\n      $lifecycle.endAttach(flags);\n    }\n  }\n\n  private checkCollectionObserver(): void {\n    const oldObserver = this.observer;\n    if (this.$state & (State.isBound | State.isBinding)) {\n      const newObserver = this.observer = getCollectionObserver(this.$lifecycle, this.items);\n      if (oldObserver !== newObserver && oldObserver) {\n        oldObserver.unsubscribeBatched(this);\n      }\n      if (newObserver) {\n        newObserver.subscribeBatched(this);\n      }\n    } else if (oldObserver) {\n      oldObserver.unsubscribeBatched(this);\n    }\n  }\n}\n","import { inject, IRegistry } from '@aurelia/kernel';\nimport { IRenderLocation } from '../../dom.interfaces';\nimport { IView, IViewFactory } from '../../lifecycle';\nimport { LifecycleFlags } from '../../observation';\nimport { ICustomAttribute, templateController } from '../custom-attribute';\n\nexport interface Replaceable extends ICustomAttribute {}\n@templateController('replaceable')\n@inject(IViewFactory, IRenderLocation)\nexport class Replaceable {\n  public static register: IRegistry['register'];\n\n  private currentView: IView;\n  private factory: IViewFactory;\n\n  constructor(factory: IViewFactory, location: IRenderLocation) {\n    this.factory = factory;\n\n    this.currentView = this.factory.create();\n    this.currentView.hold(location, LifecycleFlags.fromCreate);\n  }\n\n  public binding(flags: LifecycleFlags): void {\n    this.currentView.$bind(flags | LifecycleFlags.allowParentScopeTraversal, this.$scope);\n  }\n\n  public attaching(flags: LifecycleFlags): void {\n    this.currentView.$attach(flags);\n  }\n\n  public detaching(flags: LifecycleFlags): void {\n    this.currentView.$detach(flags);\n  }\n\n  public unbinding(flags: LifecycleFlags): void {\n    this.currentView.$unbind(flags);\n  }\n}\n","import { inject, IRegistry } from '@aurelia/kernel';\nimport { IRenderLocation } from '../../dom.interfaces';\nimport { IBindScope, IView, IViewFactory, State } from '../../lifecycle';\nimport { IBindingContext, LifecycleFlags } from '../../observation';\nimport { Scope } from '../../observation/binding-context';\nimport { bindable } from '../../templating/bindable';\nimport { ICustomAttribute, templateController } from '../custom-attribute';\n\nexport interface With extends ICustomAttribute {}\n@templateController('with')\n@inject(IViewFactory, IRenderLocation)\nexport class With {\n  public static register: IRegistry['register'];\n\n  // TODO: this type is incorrect (it can be any user-provided object), need to fix and double check Scope.\n  @bindable public value: IBindScope | IBindingContext;\n\n  private currentView: IView;\n  private factory: IViewFactory;\n\n  constructor(factory: IViewFactory, location: IRenderLocation) {\n    this.value = null;\n\n    this.factory = factory;\n    this.currentView = this.factory.create();\n    this.currentView.hold(location, LifecycleFlags.fromCreate);\n  }\n\n  public valueChanged(this: With): void {\n    if (this.$state & State.isBound) {\n      this.bindChild(LifecycleFlags.fromBindableHandler);\n    }\n  }\n\n  public binding(flags: LifecycleFlags): void {\n    this.bindChild(flags);\n  }\n\n  public attaching(flags: LifecycleFlags): void {\n    this.currentView.$attach(flags);\n  }\n\n  public detaching(flags: LifecycleFlags): void {\n    this.currentView.$detach(flags);\n  }\n\n  public unbinding(flags: LifecycleFlags): void {\n    this.currentView.$unbind(flags);\n  }\n\n  private bindChild(flags: LifecycleFlags): void {\n    const scope = Scope.fromParent(this.$scope, this.value);\n    this.currentView.$bind(flags, scope);\n  }\n}\n","import {\n  Class,\n  Constructable,\n  IContainer,\n  IResourceKind,\n  IResourceType,\n  Registration,\n  Reporter,\n  Writable\n} from '@aurelia/kernel';\nimport {\n  buildTemplateDefinition,\n  customElementBehavior,\n  customElementKey,\n  customElementName,\n  ITemplateDefinition,\n  TemplateDefinition\n} from '../definitions';\nimport { INode } from '../dom.interfaces';\nimport {\n  Hooks,\n  IAttach,\n  IBind,\n  ILifecycleHooks,\n  ILifecycleUnbindAfterDetach,\n  IMountable,\n  IRenderable\n} from '../lifecycle';\nimport { IChangeTracker } from '../observation';\nimport {\n  $attachElement,\n  $cacheElement,\n  $detachElement,\n  $mountElement,\n  $unmountElement\n} from '../templating/lifecycle-attach';\nimport {\n  $bindElement,\n  $unbindElement\n} from '../templating/lifecycle-bind';\nimport {\n  $hydrateElement,\n  defaultShadowOptions,\n  ICustomElementHost,\n  IElementHydrationOptions,\n  IElementProjector,\n  ILifecycleRender,\n  IRenderingEngine\n} from '../templating/lifecycle-render';\n\ntype CustomElementStaticProperties = Pick<TemplateDefinition, 'containerless' | 'shadowOptions' | 'bindables'>;\n\nexport type CustomElementConstructor = Constructable & CustomElementStaticProperties;\n\nexport interface ICustomElementType extends\n  IResourceType<ITemplateDefinition, ICustomElement>,\n  CustomElementStaticProperties {\n  description: TemplateDefinition;\n}\n\nexport interface ICustomElement extends\n  Partial<IChangeTracker>,\n  ILifecycleHooks,\n  ILifecycleRender,\n  IBind,\n  ILifecycleUnbindAfterDetach,\n  IAttach,\n  IMountable,\n  IRenderable {\n\n  readonly $projector: IElementProjector;\n  readonly $host: ICustomElementHost;\n  $hydrate(renderingEngine: IRenderingEngine, host: INode, options?: IElementHydrationOptions): void;\n}\n\nexport interface ICustomElementResource extends\n  IResourceKind<ITemplateDefinition, ICustomElement, Class<ICustomElement> & CustomElementStaticProperties> {\n  behaviorFor(node: INode): ICustomElement | null;\n}\n\ntype CustomElementDecorator = <T extends Constructable>(target: T) => T & ICustomElementType;\n\n/** @internal */\nexport function registerElement(this: ICustomElementType, container: IContainer): void {\n  const resourceKey = this.kind.keyFrom(this.description.name);\n  container.register(Registration.transient(resourceKey, this));\n}\n\n/**\n * Decorator: Indicates that the decorated class is a custom element.\n */\nexport function customElement(name: string): CustomElementDecorator;\nexport function customElement(definition: ITemplateDefinition): CustomElementDecorator;\nexport function customElement(nameOrDefinition: string | ITemplateDefinition): CustomElementDecorator {\n  return (target => CustomElementResource.define(nameOrDefinition, target)) as CustomElementDecorator;\n}\n\ntype HasShadowOptions = Pick<ITemplateDefinition, 'shadowOptions'>;\n\n/**\n * Decorator: Indicates that the custom element should render its view in ShadowDOM.\n */\nexport function useShadowDOM<T extends Constructable>(options?: HasShadowOptions['shadowOptions']): (target: T & HasShadowOptions) => T & Required<HasShadowOptions>;\n/**\n * Decorator: Indicates that the custom element should render its view in ShadowDOM.\n */\nexport function useShadowDOM<T extends Constructable>(target: T & HasShadowOptions): T & Required<HasShadowOptions>;\nexport function useShadowDOM<T extends Constructable>(targetOrOptions?: (T & HasShadowOptions) | HasShadowOptions['shadowOptions']): (T & Required<HasShadowOptions>) | ((target: T & HasShadowOptions) => (T & Required<HasShadowOptions>)) {\n  const options = typeof targetOrOptions === 'function' || !targetOrOptions\n    ? defaultShadowOptions\n    : targetOrOptions as HasShadowOptions['shadowOptions'];\n\n  function useShadowDOMDecorator(target: T & HasShadowOptions): T & Required<HasShadowOptions> {\n    target.shadowOptions = options;\n    return target as T & Required<HasShadowOptions>;\n  }\n\n  return typeof targetOrOptions === 'function' ? useShadowDOMDecorator(targetOrOptions) : useShadowDOMDecorator;\n}\n\ntype HasContainerless = Pick<ITemplateDefinition, 'containerless'>;\n\nfunction containerlessDecorator<T extends Constructable>(target: T & HasContainerless): T & Required<HasContainerless> {\n  target.containerless = true;\n  return target as T & Required<HasContainerless>;\n}\n\n/**\n * Decorator: Indicates that the custom element should be rendered without its element container.\n */\nexport function containerless(): typeof containerlessDecorator;\n/**\n * Decorator: Indicates that the custom element should be rendered without its element container.\n */\nexport function containerless<T extends Constructable>(target: T & HasContainerless): T & Required<HasContainerless>;\nexport function containerless<T extends Constructable>(target?: T & HasContainerless): T & Required<HasContainerless> | typeof containerlessDecorator {\n  return target === undefined ? containerlessDecorator : containerlessDecorator<T>(target);\n}\n\nfunction isType<T>(this: ICustomElementResource, Type: T & Partial<ICustomElementType>): Type is T & ICustomElementType {\n  return Type.kind === this;\n}\n\nfunction define<T extends Constructable>(this: ICustomElementResource, name: string, ctor: T | null): T & ICustomElementType;\nfunction define<T extends Constructable>(this: ICustomElementResource, definition: ITemplateDefinition, ctor: T | null): T & ICustomElementType;\nfunction define<T extends Constructable>(this: ICustomElementResource, nameOrDefinition: string | ITemplateDefinition, ctor: T | null = null): T & ICustomElementType {\n  if (!nameOrDefinition) {\n    throw Reporter.error(70);\n  }\n  const Type = (ctor === null ? class HTMLOnlyElement { /* HTML Only */ } : ctor) as T & Writable<ICustomElementType>;\n  const description = buildTemplateDefinition(Type as unknown as ICustomElementType, nameOrDefinition);\n  const proto: Writable<ICustomElement> = Type.prototype;\n\n  Type.kind = CustomElementResource;\n  Type.description = description;\n  Type.register = registerElement;\n\n  proto.$hydrate = $hydrateElement;\n  proto.$bind = $bindElement;\n  proto.$attach = $attachElement;\n  proto.$detach = $detachElement;\n  proto.$unbind = $unbindElement;\n  proto.$cache = $cacheElement;\n\n  proto.$prevBind = null;\n  proto.$nextBind = null;\n  proto.$prevAttach = null;\n  proto.$nextAttach = null;\n\n  proto.$nextUnbindAfterDetach = null;\n\n  proto.$scope = null;\n  proto.$hooks = 0;\n\n  proto.$bindableHead = null;\n  proto.$bindableTail = null;\n  proto.$attachableHead = null;\n  proto.$attachableTail = null;\n\n  proto.$mount = $mountElement;\n  proto.$unmount = $unmountElement;\n\n  proto.$nextMount = null;\n  proto.$nextUnmount = null;\n\n  proto.$projector = null;\n\n  if ('flush' in proto) {\n    proto.$nextFlush = null;\n  }\n\n  if ('binding' in proto) proto.$hooks |= Hooks.hasBinding;\n  if ('bound' in proto) {\n    proto.$hooks |= Hooks.hasBound;\n    proto.$nextBound = null;\n  }\n\n  if ('unbinding' in proto) proto.$hooks |= Hooks.hasUnbinding;\n  if ('unbound' in proto) {\n    proto.$hooks |= Hooks.hasUnbound;\n    proto.$nextUnbound = null;\n  }\n\n  if ('render' in proto) proto.$hooks |= Hooks.hasRender;\n  if ('created' in proto) proto.$hooks |= Hooks.hasCreated;\n  if ('attaching' in proto) proto.$hooks |= Hooks.hasAttaching;\n  if ('attached' in proto) {\n    proto.$hooks |= Hooks.hasAttached;\n    proto.$nextAttached = null;\n  }\n  if ('detaching' in proto) proto.$hooks |= Hooks.hasDetaching;\n  if ('caching' in proto) proto.$hooks |= Hooks.hasCaching;\n  if ('detached' in proto) {\n    proto.$hooks |= Hooks.hasDetached;\n    proto.$nextDetached = null;\n  }\n\n  return Type as ICustomElementType & T;\n}\n\nexport const CustomElementResource: ICustomElementResource = {\n  name: customElementName,\n  keyFrom: customElementKey,\n  isType,\n  behaviorFor: customElementBehavior as ICustomElementResource['behaviorFor'],\n  define\n};\n\n// tslint:enable:align\n\n// TODO\n// ## DefaultSlotProjector\n// An implementation of IElementProjector that can handle a subset of default\n// slot projection scenarios without needing real Shadow DOM.\n// ### Conditions\n// We can do a one-time, static composition of the content and view,\n// to emulate shadow DOM, if the following constraints are met:\n// * There must be exactly one slot and it must be a default slot.\n// * The default slot must not have any fallback content.\n// * The default slot must not have a custom element as its immediate parent or\n//   a slot attribute (re-projection).\n// ### Projection\n// The projector copies all content nodes to the slot's location.\n// The copy process should inject a comment node before and after the slotted\n// content, so that the bounds of the content can be clearly determined,\n// even if the slotted content has template controllers or string interpolation.\n// ### Encapsulation Source\n// Uses the same strategy as HostProjector.\n// ### Children\n// The projector adds a mutation observer to the parent node of the\n// slot comment. When direct children of that node change, the projector\n// will gather up all nodes between the start and end slot comments.\n","import { Constructable, IRegistry, Tracer } from '@aurelia/kernel';\nimport {\n  buildTemplateDefinition,\n  isTargetedInstruction,\n  TargetedInstruction,\n  TargetedInstructionType,\n  TemplateDefinition\n} from '../definitions';\nimport { DOM } from '../dom';\nimport { INode } from '../dom.interfaces';\nimport { IRenderContext, IView, IViewFactory } from '../lifecycle';\nimport { ICustomElementType } from '../resources/custom-element';\nimport { IRenderingEngine, ITemplate } from './lifecycle-render';\n\nconst slice = Array.prototype.slice;\n\nexport function createElement(tagOrType: string | Constructable, props?: Record<string, string | TargetedInstruction>, children?: ArrayLike<unknown>): RenderPlan {\n  if (typeof tagOrType === 'string') {\n    return createElementForTag(tagOrType, props, children);\n  } else {\n    return createElementForType(tagOrType as ICustomElementType, props, children);\n  }\n}\n\nexport class RenderPlan {\n  private readonly dependencies: ReadonlyArray<IRegistry>;\n  private readonly instructions: TargetedInstruction[][];\n  private readonly node: INode;\n\n  private lazyDefinition: TemplateDefinition;\n\n  constructor(node: INode, instructions: TargetedInstruction[][], dependencies: ReadonlyArray<IRegistry>) {\n    this.dependencies = dependencies;\n    this.instructions = instructions;\n    this.node = node;\n  }\n\n  public get definition(): TemplateDefinition {\n    return this.lazyDefinition || (this.lazyDefinition =\n      buildTemplateDefinition(null, null, this.node, null, typeof this.node === 'string', null, this.instructions, this.dependencies));\n  }\n\n  public getElementTemplate(engine: IRenderingEngine, Type?: ICustomElementType): ITemplate {\n    return engine.getElementTemplate(this.definition, Type);\n  }\n\n  public createView(engine: IRenderingEngine, parentContext?: IRenderContext): IView {\n    return this.getViewFactory(engine, parentContext).create();\n  }\n\n  public getViewFactory(engine: IRenderingEngine, parentContext?: IRenderContext): IViewFactory {\n    return engine.getViewFactory(this.definition, parentContext);\n  }\n\n  /** @internal */\n  public mergeInto(parent: INode, instructions: TargetedInstruction[][], dependencies: IRegistry[]): void {\n    DOM.appendChild(parent, this.node);\n    instructions.push(...this.instructions);\n    dependencies.push(...this.dependencies);\n  }\n}\n\nfunction createElementForTag(tagName: string, props?: Record<string, string | TargetedInstruction>, children?: ArrayLike<unknown>): RenderPlan {\n  if (Tracer.enabled) { Tracer.enter('createElementForTag', slice.call(arguments)); }\n  const instructions: TargetedInstruction[] = [];\n  const allInstructions: TargetedInstruction[][] = [];\n  const dependencies: IRegistry[] = [];\n  const element = DOM.createElement(tagName);\n  let hasInstructions = false;\n\n  if (props) {\n    Object.keys(props)\n      .forEach(to => {\n        const value = props[to];\n\n        if (isTargetedInstruction(value)) {\n          hasInstructions = true;\n          instructions.push(value);\n        } else {\n          DOM.setAttribute(element, to, value);\n        }\n      });\n  }\n\n  if (hasInstructions) {\n    DOM.setAttribute(element, 'class', 'au');\n    allInstructions.push(instructions);\n  }\n\n  if (children) {\n    addChildren(element, children, allInstructions, dependencies);\n  }\n\n  if (Tracer.enabled) { Tracer.leave(); }\n  return new RenderPlan(element, allInstructions, dependencies);\n}\n\nfunction createElementForType(Type: ICustomElementType, props?: object, children?: ArrayLike<unknown>): RenderPlan {\n  if (Tracer.enabled) { Tracer.enter('createElementForType', slice.call(arguments)); }\n  const tagName = Type.description.name;\n  const instructions: TargetedInstruction[] = [];\n  const allInstructions = [instructions];\n  const dependencies: IRegistry[] = [];\n  const childInstructions: TargetedInstruction[] = [];\n  const bindables = Type.description.bindables;\n  const element = DOM.createElement(tagName);\n\n  DOM.setAttribute(element, 'class', 'au');\n\n  if (!dependencies.includes(Type)) {\n    dependencies.push(Type);\n  }\n\n  instructions.push({\n    type: TargetedInstructionType.hydrateElement,\n    res: tagName,\n    instructions: childInstructions\n  });\n\n  if (props) {\n    Object.keys(props)\n      .forEach(to => {\n        const value: TargetedInstruction | string = props[to];\n\n        if (isTargetedInstruction(value)) {\n          childInstructions.push(value);\n        } else {\n          const bindable = bindables[to];\n\n          if (bindable) {\n            childInstructions.push({\n              type: TargetedInstructionType.setProperty,\n              to,\n              value\n            });\n          } else {\n            childInstructions.push({\n              type: TargetedInstructionType.setAttribute,\n              to,\n              value\n            });\n          }\n        }\n      });\n  }\n\n  if (children) {\n    addChildren(element, children, allInstructions, dependencies);\n  }\n\n  if (Tracer.enabled) { Tracer.leave(); }\n  return new RenderPlan(element, allInstructions, dependencies);\n}\n\nfunction addChildren(parent: INode, children: ArrayLike<unknown>, allInstructions: TargetedInstruction[][], dependencies: IRegistry[]): void {\n  for (let i = 0, ii = children.length; i < ii; ++i) {\n    const current = children[i];\n\n    switch (typeof current) {\n      case 'string':\n        DOM.appendChild(parent, DOM.createTextNode(current));\n        break;\n      case 'object':\n        if (DOM.isNodeInstance(current)) {\n          DOM.appendChild(parent, current);\n        } else if ('mergeInto' in (current as RenderPlan)) {\n          (current as RenderPlan).mergeInto(parent, allInstructions, dependencies);\n        }\n    }\n  }\n}\n","import { Constructable, Immutable, inject, IRegistry } from '@aurelia/kernel';\nimport {\n  IHydrateElementInstruction,\n  ITargetedInstruction,\n  ITemplateDefinition,\n  TargetedInstruction,\n  TemplateDefinition\n} from '../../definitions';\nimport { CompositionCoordinator, IRenderable, IView, IViewFactory } from '../../lifecycle';\nimport { LifecycleFlags } from '../../observation';\nimport { bindable } from '../../templating/bindable';\nimport { createElement, RenderPlan } from '../../templating/create-element';\nimport { IRenderingEngine } from '../../templating/lifecycle-render';\nimport { customElement, ICustomElement } from '../custom-element';\n\nconst composeSource: ITemplateDefinition = {\n  name: 'au-compose',\n  containerless: true\n};\n\nconst composeProps = ['subject', 'composing'];\n\ntype Subject = IViewFactory | IView | RenderPlan | Constructable | TemplateDefinition;\n\nexport interface Compose extends ICustomElement {}\n@customElement(composeSource)\n@inject(IRenderable, ITargetedInstruction, IRenderingEngine, CompositionCoordinator)\nexport class Compose {\n  public static register: IRegistry['register'];\n\n  @bindable public subject: Subject | Promise<Subject> | null;\n  @bindable public composing: boolean;\n\n  private coordinator: CompositionCoordinator;\n  private lastSubject: Subject | Promise<Subject> | null;\n  private properties: Record<string, TargetedInstruction>;\n  private renderable: IRenderable;\n  private renderingEngine: IRenderingEngine;\n\n  constructor(renderable: IRenderable, instruction: Immutable<IHydrateElementInstruction>, renderingEngine: IRenderingEngine, coordinator: CompositionCoordinator) {\n    this.subject = null;\n    this.composing = false;\n\n    this.coordinator = coordinator;\n    this.lastSubject = null;\n    this.renderable = renderable;\n    this.renderingEngine = renderingEngine;\n\n    this.coordinator.onSwapComplete = () => {\n      this.composing = false;\n    };\n\n    this.properties = instruction.instructions\n      .filter((x: ITargetedInstruction & {to?: string}) => !composeProps.includes(x.to as string))\n      .reduce(\n        (acc, item: ITargetedInstruction & {to?: string}) => {\n          if (item.to) {\n            acc[item.to] = item;\n          }\n\n          return acc;\n        },\n        {}\n      );\n  }\n\n  public binding(flags: LifecycleFlags): void {\n    this.startComposition(this.subject, null, flags);\n    this.coordinator.binding(flags, this.$scope);\n  }\n\n  public attaching(flags: LifecycleFlags): void {\n    this.coordinator.attaching(flags);\n  }\n\n  public detaching(flags: LifecycleFlags): void {\n    this.coordinator.detaching(flags);\n  }\n\n  public unbinding(flags: LifecycleFlags): void {\n    this.lastSubject = null;\n    this.coordinator.unbinding(flags);\n  }\n\n  public caching(flags: LifecycleFlags): void {\n    this.coordinator.caching(flags);\n  }\n\n  public subjectChanged(newValue: Subject | Promise<Subject>, previousValue: Subject | Promise<Subject>, flags: LifecycleFlags): void {\n    this.startComposition(newValue, previousValue, flags);\n  }\n\n  private startComposition(subject: Subject | Promise<Subject> | null, _previousSubject: Subject | Promise<Subject> | null, flags: LifecycleFlags): void {\n    if (this.lastSubject === subject) {\n      return;\n    }\n\n    this.lastSubject = subject;\n\n    if (subject instanceof Promise) {\n      subject = subject.then(x => this.resolveView(x, flags)) as Promise<IView> | null;\n    } else {\n      subject = this.resolveView(subject, flags);\n    }\n\n    this.composing = true;\n    this.coordinator.compose(subject as IView | Promise<IView>, flags);\n  }\n\n  private resolveView(subject: Subject | null, flags: LifecycleFlags): IView | null {\n    const view = this.provideViewFor(subject);\n\n    if (view) {\n      view.hold(this.$projector.host, flags);\n      view.lockScope(this.renderable.$scope);\n      return view;\n    }\n\n    return null;\n  }\n\n  private provideViewFor(subject: Subject | null): IView | null {\n    if (!subject) {\n      return null;\n    }\n\n    if ('lockScope' in subject) { // IView\n      return subject;\n    }\n\n    if ('createView' in subject) { // RenderPlan\n      return subject.createView(\n        this.renderingEngine,\n        this.renderable.$context\n      );\n    }\n\n    if ('create' in subject) { // IViewFactory\n      return subject.create();\n    }\n\n    if ('template' in subject) { // Raw Template Definition\n      return this.renderingEngine.getViewFactory(\n        subject,\n        this.renderable.$context\n      ).create();\n    }\n\n    // Constructable (Custom Element Constructor)\n    return createElement(\n      subject,\n      this.properties,\n      this.$projector.children\n    ).createView(\n      this.renderingEngine,\n      this.renderable.$context\n    );\n  }\n}\n","import { DI, inject, IRegistry } from '@aurelia/kernel';\nimport { valueConverter } from '../value-converter';\n\nconst SCRIPT_REGEX = /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi;\n\nexport interface ISanitizer {\n /**\n  * Sanitizes the provided input.\n  * @param input The input to be sanitized.\n  */\n  sanitize(input: string): string;\n}\n\nexport const ISanitizer = DI.createInterface<ISanitizer>()\n  .withDefault(x => x.singleton(class {\n    public sanitize(input: string): string {\n      return input.replace(SCRIPT_REGEX, '');\n    }\n  })\n);\n\n/**\n * Simple html sanitization converter to preserve whitelisted elements and attributes on a bound property containing html.\n */\n@valueConverter('sanitize')\n@inject(ISanitizer)\nexport class SanitizeValueConverter {\n  public static register: IRegistry['register'];\n\n  private sanitizer: ISanitizer;\n\n  constructor(sanitizer: ISanitizer) {\n    this.sanitizer = sanitizer;\n  }\n\n /**\n  * Process the provided markup that flows to the view.\n  * @param untrustedMarkup The untrusted markup to be sanitized.\n  */\n  public toView(untrustedMarkup: string): string|null {\n    if (untrustedMarkup === null || untrustedMarkup === undefined) {\n      return null;\n    }\n\n    return this.sanitizer.sanitize(untrustedMarkup);\n  }\n}\n","import { DI, IContainer, IRegistry, PLATFORM, Registration } from '@aurelia/kernel';\nimport { INode } from './dom.interfaces';\nimport { LifecycleFlags } from './observation';\nimport { CustomElementResource, ICustomElement, ICustomElementType } from './resources/custom-element';\nimport { IRenderingEngine } from './templating/lifecycle-render';\n\nexport interface ISinglePageApp {\n  host: unknown;\n  component: unknown;\n}\n\nexport class Aurelia {\n  private container: IContainer;\n  private components: ICustomElement[];\n  private startTasks: (() => void)[];\n  private stopTasks: (() => void)[];\n  private isStarted: boolean;\n  private _root: ICustomElement | null;\n\n  constructor(container: IContainer = DI.createContainer()) {\n    this.container = container;\n    this.components = [];\n    this.startTasks = [];\n    this.stopTasks = [];\n    this.isStarted = false;\n    this._root = null;\n\n    Registration\n      .instance(Aurelia, this)\n      .register(container, Aurelia);\n  }\n\n  public register(...params: (IRegistry | Record<string, Partial<IRegistry>>)[]): this {\n    this.container.register(...params);\n    return this;\n  }\n\n  public app(config: ISinglePageApp): this {\n    const host = config.host as INode & {$au?: Aurelia | null};\n    let component: ICustomElement;\n    const componentOrType = config.component as ICustomElement | ICustomElementType;\n    if (CustomElementResource.isType(componentOrType as ICustomElementType)) {\n      this.container.register(componentOrType as ICustomElementType);\n      component = this.container.get<ICustomElement>(CustomElementResource.keyFrom((componentOrType as ICustomElementType).description.name));\n    } else {\n      component = componentOrType as ICustomElement;\n    }\n\n    const startTask = () => {\n      host.$au = this;\n      if (!this.components.includes(component)) {\n        this._root = component;\n        this.components.push(component);\n        const re = this.container.get(IRenderingEngine);\n        component.$hydrate(re, host);\n      }\n\n      component.$bind(LifecycleFlags.fromStartTask | LifecycleFlags.fromBind, null);\n      component.$attach(LifecycleFlags.fromStartTask | LifecycleFlags.fromAttach, host);\n    };\n\n    this.startTasks.push(startTask);\n\n    this.stopTasks.push(() => {\n      component.$detach(LifecycleFlags.fromStopTask | LifecycleFlags.fromDetach);\n      component.$unbind(LifecycleFlags.fromStopTask | LifecycleFlags.fromUnbind);\n      host.$au = null;\n    });\n\n    if (this.isStarted) {\n      startTask();\n    }\n\n    return this;\n  }\n\n  public root(): ICustomElement | null {\n    return this._root;\n  }\n\n  public start(): this {\n    for (const runStartTask of this.startTasks) {\n      runStartTask();\n    }\n    this.isStarted = true;\n    return this;\n  }\n\n  public stop(): this {\n    this.isStarted = false;\n    for (const runStopTask of this.stopTasks) {\n      runStopTask();\n    }\n    return this;\n  }\n}\n\n(PLATFORM.global as {Aurelia: unknown}).Aurelia = Aurelia;\n","import { IContainer, IIndexable, inject, IRegistry, Tracer } from '@aurelia/kernel';\nimport { Binding } from './binding/binding';\nimport { BindingMode } from './binding/binding-mode';\nimport { Call } from './binding/call';\nimport { BindingType, IExpressionParser } from './binding/expression-parser';\nimport { InterpolationBinding, MultiInterpolationBinding } from './binding/interpolation-binding';\nimport { LetBinding } from './binding/let-binding';\nimport { Listener } from './binding/listener';\nimport { Ref } from './binding/ref';\nimport {\n  customAttributeKey,\n  customElementKey,\n  ICallBindingInstruction,\n  IHydrateAttributeInstruction,\n  IHydrateElementInstruction,\n  IHydrateLetElementInstruction,\n  IHydrateTemplateController,\n  IInterpolationInstruction,\n  IIteratorBindingInstruction,\n  IListenerBindingInstruction,\n  IPropertyBindingInstruction,\n  IRefBindingInstruction,\n  ISetAttributeInstruction,\n  ISetPropertyInstruction,\n  IStylePropertyBindingInstruction,\n  ITextBindingInstruction,\n  TargetedInstructionType,\n  TemplatePartDefinitions\n} from './definitions';\nimport { DOM } from './dom';\nimport { IElement, IHTMLElement, INode, IRenderLocation } from './dom.interfaces';\nimport { IAttach, IAttachables, IBindables, IBindScope, IRenderable, IRenderContext } from './lifecycle';\nimport { IEventManager } from './observation/event-manager';\nimport { IObserverLocator } from './observation/observer-locator';\nimport { ICustomAttribute } from './resources/custom-attribute';\nimport { ICustomElement } from './resources/custom-element';\nimport { IElementHydrationOptions, IInstructionRenderer, instructionRenderer, IRenderer, IRenderingEngine } from './templating/lifecycle-render';\n\nconst slice = Array.prototype.slice;\n\nexport function ensureExpression<TFrom>(parser: IExpressionParser, srcOrExpr: TFrom, bindingType: BindingType): Exclude<TFrom, string> {\n  if (typeof srcOrExpr === 'string') {\n    return parser.parse(srcOrExpr, bindingType) as unknown as Exclude<TFrom, string>;\n  }\n  return srcOrExpr as Exclude<TFrom, string>;\n}\n\nexport function addBindable(renderable: IBindables, bindable: IBindScope): void {\n  if (Tracer.enabled) { Tracer.enter('addBindable', slice.call(arguments)); }\n  bindable.$prevBind = renderable.$bindableTail;\n  bindable.$nextBind = null;\n  if (renderable.$bindableTail === null) {\n    renderable.$bindableHead = bindable;\n  } else {\n    renderable.$bindableTail.$nextBind = bindable;\n  }\n  renderable.$bindableTail = bindable;\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\nexport function addAttachable(renderable: IAttachables, attachable: IAttach): void {\n  if (Tracer.enabled) { Tracer.enter('addAttachable', slice.call(arguments)); }\n  attachable.$prevAttach = renderable.$attachableTail;\n  attachable.$nextAttach = null;\n  if (renderable.$attachableTail === null) {\n    renderable.$attachableHead = attachable;\n  } else {\n    renderable.$attachableTail.$nextAttach = attachable;\n  }\n  renderable.$attachableTail = attachable;\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n@inject(IExpressionParser, IObserverLocator)\n@instructionRenderer(TargetedInstructionType.textBinding)\n/** @internal */\nexport class TextBindingRenderer implements IInstructionRenderer {\n  private parser: IExpressionParser;\n  private observerLocator: IObserverLocator;\n\n  constructor(parser: IExpressionParser, observerLocator: IObserverLocator) {\n    this.parser = parser;\n    this.observerLocator = observerLocator;\n  }\n\n  public render(context: IRenderContext, renderable: IRenderable, target: INode, instruction: ITextBindingInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('TextBindingRenderer.render', slice.call(arguments)); }\n    const next = target.nextSibling;\n    if (DOM.isMarker(target)) {\n      DOM.remove(target);\n    }\n    let bindable: MultiInterpolationBinding | InterpolationBinding;\n    const expr = ensureExpression(this.parser, instruction.from, BindingType.Interpolation);\n    if (expr.isMulti) {\n      bindable = new MultiInterpolationBinding(this.observerLocator, expr, next, 'textContent', BindingMode.toView, context);\n    } else {\n      bindable = new InterpolationBinding(expr.firstExpression, expr, next, 'textContent', BindingMode.toView, this.observerLocator, context, true);\n    }\n    addBindable(renderable, bindable);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@inject(IExpressionParser, IObserverLocator)\n@instructionRenderer(TargetedInstructionType.interpolation)\n/** @internal */\nexport class InterpolationBindingRenderer implements IInstructionRenderer {\n  private parser: IExpressionParser;\n  private observerLocator: IObserverLocator;\n\n  constructor(parser: IExpressionParser, observerLocator: IObserverLocator) {\n    this.parser = parser;\n    this.observerLocator = observerLocator;\n  }\n\n  public render(context: IRenderContext, renderable: IRenderable, target: INode, instruction: IInterpolationInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('InterpolationBindingRenderer.render', slice.call(arguments)); }\n    let bindable: MultiInterpolationBinding | InterpolationBinding;\n    const expr = ensureExpression(this.parser, instruction.from, BindingType.Interpolation);\n    if (expr.isMulti) {\n      bindable = new MultiInterpolationBinding(this.observerLocator, expr, target, instruction.to, BindingMode.toView, context);\n    } else {\n      bindable = new InterpolationBinding(expr.firstExpression, expr, target, instruction.to, BindingMode.toView, this.observerLocator, context, true);\n    }\n    addBindable(renderable, bindable);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@inject(IExpressionParser, IObserverLocator)\n@instructionRenderer(TargetedInstructionType.propertyBinding)\n/** @internal */\nexport class PropertyBindingRenderer implements IInstructionRenderer {\n  private parser: IExpressionParser;\n  private observerLocator: IObserverLocator;\n\n  constructor(parser: IExpressionParser, observerLocator: IObserverLocator) {\n    this.parser = parser;\n    this.observerLocator = observerLocator;\n  }\n\n  public render(context: IRenderContext, renderable: IRenderable, target: INode, instruction: IPropertyBindingInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('PropertyBindingRenderer.render', slice.call(arguments)); }\n    const expr = ensureExpression(this.parser, instruction.from, BindingType.IsPropertyCommand | instruction.mode);\n    const bindable = new Binding(expr, target, instruction.to, instruction.mode, this.observerLocator, context);\n    addBindable(renderable, bindable);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@inject(IExpressionParser, IObserverLocator)\n@instructionRenderer(TargetedInstructionType.iteratorBinding)\n/** @internal */\nexport class IteratorBindingRenderer implements IInstructionRenderer {\n  private parser: IExpressionParser;\n  private observerLocator: IObserverLocator;\n\n  constructor(parser: IExpressionParser, observerLocator: IObserverLocator) {\n    this.parser = parser;\n    this.observerLocator = observerLocator;\n  }\n\n  public render(context: IRenderContext, renderable: IRenderable, target: INode, instruction: IIteratorBindingInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('IteratorBindingRenderer.render', slice.call(arguments)); }\n    const expr = ensureExpression(this.parser, instruction.from, BindingType.ForCommand);\n    const bindable = new Binding(expr, target, instruction.to, BindingMode.toView, this.observerLocator, context);\n    addBindable(renderable, bindable);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@inject(IExpressionParser, IEventManager)\n@instructionRenderer(TargetedInstructionType.listenerBinding)\n/** @internal */\nexport class ListenerBindingRenderer implements IInstructionRenderer {\n  private parser: IExpressionParser;\n  private eventManager: IEventManager;\n\n  constructor(parser: IExpressionParser, eventManager: IEventManager) {\n    this.parser = parser;\n    this.eventManager = eventManager;\n  }\n\n  public render(context: IRenderContext, renderable: IRenderable, target: INode, instruction: IListenerBindingInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('ListenerBindingRenderer.render', slice.call(arguments)); }\n    const expr = ensureExpression(this.parser, instruction.from, BindingType.IsEventCommand | (instruction.strategy + BindingType.DelegationStrategyDelta));\n    const bindable = new Listener(instruction.to, instruction.strategy, expr, target, instruction.preventDefault, this.eventManager, context);\n    addBindable(renderable, bindable);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@inject(IExpressionParser, IObserverLocator)\n@instructionRenderer(TargetedInstructionType.callBinding)\n/** @internal */\nexport class CallBindingRenderer implements IInstructionRenderer {\n  private parser: IExpressionParser;\n  private observerLocator: IObserverLocator;\n\n  constructor(parser: IExpressionParser, observerLocator: IObserverLocator) {\n    this.parser = parser;\n    this.observerLocator = observerLocator;\n  }\n\n  public render(context: IRenderContext, renderable: IRenderable, target: INode, instruction: ICallBindingInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('CallBindingRenderer.render', slice.call(arguments)); }\n    const expr = ensureExpression(this.parser, instruction.from, BindingType.CallCommand);\n    const bindable = new Call(expr, target, instruction.to, this.observerLocator, context);\n    addBindable(renderable, bindable);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@inject(IExpressionParser)\n@instructionRenderer(TargetedInstructionType.refBinding)\n/** @internal */\nexport class RefBindingRenderer implements IInstructionRenderer {\n  private parser: IExpressionParser;\n\n  constructor(parser: IExpressionParser) {\n    this.parser = parser;\n  }\n\n  public render(context: IRenderContext, renderable: IRenderable, target: INode, instruction: IRefBindingInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('RefBindingRenderer.render', slice.call(arguments)); }\n    const expr = ensureExpression(this.parser, instruction.from, BindingType.IsRef);\n    const bindable = new Ref(expr, target, context);\n    addBindable(renderable, bindable);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@inject(IExpressionParser, IObserverLocator)\n@instructionRenderer(TargetedInstructionType.stylePropertyBinding)\n/** @internal */\nexport class StylePropertyBindingRenderer implements IInstructionRenderer {\n  private parser: IExpressionParser;\n  private observerLocator: IObserverLocator;\n\n  constructor(parser: IExpressionParser, observerLocator: IObserverLocator) {\n    this.parser = parser;\n    this.observerLocator = observerLocator;\n  }\n\n  public render(context: IRenderContext, renderable: IRenderable, target: IHTMLElement, instruction: IStylePropertyBindingInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('StylePropertyBindingRenderer.render', slice.call(arguments)); }\n    const expr = ensureExpression(this.parser, instruction.from, BindingType.IsPropertyCommand | BindingMode.toView);\n    const bindable = new Binding(expr, target.style, instruction.to, BindingMode.toView, this.observerLocator, context);\n    addBindable(renderable, bindable);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@instructionRenderer(TargetedInstructionType.setProperty)\n/** @internal */\nexport class SetPropertyRenderer implements IInstructionRenderer {\n  public render(context: IRenderContext, renderable: IRenderable, target: IIndexable, instruction: ISetPropertyInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('SetPropertyRenderer.render', slice.call(arguments)); }\n    target[instruction.to] = instruction.value;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@instructionRenderer(TargetedInstructionType.setAttribute)\n/** @internal */\nexport class SetAttributeRenderer implements IInstructionRenderer {\n  public render(context: IRenderContext, renderable: IRenderable, target: IElement, instruction: ISetAttributeInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('SetAttributeRenderer.render', slice.call(arguments)); }\n    DOM.setAttribute(target, instruction.to, instruction.value);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@inject(IRenderingEngine)\n@instructionRenderer(TargetedInstructionType.hydrateElement)\n/** @internal */\nexport class CustomElementRenderer implements IInstructionRenderer {\n  private renderingEngine: IRenderingEngine;\n\n  constructor(renderingEngine: IRenderingEngine) {\n    this.renderingEngine = renderingEngine;\n  }\n\n  public render(context: IRenderContext, renderable: IRenderable, target: IRenderLocation, instruction: IHydrateElementInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('CustomElementRenderer.render', slice.call(arguments)); }\n    const operation = context.beginComponentOperation(renderable, target, instruction, null, null, target, true);\n    const component = context.get<ICustomElement>(customElementKey(instruction.res));\n    const instructionRenderers = context.get(IRenderer).instructionRenderers;\n    const childInstructions = instruction.instructions;\n\n    component.$hydrate(this.renderingEngine, target, instruction as IElementHydrationOptions);\n\n    for (let i = 0, ii = childInstructions.length; i < ii; ++i) {\n      const current = childInstructions[i];\n      instructionRenderers[current.type].render(context, renderable, component, current);\n    }\n\n    addBindable(renderable, component);\n    addAttachable(renderable, component);\n\n    operation.dispose();\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@inject(IRenderingEngine)\n@instructionRenderer(TargetedInstructionType.hydrateAttribute)\n/** @internal */\nexport class CustomAttributeRenderer implements IInstructionRenderer {\n  private renderingEngine: IRenderingEngine;\n\n  constructor(renderingEngine: IRenderingEngine) {\n    this.renderingEngine = renderingEngine;\n  }\n\n  public render(context: IRenderContext, renderable: IRenderable, target: IElement, instruction: IHydrateAttributeInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('CustomAttributeRenderer.render', slice.call(arguments)); }\n    const operation = context.beginComponentOperation(renderable, target, instruction);\n    const component = context.get<ICustomAttribute>(customAttributeKey(instruction.res));\n    const instructionRenderers = context.get(IRenderer).instructionRenderers;\n    const childInstructions = instruction.instructions;\n\n    component.$hydrate(this.renderingEngine);\n\n    for (let i = 0, ii = childInstructions.length; i < ii; ++i) {\n      const current = childInstructions[i];\n      instructionRenderers[current.type].render(context, renderable, component, current);\n    }\n\n    addBindable(renderable, component);\n    addAttachable(renderable, component);\n\n    operation.dispose();\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@inject(IRenderingEngine)\n@instructionRenderer(TargetedInstructionType.hydrateTemplateController)\n/** @internal */\nexport class TemplateControllerRenderer implements IInstructionRenderer {\n  private renderingEngine: IRenderingEngine;\n\n  constructor(renderingEngine: IRenderingEngine) {\n    this.renderingEngine = renderingEngine;\n  }\n\n  public render(context: IRenderContext, renderable: IRenderable, target: IElement, instruction: IHydrateTemplateController, parts?: TemplatePartDefinitions): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateControllerRenderer.render', slice.call(arguments)); }\n    const factory = this.renderingEngine.getViewFactory(instruction.def, context);\n    const operation = context.beginComponentOperation(renderable, target, instruction, factory, parts, DOM.convertToRenderLocation(target), false);\n    const component = context.get<ICustomAttribute>(customAttributeKey(instruction.res));\n    const instructionRenderers = context.get(IRenderer).instructionRenderers;\n    const childInstructions = instruction.instructions;\n\n    component.$hydrate(this.renderingEngine);\n\n    if (instruction.link) {\n      (component as ICustomAttribute & { link(attachableTail: IAttach): void}).link(renderable.$attachableTail);\n    }\n\n    for (let i = 0, ii = childInstructions.length; i < ii; ++i) {\n      const current = childInstructions[i];\n      instructionRenderers[current.type].render(context, renderable, component, current);\n    }\n\n    addBindable(renderable, component);\n    addAttachable(renderable, component);\n\n    operation.dispose();\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@inject(IExpressionParser, IObserverLocator)\n@instructionRenderer(TargetedInstructionType.hydrateLetElement)\n/** @internal */\nexport class LetElementRenderer implements IInstructionRenderer {\n  private parser: IExpressionParser;\n  private observerLocator: IObserverLocator;\n\n  constructor(parser: IExpressionParser, observerLocator: IObserverLocator) {\n    this.parser = parser;\n    this.observerLocator = observerLocator;\n  }\n\n  public render(context: IRenderContext, renderable: IRenderable, target: IElement, instruction: IHydrateLetElementInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('LetElementRenderer.render', slice.call(arguments)); }\n    target.remove();\n    const childInstructions = instruction.instructions;\n    const toViewModel = instruction.toViewModel;\n    for (let i = 0, ii = childInstructions.length; i < ii; ++i) {\n      const childInstruction = childInstructions[i];\n      const expr = ensureExpression(this.parser, childInstruction.from, BindingType.IsPropertyCommand);\n      const bindable = new LetBinding(expr, childInstruction.to, this.observerLocator, context, toViewModel);\n      addBindable(renderable, bindable);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\nexport const HtmlRenderer = {\n  register(container: IContainer): void {\n    container.register(\n      TextBindingRenderer as unknown as IRegistry,\n      InterpolationBindingRenderer as unknown as IRegistry,\n      PropertyBindingRenderer as unknown as IRegistry,\n      IteratorBindingRenderer as unknown as IRegistry,\n      ListenerBindingRenderer as unknown as IRegistry,\n      CallBindingRenderer as unknown as IRegistry,\n      RefBindingRenderer as unknown as IRegistry,\n      StylePropertyBindingRenderer as unknown as IRegistry,\n      SetPropertyRenderer as unknown as IRegistry,\n      SetAttributeRenderer as unknown as IRegistry,\n      CustomElementRenderer as unknown as IRegistry,\n      CustomAttributeRenderer as unknown as IRegistry,\n      TemplateControllerRenderer as unknown as IRegistry,\n      LetElementRenderer as unknown as IRegistry\n    );\n  }\n};\n","import { ForOfStatement, Interpolation, IsBindingBehavior } from './binding/ast';\nimport { BindingMode } from './binding/binding-mode';\nimport {\n  ICallBindingInstruction,\n  IHydrateAttributeInstruction,\n  IHydrateElementInstruction,\n  IHydrateLetElementInstruction,\n  IHydrateTemplateController,\n  IInterpolationInstruction,\n  IIteratorBindingInstruction,\n  ILetBindingInstruction,\n  IListenerBindingInstruction,\n  IPropertyBindingInstruction,\n  IRefBindingInstruction,\n  ISetPropertyInstruction,\n  IStylePropertyBindingInstruction,\n  ITargetedInstruction,\n  ITemplateDefinition,\n  ITextBindingInstruction,\n  TargetedInstruction,\n  TargetedInstructionType\n} from './definitions';\nimport { INode } from './dom.interfaces';\nimport { DelegationStrategy } from './observation/event-manager';\n\nexport class TextBindingInstruction implements ITextBindingInstruction {\n  public type: TargetedInstructionType.textBinding;\n\n  public from: string | Interpolation;\n\n  constructor(from: string | Interpolation) {\n    this.type = TargetedInstructionType.textBinding;\n\n    this.from = from;\n  }\n}\n\nexport class InterpolationInstruction implements IInterpolationInstruction {\n  public type: TargetedInstructionType.interpolation;\n\n  public from: string | Interpolation;\n  public to: string;\n\n  constructor(from: string | Interpolation, to: string) {\n    this.type = TargetedInstructionType.interpolation;\n\n    this.from = from;\n    this.to = to;\n  }\n}\n\nexport class OneTimeBindingInstruction implements IPropertyBindingInstruction {\n  public type: TargetedInstructionType.propertyBinding;\n\n  public from: string | IsBindingBehavior;\n  public mode: BindingMode.oneTime;\n  public oneTime: true;\n  public to: string;\n\n  constructor(from: string | IsBindingBehavior, to: string) {\n    this.type = TargetedInstructionType.propertyBinding;\n\n    this.from = from;\n    this.mode = BindingMode.oneTime;\n    this.oneTime = true;\n    this.to = to;\n  }\n}\n\nexport class ToViewBindingInstruction implements IPropertyBindingInstruction {\n  public type: TargetedInstructionType.propertyBinding;\n\n  public from: string | IsBindingBehavior;\n  public mode: BindingMode.toView;\n  public oneTime: false;\n  public to: string;\n\n  constructor(from: string | IsBindingBehavior, to: string) {\n    this.type = TargetedInstructionType.propertyBinding;\n\n    this.from = from;\n    this.mode = BindingMode.toView;\n    this.oneTime = false;\n    this.to = to;\n  }\n}\n\nexport class FromViewBindingInstruction implements IPropertyBindingInstruction {\n  public type: TargetedInstructionType.propertyBinding;\n\n  public from: string | IsBindingBehavior;\n  public mode: BindingMode.fromView;\n  public oneTime: false;\n  public to: string;\n\n  constructor(from: string | IsBindingBehavior, to: string) {\n    this.type = TargetedInstructionType.propertyBinding;\n\n    this.from = from;\n    this.mode = BindingMode.fromView;\n    this.oneTime = false;\n    this.to = to;\n  }\n}\n\nexport class TwoWayBindingInstruction implements IPropertyBindingInstruction {\n  public type: TargetedInstructionType.propertyBinding = TargetedInstructionType.propertyBinding;\n\n  public from: string | IsBindingBehavior;\n  public mode: BindingMode.twoWay;\n  public oneTime: false;\n  public to: string;\n\n  constructor(from: string | IsBindingBehavior, to: string) {\n    this.type = TargetedInstructionType.propertyBinding;\n\n    this.from = from;\n    this.mode = BindingMode.twoWay;\n    this.oneTime = false;\n    this.to = to;\n  }\n}\n\nexport class IteratorBindingInstruction implements IIteratorBindingInstruction {\n  public type: TargetedInstructionType.iteratorBinding;\n\n  public from: string | ForOfStatement;\n  public to: string;\n\n  constructor(from: string | ForOfStatement, to: string) {\n    this.type = TargetedInstructionType.iteratorBinding;\n\n    this.from = from;\n    this.to = to;\n  }\n}\n\nexport class TriggerBindingInstruction implements IListenerBindingInstruction {\n  public type: TargetedInstructionType.listenerBinding;\n\n  public from: string | IsBindingBehavior;\n  public preventDefault: true;\n  public strategy: DelegationStrategy.none;\n  public to: string;\n\n  constructor(from: string | IsBindingBehavior, to: string) {\n    this.type = TargetedInstructionType.listenerBinding;\n\n    this.from = from;\n    this.preventDefault = true;\n    this.strategy = DelegationStrategy.none;\n    this.to = to;\n  }\n}\n\nexport class DelegateBindingInstruction implements IListenerBindingInstruction {\n  public type: TargetedInstructionType.listenerBinding;\n\n  public from: string | IsBindingBehavior;\n  public preventDefault: false;\n  public strategy: DelegationStrategy.bubbling;\n  public to: string;\n\n  constructor(from: string | IsBindingBehavior, to: string) {\n    this.type = TargetedInstructionType.listenerBinding;\n\n    this.from = from;\n    this.preventDefault = false;\n    this.strategy = DelegationStrategy.bubbling;\n    this.to = to;\n  }\n}\n\nexport class CaptureBindingInstruction implements IListenerBindingInstruction {\n  public type: TargetedInstructionType.listenerBinding;\n\n  public from: string | IsBindingBehavior;\n  public preventDefault: false;\n  public strategy: DelegationStrategy.capturing;\n  public to: string;\n\n  constructor(from: string | IsBindingBehavior, to: string) {\n    this.type = TargetedInstructionType.listenerBinding;\n\n    this.from = from;\n    this.preventDefault = false;\n    this.strategy = DelegationStrategy.capturing;\n    this.to = to;\n  }\n}\n\nexport class CallBindingInstruction implements ICallBindingInstruction {\n  public type: TargetedInstructionType.callBinding;\n\n  public from: string | IsBindingBehavior;\n  public to: string;\n\n  constructor(from: string | IsBindingBehavior, to: string) {\n    this.type = TargetedInstructionType.callBinding;\n\n    this.from = from;\n    this.to = to;\n  }\n}\n\nexport class RefBindingInstruction implements IRefBindingInstruction {\n  public type: TargetedInstructionType.refBinding;\n\n  public from: string | IsBindingBehavior;\n\n  constructor(from: string | IsBindingBehavior) {\n    this.type = TargetedInstructionType.refBinding;\n\n    this.from = from;\n  }\n}\n\nexport class StylePropertyBindingInstruction implements IStylePropertyBindingInstruction {\n  public type: TargetedInstructionType.stylePropertyBinding;\n\n  public from: string | IsBindingBehavior;\n  public to: string;\n\n  constructor(from: string | IsBindingBehavior, to: string) {\n    this.type = TargetedInstructionType.stylePropertyBinding;\n\n    this.from = from;\n    this.to = to;\n  }\n}\n\nexport class SetPropertyInstruction implements ISetPropertyInstruction {\n  public type: TargetedInstructionType.setProperty;\n\n  public to: string;\n  public value: unknown;\n\n  constructor(value: unknown, to: string) {\n    this.type = TargetedInstructionType.setProperty;\n\n    this.to = to;\n    this.value = value;\n  }\n}\n\nexport class SetAttributeInstruction implements ITargetedInstruction {\n  public type: TargetedInstructionType.setAttribute;\n\n  public to: string;\n  public value: string;\n\n  constructor(value: string, to: string) {\n    this.type = TargetedInstructionType.setAttribute;\n\n    this.to = to;\n    this.value = value;\n  }\n}\n\nexport class HydrateElementInstruction implements IHydrateElementInstruction {\n  public type: TargetedInstructionType.hydrateElement;\n\n  public contentOverride?: INode;\n  public instructions: TargetedInstruction[];\n  public parts?: Record<string, ITemplateDefinition>;\n  public res: string;\n\n  constructor(res: string, instructions: TargetedInstruction[], parts?: Record<string, ITemplateDefinition>, contentOverride?: INode) {\n    this.type = TargetedInstructionType.hydrateElement;\n\n    this.contentOverride = contentOverride;\n    this.instructions = instructions;\n    this.parts = parts;\n    this.res = res;\n  }\n}\n\nexport class HydrateAttributeInstruction implements IHydrateAttributeInstruction {\n  public type: TargetedInstructionType.hydrateAttribute;\n\n  public instructions: TargetedInstruction[];\n  public res: string;\n\n  constructor(res: string, instructions: TargetedInstruction[]) {\n    this.type = TargetedInstructionType.hydrateAttribute;\n\n    this.instructions = instructions;\n    this.res = res;\n  }\n}\n\nexport class HydrateTemplateController implements IHydrateTemplateController {\n  public type: TargetedInstructionType.hydrateTemplateController;\n\n  public def: ITemplateDefinition;\n  public instructions: TargetedInstruction[];\n  public link?: boolean;\n  public res: string;\n\n  constructor(def: ITemplateDefinition, res: string, instructions: TargetedInstruction[], link?: boolean) {\n    this.type = TargetedInstructionType.hydrateTemplateController;\n\n    this.def = def;\n    this.instructions = instructions;\n    this.link = link;\n    this.res = res;\n  }\n}\n\nexport class LetElementInstruction implements IHydrateLetElementInstruction {\n  public type: TargetedInstructionType.hydrateLetElement;\n\n  public instructions: ILetBindingInstruction[];\n  public toViewModel: boolean;\n\n  constructor(instructions: ILetBindingInstruction[], toViewModel: boolean) {\n    this.type = TargetedInstructionType.hydrateLetElement;\n\n    this.instructions = instructions;\n    this.toViewModel = toViewModel;\n  }\n}\n\nexport class LetBindingInstruction implements ILetBindingInstruction {\n  public type: TargetedInstructionType.letBinding;\n\n  public from: string | IsBindingBehavior | Interpolation;\n  public to: string;\n\n  constructor(from: string | IsBindingBehavior | Interpolation, to: string) {\n    this.type = TargetedInstructionType.letBinding;\n\n    this.from = from;\n    this.to = to;\n  }\n}\n"],"names":["LifecycleFlags","MutationKind","Reporter","PLATFORM","SetterObserver","Observer","Tracer","DI","Registration","register","keyFrom","isType","define","BindingMode","slice","CompositionCoordinator","inject","Binding","toView","oneTime","InterpolationBinding","LetBinding","dispose","flush","CollectionLengthObserver","ArrayObserver","proto","MapObserver","nativeClear","nativeDelete","observeClear","observeDelete","SetObserver","GetterObserver","CustomSetterObserver","DirtyCheckProperty","ValueAttributeObserver","CheckedObserver","SelectValueObserver","DelegationStrategy","XLinkAttributeAccessor","DataAttributeAccessor","StyleAttributeAccessor","ClassAttributeAccessor","ElementPropertyAccessor","toStringTag","ObserverLocator","AttrBindingBehavior","fromView","OneTimeBindingBehavior","ToViewBindingBehavior","FromViewBindingBehavior","TwoWayBindingBehavior","DebounceBindingBehavior","SelfBindingBehavior","SignalBindingBehavior","ThrottleBindingBehavior","UpdateTriggerBindingBehavior","ViewCompileFlags","RenderingEngine","RuntimeCompilationResources","IContainer","all","childObserverOptions","ChildrenObserver","Renderer","If","tslib_1.__decorate","Else","Repeat","Replaceable","With","Compose","SanitizeValueConverter","TextBindingRenderer","InterpolationBindingRenderer","PropertyBindingRenderer","IteratorBindingRenderer","ListenerBindingRenderer","CallBindingRenderer","RefBindingRenderer","StylePropertyBindingRenderer","SetPropertyRenderer","SetAttributeRenderer","CustomElementRenderer","CustomAttributeRenderer","TemplateControllerRenderer","LetElementRenderer"],"mappings":"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"}